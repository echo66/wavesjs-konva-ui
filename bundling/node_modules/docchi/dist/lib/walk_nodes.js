'use strict';

var _Set = require('babel-runtime/core-js/set')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireWildcard = require('babel-runtime/helpers/interop-require-wildcard')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = walkNodes;

var _acornDistWalk = require('acorn/dist/walk');

var walk = _interopRequireWildcard(_acornDistWalk);

var _array_proxy = require('./array_proxy');

var arrayProxy = _interopRequireWildcard(_array_proxy);

var delimiter = '.';

var fnTypes = new _Set(['ArrowFunctionExpression', 'FunctionExpression', 'FunctionDeclaration']);

var names = {
  property: 'property',
  'class': 'class',
  method: 'method',
  'function': 'function',
  variable: 'variable',
  constant: 'constant'
};

function walkNodes(AST) {
  var nodes = [];

  var visitors = {

    // That pesky export.
    ExportNamedDeclaration: declareImportExport,
    ExportDefaultDeclaration: declareImportExport,

    // Smoothing over acorn implementation.
    ImportDeclaration: declareImportExport,

    // Recursion help.
    BlockStatement: function BlockStatement(node, state, cb) {
      node.body.forEach(function (node) {
        return cb(node, state);
      });
    },
    ExpressionStatement: function ExpressionStatement(node, state, cb) {
      cb(node.expression, state);
    },

    // Class.
    ClassDeclaration: declareClass.bind(null, nodes),
    ClassExpression: declareClass.bind(null, nodes),

    ClassBody: function ClassBody(node, state, cb) {
      node.body.forEach(function (node) {
        return cb(node, state[state.length - 1]);
      });
      state.pop();
    },

    MethodDefinition: function MethodDefinition(node, state, cb) {
      cb(node.value, state);

      nodes.push(_Object$assign(pickLocation(node), {
        name: node.key.name
      }, state ? {
        target: state
      } : null, node.kind ? {
        type: node.kind
      } : null, node['static'] ? {
        'static': true
      } : null));
    },

    // Prototype/function.
    FunctionDeclaration: declareFunction.bind(null, nodes),
    FunctionExpression: declareFunction.bind(null, nodes),
    ArrowFunctionExpression: declareFunction.bind(null, nodes),

    AssignmentExpression: function AssignmentExpression(node, state, cb) {
      var obj = node.left.object;
      var isInstanceAssignment = obj && obj.type === 'ThisExpression';
      var isPropertyAssignment = obj && obj.name;
      var isPrototype = isPropertyAssignment && node.left.property && node.left.property.name === 'prototype';
      var isPrototypeAssignment = obj && obj.object && obj.object.name && obj.property && obj.property.name === 'prototype';

      if (isInstanceAssignment) nodes.push(_Object$assign(pickLocation(node), {
        name: node.left.property.name,
        type: fnTypes.has(node.right.type) ? names.method : names.property,
        target: 'this'
      }));

      if (isPropertyAssignment) {
        nodes.push(_Object$assign(pickLocation(node), {
          name: node.left.property.name,
          type: fnTypes.has(node.right.type) ? names.method : names.property,
          target: obj.name
        }, !isPrototype ? {
          'static': true
        } : null));

        if (node.right.properties) node.right.properties.forEach(function (property) {
          return nodes.push(_Object$assign(pickLocation(property), {
            name: property.key.name,
            type: fnTypes.has(property.value.type) ? names.method : names.property,
            target: obj.name + (isPrototype || isPrototypeAssignment ? '' : delimiter + node.left.property.name)
          }, !isPrototype ? {
            'static': true
          } : null));
        });
      }

      if (isPrototypeAssignment) nodes.push(_Object$assign(pickLocation(node), {
        name: node.left.property.name,
        type: fnTypes.has(node.right.type) ? names.method : names.property,
        target: obj.object.name
      }));

      // Make sure a function gets treated as a class if it
      // gets prototype properties.
      if (isPrototype || isPrototypeAssignment) {
        var fn = arrayProxy.find(nodes, function (node) {
          return node.name === (obj.name || obj.object.name) && node.type === names['function'];
        }) || {};
        fn.type = names['class'];
      }

      cb(node.right, state);
    },

    // Variables.
    VariableDeclaration: function VariableDeclaration(node, state, cb) {
      if (node.declarations.length === 1) {
        var _ret = (function () {
          var declaration = node.declarations[0];

          if (declaration.init && visitors.hasOwnProperty(declaration.init.type) && !fnTypes.has(declaration.init.type)) return {
              v: cb(declaration.init, state)
            };

          nodes.push(_Object$assign(pickLocation(declaration), {
            type: node.kind === 'const' ? names.constant : names.variable
          }, declaration.id ? {
            name: declaration.id.name
          } : null));

          if (declaration.init && declaration.init.properties) declaration.init.properties.forEach(function (property) {
            return nodes.push(_Object$assign(pickLocation(property), {
              name: property.key.name,
              type: fnTypes.has(property.value.type) ? names.method : names.property
            }, declaration.id ? {
              target: declaration.id.name
            } : null));
          });
        })();

        if (typeof _ret === 'object') return _ret.v;
      }
    }
  };

  walk.recursive(AST, [], visitors);

  return nodes.sort(function (a, b) {
    return a.start - b.start;
  });
}

function declareClass(nodes, node, state, cb) {
  var name = node.id ? node.id.name : undefined;

  if (name) state.push(name);

  cb(node.body, state);

  nodes.push(_Object$assign(pickLocation(node), {
    type: names['class']
  }, name ? {
    name: name
  } : null));
}

function declareFunction(nodes, node, state, cb) {
  cb(node.body, state);

  var name = node.id ? node.id.name : undefined;

  // No anonymous functions.
  if (!name) return;

  nodes.push(_Object$assign(pickLocation(node), {
    name: name,
    type: names['function']
  }, node.generator ? {
    generator: true
  } : null));
}

function declareImportExport(node, state, cb) {
  if (node.declaration) cb(node.declaration, state);
}

function pickLocation(node) {
  var obj = {};

  obj.location = node.loc;
  obj.start = node.start;
  obj.end = node.end;

  return obj;
}
module.exports = exports['default'];