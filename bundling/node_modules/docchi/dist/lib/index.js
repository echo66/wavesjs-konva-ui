'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _slice = require('babel-runtime/helpers/slice')['default'];

var _bind = require('babel-runtime/helpers/bind')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _interopRequireWildcard = require('babel-runtime/helpers/interop-require-wildcard')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _doctrine = require('doctrine');

var _doctrine2 = _interopRequireDefault(_doctrine);

var _walk_nodes = require('./walk_nodes');

var _walk_nodes2 = _interopRequireDefault(_walk_nodes);

var _match_nodes = require('./match_nodes');

var _match_nodes2 = _interopRequireDefault(_match_nodes);

var _commonmark = require('commonmark');

var _commonmark2 = _interopRequireDefault(_commonmark);

var _acorn = require('acorn');

var acorn = _interopRequireWildcard(_acorn);

var defaultEncoding = 'utf8';
var ecmaVersion = 6;
var sourceType = 'module';
var CMparser = new _commonmark2['default'].Parser();
var CMrenderer = new _commonmark2['default'].HtmlRenderer();

/**
 * Docchi is a documentation generating tool.
 */

var Docchi = (function () {

  /**
   * Instantiate Docchi.
   *
   * @param {String|Buffer} input
   * @param {Object} options to be passed to Acorn.
   */

  function Docchi() {
    var input = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    _classCallCheck(this, Docchi);

    var comments = [];

    if (Buffer.isBuffer(input)) input = input.toString(options.encoding || defaultEncoding);

    this.AST = acorn.parse(input, _Object$assign({
      ecmaVersion: ecmaVersion,
      sourceType: sourceType,
      locations: true,
      onComment: comments
    }, options));

    // Collapse contiguous single-line comments.
    for (var index = 0; index < comments.length; index++) {
      var comment = comments[index];
      var nextComment = comments[index + 1];

      if (nextComment && comment.type === 'Line' && nextComment.type === 'Line' && nextComment.loc.start.line === comment.loc.end.line + 1) {
        comments[index + 1].value = comment.value + nextComment.value;
        comments[index + 1].start = comment.start;
        comments[index + 1].loc.start.line = comment.loc.start.line;
        comments[index + 1].loc.start.column = comment.loc.start.column;
        comments[index] = undefined;
      }
    }

    comments = comments.filter(function (comment) {
      return comment;
    }).map(function (comment) {
      comment.value = comment.value.trim();
      return comment;
    });

    this.nodes = (0, _walk_nodes2['default'])(this.AST);
    this.comments = (0, _match_nodes2['default'])(comments, this.nodes);
  }

  /**
   * Output the documentation, running either the JSDoc parser Doctrine
   * or a provided function.
   *
   * @param {Function} [fn]
   * @param {Object} [options]
   * @return {Object}
   */

  _createClass(Docchi, [{
    key: 'output',
    value: function output(fn, options) {
      if (typeof fn === 'object') {
        options = fn;
        fn = null;
      }

      return this.comments.map(function (container) {
        var comment = container.comment;

        if (typeof fn === 'function') {
          container.comment = fn(comment, options);
          return container;
        }

        var firstChar = comment.value.charAt(0);

        // Only consider block comments starting with `/**`.
        if (comment.type !== 'block' || firstChar !== '*') return null;

        options = _Object$assign({
          sloppy: true,
          render: true,
          unwrap: true
        }, options);

        container.comment = _doctrine2['default'].parse(comment.value, options);

        if (typeof options.render === 'function') container.comment.description = options.render(container.comment.description);else if (options.render) container.comment.description = CMrenderer.render(CMparser.parse(container.comment.description));

        return container;
      })

      // Filter sparse array.
      .filter(function (comment) {
        return comment;
      });
    }

    /**
     * An alternative to the constructor method, for those who don't
     * like using `new` to instantiate things.
     */
  }], [{
    key: 'parse',
    value: function parse() {
      return new (_bind.apply(this, [null].concat(_slice.call(arguments))))();
    }
  }]);

  return Docchi;
})();

exports['default'] = Docchi;
module.exports = exports['default'];