(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.wavesUI = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _shapesSegment = require('../shapes/segment');

var _shapesSegment2 = _interopRequireDefault(_shapesSegment);

var _behaviorsBaseBehavior = require('../behaviors/base-behavior');

var _behaviorsBaseBehavior2 = _interopRequireDefault(_behaviorsBaseBehavior);

/**
 * Simplified Layer for Axis. The main difference with a regular layer is that
 * an axis layer use the `Timeline~timeContext` attributes to render it's layout
 * and stay synchronized with the tracks visible area. All getters and setters
 * to the `TimelineTimeContext` attributes are bypassed.
 *
 * It also handle it's own data and its updates. The `_generateData` method is
 * responsible to create some usefull data to visualize
 *
 * [example usage of the layer-axis](./examples/layer-axis.html)
 */

var AxisLayer = (function (_Layer) {
  _inherits(AxisLayer, _Layer);

  /**
   * @param {Function} generator - A function to create data according to
   *    the `Timeline~timeContext`.
   * @param {Object} options - Layer options, cf. Layer for available options.
   */

  function AxisLayer(generator, options) {
    var _this = this;

    _classCallCheck(this, AxisLayer);

    _get(Object.getPrototypeOf(AxisLayer.prototype), 'constructor', this).call(this, 'entity', [], options);
    this._generator = generator;

    this._contextShape = new _shapesSegment2['default']({});
    this._contextShape.install({
      opacity: function opacity() {
        return 1;
      },
      color: function color() {
        return _this.params.context.color;
      },
      width: function width() {
        return _this.timeContext.visibleDuration;
      },
      height: function height() {
        return _this._renderingContext.valueToPixel.domain()[1];
      },
      y: function y() {
        return _this._renderingContext.valueToPixel.domain()[0];
      },
      x: function x() {
        return -_this.timeContext.offset;
      }
    });
    this._contextShape.params.handlerWidth = this.params.context.handlerWidth;
    this._contextShape.render(this._renderingContext);
    this._contextShape.layer = this;
    for (var i = 0; i < this._contextShape.$el.length; i++) {
      this._contextLayer.add(this._contextShape.$el[i]);
    }
    this._contextShape.$el.forEach(function (ks) {
      ks.shape = _this._contextShape;
    });

    this.setBehavior(new _behaviorsBaseBehavior2['default']());
  }

  /** @private */

  _createClass(AxisLayer, [{
    key: '_generateData',

    /**
     * This method is the main difference with a classical layer. An `AxisLayer`
     * instance generates and maintains it's own data.
     */
    value: function _generateData() {
      var that = this;
      this.contentLayers.forEach(function (l) {
        // Hacked this to make it work.
        l.destroy();
        that.contentLayers['delete'](l);
      });
      var data = this._generator(this.timeContext);
      // this.remove(this.data);
      this.set([data]);
    }

    /**
     * Generates the data and update the layer.
     */
  }, {
    key: 'update',
    value: function update() {
      this._generateData();
      _get(Object.getPrototypeOf(AxisLayer.prototype), 'update', this).call(this);
    }
  }, {
    key: 'updateContainer',
    value: function updateContainer() {
      this._updateRenderingContext();
    }
  }, {
    key: 'updateShapes',
    value: function updateShapes() {
      var changedContentLayers = new _Set();
      var that = this;

      this.allocateShapesToContentLayers(this._stage, this.data, 'datums', true).forEach(function (changedContentLayer) {
        changedContentLayers.add(changedContentLayer);
      });

      changedContentLayers.forEach(function (changedContentLayer) {
        changedContentLayer.y(that.params.top).offsetX(0);
        changedContentLayer.clear();
        changedContentLayer.batchDraw();
      });

      this._contextShape.update(this._renderingContext, this.timeContext);

      this._contextLayer.y(that.params.top).batchDraw().moveToBottom();
    }

    /**
     * Updates the rendering context for the shapes.
     */
  }, {
    key: '_updateRenderingContext',
    value: function _updateRenderingContext() {
      this._renderingContext.timeToPixel = this.timeContext.timeToPixel;
      this._renderingContext.valueToPixel = this._valueToPixel;

      this._renderingContext.height = this.params.height;
      this._renderingContext.width = this.timeContext.timeToPixel(this.timeContext.visibleDuration);

      // for foreign object issue in chrome
      this._renderingContext.offsetX = this.timeContext.timeToPixel(this.timeContext.offset);

      // expose some timeline attributes - allow to improve perf in some cases - cf. Waveform
      this._renderingContext.trackOffsetX = this.timeContext.timeToPixel(this.timeContext.offset);
      this._renderingContext.visibleWidth = this.timeContext.visibleWidth;
    }
  }, {
    key: 'visible_data',
    value: function visible_data(timeContext, data) {
      return undefined;
    }
  }, {
    key: 'sort_data',
    value: function sort_data(data) {}
  }, {
    key: 'stretchRatio',
    set: function set(value) {
      return;
    },

    /** @private */

    /** @private */
    get: function get() {
      return;
    }

    /** @private */
  }, {
    key: 'offset',
    set: function set(value) {
      return;
    },

    /** @private */
    get: function get() {
      return;
    }

    /** @private */
  }, {
    key: 'start',
    set: function set(value) {
      return;
    },

    /** @private */
    get: function get() {
      return;
    }

    /** @private */
  }, {
    key: 'duration',
    set: function set(value) {
      return;
    },
    get: function get() {
      return;
    }

    /**
     * The generator that creates the data to be rendered to display the axis.
     *
     * @type {Function}
     */
  }, {
    key: 'generator',
    set: function set(func) {
      this._generator = func;
    },

    /**
     * The generator that creates the data to be rendered to display the axis.
     *
     * @type {Function}
     */
    get: function get() {
      return this._generator;
    }
  }]);

  return AxisLayer;
})(_coreLayer2['default']);

exports['default'] = AxisLayer;

module.exports = AxisLayer;
module.exports = exports['default'];

},{"../behaviors/base-behavior":5,"../core/layer":20,"../shapes/segment":53,"babel-runtime/core-js/set":85,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = beatGridAxisGenerator;

function beatGridAxisGenerator(beatGrid, signature) {
  var _beatGrid = beatGrid;
  signature = signature || '4/4';
  var _unit = 1 / parseInt(signature.split('/')[1], 10);
  var _nbrUnitsPerMesure = parseInt(signature.split('/')[0], 10);

  return function (timeContext) {

    var start = Math.round(Math.max(0, _beatGrid.beats(-timeContext.offset)));
    var end = Math.round(_beatGrid.beats(-timeContext.offset + timeContext.visibleDuration));
    var focused = false;
    var data = [];

    for (var beat = start; beat < end; beat++) {
      var time = _beatGrid.seconds(beat);
      var label = "" + beat;
      // let focused = (beat % 4 === 0)? true : false;
      data.push({ time: time, focused: focused, label: label });
    }

    return data;
  };
}

module.exports = beatGridAxisGenerator;
module.exports = exports['default'];

},{}],3:[function(require,module,exports){
'use strict';

/**
 * A generator to create data for grid axis according to a `bpm` and a `meter`.
 *
 * [example usage](./examples/layer-axis.html)
 *
 * @param {Number} bpm - The number of beats per minutes.
 * @param {String} signature - The meter of the mesure (`'4/4'`, `'3/8'`, ...).
 * @return {Function} - The configured function returning the data when called.
 */
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = gridAxisGenerator;

function gridAxisGenerator(bpm, signature) {
  var _bps = bpm / 60; // sec
  var _unit = 1 / parseInt(signature.split('/')[1], 10);
  var _nbrUnitsPerMesure = parseInt(signature.split('/')[0], 10);

  return function (timeContext) {
    var duration = timeContext.visibleDuration;
    var offset = timeContext.offset;
    var data = [];

    // const min = Math.min(-offset, 0);
    var min = -offset;
    // remove the timeline's offset to keep the layer centered
    var max = duration - offset;

    // define pixels for 1 second
    var pixelsPerSecond = timeContext.computedPixelsPerSecond;
    // time for one _unit
    var unitTime = 1 / _bps;
    // define the first tick > min
    var modulo = min % unitTime;
    var mult = (min - modulo) / unitTime;
    var firstTickTime = unitTime * mult;
    // track which position of current beat in the mesure
    var positionInMesure = mult % _nbrUnitsPerMesure;

    // remove not focused beats, if zoomed out
    var pixelsPerTick = pixelsPerSecond / _bps;
    var minStep = 5;

    // time should be
    for (var time = firstTickTime; time < max; time += unitTime) {
      // find first beat
      var focused = positionInMesure++ % _nbrUnitsPerMesure === 0;
      // ignore if pixels per ticks is too small
      if (pixelsPerTick <= minStep && !focused) {
        continue;
      }

      data.push({ time: time, focused: focused });
    }

    return data;
  };
}

module.exports = gridAxisGenerator;
module.exports = exports['default'];

},{}],4:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = timeAxisGenerator;

var _utilsFormat = require('../utils/format');

/**
 * A generator to create data for time axis.
 *
 * [example usage](./examples/layer-axis.html)
 *
 * @return {Function} - The configured function returning the data when called.
 */

function timeAxisGenerator() {
  // add factory to share API with bpmGenerator
  return function (timeContext) {
    var duration = timeContext.visibleDuration;
    var offset = timeContext.offset;
    var data = [];

    // const min = Math.min(-offset, 0);
    var min = -offset;
    // remove the timeline's offset to keep the layer centered
    var max = duration - offset;

    // define pixels for 1 second
    var pixelsPerSecond = timeContext.computedPixelsPerSecond;
    var minStep = 7;

    // define all display information according to the pixelsPerSecond ratio
    var step = undefined,
        type = undefined,
        toFixed = undefined,
        markerModulo = undefined,
        includeModulo = undefined;

    if (pixelsPerSecond * 4 > minStep) {
      step = 1; // the step to use to compute time
      toFixed = 0;
      markerModulo = 60; // a timestamp every 5 stepixelsPerSecond
      includeModulo = 5; // a tick every 5 stepixelsPerSecond
      type = '60sec';
    }

    if (pixelsPerSecond * 2 > minStep) {
      step = 1;
      toFixed = 0;
      markerModulo = 30;
      includeModulo = 1;
      type = '30sec';
    }

    if (pixelsPerSecond > minStep) {
      step = 1;
      toFixed = 0;
      markerModulo = 10;
      includeModulo = 1;
      type = 'sec';
    }

    if (pixelsPerSecond / 10 > minStep) {
      step = 1 / 10;
      toFixed = 1;
      markerModulo = 10;
      includeModulo = 1;
      type = 'ds';
    }

    if (pixelsPerSecond / 100 > minStep) {
      step = 1 / 100;
      toFixed = 2;
      markerModulo = 10;
      includeModulo = 1;
      type = 'cs';
    }

    if (pixelsPerSecond / 1000 > minStep) {
      step = 1 / 1000;
      toFixed = 3;
      markerModulo = 10;
      includeModulo = 1;
      type = 'ms';
    }

    for (var time = min; time < max; time += step) {
      var formattedTime = time.toFixed(toFixed);

      if (Math.round(formattedTime / step) % includeModulo !== 0) {
        continue;
      }

      // avoid floating point errors
      var focused = Math.round(formattedTime / step) % markerModulo === 0 ? true : false;

      var datum = { time: formattedTime, focused: focused };

      if (focused === true) {
        var date = new Date(1000 * formattedTime);
        var _min = (0, _utilsFormat.padLeft)(date.getMinutes(), 0, 2);
        var sec = (0, _utilsFormat.padLeft)(date.getSeconds(), 0, 2);
        var milli = (0, _utilsFormat.padLeft)(date.getMilliseconds(), 0, 3);
        var label = _min + ':' + sec + ':' + milli;

        datum.label = label;
      }

      data.push(datum);
    }

    return data;
  };
}

module.exports = timeAxisGenerator;
module.exports = exports['default'];

},{"../utils/format":72}],5:[function(require,module,exports){
'use strict';

/**
 * Is an abstract class or interface to be overriden in order to define the way
 * a given shape should behave when selected or edited by a user. Instances of
 * `BaseBehavior` are internally used by `Layer` instances to modify the data
 * according to a user interaction and a given shape. A single instance of
 * `Behavior` is created in one given shape.
 *
 * By default, the only method to override to define a new behavior for a
 * shape is the `edit` method. However, if needed in special cases, all the
 * selection handling can be overriden too.
 *
 * The flow is the following:
 * `Event`  - (forwarded to) -> `Layer` - (command) -> `Behavior` - (modify) -> `data` - (upates) -> `Shape`
 *
 * The behavior responsability is then to modify the data according to the
 * user interactions, while shapes are always a view of the current state of the
 * data.
 */

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var BaseBehavior = (function () {
  function BaseBehavior() {
    _classCallCheck(this, BaseBehavior);

    this._selectedDatums = new _Set(); // no duplicate in Set
    this._selectedClass = null;
    this._layer = null;
  }

  _createClass(BaseBehavior, [{
    key: 'initialize',
    value: function initialize(layer) {
      this._layer = layer;
      this._selectedClass = layer.params.selectedClassName;
    }

    /**
     * Destroy the references to the selected datums.
     *
     * @type {String}
     * @todo - rename to `clearSelection` (removing the class) ?
     */
  }, {
    key: 'destroy',
    value: function destroy() {
      this._selectedDatums.clear();
    }

    /**
     * The class to add to the shapes when selected.
     *
     * @type {String}
     */
  }, {
    key: 'select',

    /**
     * @param {Object} datum - The datum to select.
     * @todo - Pass the shape object to get the accessors ?
     */
    value: function select(datum) {
      // $item.classList.add(this.selectedClass);
      this._selectedDatums.add(datum);
      return true;
    }

    /**
     * @param {Object} datum - The datum to unselect.
     * @todo - Pass the shape object to get the accessors ?
     */
  }, {
    key: 'unselect',
    value: function unselect(datum) {
      // $item.classList.remove(this.selectedClass);
      this._selectedDatums['delete'](datum);
      return true;
    }

    /**
     * @param {Object} datum - The datum to toggle selection.
     * @todo - Pass the shape object to get the accessors ?
     */
  }, {
    key: 'toggleSelection',
    value: function toggleSelection(datum) {
      var method = this._selectedDatums.has(datum) ? 'unselect' : 'select';
      return this[method](datum);
    }

    /**
     * Interface method to override in order to define its particular behavior when
     * interacted with.
     *
     * @param {Object} renderingContext - The layer rendering context.
     * @param {BaseShape} shape - The shape object to be edited.
     * @param {Object|Array} datum - The related datum to modify.
     * @param {Number} dx - The value of the interaction in the x axis (in pixels).
     * @param {Number} dy - The value of the interaction in the y axis (in pixels).
     * @param {Element} $target - The target DOM element of the interaction.
     */
  }, {
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, $target) {
      // must be implemented in children
      return false;
    }

    /**
     * TODO: possible actions are 'add', 'remove', 'edit', 'minimize', 'highlight', 'select', 'unselect'.
     */
  }, {
    key: 'can',
    value: function can(action, datums) {
      return true;
    }

    /**
     * TODO
     */
  }, {
    key: 'minimize',
    value: function minimize() {
      return false;
    }

    /**
     * TODO
     */
  }, {
    key: 'highlight',
    value: function highlight(datum, isHighlighted) {
      return false;
    }
  }, {
    key: 'selectedClass',
    set: function set(value) {
      this._selectedClass = value;
    },

    /**
     * The class to add to the shapes when selected.
     *
     * @type {String}
     */
    get: function get() {
      return this._selectedClass;
    }

    /**
     * An array containing all the selected datums of the layer.
     *
     * @type {Array}
     */
  }, {
    key: 'selectedDatums',
    get: function get() {
      return this._selectedDatums;
    }
  }]);

  return BaseBehavior;
})();

exports['default'] = BaseBehavior;
module.exports = exports['default'];

},{"babel-runtime/core-js/set":85,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89}],6:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

var BeatGridSnapSegmentBehavior = (function (_BaseBehavior) {
  _inherits(BeatGridSnapSegmentBehavior, _BaseBehavior);

  function BeatGridSnapSegmentBehavior(beatGrid) {
    _classCallCheck(this, BeatGridSnapSegmentBehavior);

    _get(Object.getPrototypeOf(BeatGridSnapSegmentBehavior.prototype), 'constructor', this).call(this);
    this._beatGrid = beatGrid;
    this._snapToGrid = true;
  }

  _createClass(BeatGridSnapSegmentBehavior, [{
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, target) {
      var action = 'move';

      if (target.hasName('handler')) {
        if (target.hasName('left')) action = 'resizeLeft';else if (target.hasName('right')) action = 'resizeRight';else throw new Error('Unexpected konva shape name');
      } else if (target.hasName('segment')) action = 'move';else throw new Error('Unexpected konva shape name');

      this['_' + action](renderingContext, shape, datum, dx, dy, target);
    }
  }, {
    key: '_move',
    value: function _move(renderingContext, shape, datum, dx, dy, target) {
      var timeToPixel = renderingContext.timeToPixel;
      var layerHeight = renderingContext.height;
      // current values
      var x = renderingContext.timeToPixel(Math.max(0, shape.x(datum)));
      var y = renderingContext.valueToPixel(shape.y(datum));
      var width = renderingContext.timeToPixel(shape.width(datum));
      var height = renderingContext.valueToPixel(shape.height(datum));
      // target values
      var targetX = Math.max(x + dx, 0);
      var targetY = y + dy;

      // lock in layer's y axis
      if (targetY > layerHeight) {
        targetY = layerHeight;
      } else if (targetY - (layerHeight - height) < 0) {
        targetY = layerHeight - height;
      }

      if (this.snapToGrid) {
        var beat0 = this._beatGrid.beats(timeToPixel.invert(targetX));
        var snapped0 = this._beatGrid.seconds(dx > 0 ? Math.ceil(beat0) : Math.floor(beat0));
        var beat1 = this._beatGrid.beats(timeToPixel.invert(targetX) + shape.width(datum));
        var snapped1 = this._beatGrid.seconds(dx > 0 ? Math.ceil(beat1) : Math.floor(beat1));

        if (snapped0 !== snapped1) {
          shape.x(datum, snapped0);
          shape.width(datum, snapped1 - snapped0);
          // shape.y(datum, renderingContext.valueToPixel.invert(targetY));
        }
      } else {
          shape.x(datum, timeToPixel.invert(targetX));
        }
    }
  }, {
    key: '_resizeLeft',
    value: function _resizeLeft(renderingContext, shape, datum, dx, dy, target) {
      var timeToPixel = renderingContext.timeToPixel;
      // current values
      var x = timeToPixel(Math.max(0, shape.x(datum)));
      var width = timeToPixel(shape.width(datum));
      // target values
      var maxTargetX = x + width;
      var targetX = x + dx < maxTargetX ? Math.max(x + dx, 0) : x;
      var targetWidth = targetX !== 0 ? Math.max(width - dx, 1) : width;

      if (this.snapToGrid) {
        var beat0 = this._beatGrid.beats(timeToPixel.invert(targetX));
        var snapped0 = this._beatGrid.seconds(dx > 0 ? Math.ceil(beat0) : Math.floor(beat0));
        var beat1 = this._beatGrid.beats(timeToPixel.invert(targetX) + timeToPixel.invert(targetWidth));
        var snapped1 = this._beatGrid.seconds(dx > 0 ? Math.ceil(beat1) : Math.floor(beat1));

        if (snapped0 !== snapped1) {
          shape.x(datum, snapped0);
          shape.width(datum, snapped1 - snapped0);
        }
      } else {
        shape.x(datum, renderingContext.timeToPixel.invert(targetX));
        shape.width(datum, renderingContext.timeToPixel.invert(targetWidth));
      }
    }
  }, {
    key: '_resizeRight',
    value: function _resizeRight(renderingContext, shape, datum, dx, dy, target) {
      // current values
      var width = renderingContext.timeToPixel(shape.width(datum));
      // target values
      var targetWidth = Math.max(width + dx, 1);

      if (this.snapToGrid) {
        var beat1 = this._beatGrid.beats(shape.x(datum) + renderingContext.timeToPixel.invert(targetWidth));
        var snapped1 = this._beatGrid.seconds(dx > 0 ? Math.ceil(beat1) : Math.floor(beat1));

        if (snapped1 - shape.x(datum)) {
          shape.width(datum, snapped1 - shape.x(datum));
        }
      } else {
        shape.width(datum, renderingContext.timeToPixel.invert(targetWidth));
      }
    }
  }, {
    key: 'select',
    value: function select(datum) {
      _get(Object.getPrototypeOf(BeatGridSnapSegmentBehavior.prototype), 'select', this).call(this, datum);
      this.highlight(datum, true);
    }
  }, {
    key: 'unselect',
    value: function unselect(datum) {
      _get(Object.getPrototypeOf(BeatGridSnapSegmentBehavior.prototype), 'unselect', this).call(this, datum);
      this.highlight(datum, false);
    }
  }, {
    key: 'highlight',
    value: function highlight(datum, isHighlighted) {
      var shape = this._layer.getShapeFromDatum(datum);
      if (shape) {
        if (isHighlighted) {
          shape.params.color = 'red';
        } else {
          shape.params.color = 'black';
        }
      } else {
        throw new Error('No shape for this datum in this layer', { datum: datum, layer: this._layer });
      }
    }
  }, {
    key: 'beatGrid',
    set: function set(value) {
      this._beatGrid = value;
    },
    get: function get() {
      return this._beatGrid;
    }
  }, {
    key: 'snapToGrid',
    set: function set(value) {
      this._snapToGrid = value;
    },
    get: function get() {
      return this._snapToGrid;
    }
  }]);

  return BeatGridSnapSegmentBehavior;
})(_baseBehavior2['default']);

exports['default'] = BeatGridSnapSegmentBehavior;
module.exports = exports['default'];

},{"./base-behavior":5,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],7:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

var BreakpointBehavior = (function (_BaseBehavior) {
  _inherits(BreakpointBehavior, _BaseBehavior);

  function BreakpointBehavior(snapFn) {
    _classCallCheck(this, BreakpointBehavior);

    _get(Object.getPrototypeOf(BreakpointBehavior.prototype), 'constructor', this).call(this);
    this.snapFn = snapFn || function (datum, accessor, value) {
      return value;
    };
  }

  _createClass(BreakpointBehavior, [{
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, target) {
      var data = this._layer.data;
      var layerHeight = renderingContext.height;
      // current position
      var x = renderingContext.timeToPixel(shape.x(datum));
      var y = renderingContext.valueToPixel(shape.y(datum));
      // target position
      var targetX = x + dx;
      var targetY = y + dy;

      // if (data.length > 2) {
      //   // create a sorted map of all `x` positions
      //   const xMap = data.map((d) => renderingContext.timeToPixel(shape.x(d)));
      //   xMap.sort((a, b) => a < b ? -1 : 1);
      //   // find index of our shape x position
      //   const index = xMap.indexOf(x);
      //   // lock to next siblings
      //   if (targetX < xMap[index - 1] || targetX > xMap[index + 1]) {
      //     targetX = x;
      //   }
      // }

      // ASSUME THAT THE 'data' ARRAY IS ORDERED ACCORDING TO x.

      if (targetX < 0) targetX = 0;

      // lock in y axis
      if (targetY < 0) {
        targetY = 0;
      } else if (targetY > layerHeight) {
        targetY = layerHeight;
      }

      // update datum with new values
      shape.x(datum, this.snapFn(datum, 'x', renderingContext.timeToPixel.invert(targetX)));
      shape.y(datum, this.snapFn(datum, 'y', renderingContext.valueToPixel.invert(targetY)));
    }
  }, {
    key: 'select',
    value: function select(datum) {
      _get(Object.getPrototypeOf(BreakpointBehavior.prototype), 'select', this).call(this, datum);
      this.highlight(datum, true);
    }
  }, {
    key: 'unselect',
    value: function unselect(datum) {
      _get(Object.getPrototypeOf(BreakpointBehavior.prototype), 'unselect', this).call(this, datum);
      this.highlight(datum, false);
    }
  }, {
    key: 'highlight',
    value: function highlight(datum, isHighlighted) {
      var shape = this._layer.getShapeFromDatum(datum);
      if (shape) {
        if (isHighlighted) {
          shape.params.color = 'red';
        } else {
          shape.params.color = undefined;
        }
      } else {
        throw new Error('No shape for this datum in this layer', { datum: datum, layer: this._layer });
      }
    }
  }]);

  return BreakpointBehavior;
})(_baseBehavior2['default']);

exports['default'] = BreakpointBehavior;
module.exports = exports['default'];

},{"./base-behavior":5,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],8:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

var MarkerBehavior = (function (_BaseBehavior) {
	_inherits(MarkerBehavior, _BaseBehavior);

	function MarkerBehavior(snapFn) {
		_classCallCheck(this, MarkerBehavior);

		_get(Object.getPrototypeOf(MarkerBehavior.prototype), 'constructor', this).call(this);
		this.snapFn = snapFn || function (datum, accessor, value) {
			return value;
		};
	}

	_createClass(MarkerBehavior, [{
		key: 'edit',
		value: function edit(renderingContext, shape, datum, dx, dy, target) {
			var x = renderingContext.timeToPixel(shape.x(datum));
			var targetX = x + dx > 0 ? x + dx : 0;

			shape.x(datum, this.snapFn(datum, 'x', renderingContext.timeToPixel.invert(targetX)));
		}
	}, {
		key: 'select',
		value: function select(datum) {
			_get(Object.getPrototypeOf(MarkerBehavior.prototype), 'select', this).call(this, datum);
			this.highlight(datum, true);
		}
	}, {
		key: 'unselect',
		value: function unselect(datum) {
			_get(Object.getPrototypeOf(MarkerBehavior.prototype), 'unselect', this).call(this, datum);
			this.highlight(datum, false);
		}
	}, {
		key: 'highlight',
		value: function highlight(datum, isHighlighted) {
			var shape = this._layer.getShapeFromDatum(datum);
			if (shape) {
				if (isHighlighted) {
					shape.params.color = shape.params.handlerColor = 'red';
				} else {
					shape.params.color = shape.params.handlerColor = undefined;
				}
			} else {
				throw new Error('No shape for this datum in this layer', { datum: datum, layer: this._layer });
			}
		}
	}]);

	return MarkerBehavior;
})(_baseBehavior2['default']);

exports['default'] = MarkerBehavior;
module.exports = exports['default'];

},{"./base-behavior":5,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],9:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

var NoBehavior = (function (_BaseBehavior) {
  _inherits(NoBehavior, _BaseBehavior);

  function NoBehavior() {
    _classCallCheck(this, NoBehavior);

    _get(Object.getPrototypeOf(NoBehavior.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(NoBehavior, [{
    key: 'select',
    value: function select(datum) {}
  }, {
    key: 'unselect',
    value: function unselect(datum) {}
  }, {
    key: 'toggleSelection',
    value: function toggleSelection(datum) {}
  }, {
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, $target) {}
  }, {
    key: 'can',
    value: function can(action, datums) {
      return false;
    }
  }, {
    key: 'create',
    value: function create(datum) {}
  }, {
    key: 'remove',
    value: function remove(datum) {}
  }, {
    key: 'minimize',
    value: function minimize() {}
  }, {
    key: 'highlight',
    value: function highlight(datum, isHighlighted) {}
  }, {
    key: 'selectedClass',
    set: function set(value) {},
    get: function get() {}
  }, {
    key: 'selectedDatums',
    get: function get() {}
  }]);

  return NoBehavior;
})(_baseBehavior2['default']);

exports['default'] = NoBehavior;
module.exports = exports['default'];

},{"./base-behavior":5,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],10:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

/*
 *  Allow to create a new datum only in empty spaces.
 *  When the layer requests an edit, refuse it if the new datum version overlaps an existing segment.
 */

var NoHorizontallOverlappingSegmentsBehavior = (function (_BaseBehavior) {
  _inherits(NoHorizontallOverlappingSegmentsBehavior, _BaseBehavior);

  /* This class name clearly shows the author suffers from some Java/COBOL related cognitive disease. */

  function NoHorizontallOverlappingSegmentsBehavior(accessors) {
    _classCallCheck(this, NoHorizontallOverlappingSegmentsBehavior);

    _get(Object.getPrototypeOf(NoHorizontallOverlappingSegmentsBehavior.prototype), 'constructor', this).call(this);
    this.dummy = {
      x: function x(d, v) {
        if (v === undefined) v = null;
        if (v === null) {
          return d.x;
        }
        d.x = v;
      },
      width: function width(d, v) {
        if (v === undefined) v = null;
        if (v === null) {
          return d.width;
        }
        d.width = v;
      }
    };
    for (var key in accessors) {
      this.dummy[key] = accessors[key];
    }
  }

  _createClass(NoHorizontallOverlappingSegmentsBehavior, [{
    key: 'initialize',
    value: function initialize(layer) {
      _get(Object.getPrototypeOf(NoHorizontallOverlappingSegmentsBehavior.prototype), 'initialize', this).call(this, layer);
      var accessors = this._layer._shapeConfiguration ? this._layer._shapeConfiguration.accessors : {};
      for (var key in accessors) {
        this.dummy[key] = accessors[key];
      }
    }
  }, {
    key: 'intersects',
    value: function intersects(datum1, datum2) {
      if (this.dummy.x(datum1) >= this.dummy.x(datum2) + this.dummy.width(datum2) || this.dummy.x(datum1) + this.dummy.width(datum1) <= this.dummy.x(datum2)) return false;else return true;
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      _get(Object.getPrototypeOf(NoHorizontallOverlappingSegmentsBehavior.prototype), 'destroy', this).call(this);
      this.intersects = null;
    }
  }, {
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, target) {
      var action = 'move';

      if (target.hasName('handler')) {
        if (target.hasName('left')) action = 'resizeLeft';else if (target.hasName('right')) action = 'resizeRight';else throw new Error('Unexpected konva shape name');
      } else if (target.hasName('segment')) action = 'move';else throw new Error('Unexpected konva shape name');

      this['_' + action](renderingContext, shape, datum, dx, dy, target);
    }
  }, {
    key: '_move',
    value: function _move(renderingContext, shape, datum, dx, dy, target) {
      var layerHeight = renderingContext.height;
      // current values
      var x = renderingContext.timeToPixel(shape.x(datum));
      var y = renderingContext.valueToPixel(shape.y(datum));
      var width = renderingContext.timeToPixel(shape.width(datum));
      var height = renderingContext.valueToPixel(shape.height(datum));
      // target values
      var targetX = Math.max(x + dx, 0);

      targetX = renderingContext.timeToPixel.invert(targetX);
      x = shape.x(datum);

      shape.x(datum, targetX);

      for (var i = 0; i < this._layer.data.length; i++) {
        if (this._layer.data[i] !== datum && this.intersects(this._layer.data[i], datum)) {
          if (x < shape.x(this._layer.data[i])) shape.x(datum, shape.x(this._layer.data[i]) - shape.width(datum));else shape.x(datum, shape.x(this._layer.data[i]) + shape.width(this._layer.data[i]));
          return;
        }
      }
    }
  }, {
    key: '_resizeLeft',
    value: function _resizeLeft(renderingContext, shape, datum, dx, dy, target) {
      // current values
      var x = renderingContext.timeToPixel(shape.x(datum));
      var width = renderingContext.timeToPixel(shape.width(datum));
      // target values
      var maxTargetX = x + width;
      var targetX = x + dx < maxTargetX ? Math.max(x + dx, 0) : x;
      var targetWidth = targetX !== 0 ? Math.max(width - dx, 1) : width;

      targetX = renderingContext.timeToPixel.invert(targetX);
      targetWidth = renderingContext.timeToPixel.invert(targetWidth);
      x = shape.x(datum);
      width = shape.width(datum);

      shape.x(datum, targetX);
      shape.width(datum, targetWidth);

      for (var i = 0; i < this._layer.data.length; i++) {
        if (this._layer.data[i] !== datum && this.intersects(this._layer.data[i], datum)) {
          shape.width(datum, x + width - (shape.x(this._layer.data[i]) + shape.width(this._layer.data[i])));
          shape.x(datum, shape.x(this._layer.data[i]) + shape.width(this._layer.data[i]));
          return;
        }
      }
    }
  }, {
    key: '_resizeRight',
    value: function _resizeRight(renderingContext, shape, datum, dx, dy, target) {
      // current values
      var width = renderingContext.timeToPixel(shape.width(datum));
      // target values
      var targetWidth = renderingContext.timeToPixel.invert(Math.max(width + dx, 1));
      var x = shape.x(datum);
      width = shape.width(datum);

      shape.width(datum, targetWidth);

      for (var i = 0; i < this._layer.data.length; i++) {
        if (this._layer.data[i] !== datum && this.intersects(this._layer.data[i], datum)) {
          shape.width(datum, shape.x(this._layer.data[i]) - shape.x(datum));
          return;
        }
      }
    }
  }, {
    key: 'can',
    value: function can(action, datums) {
      switch (action) {
        case 'add':
          var i = 0,
              j = 0;
          for (i = 0; i < datums.length; i++) for (j = i + 1; j < datums.length; j++) if (datums[i] !== datums[j] && this.intersects(datums[i], datums[j])) return false;

          for (i = 0; i < this._layer.data.length; i++) for (j = 0; j < datums.length; j++) if (this._layer.data[i] !== datums[j] && this.intersects(this._layer.data[i], datums[j])) return false;

          return true;
        default:
          return true;
      }
    }
  }]);

  return NoHorizontallOverlappingSegmentsBehavior;
})(_baseBehavior2['default']);

exports['default'] = NoHorizontallOverlappingSegmentsBehavior;
module.exports = exports['default'];

},{"./base-behavior":5,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],11:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

var ScrollSegmentBehavior = (function (_BaseBehavior) {
  _inherits(ScrollSegmentBehavior, _BaseBehavior);

  function ScrollSegmentBehavior(targetTimelines) {
    _classCallCheck(this, ScrollSegmentBehavior);

    _get(Object.getPrototypeOf(ScrollSegmentBehavior.prototype), 'constructor', this).call(this);
    this.targetTimelines = targetTimelines;
  }

  _createClass(ScrollSegmentBehavior, [{
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, target) {
      var action = 'move';

      if (target.hasName('handler')) {
        if (target.hasName('left')) action = 'resizeLeft';else if (target.hasName('right')) action = 'resizeRight';else throw new Error('Unexpected konva shape name');
      } else if (target.hasName('segment')) action = 'move';else throw new Error('Unexpected konva shape name');

      this['_' + action](renderingContext, shape, datum, dx, dy, target);
    }
  }, {
    key: '_move',
    value: function _move(renderingContext, shape, datum, dx, dy, target) {
      var layerHeight = renderingContext.height;
      // current values
      var x = renderingContext.timeToPixel(shape.x(datum));
      var y = renderingContext.valueToPixel(shape.y(datum));
      var width = renderingContext.timeToPixel(shape.width(datum));
      var height = renderingContext.valueToPixel(shape.height(datum));
      // target values
      var targetX = Math.max(x + dx, 0);
      var targetY = y + dy;

      // lock in layer's y axis
      if (targetY > layerHeight) {
        targetY = layerHeight;
      } else if (targetY - (layerHeight - height) < 0) {
        targetY = layerHeight - height;
      }

      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
      shape.y(datum, renderingContext.valueToPixel.invert(targetY));

      this._refresh(shape.x(datum), shape.width(datum));
    }
  }, {
    key: '_resizeLeft',
    value: function _resizeLeft(renderingContext, shape, datum, dx, dy, target) {
      // current values
      var x = renderingContext.timeToPixel(shape.x(datum));
      var width = renderingContext.timeToPixel(shape.width(datum));
      // target values
      var maxTargetX = x + width;
      var targetX = x + dx < maxTargetX ? Math.max(x + dx, 0) : x;
      var targetWidth = targetX !== 0 ? Math.max(width - dx, 1) : width;

      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
      shape.width(datum, renderingContext.timeToPixel.invert(targetWidth));

      this._refresh(shape.x(datum), shape.width(datum));
    }
  }, {
    key: '_resizeRight',
    value: function _resizeRight(renderingContext, shape, datum, dx, dy, target) {
      // current values
      var width = renderingContext.timeToPixel(shape.width(datum));
      // target values
      var targetWidth = Math.max(width + dx, 1);

      shape.width(datum, renderingContext.timeToPixel.invert(targetWidth));

      this._refresh(shape.x(datum), shape.width(datum));
    }
  }, {
    key: '_refresh',
    value: function _refresh(x, width) {
      x = x === undefined ? this.layer.data[0].x : x;
      width = width === undefined ? this.layer.data[0].width : width;
      this.targetTimelines.forEach(function (timeline) {
        timeline.visibleInterval = { start: x, duration: width };
        timeline.tracks.update();
      });
    }
  }]);

  return ScrollSegmentBehavior;
})(_baseBehavior2['default']);

exports['default'] = ScrollSegmentBehavior;
module.exports = exports['default'];

},{"./base-behavior":5,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],12:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

var SegmentBehavior = (function (_BaseBehavior) {
  _inherits(SegmentBehavior, _BaseBehavior);

  function SegmentBehavior(snapFn) {
    _classCallCheck(this, SegmentBehavior);

    _get(Object.getPrototypeOf(SegmentBehavior.prototype), 'constructor', this).call(this);
    this.snapFn = snapFn || function (datum, accessor, value) {
      return value;
    };
  }

  _createClass(SegmentBehavior, [{
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, target) {
      var action = 'move';

      if (target.hasName('handler')) {
        if (target.hasName('left')) action = 'resizeLeft';else if (target.hasName('right')) action = 'resizeRight';else if (target.hasName('top')) action = 'resizeTop';else if (target.hasName('bottom')) action = 'resizeBottom';else throw new Error('Unexpected konva shape name');
      } else if (target.hasName('segment')) action = 'move';else throw new Error('Unexpected konva shape name');

      this['_' + action](renderingContext, shape, datum, dx, dy, target);
    }
  }, {
    key: '_move',
    value: function _move(renderingContext, shape, datum, dx, dy, target) {
      var layerHeight = renderingContext.height;
      // current values
      var x = renderingContext.timeToPixel(shape.x(datum));
      var y = renderingContext.valueToPixel(shape.y(datum));
      var width = renderingContext.timeToPixel(shape.width(datum));
      // const height = renderingContext.valueToPixel(shape.height(datum));
      var height = Math.abs(renderingContext.valueToPixel(shape.y(datum) + shape.height(datum)) - renderingContext.valueToPixel(shape.y(datum)));

      // target values
      var targetX = Math.max(x + dx, 0);
      var targetY = Math.min(Math.max(0, y + dy), layerHeight);

      // console.log([targetY, y, height, layerHeight]);

      // lock in layer's y axis
      if (targetY > layerHeight) {
        targetY = layerHeight;
      } else if (targetY - height < 0) {
        targetY = height;
      }

      shape.x(datum, this.snapFn(datum, 'x', renderingContext.timeToPixel.invert(targetX)));
      shape.y(datum, this.snapFn(datum, 'y', renderingContext.valueToPixel.invert(targetY)));
    }
  }, {
    key: '_resizeLeft',
    value: function _resizeLeft(renderingContext, shape, datum, dx, dy, target) {
      // current values
      var x = renderingContext.timeToPixel(shape.x(datum));
      var width = renderingContext.timeToPixel(shape.width(datum));
      // target values
      var maxTargetX = x + width;
      var targetX = x + dx < maxTargetX ? Math.max(x + dx, 0) : x;
      var targetWidth = targetX !== 0 ? Math.max(width - dx, 1) : width;

      shape.x(datum, this.snapFn(datum, 'x', renderingContext.timeToPixel.invert(targetX)));
      shape.width(datum, this.snapFn(datum, 'width', renderingContext.timeToPixel.invert(targetWidth)));
    }
  }, {
    key: '_resizeRight',
    value: function _resizeRight(renderingContext, shape, datum, dx, dy, target) {
      // current values
      var width = renderingContext.timeToPixel(shape.width(datum));
      // target values
      var targetWidth = Math.max(width + dx, 1);

      shape.width(datum, this.snapFn(datum, 'width', renderingContext.timeToPixel.invert(targetWidth)));
    }
  }, {
    key: '_resizeTop',
    value: function _resizeTop(renderingContext, shape, datum, dx, dy, target) {
      // console.log('top ' + dy);

      var height = renderingContext.valueToPixel(shape.height(datum));

      var targetHeight = height + dy;

      shape.height(datum, this.snapFn(datum, 'height', renderingContext.valueToPixel.invert(targetHeight)));
    }
  }, {
    key: '_resizeBottom',
    value: function _resizeBottom(renderingContext, shape, datum, dx, dy, target) {
      // console.log('bottom ' + dy);

      var layerHeight = renderingContext.height;
      var y = renderingContext.valueToPixel(shape.y(datum));
      var height = renderingContext.valueToPixel(shape.height(datum));

      var targetY = Math.min(Math.max(0, y + dy), layerHeight);
      var targetHeight = height - dy;

      shape.y(datum, this.snapFn(datum, 'y', renderingContext.valueToPixel.invert(targetY)));
      shape.height(datum, this.snapFn(datum, 'height', renderingContext.valueToPixel.invert(targetHeight)));
    }
  }, {
    key: 'select',
    value: function select(datum) {
      _get(Object.getPrototypeOf(SegmentBehavior.prototype), 'select', this).call(this, datum);
      this.highlight(datum, true);
    }
  }, {
    key: 'unselect',
    value: function unselect(datum) {
      _get(Object.getPrototypeOf(SegmentBehavior.prototype), 'unselect', this).call(this, datum);
      this.highlight(datum, false);
    }
  }, {
    key: 'highlight',
    value: function highlight(datum, isHighlighted) {
      var shape = this._layer.getShapeFromDatum(datum);
      if (shape) {
        if (isHighlighted) {
          shape.params.color = 'red';
        } else {
          shape.params.color = undefined;
        }
      } else {
        throw new Error('No shape for this datum in this layer', { datum: datum, layer: this._layer });
      }
    }
  }]);

  return SegmentBehavior;
})(_baseBehavior2['default']);

exports['default'] = SegmentBehavior;
module.exports = exports['default'];

},{"./base-behavior":5,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],13:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

var SiblingLockedSegmentBehavior = (function (_BaseBehavior) {
  _inherits(SiblingLockedSegmentBehavior, _BaseBehavior);

  function SiblingLockedSegmentBehavior() {
    _classCallCheck(this, SiblingLockedSegmentBehavior);

    _get(Object.getPrototypeOf(SiblingLockedSegmentBehavior.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SiblingLockedSegmentBehavior, [{
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, target) {
      var data = this._layer.data;
      var layerHeight = renderingContext.height;
      // current position
      var x = renderingContext.timeToPixel(shape.x(datum));
      var y = renderingContext.valueToPixel(shape.y(datum));
      // target position
      var targetX = x + dx;
      var targetY = y + dy;

      if (data.length > 2) {
        // create a sorted map of all `x` positions
        var xMap = data.map(function (d) {
          var x = renderingContext.timeToPixel(shape.x(d));
          var width = renderingContext.timeToPixel(shape.x(d) + shape.width(d));
          return { start: x, end: x + width };
        });
        xMap.sort(function (a, b) {
          return a.start < b.start ? -1 : 1;
        });
        // find index of our shape x position
        var index = xMap.indexOf(x);
        // lock to next siblings
        if (targetX < xMap[index - 1].end || targetX + shape.width(datum) > xMap[index + 1].start) {
          targetX = x;
        }
      }

      if (targetX < 0) targetX = 0;

      // lock in y axis
      if (targetY < 0) {
        targetY = 0;
      } else if (targetY > layerHeight) {
        targetY = layerHeight;
      }

      // update datum with new values
      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
      shape.y(datum, renderingContext.valueToPixel.invert(targetY));
    }
  }, {
    key: 'select',
    value: function select(datum) {
      _get(Object.getPrototypeOf(SiblingLockedSegmentBehavior.prototype), 'select', this).call(this, datum);
      this.highlight(datum, true);
    }
  }, {
    key: 'unselect',
    value: function unselect(datum) {
      _get(Object.getPrototypeOf(SiblingLockedSegmentBehavior.prototype), 'unselect', this).call(this, datum);
      this.highlight(datum, false);
    }
  }, {
    key: 'highlight',
    value: function highlight(datum, isHighlighted) {
      var shape = this._layer.getShapeFromDatum(datum);
      if (shape) {
        if (isHighlighted) {
          shape.params.color = 'red';
        } else {
          shape.params.color = 'black';
        }
      } else {
        throw new Error('No shape for this datum in this layer', { datum: datum, layer: this._layer });
      }
    }
  }]);

  return SiblingLockedSegmentBehavior;
})(_baseBehavior2['default']);

exports['default'] = SiblingLockedSegmentBehavior;
module.exports = exports['default'];

},{"./base-behavior":5,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],14:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

var SimpleSnapSegmentBehavior = (function (_BaseBehavior) {
  _inherits(SimpleSnapSegmentBehavior, _BaseBehavior);

  function SimpleSnapSegmentBehavior() {
    _classCallCheck(this, SimpleSnapSegmentBehavior);

    _get(Object.getPrototypeOf(SimpleSnapSegmentBehavior.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SimpleSnapSegmentBehavior, [{
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, target) {
      var action = 'move';

      if (target.hasName('handler')) {
        if (target.hasName('left')) action = 'resizeLeft';else if (target.hasName('right')) action = 'resizeRight';else throw new Error('Unexpected konva shape name');
      } else if (target.hasName('segment')) action = 'move';else throw new Error('Unexpected konva shape name');

      this['_' + action](renderingContext, shape, datum, dx, dy, target);
    }
  }, {
    key: '_move',
    value: function _move(renderingContext, shape, datum, dx, dy, target) {
      var layerHeight = renderingContext.height;
      // current values
      var x = renderingContext.timeToPixel(shape.x(datum));
      var y = renderingContext.valueToPixel(shape.y(datum));
      var width = renderingContext.timeToPixel(shape.width(datum));
      var height = renderingContext.valueToPixel(shape.height(datum));
      // target values
      var targetX = Math.max(x + dx, 0);
      var targetY = y + dy;

      // lock in layer's y axis
      if (targetY > layerHeight) {
        targetY = layerHeight;
      } else if (targetY - (layerHeight - height) < 0) {
        targetY = layerHeight - height;
      }

      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
      shape.y(datum, renderingContext.valueToPixel.invert(targetY));

      var snappedX = renderingContext.timeToPixel(Math.round(shape.x(datum)));

      shape.x(datum, renderingContext.timeToPixel.invert(snappedX));
    }
  }, {
    key: '_resizeLeft',
    value: function _resizeLeft(renderingContext, shape, datum, dx, dy, target) {
      // current values
      var x = renderingContext.timeToPixel(shape.x(datum));
      var width = renderingContext.timeToPixel(shape.width(datum));
      // target values
      var maxTargetX = x + width;
      var targetX = x + dx < maxTargetX ? Math.max(x + dx, 0) : x;
      var targetWidth = targetX !== 0 ? Math.max(width - dx, 1) : width;

      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
      shape.width(datum, renderingContext.timeToPixel.invert(targetWidth));
    }
  }, {
    key: '_resizeRight',
    value: function _resizeRight(renderingContext, shape, datum, dx, dy, target) {
      // current values
      var width = renderingContext.timeToPixel(shape.width(datum));
      // target values
      var targetWidth = Math.max(width + dx, 1);

      shape.width(datum, renderingContext.timeToPixel.invert(targetWidth));
    }
  }, {
    key: 'select',
    value: function select(datum) {
      _get(Object.getPrototypeOf(SimpleSnapSegmentBehavior.prototype), 'select', this).call(this, datum);
      this.highlight(datum, true);
    }
  }, {
    key: 'unselect',
    value: function unselect(datum) {
      _get(Object.getPrototypeOf(SimpleSnapSegmentBehavior.prototype), 'unselect', this).call(this, datum);
      this.highlight(datum, false);
    }
  }, {
    key: 'highlight',
    value: function highlight(datum, isHighlighted) {
      var shape = this._layer.getShapeFromDatum(datum);
      if (shape) {
        if (isHighlighted) {
          shape.params.color = 'red';
        } else {
          shape.params.color = 'black';
        }
      } else {
        throw new Error('No shape for this datum in this layer', { datum: datum, layer: this._layer });
      }
    }
  }]);

  return SimpleSnapSegmentBehavior;
})(_baseBehavior2['default']);

exports['default'] = SimpleSnapSegmentBehavior;
module.exports = exports['default'];

},{"./base-behavior":5,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],15:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

var SnapBaseBehavior = (function (_BaseBehavior) {
	_inherits(SnapBaseBehavior, _BaseBehavior);

	function SnapBaseBehavior() {
		_classCallCheck(this, SnapBaseBehavior);

		_get(Object.getPrototypeOf(SnapBaseBehavior.prototype), 'constructor', this).call(this);

		this.snapFn = function (datum, accessor, value) {
			return value;
		};
	}

	return SnapBaseBehavior;
})(_baseBehavior2['default']);

exports['default'] = SnapBaseBehavior;
module.exports = exports['default'];

},{"./base-behavior":5,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],16:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

/**
* TimeContextBehavior is used internally in Layers to modify their TimeContext.
* This object is different from other Shapes Behaviors and exists mostly to decrease the size of the Layer.
* All the code here could be considered as part of the layer.
*/

var TimeContextBehavior = (function (_BaseBehavior) {
	_inherits(TimeContextBehavior, _BaseBehavior);

	function TimeContextBehavior() {
		_classCallCheck(this, TimeContextBehavior);

		_get(Object.getPrototypeOf(TimeContextBehavior.prototype), 'constructor', this).apply(this, arguments);
	}

	_createClass(TimeContextBehavior, [{
		key: 'edit',
		value: function edit(layer, dx, dy, target) {
			var timeContext = layer.timeContext;

			if (target.hasName('handler')) {
				if (target.hasName('left')) this._editLeft(timeContext, dx);else if (target.hasName('right')) this._editRight(timeContext, dx);else throw new Error('Unexpected konva shape name');
			} else if (target.hasName('segment')) this._move(timeContext, dx);else throw new Error('Unexpected konva shape name');
		}
	}, {
		key: '_editLeft',
		value: function _editLeft(timeContext, dx) {
			// edit `start`, `offset` and `duration`
			var x = timeContext.parent.timeToPixel(timeContext.start);
			var offset = timeContext.timeToPixel(timeContext.offset);
			var width = timeContext.timeToPixel(timeContext.duration);

			var targetX = x + dx;
			var targetOffset = offset - dx;
			var targetWidth = Math.max(width - dx, 1);

			timeContext.start = timeContext.parent.timeToPixel.invert(targetX);
			timeContext.offset = timeContext.timeToPixel.invert(targetOffset);
			timeContext.duration = timeContext.timeToPixel.invert(targetWidth);
		}
	}, {
		key: '_editRight',
		value: function _editRight(timeContext, dx) {
			var width = timeContext.timeToPixel(timeContext.duration);
			var targetWidth = Math.max(width + dx, 1);

			timeContext.duration = timeContext.timeToPixel.invert(targetWidth);
		}
	}, {
		key: '_move',
		value: function _move(timeContext, dx) {
			var x = timeContext.parent.timeToPixel(timeContext.start);
			var targetX = Math.max(x + dx, 0);

			timeContext.start = timeContext.parent.timeToPixel.invert(targetX);
		}
	}, {
		key: 'stretch',
		value: function stretch(layer, dx, dy, target) {
			var timeContext = layer.timeContext;
			var lastDuration = timeContext.duration;
			var lastOffset = timeContext.offset;

			this.edit(layer, dx, dy, target);

			var newDuration = timeContext.duration;
			var ratio = newDuration / lastDuration;

			timeContext.stretchRatio *= ratio;
			timeContext.offset = lastOffset;
			timeContext.duration = lastDuration;
		}
	}]);

	return TimeContextBehavior;
})(_baseBehavior2['default']);

exports['default'] = TimeContextBehavior;
module.exports = exports['default'];

},{"./base-behavior":5,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],17:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

var TraceBehavior = (function (_BaseBehavior) {
  _inherits(TraceBehavior, _BaseBehavior);

  function TraceBehavior() {
    _classCallCheck(this, TraceBehavior);

    _get(Object.getPrototypeOf(TraceBehavior.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(TraceBehavior, [{
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, target) {
      if (target.hasName('min')) {
        this._editRange(renderingContext, shape, datum, dx, -dy, 'min');
      } else if (target.hasName('max')) {
        this._editRange(renderingContext, shape, datum, dx, -dy, 'max');
      } else if (target.hasName('mean')) {
        this._editMean(renderingContext, shape, datum, dx, -dy);
      } else throw new Error('Unexpected konva shape name');
    }
  }, {
    key: '_editMean',
    value: function _editMean(renderingContext, shape, datum, dx, dy) {
      // work in pixel domain
      var x = renderingContext.timeToPixel(shape.x(datum));
      var y = renderingContext.valueToPixel(shape.mean(datum));

      var targetX = x + dx;
      var targetY = y - dy;

      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
      shape.mean(datum, renderingContext.valueToPixel.invert(targetY));
    }
  }, {
    key: '_editRange',
    value: function _editRange(renderingContext, shape, datum, dx, dy, rangeSide) {
      var range = renderingContext.valueToPixel(shape.range(datum));

      var targetRange = rangeSide === 'min' ? range + 2 * dy : range - 2 * dy;
      targetRange = Math.max(targetRange, 0);

      shape.range(datum, Math.max(0, renderingContext.valueToPixel.invert(targetRange)));
    }
  }, {
    key: 'select',
    value: function select(datum) {
      _get(Object.getPrototypeOf(TraceBehavior.prototype), 'select', this).call(this, datum);
      this.highlight(datum, true);
    }
  }, {
    key: 'unselect',
    value: function unselect(datum) {
      _get(Object.getPrototypeOf(TraceBehavior.prototype), 'unselect', this).call(this, datum);
      this.highlight(datum, false);
    }
  }, {
    key: 'highlight',
    value: function highlight(datum, isHighlighted) {
      var shape = this._layer.getShapeFromDatum(datum);
      if (shape) {
        if (isHighlighted) {
          shape.params.meanColor = 'red';
          shape.params.rangeColor = 'red';
        } else {
          var defaults = shape._getDefaults();
          shape.params.meanColor = defaults.meanColor;
          shape.params.rangeColor = defaults.rangeColor;
        }
      } else {
        throw new Error('No shape for this datum in this layer', { datum: datum, layer: this._layer });
      }
    }
  }]);

  return TraceBehavior;
})(_baseBehavior2['default']);

exports['default'] = TraceBehavior;
module.exports = exports['default'];

},{"./base-behavior":5,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],18:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

var WaveformBehavior = (function (_BaseBehavior) {
  _inherits(WaveformBehavior, _BaseBehavior);

  function WaveformBehavior() {
    _classCallCheck(this, WaveformBehavior);

    _get(Object.getPrototypeOf(WaveformBehavior.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(WaveformBehavior, [{
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, target) {
      var action = 'move';

      if (target.hasName('handler')) {
        if (target.hasName('left')) action = 'resizeLeft';else if (target.hasName('right')) action = 'resizeRight';else throw new Error('Unexpected konva shape name');
      } else if (target.hasName('body')) {
        action = 'move';
      } else if (target.hasName('header')) {
        // TODO
        return;
      } else throw new Error('Unexpected konva shape name');

      this['_' + action](renderingContext, shape, datum, dx, dy, target);
    }
  }, {
    key: '_move',
    value: function _move(renderingContext, shape, datum, dx, dy, target) {
      var layerHeight = renderingContext.height;
      // current values
      var x = renderingContext.timeToPixel(shape.x(datum));
      // const y = renderingContext.valueToPixel(shape.y(datum));
      var y = 0;
      var width = renderingContext.timeToPixel(shape.width(datum));
      // const height = renderingContext.valueToPixel(shape.height(datum));
      var height = renderingContext.height;
      // target values
      var targetX = Math.max(x + dx, 0);
      var targetY = y + dy;

      // lock in layer's y axis
      if (targetY > layerHeight) {
        targetY = layerHeight;
      } else if (targetY - (layerHeight - height) < 0) {
        targetY = layerHeight - height;
      }

      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
      // shape.y(datum, renderingContext.valueToPixel.invert(targetY));
    }
  }, {
    key: '_resizeLeft',
    value: function _resizeLeft(renderingContext, shape, datum, dx, dy, target) {
      // return; // TODO: update this for the waveform shape
      // current values
      var x = renderingContext.timeToPixel(shape.x(datum));
      var width = renderingContext.timeToPixel(shape.width(datum));
      // target values
      var maxTargetX = x + width;
      var targetX = x + dx < maxTargetX ? Math.max(x + dx, 0) : x;
      var targetWidth = targetX !== 0 ? Math.max(width - dx, 1) : width;

      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
      shape.width(datum, renderingContext.timeToPixel.invert(targetWidth));
    }
  }, {
    key: '_resizeRight',
    value: function _resizeRight(renderingContext, shape, datum, dx, dy, target) {
      // return; // TODO: update this for the waveform shape
      // current values
      var width = renderingContext.timeToPixel(shape.width(datum));
      // target values
      var targetWidth = Math.max(width + dx, 1);

      shape.width(datum, renderingContext.timeToPixel.invert(targetWidth));
    }
  }, {
    key: 'select',
    value: function select(datum) {
      _get(Object.getPrototypeOf(WaveformBehavior.prototype), 'select', this).call(this, datum);
      this.highlight(datum, true);
    }
  }, {
    key: 'unselect',
    value: function unselect(datum) {
      _get(Object.getPrototypeOf(WaveformBehavior.prototype), 'unselect', this).call(this, datum);
      this.highlight(datum, false);
    }
  }, {
    key: 'highlight',
    value: function highlight(datum, isHighlighted) {
      var shape = this._layer.getShapeFromDatum(datum);
      if (shape) {
        // if (isHighlighted) {
        //   shape.params.color = 'red';
        // } else {
        //   shape.params.color = 'black';
        // }
      } else {
          throw new Error('No shape for this datum in this layer', { datum: datum, layer: this._layer });
        }
    }
  }]);

  return WaveformBehavior;
})(_baseBehavior2['default']);

exports['default'] = WaveformBehavior;
module.exports = exports['default'];

},{"./base-behavior":5,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],19:[function(require,module,exports){
'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _utilsScales = require('../utils/scales');

var _utilsScales2 = _interopRequireDefault(_utilsScales);

var LayerTimeContext = (function () {
  /**
   * @param {TimelineTimeContext} parent - The `TimelineTimeContext` instance of the timeline.
   */

  function LayerTimeContext(parent) {
    _classCallCheck(this, LayerTimeContext);

    if (!parent) {
      throw new Error('LayerTimeContext must have a parent');
    }

    /**
     * The `TimelineTimeContext` instance of the timeline.
     *
     * @type {TimelineTimeContext}
     */
    this.parent = parent;
    this._lockedToParentInterval = false;

    this._timeToPixel = null;
    this._start = 0;
    this._duration = parent.visibleDuration;
    this._offset = 0;
    this._stretchRatio = 1;
    // register into the timeline's TimeContext
    this.parent._children.push(this);
  }

  /**
   * Creates a clone of the current time context.
   *
   * @return {LayerTimeContext}
   */

  _createClass(LayerTimeContext, [{
    key: 'clone',
    value: function clone() {
      var ctx = new this();

      ctx.parent = this.parent;
      ctx.start = this.start;
      ctx.duration = this.duration;
      ctx.offset = this.offset;
      ctx.stretchRatio = this.stretchRatio; // creates the local scale if needed

      return ctx;
    }

    /**
     * Returns the start position of the time context (in seconds).
     *
     * @type {Number}
     */
  }, {
    key: 'pixelToTime',

    /**
     * Helper function to convert pixel to time.
     *
     * @param {Number} px
     * @return {Number}
     */
    value: function pixelToTime(px) {
      if (!this._timeToPixel) {
        return this.parent.timeToPixel.invert(px);
      }

      return this._timeToPixel.invert(px);
    }

    /**
     * Returns the time interval of the visible area in the timeline.
     *
     * @type {Object} 
     */
  }, {
    key: 'start',
    get: function get() {
      return !this._lockedToParentInterval ? this._start : -this.parent.offset;
    },

    /**
     * Sets the start position of the time context (in seconds).
     *
     * @type {Number}
     */
    set: function set(value) {
      this._start = value;
    }

    /**
     * Returns the duration of the time context (in seconds).
     *
     * @type {Number}
     */
  }, {
    key: 'duration',
    get: function get() {
      return !this._lockedToParentInterval ? this._duration : this.parent.visibleDuration;
    },

    /**
     * Sets the duration of the time context (in seconds).
     *
     * @type {Number}
     */
    set: function set(value) {
      this._duration = value;
    }

    /**
     * Returns the offset of the time context (in seconds).
     *
     * @type {Number}
     */
  }, {
    key: 'offset',
    get: function get() {
      return !this._lockedToParentInterval ? this._offset : this.parent.offset;
    },

    /**
     * Sets the offset of the time context (in seconds).
     *
     * @type {Number}
     */
    set: function set(value) {
      this._offset = value;
    }

    /**
     * Returns the stretch ratio of the time context.
     *
     * @type {Number}
     */
  }, {
    key: 'stretchRatio',
    get: function get() {
      return this._stretchRatio;
    },

    /**
     * Sets the stretch ratio of the time context.
     *
     * @type {Number}
     */
    set: function set(value) {
      // remove local scale if ratio = 1
      if (value === 1) {
        this._timeToPixel = null;
        return;
      }
      // reuse previsously created local scale if exists
      var timeToPixel = this._timeToPixel ? this._timeToPixel : _utilsScales2['default'].linear().domain([0, 1]);

      timeToPixel.range([0, this.parent.computedPixelsPerSecond * value]);

      this._timeToPixel = timeToPixel;
      this._stretchRatio = value;
    }

    /**
     * Returns the time to pixel transfert function of the time context. If
     * the `stretchRatio` attribute is equal to 1, this function is the global
     * one from the `TimelineTimeContext` instance.
     *
     * @type {Function}
     */
  }, {
    key: 'timeToPixel',
    get: function get() {
      if (!this._timeToPixel) {
        return this.parent.timeToPixel;
      }

      return this._timeToPixel;
    }
  }, {
    key: 'visibleInterval',
    get: function get() {
      var interval = {};
      interval.start = -this.offset;
      interval.duration = this.duration;
      return interval;
    },

    /**
     * Focus the timeline visible area in the provided time interval.
     *
     * @type {Object} 
     */
    set: function set(value) {
      this.offset = -value.start;
      this.duration = value.duration;
    }

    /**
     *  TODO
     */
  }, {
    key: 'lockedToParentInterval',
    get: function get() {
      return this._lockedToParentInterval;
    },
    set: function set(value) {
      this._lockedToParentInterval = value;
    }
  }]);

  return LayerTimeContext;
})();

exports['default'] = LayerTimeContext;
module.exports = exports['default'];

},{"../utils/scales":74,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/interop-require-default":92}],20:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _Map = require('babel-runtime/core-js/map')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _utilsScales = require('../utils/scales');

var _utilsScales2 = _interopRequireDefault(_utilsScales);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _shapesSegment = require('../shapes/segment');

var _shapesSegment2 = _interopRequireDefault(_shapesSegment);

var _behaviorsTimeContextBehavior = require('../behaviors/time-context-behavior');

var _behaviorsTimeContextBehavior2 = _interopRequireDefault(_behaviorsTimeContextBehavior);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var Layer = (function (_events$EventEmitter) {
	_inherits(Layer, _events$EventEmitter);

	function Layer(dataType, data, options) {
		var _this = this;

		_classCallCheck(this, Layer);

		_get(Object.getPrototypeOf(Layer.prototype), 'constructor', this).call(this);

		this.dataType = dataType;

		if (!options) options = {};

		var defaults = {
			height: 100,
			top: 0,
			opacity: 1,
			yDomain: [0, 1],
			className: null, // TODO
			selectedClassName: 'selected',
			context: {
				handlerWidth: 10,
				handlerOpacity: 0.2,
				opacity: 0.5,
				color: '#787878'
			},
			hittable: true };

		// when false the layer is not returned by `BaseState.getHitLayers`
		this._behavior = null;

		/**
  * Parameters of the layers, `defaults` overrided with options.
  * @type {Object}
  */
		this.params = _Object$assign({}, defaults, options);
		this.timeContextBehavior = new _behaviorsTimeContextBehavior2['default']();

		this._shapeConfiguration = null; // { ctor, accessors, options }
		this._commonShapeConfiguration = null; // { ctor, accessors, options }
		this._$datumToShape = new _Map();
		this._$shapeToDatum = new _Map();
		this._commonShape = null;
		this._renderingContext = {};
		this.data = [];

		this._isContextEditable = false;

		this._valueToPixel = _utilsScales2['default'].linear().domain(this.params.yDomain).range([this.params.height, 0]);

		this.contentLayers = new _Set();

		this._dragLayer = new _konva2['default'].Layer({});

		this._commonShapeLayer = new _konva2['default'].FastLayer({});
		this._commonShapeLayer.addName('common-shape-layer');
		this._commonShapeLayer.layer = this;

		this._contextLayer = new _konva2['default'].Layer({});
		this._contextLayer.layer = this;
		this._contextLayer.addName('context-layer');

		this.setContextEditable(this._isContextEditable);

		this._contextShape = new _shapesSegment2['default']({});
		this._contextShape.install({
			opacity: function opacity() {
				return 1;
			},
			color: function color() {
				return _this.params.context.color;
			},
			width: function width() {
				return _this.timeContext.duration;
			},
			height: function height() {
				return _this._renderingContext.valueToPixel.domain()[1];
			},
			y: function y() {
				return _this._renderingContext.valueToPixel.domain()[0];
			},
			x: function x() {
				return _this.timeContext.start / _this.timeContext.stretchRatio;
			}
		});
		this._contextShape.params.handlerWidth = this.params.context.handlerWidth;
		this._contextShape.render(this._renderingContext);
		this._contextShape.layer = this;
		this._contextShape.isContextShape = true;
		for (var i = 0; i < this._contextShape.$el.length; i++) {
			this._contextLayer.add(this._contextShape.$el[i]);
		}
		this._contextShape.$el.forEach(function (ks) {
			ks.shape = _this._contextShape;
		});

		this._stage = null;
	}

	_createClass(Layer, [{
		key: 'createContainer',
		value: function createContainer(stage) {
			this._stage = stage;

			this._stage.add(this._contextLayer);
			this._stage.add(this._commonShapeLayer);
			this._stage.add(this._dragLayer);
		}
	}, {
		key: '_destroy',
		value: function _destroy(it) {
			var entry = it.next();
			while (!entry.done) {
				var layer = entry.value;
				layer.destroy();
				entry = it.next();
			}
		}
	}, {
		key: 'destroy',
		value: function destroy() {
			this._contextShape.destroy();
			this._destroy(this._$datumToShape.values());
			this._destroy(this.contentLayers.values());
			this.contentLayers.clear();

			this._commonShapeLayer = null;
			this._contextLayer = null;
			this._contextShape = null;
			this._stage = null;
			this.params = null;
			this.timeContextBehavior = null;
			this._shapeConfiguration = null;
			this._commonShapeConfiguration = null;
			this._$datumToShape = null;
			this._$shapeToDatum = null;
			this._commonShape = null;
			this._renderingContext = null;
			this._isContextEditable = null;
			this._behavior = null;
		}

		/**
   * Allows to override default the `TimeContextBehavior` used to edit the layer.
   *
   * @param {Object} ctor
   */
	}, {
		key: 'setBehavior',

		/**
   * Register the behavior to use when interacting with a shape.
   *
   * @param {BaseBehavior} behavior
   */
		value: function setBehavior(behavior) {
			behavior.initialize(this);
			this._behavior = behavior;
		}

		/******************************************************************/
		/******************************************************************/
		/******************************************************************/
		/************************** SELECTION *****************************/
		/******************************************************************/
		/******************************************************************/
		/******************************************************************/

	}, {
		key: 'isSelected',
		value: function isSelected(datum) {
			return this._behavior._selectedDatums.has(datum);
		}
	}, {
		key: 'select',
		value: function select($datums) {
			var _this2 = this;

			if ($datums === undefined || $datums.length === undefined && $datums.size === undefined) $datums = this.data;

			if (!this._behavior || !this._behavior.can('select', $datums)) return false;

			var that = this;
			$datums.forEach(function (datum) {
				var shape = that._$datumToShape.get(datum);
				if (shape) {
					_this2._behavior.select(datum);
					_this2._toFront(datum);
					that.emit('select', datum);
				} else {
					that._add(datum);
					_this2._behavior.select(datum);
					// throw new Error('No shape for this datum in this layer', { datum: datum, layer: that });
				}
			});

			return true;
		}
	}, {
		key: 'unselect',
		value: function unselect($datums) {
			var _this3 = this;

			if ($datums === undefined || $datums.length === undefined && $datums.size === undefined) $datums = this.data;

			if (!this._behavior || !this._behavior.can('unselect', $datums)) return false;

			var that = this;
			$datums.forEach(function (datum) {
				var shape = that._$datumToShape.get(datum);
				if (shape) {
					_this3._behavior.unselect(datum);
					that.emit('unselect', datum);
				} else {
					that._add(datum);
					_this3._behavior.unselect(datum);
				}
			});

			return true;
		}
	}, {
		key: '_toFront',
		value: function _toFront($datum) {
			var $shape = this._$datumToShape.get($datum);
			if (!$shape) {
				this._add($datum);
				$shape = this._$datumToShape.get($datum);
			}
			if ($shape.$el instanceof Array || $shape.$el instanceof _Set) {
				$shape.$el.forEach(function (el) {
					return el.moveToTop();
				});
			} else {
				$shape.$el.moveToTop();
			}
		}
	}, {
		key: 'toDragLayer',
		value: function toDragLayer($datums) {
			var _this4 = this;

			var that = this;
			$datums.forEach(function ($datum) {
				var $shape = _this4._$datumToShape.get($datum);
				if (!$shape) {
					that._add($datum);
					$shape = _this4._$datumToShape.get($datum);
				}
				if ($shape.$el instanceof Array || $shape.$el instanceof _Set) {
					$shape.$el.forEach(function (el) {
						return that._dragLayer.add(el);
					});
				} else {
					_this4._dragLayer.add($shape.$el);
				}
			});
		}
	}, {
		key: 'toggleSelection',
		value: function toggleSelection($datums) {
			var _this5 = this;

			var that = this;

			// TODO: use the this._behavior.can method.
			$datums.forEach(function (datum) {
				var shape = that._$datumToShape.get(datum);
				if (!shape) {
					that._add(datum);
					shape = _this5._$datumToShape.get(datum);
				}
				_this5._behavior.toggleSelection(datum);
				that.emit('toggle-select', datum);
			});
		}

		/******************************************************************/
		/******************************************************************/
		/******************************************************************/
		/******************************************************************/
		/******************************************************************/
		/******************************************************************/
		/******************************************************************/

		/**
   * Sets the context of the layer, thus defining its `start`, `duration`,
   * `offset` and `stretchRatio`.
   *
   * @param {TimeContext} timeContext - The timeContext in which the layer is displayed.
   */
	}, {
		key: 'setTimeContext',
		value: function setTimeContext(timeContext) {
			this.timeContext = timeContext;
			// create a mixin to pass to the shapes
			this._renderingContext = {};
			this._updateRenderingContext();
		}

		/**
  * Register a shape and its configuration to use in order to render the data.
  *
  * @param {BaseShape} ctor - The constructor of the shape to be used.
  * @param {Object} [accessors={}] - Defines how the shape should adapt to a particular data struture.
  * @param {Object} [options={}] - Global configuration for the shapes, is specific to each `Shape`.
  */
	}, {
		key: 'configureShape',
		value: function configureShape(ctor, accessors, options) {
			if (!accessors) accessors = {};
			if (!options) options = {};
			this._shapeConfiguration = { ctor: ctor, accessors: accessors, options: options };
		}

		/**
  * Optionnaly register a shape to be used accros the entire collection.
  *
  * @param {BaseShape} ctor - The constructor of the shape to be used.
  * @param {Object} [accessors={}] - Defines how the shape should adapt to a particular data struture.
  * @param {Object} [options={}] - Global configuration for the shapes, is specific to each `Shape`.
  */
	}, {
		key: 'configureCommonShape',
		value: function configureCommonShape(Ctor, accessors, options) {
			var _this6 = this;

			if (!accessors) accessors = {};
			if (!options) options = {};
			this._commonShapeConfiguration = { ctor: Ctor, accessors: accessors, options: options };
			this._commonShape = new Ctor(options);
			this._commonShape.install(accessors);
			this._commonShape.render(this._renderingContext);
			if (this._commonShape.$el instanceof Array || this._commonShape.$el instanceof _Set) {
				this._commonShape.$el.forEach(function (el) {
					return _this6._commonShapeLayer.add(el);
				});
			} else {
				this._commonShapeLayer.add(this._commonShape.$el);
			}
		}

		/**
  * Defines if the `Layer`, and thus the `LayerTimeContext` is editable or not.
  *
  * @params {Boolean} [bool=true]
  */
	}, {
		key: 'setContextEditable',
		value: function setContextEditable(editable) {
			if (editable === undefined) editable = true;
			// this._contextLayer.visible(editable);
			this._contextLayer.opacity(editable ? this.params.context.opacity : 0);
			this._contextLayer.listening(editable);
			this._contextLayer.visible(editable);
			this._isContextEditable = editable;
		}

		/**
  * Updates the values stored int the `_renderingContext` passed	to shapes
  * for rendering and updating.
  */
	}, {
		key: '_updateRenderingContext',
		value: function _updateRenderingContext() {

			this._renderingContext.timeToPixel = this.timeContext.timeToPixel;
			this._renderingContext.valueToPixel = this._valueToPixel;

			this._renderingContext.height = this.params.height;
			this._renderingContext.width = this.timeContext.timeToPixel(this.timeContext.duration);
			// for foreign object issue in chrome
			this._renderingContext.offsetX = this.timeContext.timeToPixel(this.timeContext.offset);
			this._renderingContext.startX = this.timeContext.parent.timeToPixel(this.timeContext.start);
			this._renderingContext.pixelsPerSecond = this.timeContext.parent.computedPixelsPerSecond;

			// @todo replace with `minX` and `maxX` representing the visible pixels in which
			// the shapes should be rendered, could allow to not update the DOM of shapes
			// who are not in this area.
			this._renderingContext.trackOffsetX = this.timeContext.parent.timeToPixel(this.timeContext.parent.offset);
			this._renderingContext.visibleWidth = this.timeContext.parent.visibleWidth;
		}

		// --------------------------------------
		// Helpers
		// --------------------------------------

	}, {
		key: 'getDatumFromShape',
		value: function getDatumFromShape($shape) {
			return this._$shapeToDatum.get($shape);
		}
	}, {
		key: 'getShapeFromDatum',
		value: function getShapeFromDatum($datum) {
			return this._$datumToShape.get($datum);
		}

		/**
  * Retrieve all the datums in a given area as defined in the registered `Shape~inArea` method.
  *
  * @param {Object} area - The area in which to find the elements
  * @param {Number} area.top
  * @param {Number} area.left
  * @param {Number} area.width
  * @param {Number} area.height
  * @return {Array} - list of the datums presents in the area
  */
	}, {
		key: 'getDatumsInArea',
		value: function getDatumsInArea(area) {
			var _this7 = this;

			var x1 = area.left;
			var y1 = area.top;
			var x2 = area.left + area.width;
			var y2 = area.top + area.height + this.params.top;

			var $filteredDatums = new _Set();

			var $entries = this._$datumToShape.entries();

			var that = this;

			this.contentLayers.forEach(function (contentLayer) {
				contentLayer.children.forEach(function (konvaShape) {
					var $shape = konvaShape.shape;
					if ($shape) {
						var $datum = that.getDatumFromShape($shape);
						var inArea = $shape.inArea(_this7._renderingContext, $datum, x1, y1, x2, y2);

						if (inArea) {
							$filteredDatums.add($datum);
						}
					}
				});
			});

			return $filteredDatums;
		}
	}, {
		key: 'getDatumsInInterval',
		value: function getDatumsInInterval(start, duration) {
			throw new Error('The developer must assign a proper function');
		}
	}, {
		key: 'update',
		value: function update($datums) {

			this.updateContainer();

			if (this.visible) this.updateShapes($datums);
		}
	}, {
		key: 'sort_data',
		value: function sort_data(data) {
			throw new Error('The developer must assign a proper function');
		}
	}, {
		key: 'visible_data',
		value: function visible_data(timeContext, data) {
			throw new Error('The developer must assign a proper function');
		}
	}, {
		key: 'updateShapes',
		value: function updateShapes($datums) {
			var that = this;
			var changedContentLayers = new _Set();
			var targetData = null;
			var interval = null;
			var eraseChildren = true;

			if ($datums === undefined || this._commonShape) {
				interval = this.visible_data(this.timeContext, this.data);
			}

			if ($datums === undefined) {
				targetData = this.data.slice(interval[0], Math.min(interval[1] + 1, this.data.length));
			} else {
				targetData = $datums;
				eraseChildren = false;
			}

			// console.log([this._$datumToShape.size, this.data.length]);
			this.allocateShapesToContentLayers(this._stage, targetData, 'datums', eraseChildren).forEach(function (changedContentLayer) {
				changedContentLayers.add(changedContentLayer);
			});

			// console.log('number of changedContentLayers : ' + changedContentLayers.size);

			changedContentLayers.forEach(function (changedContentLayer) {
				changedContentLayer.y(that.params.top).offsetX(-that._renderingContext.startX).x(that._renderingContext.offsetX).clip({
					x: -that._renderingContext.offsetX,
					y: 0,
					width: that._renderingContext.width,
					height: that._renderingContext.height
				});
				changedContentLayer.clear();
				changedContentLayer.batchDraw();
			});

			this._dragLayer.y(that.params.top).offsetX(-that._renderingContext.startX).x(that._renderingContext.offsetX).clip({
				x: -that._renderingContext.offsetX,
				y: 0,
				width: that._renderingContext.width,
				height: that._renderingContext.height
			}).clear().batchDraw();

			if (this._commonShape) {
				this._commonShapeLayer.y(that.params.top).offsetX(-that._renderingContext.startX).x(that._renderingContext.offsetX).clip({
					x: -that._renderingContext.offsetX,
					y: 0,
					width: that._renderingContext.width,
					height: that._renderingContext.height
				});
				this._commonShape.update(this._renderingContext, that.data.slice(interval[0], interval[1] + 1));
				this._commonShapeLayer.batchDraw();
				// this._commonShapeLayer.moveToBottom();
			}

			this._contextShape.update(this._renderingContext, this.timeContext);

			this._contextLayer.y(that.params.top).batchDraw();
			// .moveToBottom();
		}
	}, {
		key: 'updateContainer',
		value: function updateContainer() {
			var _this8 = this;

			this._updateRenderingContext();
			var that = this;

			this.contentLayers.forEach(function (contentLayer) {
				contentLayer.offsetX(-_this8._renderingContext.startX).x(_this8._renderingContext.offsetX).clip({ x: -_this8._renderingContext.offsetX, y: 0, width: _this8._renderingContext.width, height: _this8._renderingContext.height });
			});
		}
	}, {
		key: 'allocateShapesToContentLayers',
		value: function allocateShapesToContentLayers(stage, objs, type, eraseChildren) {
			var LIMIT = Infinity; // TODO: make the LIMIT a dynamic variable, controlled by a user defined function.

			var changedContentLayers = new _Set();

			var konvaShapes = new _Set();

			/*
    * Of course one could write less code by including the type checking inside the forEach.
    * But that would mean a check for each object. This way, the program checks only one time.
    * This is meant to be a small optimization. Not pretty, of course.
    * Another thing: in order to use just one forEach at updateShapes, I included the shape update in here
    */
			var that = this;
			if (type == 'datums') {
				objs.forEach(function (datum) {
					var shape = that.getShapeFromDatum(datum);
					if (shape === undefined) {
						// throw new Error('Unknown datum', { datum: datum, layer: that });
						that._add(datum);
						shape = that.getShapeFromDatum(datum);
					}
					shape.update(that._renderingContext, datum);
					if (shape.$el instanceof Array || shape.$el instanceof _Set) {
						shape.$el.forEach(function (el) {
							return konvaShapes.add(el);
						});
					} else {
						konvaShapes.add(shape.$el);
					}
				});
			} else if (type == 'shapes') {
				objs.forEach(function (shape) {
					var datum = that.getDatumFromShape(shape);
					if (datum === undefined) {
						throw new Error('Unknown shape', { shape: shape, layer: that });
					}
					shape.update(that._renderingContext, datum);
					if (shape.$el instanceof Array || shape.$el instanceof _Set) {
						shape.$el.forEach(function (el) {
							return konvaShapes.add(el);
						});
					} else {
						konvaShapes.add(shape.$el);
					}
				});
			} else {
				throw new Error('Unknown objects type');
			}

			var ksIt = konvaShapes.entries();

			var clIt = this.contentLayers.entries();

			var cle = clIt.next();
			var kse = ksIt.next();

			var previousShape = null;

			while (!cle.done) {
				var layer = cle.value[1];
				while (!kse.done) {
					var konvaShape = kse.value[1];
					if (layer.children.length >= LIMIT && konvaShape.shape != previousShape) {
						break;
					}
					if (eraseChildren && !changedContentLayers.has(layer)) {
						layer.removeChildren();
					}
					konvaShape.remove();
					layer.add(konvaShape);
					kse = ksIt.next();
					changedContentLayers.add(layer);
				}
				cle = clIt.next();
			}

			while (!kse.done) {
				var layer = new _konva2['default'].Layer({});
				layer.layer = this;
				layer.addName('content-layer');
				layer.clearBeforeDraw(true);
				this.contentLayers.add(layer);
				stage.add(layer);
				while (!kse.done && layer.children.length < LIMIT) {
					var konvaShape = kse.value[1];
					konvaShape.remove();
					layer.add(konvaShape);
					kse = ksIt.next();
				}
				changedContentLayers.add(layer);
			}

			// konvaShapes.forEach((ks) => ks.shape.startDrag());

			return changedContentLayers;
		}
	}, {
		key: 'set',
		value: function set(data) {
			if (!this._behavior || !this._behavior.can('add', data)) return false;

			var that = this;

			this.unselect();

			this.data.forEach(function (datum) {
				return that._$datumToShape.get(datum).destroy();
			});
			this._$datumToShape.clear();
			this._$shapeToDatum.clear();

			this.contentLayers.forEach(function (layer) {
				return layer.destroy();
			});

			this.data.length = 0;

			data.forEach(function (datum) {
				that._add(datum);
			});

			this.data = data;

			this.sort_data(this.data);

			this.emit('set', data);

			return true;
		}
	}, {
		key: '_add',
		value: function _add(datum) {
			var Ctor = this._shapeConfiguration.ctor;
			var accessors = this._shapeConfiguration.accessors;
			var options = this._shapeConfiguration.options;

			var shape = new Ctor(options);
			shape.install(accessors);
			shape.render(this._renderingContext);
			shape.layer = this;
			shape.datum = datum;
			this._$datumToShape.set(datum, shape);
			this._$shapeToDatum.set(shape, datum);
		}
	}, {
		key: 'add',
		value: function add(datum) {
			if (!this._behavior || !this._behavior.can('add', [datum])) return false;

			this._add(datum);
			this.data[this.data.length] = datum;
			this.sort_data(this.data);

			this.emit('add', datum);

			return true;
		}
	}, {
		key: 'remove',
		value: function remove(datum) {
			var _this9 = this;

			if (!this._behavior || !this._behavior.can('remove', [datum])) return false;

			this.unselect([datum]);
			var shape = this._$datumToShape.get(datum);
			if (shape) {
				(function () {
					var changedContentLayers = new _Set();
					if (shape.$el instanceof Array || shape.$el instanceof _Set) {
						shape.$el.forEach(function (el) {
							return changedContentLayers.add(el.getParent());
						});
					} else {
						changedContentLayers.add(shape.$el.getParent());
					}
					shape.layer = null;
					shape.destroy();
					_this9._$datumToShape['delete'](datum);
					_this9._$shapeToDatum['delete'](shape);

					changedContentLayers.forEach(function (layer) {
						if (layer !== undefined) if (layer.children === 0) {
							layer.destroy();
							_this9.contentLayers['delete'](layer);
						} else {
							layer.batchDraw(); // a little hack..
						}
					});
				})();
			}

			this.data.splice(this.data.indexOf(datum), 1);

			this.emit('remove', datum);

			return true;
		}

		/******************************************************************/
		/******************************************************************/
		/******************************************************************/
		/*************************** EDITION ******************************/
		/******************************************************************/
		/******************************************************************/
		/******************************************************************/

		/**
   * Edit datum(s) according to the `edit` defined in the registered `Behavior`.
   *
   * @param {Object[]} $datums - The datum(s) to edit.
   * @param {Number} dx - The modification to apply in the x axis (in pixels).
   * @param {Number} dy - The modification to apply in the y axis (in pixels).
   * @param {Element} $target - The target of the interaction (for example, left
   *    handler DOM element in a segment).
   */
	}, {
		key: 'edit',
		value: function edit($datums, dx, dy, $target) {
			var _this10 = this;

			if (!this._behavior || !this._behavior.can('edit', $datums)) return false;

			var that = this;
			$datums.forEach(function (datum) {
				var shape = that._$datumToShape.get(datum);
				_this10._behavior.edit(_this10._renderingContext, shape, datum, dx, dy, $target);
			});
			this.emit('edit', $datums);

			return true;
		}

		/**
  * Edit the layer and thus its related `LayerTimeContext` attributes.
  *
  * @param {Number} dx - The modification to apply in the x axis (in pixels).
  * @param {Number} dy - The modification to apply in the y axis (in pixels).
  * @param {Element} $target - The target of the event of the interaction.
  */
	}, {
		key: 'editContext',
		value: function editContext(dx, dy, $target) {
			// TODO
			this.timeContextBehavior.edit(this, dx, dy, $target);
			this.emit('edit-context');
		}

		/**
  * Stretch the layer and thus its related `LayerTimeContext` attributes.
  *
  * @param {Number} dx - The modification to apply in the x axis (in pixels).
  * @param {Number} dy - The modification to apply in the y axis (in pixels).
  * @param {Element} $target - The target of the event of the interaction.
  */
	}, {
		key: 'stretchContext',
		value: function stretchContext(dx, dy, $target) {
			// TODO
			this.timeContextBehavior.stretch(this, dx, dy, $target);
			this.emit('stretch-context');
		}
	}, {
		key: 'minimize',
		value: function minimize() {
			// TODO
		}
	}, {
		key: 'find_index',
		value: function find_index(values, target, compareFn) {
			if (values.length === 0 || compareFn(target, values[0]) < 0) {
				return [undefined, 0];
			}
			if (compareFn(target, values[values.length - 1]) > 0) {
				return [values.length - 1, undefined];
			}
			return this.modified_binary_search(values, 0, values.length - 1, target, compareFn);
		}
	}, {
		key: 'modified_binary_search',
		value: function modified_binary_search(values, start, end, target, compareFn) {
			// if the target is bigger than the last of the provided values.
			if (start > end) {
				return [end];
			}

			var middle = Math.floor((start + end) / 2);
			var middleValue = values[middle];

			if (compareFn(middleValue, target) < 0 && values[middle + 1] && compareFn(values[middle + 1], target) > 0)
				// if the target is in between the two halfs.
				return [middle, middle + 1];else if (compareFn(middleValue, target) > 0) return this.modified_binary_search(values, start, middle - 1, target, compareFn);else if (compareFn(middleValue, target) < 0) return this.modified_binary_search(values, middle + 1, end, target, compareFn);else return [middle]; //found!
		}
	}, {
		key: 'visible',
		get: function get() {
			return this._dragLayer.visible();
		},
		set: function set(visible) {
			this._contextLayer.visible(visible);
			this._commonShapeLayer.visible(visible);
			this._dragLayer.visible(visible);
			this.contentLayers.forEach(function (l) {
				return l.visible(visible);
			});
			if (!this._visible && visible) {
				this._visible = visible;
				this.updateShapes();
			}
		}
	}, {
		key: 'zIndex',
		get: function get() {
			return this._contextLayer.getZIndex();
		}
	}, {
		key: 'start',

		/**
   * Returns `LayerTimeContext`'s `start` time domain value.
   *
   * @type {Number}
   */
		get: function get() {
			return this.timeContext.start;
		},

		/**
   * Sets `LayerTimeContext`'s `start` time domain value.
   *
   * @type {Number}
   */
		set: function set(value) {
			this.timeContext.start = value;
		}

		/**
   * Returns `LayerTimeContext`'s `offset` time domain value.
   *
   * @type {Number}
   */
	}, {
		key: 'offset',
		get: function get() {
			return this.timeContext.offset;
		},

		/**
   * Sets `LayerTimeContext`'s `offset` time domain value.
   *
   * @type {Number}
   */
		set: function set(value) {
			this.timeContext.offset = value;
		}

		/**
   * Returns `LayerTimeContext`'s `duration` time domain value.
   *
   * @type {Number}
   */
	}, {
		key: 'duration',
		get: function get() {
			return this.timeContext.duration;
		},

		/**
   * Sets `LayerTimeContext`'s `duration` time domain value.
   *
   * @type {Number}
   */
		set: function set(value) {
			this.timeContext.duration = value;
		}

		/**
   * Returns `LayerTimeContext`'s `stretchRatio` time domain value.
   *
   * @type {Number}
   */
	}, {
		key: 'stretchRatio',
		get: function get() {
			return this.timeContext.stretchRatio;
		},

		/**
   * Sets `LayerTimeContext`'s `stretchRatio` time domain value.
   *
   * @type {Number}
   */
		set: function set(value) {
			this.timeContext.stretchRatio = value;
		}

		/**
   * Set the domain boundaries of the data for the y axis.
   *
   * @type {Array}
   */
	}, {
		key: 'yDomain',
		set: function set(domain) {
			this.params.yDomain = domain;
			this._valueToPixel.domain(domain);
			this._updateRenderingContext();
		},

		/**
   * Returns the domain boundaries of the data for the y axis.
   *
   * @type {Array}
   */
		get: function get() {
			return this.params.yDomain;
		}

		/**
   * Sets the opacity of the whole layer.
   *
   * @type {Number}
   */
	}, {
		key: 'opacity',
		set: function set(value) {
			this.params.opacity = value;
		},

		/**
   * Returns the opacity of the whole layer.
   *
   * @type {Number}
   */
		get: function get() {
			return this.params.opacity;
		}

		/**
   * Returns the transfert function used to display the data in the x axis.
   *
   * @type {Number}
   */
	}, {
		key: 'timeToPixel',
		get: function get() {
			return this.timeContext.timeToPixel;
		}

		/**
   * Returns the transfert function used to display the data in the y axis.
   *
   * @type {Number}
   */
	}, {
		key: 'valueToPixel',
		get: function get() {
			return this._valueToPixel;
		}
	}, {
		key: 'height',
		get: function get() {
			return this.params.height;
		},
		set: function set(value) {
			this.params.height = value;
			this._valueToPixel.range([this.params.height, 0]);
			this._updateRenderingContext();
		}
	}, {
		key: 'selectedDatums',
		get: function get() {
			return this._behavior ? this._behavior.selectedDatums : new _Set();
		}
	}], [{
		key: 'configureTimeContextBehavior',
		value: function configureTimeContextBehavior(ctor) {
			this.timeContextBehaviorCtor = ctor;
		}
	}]);

	return Layer;
})(_events2['default'].EventEmitter);

exports['default'] = Layer;
module.exports = exports['default'];

},{"../behaviors/time-context-behavior":16,"../shapes/segment":53,"../utils/scales":74,"babel-runtime/core-js/map":77,"babel-runtime/core-js/object/assign":78,"babel-runtime/core-js/set":85,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92,"events":182,"konva":180}],21:[function(require,module,exports){
'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _utilsScales = require('../utils/scales');

var _utilsScales2 = _interopRequireDefault(_utilsScales);

var TimelineTimeContext = (function () {
  /**
   * @param {Number} pixelsPerSecond - The number of pixels that should be
   *    used to display one second.
   * @param {Number} visibleWidth - The default with of the visible area
   *    displayed in `tracks` (in pixels).
   */

  function TimelineTimeContext(pixelsPerSecond, visibleWidth) {
    _classCallCheck(this, TimelineTimeContext);

    this._children = [];

    this._timeToPixel = null;
    this._offset = 0;
    this._zoom = 1;
    this._computedPixelsPerSecond = pixelsPerSecond;
    // params
    this._visibleWidth = visibleWidth;
    this._maintainVisibleDuration = false;

    // create the timeToPixel scale
    var scale = _utilsScales2['default'].linear().domain([0, 1]).range([0, pixelsPerSecond]);

    this._timeToPixel = scale;

    this._originalPixelsPerSecond = this._computedPixelsPerSecond;
  }

  /**
   * Returns the number of pixels per seconds ignoring the current zoom value.
   *
   * @type {Number}
   */

  _createClass(TimelineTimeContext, [{
    key: '_updateTimeToPixelRange',
    value: function _updateTimeToPixelRange() {
      this.timeToPixel.range([0, this._computedPixelsPerSecond]);
    }

    /**
     * Returns the time interval of the visible area in the timeline.
     *
     * @type {Object} 
     */
  }, {
    key: 'pixelsPerSecond',
    get: function get() {
      return this._originalPixelsPerSecond;
    },

    /**
     * Updates all the caracteristics of this object according to the new
     * given value of pixels per seconds. Propagates the changes to the
     * `LayerTimeContext` children.
     *
     * @type {Number}
     */
    set: function set(value) {
      this._computedPixelsPerSecond = value * this.zoom;
      this._originalPixelsPerSecond = value;
      this._updateTimeToPixelRange();

      // force children scale update
      this._children.forEach(function (child) {
        if (child.stretchRatio === 1) {
          return;
        }
        child.stretchRatio = child.stretchRatio;
      });
    }

    /**
     * Returns the number of pixels per seconds including the current zoom value.
     *
     * @type {Number}
     */
  }, {
    key: 'computedPixelsPerSecond',
    get: function get() {
      return this._computedPixelsPerSecond;
    }

    /**
     * Returns the current offset applied to the registered `Track` instances
     * from origin (in seconds).
     *
     * @type {Number}
     */
  }, {
    key: 'offset',
    get: function get() {
      return this._offset;
    },

    /**
     * Sets the offset to apply to the registered `Track` instances from origin
     * (in seconds).
     *
     * @type {Number}
     */
    set: function set(value) {
      this._offset = value;
    }

    /**
     * Returns the current zoom level applied to the whole visualization.
     *
     * @type {Number}
     */
  }, {
    key: 'zoom',
    get: function get() {
      return this._zoom;
    },

    /**
     * Sets the zoom ratio for the whole visualization.
     *
     * @type {Number}
     */
    set: function set(value) {
      // Compute change to propagate to children who have their own timeToPixel
      var ratioChange = value / this._zoom;
      this._zoom = value;
      this._computedPixelsPerSecond = this._originalPixelsPerSecond * value;
      this._updateTimeToPixelRange();

      this._children.forEach(function (child) {
        if (child.stretchRatio === 1) {
          return;
        }
        child.stretchRatio = child.stretchRatio * ratioChange;
      });
    }

    /**
     * Returns the visible width of the `Track` instances.
     *
     * @type {Number}
     */
  }, {
    key: 'visibleWidth',
    get: function get() {
      return this._visibleWidth;
    },

    /**
     * Sets the visible width of the `Track` instances.
     *
     * @type {Number}
     */
    set: function set(value) {
      var widthRatio = value / this.visibleWidth;
      this._visibleWidth = value;

      if (this.maintainVisibleDuration) {
        this.pixelsPerSecond = this._computedPixelsPerSecond * widthRatio;
      }
    }

    /**
     * Returns the duration displayed by `Track` instances.
     *
     * @type {Number}
     */
  }, {
    key: 'visibleDuration',
    get: function get() {
      return this.visibleWidth / this._computedPixelsPerSecond;
    }

    /**
     * Returns if the duration displayed by tracks should be maintained when
     * their width is updated.
     *
     * @type {Number}
     */
  }, {
    key: 'maintainVisibleDuration',
    get: function get() {
      return this._maintainVisibleDuration;
    },

    /**
     * Defines if the duration displayed by tracks should be maintained when
     * their width is updated.
     *
     * @type {Boolean}
     */
    set: function set(bool) {
      this._maintainVisibleDuration = bool;
    }

    /**
     * Returns the time to pixel trasfert function.
     *
     * @type {Function}
     */
  }, {
    key: 'timeToPixel',
    get: function get() {
      return this._timeToPixel;
    }
  }, {
    key: 'visibleInterval',
    get: function get() {
      var interval = {};
      interval.start = -this.offset;
      interval.duration = this.visibleDuration;
      return interval;
    },

    /**
     * Focus the timeline visible area in the provided time interval.
     *
     * @type {Object} 
     */
    set: function set(value) {
      this.offset = -value.start;
      this.pixelsPerSecond = this.visibleWidth / value.duration;
    }
  }]);

  return TimelineTimeContext;
})();

exports['default'] = TimelineTimeContext;
module.exports = exports['default'];

},{"../utils/scales":74,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/interop-require-default":92}],22:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Symbol$iterator = require('babel-runtime/core-js/symbol/iterator')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _track = require('./track');

var _track2 = _interopRequireDefault(_track);

var _trackCollection = require('./track-collection');

var _trackCollection2 = _interopRequireDefault(_trackCollection);

var _timelineTimeContext = require('./timeline-time-context');

var _timelineTimeContext2 = _interopRequireDefault(_timelineTimeContext);

var _layerTimeContext = require('./layer-time-context');

var _layerTimeContext2 = _interopRequireDefault(_layerTimeContext);

var _interactionsKonvaSurface = require('../interactions/konva-surface');

var _interactionsKonvaSurface2 = _interopRequireDefault(_interactionsKonvaSurface);

var _interactionsKeyboard = require('../interactions/keyboard');

var _interactionsKeyboard2 = _interopRequireDefault(_interactionsKeyboard);

var Timeline = (function (_events$EventEmitter) {
  _inherits(Timeline, _events$EventEmitter);

  /**
   * @param {Number} [pixelsPerSecond=100] - the default scaling between time and pixels.
   * @param {Number} [visibleWidth=1000] - the default visible area for all registered tracks.
   */

  function Timeline(pixelsPerSecond, visibleWidth, opts) {
    _classCallCheck(this, Timeline);

    _get(Object.getPrototypeOf(Timeline.prototype), 'constructor', this).call(this);

    if (pixelsPerSecond === undefined) pixelsPerSecond = 100;
    if (visibleWidth === undefined) visibleWidth = 1000;
    if (opts === undefined) {
      opts = { registerKeyboard: true };
    } else if (opts.registerKeyboard === undefined) {
      opts.registerKeyboard = true;
    }

    this._tracks = new _trackCollection2['default'](this);
    this._state = null;

    // default interactions
    this._surfaceCtor = _interactionsKonvaSurface2['default'];

    if (opts.registerKeyboard) {
      this.createInteraction(_interactionsKeyboard2['default'], document);
    }

    // stores
    this._trackById = {};
    this._groupedLayers = {};

    /** @type {TimelineTimeContext} - master time context for the visualization. */
    this.timeContext = new _timelineTimeContext2['default'](pixelsPerSecond, visibleWidth);
  }

  /**
   * Returns `TimelineTimeContext`'s `offset` time domain value.
   *
   * @type {Number} [offset=0]
   */

  _createClass(Timeline, [{
    key: 'configureSurface',

    /**
     * Overrides the default `Surface` that is instanciated on each `Track`
     * instance. This methos should be called before adding any `Track` instance
     * to the current `timeline`.
     *
     * @param {EventSource} Ctor - The constructor to use in order to catch mouse
     *    events on each `Track` instances.
     */
    value: function configureSurface(Ctor) {
      this._surfaceCtor = Ctor;
    }

    /**
     * Factory method to add interaction modules the timeline should listen to.
     * By default, the timeline instanciate a global `Keyboard` instance and a
     * `Surface` instance on each container.
     * Should be used to install new interactions implementing the `EventSource` interface.
     *
     * @param {EventSource} Ctor - The contructor of the interaction module to instanciate.
     * @param {Element} $el - The DOM element which will be binded to the `EventSource` module.
     * @param {Object} [options={}] - Options to be applied to the `Ctor`.
     */
  }, {
    key: 'createInteraction',
    value: function createInteraction(Ctor, $el, options) {
      var _this = this;

      if (options === undefined) options = {};
      var interaction = new Ctor($el, options);
      interaction.on('event', function (e) {
        return _this._handleEvent(e);
      });
    }

    /**
     * Returns a list of the layers situated under the position of a `WaveEvent`.
     *
     * @param {WavesEvent} e - An event triggered by a `WaveEvent`
     * @return {Array} - Matched layers
     */
  }, {
    key: 'getHitLayers',
    value: function getHitLayers(e) {
      var x = e.originalEvent.offsetX;
      var y = e.originalEvent.offsetY;

      var layers = [];

      this.layers.forEach(function (layer) {
        var ctxX = layer._contextShape.$segment.getAbsolutePosition().x;
        var ctxY = layer._contextShape.$segment.getAbsolutePosition().y;
        var ctxW = layer._contextShape.$segment.width();
        var ctxH = layer._contextShape.$segment.height();

        if (x >= ctxX && x <= ctxX + ctxW && y >= ctxY && y <= ctxY + ctxH) layers.push(layer);
      });

      return layers;
    }

    /**
     * The callback that is used to listen to interactions modules.
     *
     * @param {WaveEvent} e - An event generated by an interaction modules (`EventSource`).
     */
  }, {
    key: '_handleEvent',
    value: function _handleEvent(e) {
      var hitLayers = e.source === 'surface' ? this.getHitLayers(e) : null;
      // emit event as a middleware
      this.emit('event', e, hitLayers);
      // propagate to the state
      if (!this._state) {
        return;
      }
      this._state.handleEvent(e, hitLayers);
    }

    /**
     * Updates the state of the timeline.
     *
     * @type {BaseState}
     */
  }, {
    key: 'add',

    /**
     * Adds a new track to the timeline.
     *
     * @param {Track} track - The new track to be registered in the timeline.
     * @param {String} [trackId=null] - Optionnal unique id to associate with
     *    the track, this id only exists in timeline's context and should be used
     *    in conjonction with `addLayer` method.
     */
    value: function add(track, trackId) {
      if (trackId === undefined) trackId = null;

      if (this.tracks.indexOf(track) !== -1) {
        throw new Error('track already added to the timeline');
      }

      this._registerTrackId(track, trackId);
      track.configure(this.timeContext);

      this.tracks.push(track);
      this.createInteraction(this._surfaceCtor, track);

      this.emit('add', track, trackId);
    }

    /**
     * Removes a track from the timeline and destroys that track.
     *
     * @param {Track} track - the track to remove from the timeline.
     * @todo not implemented.
     */
  }, {
    key: 'remove',
    value: function remove(track) {
      var index = this.tracks.indexOf(track);
      var trackId;
      if (index !== -1) {
        track.destroy();
        delete this._trackById[track.id];
        trackId = track.id;
        track.id = null;
        this.tracks.splice(index, 1);
        this.emit('remove', track, trackId);
      }
    }

    /**
     * Helper to create a new `Track` instance. The `track` is added,
     * rendered and updated before being returned.
     *
     * @param {Element} $el - The DOM element where the track should be inserted.
     * @param {Number} trackHeight - The height of the newly created track.
     * @param {String} [trackId=null] - Optionnal unique id to associate with
     *    the track, this id only exists in timeline's context and should be used in
     *    conjonction with `addLayer` method.
     * @return {Track}
     */
  }, {
    key: 'createTrack',
    value: function createTrack($el, trackHeight, trackId) {
      if (trackHeight === undefined) trackHeight = 100;
      if (trackId === undefined) trackId = null;

      var track = new _track2['default']($el, trackHeight);
      // Add track to the timeline
      this.add(track, trackId);

      track.update();

      return track;
    }

    /**
     * If track id is defined, associate a track with a unique id.
     */
  }, {
    key: '_registerTrackId',
    value: function _registerTrackId(track, trackId) {
      if (trackId !== null) {
        if (this._trackById[trackId] !== undefined) {
          throw new Error('trackId: "' + trackId + '" is already used');
        }
        track.id = trackId;
        this._trackById[trackId] = track;
      }
    }

    /**
     * Helper to add a `Layer` instance into a given `Track`. Is designed to be
     * used in conjonction with the `Timeline~getLayersByGroup` method. The
     * layer is internally rendered and updated.
     *
     * @param {Layer} layer - The `Layer` instance to add into the visualization.
     * @param {(Track|String)} trackOrTrackId - The `Track` instance (or its `id`
     *    as defined in the `createTrack` method) where the `Layer` instance should be inserted.
     * @param {String} [groupId='default'] - An optionnal group id in which the
     *    `Layer` should be inserted.
     * @param {Boolean} [isAxis] - Set to `true` if the added `layer` is an
     *    instance of `AxisLayer` (these layers shares the `TimlineTimeContext` instance
     *    of the timeline).
     */
  }, {
    key: 'addLayer',
    value: function addLayer(layer, trackOrTrackId, groupId, isAxis) {

      if (groupId === undefined) groupId = 'default';
      if (isAxis === undefined) isAxis = false;

      var track = trackOrTrackId;

      if (typeof trackOrTrackId === 'string') {
        track = this.getTrackById(trackOrTrackId);
      }

      // creates the `LayerTimeContext` if not present
      if (!layer.timeContext) {
        var timeContext = isAxis ? this.timeContext : new _layerTimeContext2['default'](this.timeContext);

        layer.setTimeContext(timeContext);
      }

      // we should have a Track instance at this point
      track.add(layer);

      if (!this._groupedLayers[groupId]) {
        this._groupedLayers[groupId] = [];
      }

      this._groupedLayers[groupId].push(layer);

      layer.update();
    }

    /**
     * Removes a layer from its track. The layer is detatched from the DOM but
     * can still be reused later.
     *
     * @param {Layer} layer - The layer to remove.
     */
  }, {
    key: 'removeLayer',
    value: function removeLayer(layer) {
      this.tracks.forEach(function (track) {
        var index = track.layers.indexOf(layer);
        if (index !== -1) {
          track.remove(layer);
        }
      });

      // clean references in helpers
      for (var groupId in this._groupedLayers) {
        var group = this._groupedLayers[groupId];
        var index = group.indexOf(layer);

        if (index !== -1) {
          group.splice(layer, 1);
        }

        if (!group.length) {
          delete this._groupedLayers[groupId];
        }
      }
    }

    /**
     * Returns a `Track` instance from it's given id.
     *
     * @param {String} trackId
     * @return {Track}
     */
  }, {
    key: 'getTrackById',
    value: function getTrackById(trackId) {
      return this._trackById[trackId];
    }

    /**
     * Returns the track containing a given DOM Element, returns null if no match found.
     *
     * @param {Element} $el - The DOM Element to be tested.
     * @return {Track}
     */
  }, {
    key: 'getTrackFromDOMElement',
    value: function getTrackFromDOMElement($el) {

      for (var i = 0; i < this.tracks.length; i++) {
        var node = $el;
        while (node !== document.body && node !== null) {
          if (this.tracks[i].$stage.content === node) return this.tracks[i];
          node = node.parentElement;
        }
      }

      return undefined;
    }

    /**
     * Returns an array of layers from their given group id.
     *
     * @param {String} groupId - The id of the group as defined in `addLayer`.
     * @return {(Array|undefined)}
     */
  }, {
    key: 'getLayersByGroup',
    value: function getLayersByGroup(groupId) {
      return this._groupedLayers[groupId];
    }

    /**
     * Iterates through the added tracks.
     */
  }, {
    key: _Symbol$iterator,
    value: _regeneratorRuntime.mark(function value() {
      return _regeneratorRuntime.wrap(function value$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            return context$2$0.delegateYield(_getIterator(this.tracks), 't0', 1);

          case 1:
          case 'end':
            return context$2$0.stop();
        }
      }, value, this);
    })
  }, {
    key: 'offset',
    get: function get() {
      return this.timeContext.offset;
    },

    /**
     * Updates `TimelineTimeContext`'s `offset` time domain value.
     *
     * @type {Number} [offset=0]
     */
    set: function set(value) {
      this.timeContext.offset = value;
    }

    /**
     * Returns the `TimelineTimeContext`'s `zoom` value.
     *
     * @type {Number} [offset=0]
     */
  }, {
    key: 'zoom',
    get: function get() {
      return this.timeContext.zoom;
    },

    /**
     * Updates the `TimelineTimeContext`'s `zoom` value.
     *
     * @type {Number} [offset=0]
     */
    set: function set(value) {
      this.timeContext.zoom = value;
    }

    /**
     * Returns the `TimelineTimeContext`'s `pixelsPerSecond` ratio.
     *
     * @type {Number} [offset=0]
     */
  }, {
    key: 'pixelsPerSecond',
    get: function get() {
      return this.timeContext.pixelsPerSecond;
    },

    /**
     * Updates the `TimelineTimeContext`'s `pixelsPerSecond` ratio.
     *
     * @type {Number} [offset=0]
     */
    set: function set(value) {
      this.timeContext.pixelsPerSecond = value;
    }

    /**
     * Returns the time interval of the visible area in the timeline.
     *
     * @type {Object} 
     */
  }, {
    key: 'visibleInterval',
    get: function get() {
      return this.timeContext.visibleInterval;
    },

    /**
     * Focus the timeline visible area in the provided time interval.
     *
     * @type {Object} 
     */
    set: function set(value) {
      this.timeContext.visibleInterval = value;
    }

    /**
     * Returns the `TimelineTimeContext`'s `visibleWidth` pixel domain value.
     *
     * @type {Number} [offset=0]
     */
  }, {
    key: 'visibleWidth',
    get: function get() {
      return this.timeContext.visibleWidth;
    },

    /**
     * Updates the `TimelineTimeContext`'s `visibleWidth` pixel domain value.
     *
     * @type {Number} [offset=0]
     */
    set: function set(value) {
      this.timeContext.visibleWidth = value;
    }

    /**
     * Returns `TimelineTimeContext`'s `timeToPixel` transfert function.
     *
     * @type {Function}
     */
  }, {
    key: 'timeToPixel',
    get: function get() {
      return this.timeContext.timeToPixel;
    }

    /**
     * Returns `TimelineTimeContext`'s `visibleDuration` helper value.
     *
     * @type {Number}
     */
  }, {
    key: 'visibleDuration',
    get: function get() {
      return this.timeContext.visibleDuration;
    }

    /**
     * Updates the `TimelineTimeContext`'s `maintainVisibleDuration` value.
     * Defines if the duration of the visible area should be maintain when
     * the `visibleWidth` attribute is updated.
     *
     * @type {Boolean}
     */
  }, {
    key: 'maintainVisibleDuration',
    set: function set(bool) {
      this.timeContext.maintainVisibleDuration = bool;
    },

    /**
     * Returns `TimelineTimeContext`'s `maintainVisibleDuration` current value.
     *
     * @type {Boolean}
     */
    get: function get() {
      return this.timeContext.maintainVisibleDuration;
    }

    /**
     * Object maintaining arrays of `Layer` instances ordered by their `groupId`.
     * Is used internally by the `TrackCollection` instance.
     *
     * @type {Object}
     */
  }, {
    key: 'groupedLayers',
    get: function get() {
      return this._groupedLayers;
    }
  }, {
    key: 'state',
    set: function set(state) {
      if (this._state) {
        this._state.exit();
      }
      this._state = state;
      if (this._state) {
        this._state.enter();
      }
    },

    /**
     * Returns the current state of the timeline.
     *
     * @type {BaseState}
     */
    get: function get() {
      return this._state;
    }

    /**
     * Returns the `TrackCollection` instance.
     *
     * @type {TrackCollection}
     */
  }, {
    key: 'tracks',
    get: function get() {
      return this._tracks;
    }

    /**
     * Returns the list of all registered layers.
     *
     * @type {Array}
     */
  }, {
    key: 'layers',
    get: function get() {
      return this._tracks.layers;
    }
  }]);

  return Timeline;
})(_events2['default'].EventEmitter);

exports['default'] = Timeline;
module.exports = exports['default'];

},{"../interactions/keyboard":41,"../interactions/konva-surface":42,"./layer-time-context":19,"./timeline-time-context":21,"./track":24,"./track-collection":23,"babel-runtime/core-js/get-iterator":76,"babel-runtime/core-js/symbol/iterator":87,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92,"babel-runtime/regenerator":178,"events":182}],23:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _layer = require('./layer');

var _layer2 = _interopRequireDefault(_layer);

/**
 * Collection hosting all the `Track` instances registered into the timeline.
 * It provides shorcuts to trigger `render` / `update` methods on tracks or
 * layers. Extend built-in Array
 */

var TrackCollection = (function (_Array) {
  _inherits(TrackCollection, _Array);

  function TrackCollection(timeline) {
    _classCallCheck(this, TrackCollection);

    _get(Object.getPrototypeOf(TrackCollection.prototype), 'constructor', this).call(this);

    this._timeline = timeline;
  }

  // @note - should be in the timeline ?
  // @todo - allow to pass an array of layers

  _createClass(TrackCollection, [{
    key: '_getLayersOrGroups',
    value: function _getLayersOrGroups(layerOrGroup) {
      if (layerOrGroup === undefined) layerOrGroup = null;

      var layers = null;

      if (typeof layerOrGroup === 'string') {
        layers = this._timeline.groupedLayers[layerOrGroup];
      } else if (layerOrGroup instanceof _layer2['default']) {
        layers = [layerOrGroup];
      } else {
        layers = this.layers;
      }

      return layers;
    }

    // @NOTE keep this ?
    // could prepare some vertical resizing ability
    // this should be able to modify the layers yScale to be really usefull

    /**
     * @type {Number} - Updates the height of all tracks at once.
     * @todo - Propagate to layers, not usefull for now.
     */
  }, {
    key: 'render',

    /**
     * Render all tracks and layers. When done, the timeline triggers a `render` event.
     */
    value: function render() {
      this.forEach(function (track) {
        return track.render();
      });
      this._timeline.emit('render');
    }

    /**
     * Updates all tracks and layers. When done, the timeline triggers a
     * `update` event.
     *
     * @param {Layer|String} layerOrGroup - Filter the layers to update by
     *    passing the `Layer` instance to update or a `groupId`
     */
  }, {
    key: 'update',
    value: function update(layerOrGroup) {
      var layers = this._getLayersOrGroups(layerOrGroup);
      this.forEach(function (track) {
        return track.update(layers);
      });
      this._timeline.emit('update', layers);
    }

    /**
     * Updates all `Track` containers, layers are not updated with this method.
     * When done, the timeline triggers a `update:containers` event.
     */
  }, {
    key: 'updateContainer',
    value: function updateContainer() /* trackOrTrackIds */{
      this.forEach(function (track) {
        return track.updateContainer();
      });
      this._timeline.emit('update:containers');
    }

    /**
     * Updates all layers. When done, the timeline triggers a `update:layers` event.
     *
     * @param {Layer|String} layerOrGroup - Filter the layers to update by
     *    passing the `Layer` instance to update or a `groupId`
     */
  }, {
    key: 'updateLayers',
    value: function updateLayers(layerOrGroup) {
      var layers = this._getLayersOrGroups(layerOrGroup);
      this.forEach(function (track) {
        return track.updateLayers(layers);
      });
      this._timeline.emit('update:layers', layers);
    }
  }, {
    key: 'height',
    set: function set(value) {
      this.forEach(function (track) {
        return track.height = value;
      });
    },
    get: function get() {
      throw new Error('Not implemented');
    }

    /**
     * An array of all registered layers.
     *
     * @type {Array<Layer>}
     */
  }, {
    key: 'layers',
    get: function get() {
      var layers = new _Set();
      this.forEach(function (track) {
        return track.layers.forEach(function (layer) {
          return layers.add(layer);
        });
      });

      return layers;
    }
  }]);

  return TrackCollection;
})(Array);

exports['default'] = TrackCollection;
module.exports = exports['default'];

},{"./layer":20,"babel-runtime/core-js/set":85,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],24:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Symbol$iterator = require('babel-runtime/core-js/symbol/iterator')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var Track = (function (_events$EventEmitter) {
  _inherits(Track, _events$EventEmitter);

  /**
   * @param {DOMElement} $el
   * @param {Number} [height = 100]
   */

  function Track($el, height) {
    _classCallCheck(this, Track);

    _get(Object.getPrototypeOf(Track.prototype), 'constructor', this).call(this);

    if (!height) height = 100;

    this._height = height;

    /**
     * The DOM element in which the track is created.
     * @type {Element}
     */
    this.$el = $el;

    this.$stage = null;

    this.$dragLayer = null;

    this.$interactionsLayer = null;

    this.$backgroundLayer = null;

    /**
     * A set of all the layers belonging to the track.
     * @type {Set<Layer>}
     */
    this.layers = new _Set();
    /**
     * The context used to maintain the DOM structure of the track.
     * @type {TimelineTimeContext}
     */
    this.renderingContext = null;

    this._createContainer();
  }

  /**
   * Returns the height of the track.
   *
   * @type {Number}
   */

  _createClass(Track, [{
    key: 'configure',

    /**
     * This method is called when the track is added to the timeline. The
     * track cannot be updated without being added to a timeline.
     *
     * @private
     * @param {TimelineTimeContext} renderingContext
     */
    value: function configure(renderingContext) {
      this.renderingContext = renderingContext;
    }

    /**
     * Destroy the track and its layers.
     */
  }, {
    key: 'destroy',
    value: function destroy() {
      this.layers.forEach(function (layer) {
        return layer.destroy();
      });
      this.layers.clear();

      this.$stage.destroy();
      this.$interactionsLayer.destroy();
      this.$backgroundLayer.destroy();

      this._height = null;
      this.$el = null;
      this.$stage = null;
      this.$interactionsLayer = null;
      this.$backgroundLayer = null;
      this.renderingContext = null;
    }

    /**
     * Creates the basic Konva structure of the track.
     */
  }, {
    key: '_createContainer',
    value: function _createContainer() {
      this.$stage = new _konva2['default'].Stage({
        height: this.height,
        container: this.$el
      });
      this.$stage.addName('track-stage');

      this.$interactionsLayer = new _konva2['default'].Layer({});
      this.$interactionsLayer.addName('track-interactions');

      this.$backgroundLayer = new _konva2['default'].Layer({});
      this.$backgroundLayer.addName('track-background');
      var bgrect = new _konva2['default'].Rect({});
      bgrect.addName('track-background-rect');
      this.$backgroundLayer.add(bgrect);
      // this.$backgroundLayer.children[0].shape = { layer: { track: this } }; // Shame!!! ..... Shame!!! .... Shame!!!

      this.$dragLayer = new _konva2['default'].Layer({});
      this.$dragLayer.addName('track-drag-layer');

      this.$stage.add(this.$dragLayer);
      this.$stage.add(this.$interactionsLayer);
      this.$stage.add(this.$backgroundLayer);
    }

    /**
     * Adds a layer to the track.
     *
     * @param {Layer} layer - the layer to add to the track.
     */
  }, {
    key: 'add',
    value: function add(layer) {
      if (!this.layers.has(layer)) {
        layer.createContainer(this.$stage);
        this.layers.add(layer);
        this.moveToTop(layer);
        this.emit('add', layer);
      }
    }

    /**
     * Removes a layer from the track and destroys that alyer
     *
     * @param {Layer} layer - the layer to remove from the track.
     */
  }, {
    key: 'remove',
    value: function remove(layer) {
      // TODO
      if (this.layers.has(layer)) {
        this.layers['delete'](layer);
        layer.destroy();
        this.emit('remove', layer);
      } else {
        throw new Error('Layer not found');
      }
    }

    /**
     * Tests if a given element belongs to the track.
     *
     * @param {Element} $el
     * @return {bool}
     */
  }, {
    key: 'hasElement',
    value: function hasElement($el) {
      throw new Error("deprecated");

      // do {
      //   if ($el === this.$el) {
      //     return true;
      //   }

      //   $el = $el.parentNode;
      // } while ($el !== null);

      // return false;
    }
  }, {
    key: 'hasLayer',
    value: function hasLayer(layer) {
      return this.layers.has(layer);
    }

    /**
     * Render all the layers added to the track.
     */
  }, {
    key: 'render',
    value: function render() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _getIterator(this), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var layer = _step.value;
          layer.render();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    /**
     * Updates the track Konva structure and updates the layers.
     *
     * @param {Array<Layer>} [layers=null] - if not null, a subset of the layers to update.
     */
  }, {
    key: 'update',
    value: function update(layers) {
      if (layers === undefined) layers = null;

      this.updateContainer();
      this.updateLayers(layers);
    }

    /**
     * Updates the track Konva structure.
     */
  }, {
    key: 'updateContainer',
    value: function updateContainer() {
      // Should be in some update layout
      var renderingContext = this.renderingContext;
      var height = this.height;
      var width = Math.round(renderingContext.visibleWidth);
      var offsetX = -Math.round(renderingContext.timeToPixel(renderingContext.offset));

      this.$stage.width(width).height(this.height).offsetX(offsetX);
      this.$interactionsLayer.offsetX(-offsetX);
      this.$backgroundLayer.offsetX(-offsetX);
      this.$backgroundLayer.children[0].x(0).y(0).width(width).height(this.height).opacity(0).moveToBottom();
      this.$backgroundLayer.batchDraw();

      /*
       * Change the layer stack order according to Layer.zIndex.
       */
      // var zIndexCounter = 0;
      // var maxZIndex = -Infinity;
      // this.$backgroundLayer.setZIndex(zIndexCounter++);
      // this.layers.forEach((layer) => {
      //   layer._contextLayer.setZIndex(layer.zIndex + zIndexCounter++);
      //   layer._commonShapeLayer.setZIndex(layer.zIndex + zIndexCounter++);
      //   layer.contentLayers.forEach((konvaLayer) => konvaLayer.setZIndex(layer.zIndex + zIndexCounter++));
      //   layer._dragLayer.setZIndex(layer.zIndex + zIndexCounter++);
      //   maxZIndex = Math.max(maxZIndex, layer.zIndex);
      // })
      // this.$interactionsLayer.setZIndex(maxZIndex + zIndexCounter);
    }

    /**
     * Updates the layers.
     *
     * @param {Array<Layer>} [layers=null] - if not null, a subset of the layers to update.
     */
  }, {
    key: 'updateLayers',
    value: function updateLayers(layers) {
      var _this = this;

      if (layers === undefined) layers = null;

      layers = layers === null ? this.layers : layers;

      if (!(layers instanceof _Set) && !(layers instanceof Array)) layers = [layers];

      var that = this;

      layers.forEach(function (layer) {
        if (!_this.layers.has(layer)) {
          return;
        }
        layer.height = that.height;
        layer.update();
      });
      this.$backgroundLayer.moveToBottom();
    }
  }, {
    key: 'minimize',
    value: function minimize() {
      // TODO
    }
  }, {
    key: 'maximize',
    value: function maximize() {
      // TODO
    }
  }, {
    key: 'moveToTop',
    value: function moveToTop(layer) {
      layer._contextLayer.moveToTop();
      layer._commonShapeLayer.moveToTop();
      layer.contentLayers.forEach(function (konvaLayer) {
        return konvaLayer.moveToTop();
      });

      this.$interactionsLayer.moveToTop();
      this.$backgroundLayer.moveToBottom();
    }
  }, {
    key: 'moveToBottom',
    value: function moveToBottom(layer) {
      this.$interactionsLayer.moveToTop();

      layer.contentLayers.forEach(function (konvaLayer) {
        return konvaLayer.moveToBottom();
      });
      layer._commonShapeLayer.moveToBottom();
      layer._contextLayer.moveToBottom();

      this.$backgroundLayer.moveToBottom();
    }

    /**
     * Iterates through the added layers.
     */
  }, {
    key: _Symbol$iterator,
    value: _regeneratorRuntime.mark(function value() {
      return _regeneratorRuntime.wrap(function value$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            return context$2$0.delegateYield(_getIterator(this.layers), 't0', 1);

          case 1:
          case 'end':
            return context$2$0.stop();
        }
      }, value, this);
    })
  }, {
    key: 'height',
    get: function get() {
      return this._height;
    },

    /**
     * Sets the height of the track.
     *
     * @todo propagate to layers, keeping ratio? could be handy for vertical
     *    resize. This is why a set/get is implemented here.
     * @type {Number}
     */
    set: function set(value) {
      this._height = value;
      this.$stage.height(this._height);
    }
  }]);

  return Track;
})(_events2['default'].EventEmitter);

exports['default'] = Track;
module.exports = exports['default'];

},{"babel-runtime/core-js/get-iterator":76,"babel-runtime/core-js/set":85,"babel-runtime/core-js/symbol/iterator":87,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92,"babel-runtime/regenerator":178,"events":182,"konva":180}],25:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _shapesAnnotatedMarker = require('../shapes/annotated-marker');

var _shapesAnnotatedMarker2 = _interopRequireDefault(_shapesAnnotatedMarker);

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _behaviorsMarkerBehavior = require('../behaviors/marker-behavior');

var _behaviorsMarkerBehavior2 = _interopRequireDefault(_behaviorsMarkerBehavior);

var AnnotatedMarkerLayer = (function (_Layer) {
  _inherits(AnnotatedMarkerLayer, _Layer);

  function AnnotatedMarkerLayer(data) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    _classCallCheck(this, AnnotatedMarkerLayer);

    _get(Object.getPrototypeOf(AnnotatedMarkerLayer.prototype), 'constructor', this).call(this, 'collection', data, options);

    this.configureShape(_shapesAnnotatedMarker2['default']);
    this.setBehavior(new _behaviorsMarkerBehavior2['default']());
  }

  return AnnotatedMarkerLayer;
})(_coreLayer2['default']);

exports['default'] = AnnotatedMarkerLayer;
module.exports = exports['default'];

},{"../behaviors/marker-behavior":8,"../core/layer":20,"../shapes/annotated-marker":46,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],26:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _shapesAnnotatedSegment = require('../shapes/annotated-segment');

var _shapesAnnotatedSegment2 = _interopRequireDefault(_shapesAnnotatedSegment);

var _behaviorsSegmentBehavior = require('../behaviors/segment-behavior');

var _behaviorsSegmentBehavior2 = _interopRequireDefault(_behaviorsSegmentBehavior);

var AnnotatedSegmentLayer = (function (_Layer) {
  _inherits(AnnotatedSegmentLayer, _Layer);

  function AnnotatedSegmentLayer(data) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var accessors = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, AnnotatedSegmentLayer);

    _get(Object.getPrototypeOf(AnnotatedSegmentLayer.prototype), 'constructor', this).call(this, 'collection', data, options);

    options = _Object$assign({
      displayHandlers: true,
      opacity: 0.6
    }, options);

    this.configureShape(_shapesAnnotatedSegment2['default'], accessors, {
      displayHandlers: options.displayHandlers,
      opacity: options.opacity
    });

    this.setBehavior(new _behaviorsSegmentBehavior2['default']());
  }

  return AnnotatedSegmentLayer;
})(_coreLayer2['default']);

exports['default'] = AnnotatedSegmentLayer;
module.exports = exports['default'];

},{"../behaviors/segment-behavior":12,"../core/layer":20,"../shapes/annotated-segment":47,"babel-runtime/core-js/object/assign":78,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],27:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _axisAxisLayer = require('../axis/axis-layer');

var _axisAxisLayer2 = _interopRequireDefault(_axisAxisLayer);

var _shapesTicks = require('../shapes/ticks');

var _shapesTicks2 = _interopRequireDefault(_shapesTicks);

var _axisBeatGridAxisGenerator = require('../axis/beat-grid-axis-generator');

var _axisBeatGridAxisGenerator2 = _interopRequireDefault(_axisBeatGridAxisGenerator);

var BeatGridAxisLayer = (function (_AxisLayer) {
  _inherits(BeatGridAxisLayer, _AxisLayer);

  function BeatGridAxisLayer(options) {
    _classCallCheck(this, BeatGridAxisLayer);

    options = _Object$assign({
      color: 'steelblue',
      signature: '4/4'
    }, options);

    _get(Object.getPrototypeOf(BeatGridAxisLayer.prototype), 'constructor', this).call(this, (0, _axisBeatGridAxisGenerator2['default'])(options.beatGrid, options.signature), options);

    this.configureShape(_shapesTicks2['default'], {}, {
      color: options.color
    });
  }

  return BeatGridAxisLayer;
})(_axisAxisLayer2['default']);

exports['default'] = BeatGridAxisLayer;
module.exports = exports['default'];

},{"../axis/axis-layer":1,"../axis/beat-grid-axis-generator":2,"../shapes/ticks":54,"babel-runtime/core-js/object/assign":78,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],28:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _shapesMarker = require('../shapes/marker');

var _shapesMarker2 = _interopRequireDefault(_shapesMarker);

var _behaviorsMarkerBehavior = require('../behaviors/marker-behavior');

var _behaviorsMarkerBehavior2 = _interopRequireDefault(_behaviorsMarkerBehavior);

var BeatGridLayer = (function (_Layer) {
  _inherits(BeatGridLayer, _Layer);

  function BeatGridLayer(data) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var accessors = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, BeatGridLayer);

    _get(Object.getPrototypeOf(BeatGridLayer.prototype), 'constructor', this).call(this, 'collection', data, options);

    this.sort_data = options.sort_data;
    this.visible_data = options.visible_data;

    options = _Object$assign({ displayHandlers: true }, options);
    var color = options.color;
    if (color) {
      accessors.color = function () {
        return color;
      };
    }

    this.configureShape(_shapesMarker2['default'], accessors, {
      displayHandlers: options.displayHandlers
    });

    this.setBehavior(new _behaviorsMarkerBehavior2['default']());
  }

  return BeatGridLayer;
})(_coreLayer2['default']);

exports['default'] = BeatGridLayer;
module.exports = exports['default'];

},{"../behaviors/marker-behavior":8,"../core/layer":20,"../shapes/marker":52,"babel-runtime/core-js/object/assign":78,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],29:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _behaviorsBreakpointBehavior = require('../behaviors/breakpoint-behavior');

var _behaviorsBreakpointBehavior2 = _interopRequireDefault(_behaviorsBreakpointBehavior);

var _shapesDot = require('../shapes/dot');

var _shapesDot2 = _interopRequireDefault(_shapesDot);

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _shapesLine = require('../shapes/line');

var _shapesLine2 = _interopRequireDefault(_shapesLine);

var BreakpointLayer = (function (_Layer) {
  _inherits(BreakpointLayer, _Layer);

  function BreakpointLayer(data) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var accessors = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, BreakpointLayer);

    _get(Object.getPrototypeOf(BreakpointLayer.prototype), 'constructor', this).call(this, 'collection', data, options);

    this.sort_data = options.sort_data;
    this.visible_data = options.visible_data;

    var color = options.color;
    var commonShapeOptions = {};

    if (color) {
      accessors.color = function () {
        return color;
      };
      commonShapeOptions.color = color;
    }

    this.configureCommonShape(_shapesLine2['default'], accessors, commonShapeOptions);
    this.configureShape(_shapesDot2['default'], accessors, {});
    this.setBehavior(new _behaviorsBreakpointBehavior2['default']());
  }

  return BreakpointLayer;
})(_coreLayer2['default']);

exports['default'] = BreakpointLayer;
module.exports = exports['default'];

},{"../behaviors/breakpoint-behavior":7,"../core/layer":20,"../shapes/dot":50,"../shapes/line":51,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],30:[function(require,module,exports){
'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var BrushController = (function () {
	function BrushController(track, style) {
		_classCallCheck(this, BrushController);

		if (style === undefined) style = {};
		this.track = track;
		this.innerColor = style.innerColor || '#686868';
		this.opacity = style.opacity || 0.5;
	}

	_createClass(BrushController, [{
		key: 'addBrush',
		value: function addBrush() {
			if (this.track.$brush) return;

			var brush = new _konva2['default'].Rect({});
			brush.fill(this.innerColor).opacity(this.opacity);

			this.track.$interactionsLayer.add(brush);
			this.track.$interactionsLayer.moveToTop();

			this.track.$brush = brush;

			this.track.$interactionsLayer.batchDraw();
		}
	}, {
		key: 'removeBrush',
		value: function removeBrush() {
			if (this.track.$brush === undefined) return;

			this.resetBrush();

			this.track.$brush.destroy();

			this.track.$interactionsLayer.batchDraw();

			delete this.track.$brush;
		}
	}, {
		key: 'resetBrush',
		value: function resetBrush() {
			var $brush = this.track.$brush;
			// reset brush element
			$brush.x(0).y(0).width(0).height(0);
			this.track.$interactionsLayer.batchDraw();
		}
	}, {
		key: 'updateBrush',
		value: function updateBrush(e) {
			var $brush = this.track.$brush;

			$brush.x(e.area.left).y(0).width(e.area.width).height(this.track.height);

			this.track.$interactionsLayer.batchDraw();
		}
	}, {
		key: 'brushArea',
		get: function get() {
			var $brush = this.track.$brush;

			return {
				x: $brush.x(),
				y: $brush.y(),
				width: $brush.width(),
				height: $brush.height()
			};
		},
		set: function set(A) {
			var x = A.x,
			    y = A.y || 0,
			    width = A.width,
			    height = A.height || this.track.height;

			this.track.$brush.x(x).y(y).width(width).height(height);

			this.track.$interactionsLayer.batchDraw();
		}
	}, {
		key: 'opacity',
		set: function set(value) {
			this._opacity = value;
			if (this.track.$brush) this.track.$brush.opacity(this._opacity);
			this.track.$interactionsLayer.batchDraw();
		},
		get: function get() {
			return this._opacity;
		}
	}, {
		key: 'innerColor',
		set: function set(value) {
			this._innerColor = value;
			if (this.track.$brush) this.track.$brush.fill(this._innerColor);
			this.track.$interactionsLayer.batchDraw();
		},
		get: function get() {
			return this._innerColor;
		}
	}]);

	return BrushController;
})();

exports['default'] = BrushController;
module.exports = exports['default'];

},{"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/interop-require-default":92,"konva":180}],31:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _shapesCursor = require('../shapes/cursor');

var _shapesCursor2 = _interopRequireDefault(_shapesCursor);

var CursorLayer = (function (_Layer) {
  _inherits(CursorLayer, _Layer);

  function CursorLayer() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, CursorLayer);

    var defaults = {
      color: 'red',
      hittable: false };

    // kind of pass through layer
    var data = { currentPosition: 0 };

    options = _Object$assign(defaults, options);
    _get(Object.getPrototypeOf(CursorLayer.prototype), 'constructor', this).call(this, 'entity', data, options);

    this.configureShape(_shapesCursor2['default'], { x: function x(d) {
        return d.currentPosition;
      } }, {
      color: options.color
    });

    this.data[0] = data;
  }

  _createClass(CursorLayer, [{
    key: 'currentPosition',
    set: function set(value) {
      this.data[0].currentPosition = value;
    },
    get: function get() {
      return this.data[0].currentPosition;
    }
  }]);

  return CursorLayer;
})(_coreLayer2['default']);

exports['default'] = CursorLayer;
module.exports = exports['default'];

},{"../core/layer":20,"../shapes/cursor":49,"babel-runtime/core-js/object/assign":78,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],32:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _axisAxisLayer = require('../axis/axis-layer');

var _axisAxisLayer2 = _interopRequireDefault(_axisAxisLayer);

var _shapesTicks = require('../shapes/ticks');

var _shapesTicks2 = _interopRequireDefault(_shapesTicks);

var _axisGridAxisGenerator = require('../axis/grid-axis-generator');

var _axisGridAxisGenerator2 = _interopRequireDefault(_axisGridAxisGenerator);

var GridAxisLayer = (function (_AxisLayer) {
  _inherits(GridAxisLayer, _AxisLayer);

  function GridAxisLayer(options) {
    _classCallCheck(this, GridAxisLayer);

    options = _Object$assign({
      color: 'steelblue',
      bpm: 60,
      signature: '4/4'
    }, options);

    _get(Object.getPrototypeOf(GridAxisLayer.prototype), 'constructor', this).call(this, (0, _axisGridAxisGenerator2['default'])(options.bpm, options.signature), options);

    this.configureShape(_shapesTicks2['default'], {}, {
      color: options.color
    });
  }

  return GridAxisLayer;
})(_axisAxisLayer2['default']);

exports['default'] = GridAxisLayer;
module.exports = exports['default'];

},{"../axis/axis-layer":1,"../axis/grid-axis-generator":3,"../shapes/ticks":54,"babel-runtime/core-js/object/assign":78,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],33:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _shapesMarker = require('../shapes/marker');

var _shapesMarker2 = _interopRequireDefault(_shapesMarker);

var _behaviorsMarkerBehavior = require('../behaviors/marker-behavior');

var _behaviorsMarkerBehavior2 = _interopRequireDefault(_behaviorsMarkerBehavior);

var MarkerLayer = (function (_Layer) {
  _inherits(MarkerLayer, _Layer);

  function MarkerLayer(data) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var accessors = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, MarkerLayer);

    _get(Object.getPrototypeOf(MarkerLayer.prototype), 'constructor', this).call(this, 'collection', data, options);

    this.sort_data = options.sort_data;
    this.visible_data = options.visible_data;

    options = _Object$assign({ displayHandlers: true }, options);
    var color = options.color;
    if (color) {
      accessors.color = function () {
        return color;
      };
    }

    this.configureShape(_shapesMarker2['default'], accessors, {
      displayHandlers: options.displayHandlers
    });

    this.setBehavior(new _behaviorsMarkerBehavior2['default']());
  }

  return MarkerLayer;
})(_coreLayer2['default']);

exports['default'] = MarkerLayer;
module.exports = exports['default'];

},{"../behaviors/marker-behavior":8,"../core/layer":20,"../shapes/marker":52,"babel-runtime/core-js/object/assign":78,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],34:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _coreTimeline = require('../core/timeline');

var _coreTimeline2 = _interopRequireDefault(_coreTimeline);

var _coreTrack = require('../core/track');

var _coreTrack2 = _interopRequireDefault(_coreTrack);

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _coreLayerTimeContext = require('../core/layer-time-context');

var _coreLayerTimeContext2 = _interopRequireDefault(_coreLayerTimeContext);

var _behaviorsScrollSegmentBehavior = require('../behaviors/scroll-segment-behavior');

var _behaviorsScrollSegmentBehavior2 = _interopRequireDefault(_behaviorsScrollSegmentBehavior);

var _shapesSegment = require('../shapes/segment');

var _shapesSegment2 = _interopRequireDefault(_shapesSegment);

var _statesSimpleEditionState = require('../states/simple-edition-state');

var _statesSimpleEditionState2 = _interopRequireDefault(_statesSimpleEditionState);

var Scroller = (function (_events$EventEmitter) {
	_inherits(Scroller, _events$EventEmitter);

	function Scroller($el, targetTimelines, pixelsPerSecond, width, height, start, duration) {
		_classCallCheck(this, Scroller);

		_get(Object.getPrototypeOf(Scroller.prototype), 'constructor', this).call(this);
		var that = this;
		this.handlers = {
			set: function set(timelines, index, value) {
				// console.log([timelines, index, value]);
				if (!isNaN(parseInt(index))) {
					timelines[index] = value;
					var interval = {
						start: that.visibleRange.start,
						duration: that.visibleRange.duration
					};
					timelines[index].visibleInterval = interval;
					timelines[index].tracks.update();
				}
				return true;
			}
		};
		this.auxTimeline = new _coreTimeline2['default'](pixelsPerSecond, width);
		var t = document.createElement('div');
		t.classList.add("scroll-div");
		$el.appendChild(t);

		this.auxTrack = new _coreTrack2['default'](t, 20, width);

		this.auxScrollLayer = new _coreLayer2['default']('collection', [], {
			height: height,
			yDomain: [0, 1]
		});
		this.auxScrollLayer.setBehavior(new _behaviorsScrollSegmentBehavior2['default'](new Proxy([], this.handlers)));
		this.auxScrollLayer.setTimeContext(new _coreLayerTimeContext2['default'](this.auxTimeline.timeContext));
		this.auxScrollLayer.configureShape(_shapesSegment2['default'], {});
		this.auxScrollLayer.timeContext.lockedToParentInterval = true;

		this.auxScrollLayer.sort_data = function (data) {};
		this.auxScrollLayer.visible_data = function (timeContext, data) {
			return [0, data.length - 1];
		};
		this.auxScrollLayer.timeContext.lockedToParentInterval = true;

		var visibleInterval = { start: start || 0, duration: duration || 10 };

		this.scrollDatum = { x: visibleInterval.start, duration: visibleInterval.duration };
		this.auxScrollLayer.add(this.scrollDatum);

		this.auxTimeline.visibleInterval = visibleInterval;

		targetTimelines = targetTimelines instanceof Array ? targetTimelines : [targetTimelines];
		targetTimelines.forEach(function (timeline) {
			that.timelines.push(timeline);
		});

		this.auxTrack.add(this.auxScrollLayer);
		this.auxTimeline.add(this.auxTrack);
		this.auxTimeline.tracks.update();

		this.auxScrollLayer.edit([this.scrollDatum], 0, 0, this.auxScrollLayer.getShapeFromDatum(this.scrollDatum).$segment);

		this.auxTimeline.state = new _statesSimpleEditionState2['default'](this.auxTimeline);

		this.auxTimeline.on('event', function (e) {
			if (e.type == 'click' && e.target && !e.target.shape) {
				var offset = -that.auxTimeline.timeContext.offset;
				var time = that.auxTimeline.timeContext.timeToPixel.invert(e.x);
				var currentTime = offset + time;
				var dx = e.x - that.auxTimeline.timeContext.timeToPixel(that.scrollDatum.x);
				var shape = that.auxScrollLayer.getShapeFromDatum(that.scrollDatum);

				that.auxScrollLayer.edit([that.scrollDatum], dx, 0, shape.$segment);
				that.auxTimeline.tracks.update();
				that.emit('drag');
			} else if (e.type == 'mousemove') {
				that.emit('drag');
			}
		});
	}

	_createClass(Scroller, [{
		key: 'availableScrollRange',
		set: function set(interval) {
			this.auxTimeline.visibleInterval = interval;
			this.auxTimeline.tracks.update();
		},
		get: function get() {
			return this.auxTimeline.visibleInterval;
		}
	}, {
		key: 'visibleRange',
		set: function set(interval) {
			var targetX = this.auxTimeline.timeContext.timeToPixel(interval.start);
			var x = this.auxTimeline.timeContext.timeToPixel(this.scrollDatum.x);
			var dx = targetX - x;
			this.scrollDatum.width = interval.duration;

			var shape = this.auxScrollLayer.getShapeFromDatum(this.scrollDatum);
			this.auxScrollLayer.edit([this.scrollDatum], dx, 0, shape.$segment);

			this.auxTimeline.tracks.update();
		},
		get: function get() {
			return { start: this.scrollDatum.x, duration: this.scrollDatum.width || 10 };
		}
	}, {
		key: 'color',
		set: function set(value) {
			this.auxScrollLayer.getShapeFromDatum(this.scrollDatum).params.color = value;
			this.auxTimeline.tracks.update();
		},
		get: function get() {
			return this.auxScrollLayer.getShapeFromDatum(this.scrollDatum).params.color;
		}
	}, {
		key: 'timelines',
		set: function set(timelines) {
			this.auxScrollLayer._behavior.targetTimelines = new Proxy(timelines, this.handlers);
			this.auxScrollLayer._behavior._refresh();
		},
		get: function get() {
			return this.auxScrollLayer._behavior.targetTimelines;
		}
	}]);

	return Scroller;
})(_events2['default'].EventEmitter);

exports['default'] = Scroller;
module.exports = exports['default'];

},{"../behaviors/scroll-segment-behavior":11,"../core/layer":20,"../core/layer-time-context":19,"../core/timeline":22,"../core/track":24,"../shapes/segment":53,"../states/simple-edition-state":71,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92,"events":182}],35:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _shapesSegment = require('../shapes/segment');

var _shapesSegment2 = _interopRequireDefault(_shapesSegment);

var _behaviorsSegmentBehavior = require('../behaviors/segment-behavior');

var _behaviorsSegmentBehavior2 = _interopRequireDefault(_behaviorsSegmentBehavior);

var SegmentLayer = (function (_Layer) {
  _inherits(SegmentLayer, _Layer);

  function SegmentLayer(data) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var accessors = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, SegmentLayer);

    _get(Object.getPrototypeOf(SegmentLayer.prototype), 'constructor', this).call(this, 'collection', data, options);

    this.sort_data = options.sort_data;
    this.visible_data = options.visible_data;

    options = _Object$assign({
      displayHandlers: true,
      opacity: 0.6
    }, options);

    this.configureShape(_shapesSegment2['default'], accessors, {
      displayHandlers: options.displayHandlers,
      opacity: options.opacity
    });

    this.setBehavior(new _behaviorsSegmentBehavior2['default']());
  }

  return SegmentLayer;
})(_coreLayer2['default']);

exports['default'] = SegmentLayer;
module.exports = exports['default'];

},{"../behaviors/segment-behavior":12,"../core/layer":20,"../shapes/segment":53,"babel-runtime/core-js/object/assign":78,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],36:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _shapesTicks = require('../shapes/ticks');

var _shapesTicks2 = _interopRequireDefault(_shapesTicks);

var TickLayer = (function (_Layer) {
  _inherits(TickLayer, _Layer);

  function TickLayer(data, options, accessors) {
    _classCallCheck(this, TickLayer);

    options = _Object$assign({}, options);

    _get(Object.getPrototypeOf(TickLayer.prototype), 'constructor', this).call(this, 'entity', data, options);

    this.sort_data = options.sort_data;
    this.visible_data = options.visible_data;

    var config = options.color ? { color: options.color } : undefined;
    this.configureShape(_shapesTicks2['default'], accessors, config);
  }

  return TickLayer;
})(_coreLayer2['default']);

exports['default'] = TickLayer;
module.exports = exports['default'];

},{"../core/layer":20,"../shapes/ticks":54,"babel-runtime/core-js/object/assign":78,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],37:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _axisAxisLayer = require('../axis/axis-layer');

var _axisAxisLayer2 = _interopRequireDefault(_axisAxisLayer);

var _shapesTicks = require('../shapes/ticks');

var _shapesTicks2 = _interopRequireDefault(_shapesTicks);

var _axisTimeAxisGenerator = require('../axis/time-axis-generator');

var _axisTimeAxisGenerator2 = _interopRequireDefault(_axisTimeAxisGenerator);

var TimeAxisLayer = (function (_AxisLayer) {
  _inherits(TimeAxisLayer, _AxisLayer);

  function TimeAxisLayer(options) {
    _classCallCheck(this, TimeAxisLayer);

    options = _Object$assign({ color: 'steelblue' }, options);
    _get(Object.getPrototypeOf(TimeAxisLayer.prototype), 'constructor', this).call(this, (0, _axisTimeAxisGenerator2['default'])(), options);

    this.sort_data = options.sort_data;
    this.visible_data = options.visible_data;

    this.configureShape(_shapesTicks2['default'], {}, {
      color: options.color
    });
  }

  return TimeAxisLayer;
})(_axisAxisLayer2['default']);

exports['default'] = TimeAxisLayer;
module.exports = exports['default'];

},{"../axis/axis-layer":1,"../axis/time-axis-generator":4,"../shapes/ticks":54,"babel-runtime/core-js/object/assign":78,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],38:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _shapesTracePath = require('../shapes/trace-path');

var _shapesTracePath2 = _interopRequireDefault(_shapesTracePath);

var _shapesTraceDots = require('../shapes/trace-dots');

var _shapesTraceDots2 = _interopRequireDefault(_shapesTraceDots);

var _behaviorsTraceBehavior = require('../behaviors/trace-behavior');

var _behaviorsTraceBehavior2 = _interopRequireDefault(_behaviorsTraceBehavior);

var TraceLayer = (function (_Layer) {
  _inherits(TraceLayer, _Layer);

  function TraceLayer(data) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var accessors = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, TraceLayer);

    options = _Object$assign({ displayDots: true }, options);
    _get(Object.getPrototypeOf(TraceLayer.prototype), 'constructor', this).call(this, options.displayDots ? 'collection' : 'entity', data, options);

    this.sort_data = options.sort_data;
    this.visible_data = options.visible_data;

    var shapeOptions = {};
    if (options.meanColor !== undefined) {
      shapeOptions.meanColor = options.meanColor;
    }
    if (options.rangeColor !== undefined) {
      shapeOptions.rangeColor = options.rangeColor;
    }
    if (options.displayMean !== undefined) {
      shapeOptions.displayMean = options.displayMean;
    }

    if (options.displayDots) {
      this.configureCommonShape(_shapesTracePath2['default'], accessors, shapeOptions);
      this.configureShape(_shapesTraceDots2['default'], accessors, shapeOptions);
    } else {
      this.configureShape(_shapesTracePath2['default'], accessors, shapeOptions);
    }

    this.setBehavior(new _behaviorsTraceBehavior2['default']());
  }

  return TraceLayer;
})(_coreLayer2['default']);

exports['default'] = TraceLayer;
module.exports = exports['default'];

},{"../behaviors/trace-behavior":17,"../core/layer":20,"../shapes/trace-dots":55,"../shapes/trace-path":56,"babel-runtime/core-js/object/assign":78,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],39:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _shapesWaveform = require('../shapes/waveform');

var _shapesWaveform2 = _interopRequireDefault(_shapesWaveform);

var defaults = {
  yDomain: [-1, 1],
  channel: 0,
  color: 'steelblue',
  renderingStrategy: 'svg'
};

var WaveformLayer = (function (_Layer) {
  _inherits(WaveformLayer, _Layer);

  function WaveformLayer(data, options) {
    _classCallCheck(this, WaveformLayer);

    options = _Object$assign({}, defaults, options);

    _get(Object.getPrototypeOf(WaveformLayer.prototype), 'constructor', this).call(this, 'collection', data, options);

    this.sort_data = options.sort_data;
    this.visible_data = options.visible_data;

    this.configureShape(_shapesWaveform2['default'], {}, {
      sampleRate: buffer.sampleRate,
      color: options.color,
      renderingStrategy: options.renderingStrategy
    });
  }

  return WaveformLayer;
})(_coreLayer2['default']);

exports['default'] = WaveformLayer;
module.exports = exports['default'];

},{"../core/layer":20,"../shapes/waveform":57,"babel-runtime/core-js/object/assign":78,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],40:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

/**
 * Abstract class to extend to create new sources of interactions.
 * A `Surface` and `Keyboard` event sources are provided.
 */

var EventSource = (function (_events$EventEmitter) {
  _inherits(EventSource, _events$EventEmitter);

  function EventSource($el) {
    _classCallCheck(this, EventSource);

    _get(Object.getPrototypeOf(EventSource.prototype), 'constructor', this).call(this);
    /**
     * The element on which the listener is added
     * @type {Element}
     */
    this.$el = $el;

    this._bindEvents();
  }

  _createClass(EventSource, [{
    key: '_createEvent',
    value: function _createEvent(type, e) {}
  }, {
    key: '_bindEvents',
    value: function _bindEvents() {}
  }]);

  return EventSource;
})(_events2['default'].EventEmitter);

exports['default'] = EventSource;
module.exports = exports['default'];

},{"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92,"events":182}],41:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _eventSource = require('./event-source');

var _eventSource2 = _interopRequireDefault(_eventSource);

var _waveEvent = require('./wave-event');

var _waveEvent2 = _interopRequireDefault(_waveEvent);

/**
 * A global event sourve for the keyboard. Only one instance of this source
 * can be created. The first created timeline instanciate the singleton, each
 * subsequent instanciation returns the first created instance.
 */

var Keyboard = (function (_EventSource) {
  _inherits(Keyboard, _EventSource);

  /**
   * @param {Element} $el - The element on which to install the listener.
   */

  function Keyboard($el) {
    _classCallCheck(this, Keyboard);

    // kind of singleton
    if (Keyboard._instance) {
      return Keyboard._instance;
    }

    _get(Object.getPrototypeOf(Keyboard.prototype), 'constructor', this).call(this, $el);
    /**
     * The name of the source
     * @type {String}
     */
    this.sourceName = 'keyboard';

    Keyboard._instance = this;

    this._beingPressed = new _Set();
  }

  _createClass(Keyboard, [{
    key: '_createEvent',
    value: function _createEvent(type, e) {
      var event = new _waveEvent2['default'](this.sourceName, type, e);

      event.shiftKey = e.shiftKey;
      event.ctrlKey = e.ctrlKey;
      event.altKey = e.altKey;
      event.metaKey = e.metaKey;

      event.keyCode = e.keyCode;
      event.char = String.fromCharCode(e.keyCode);

      return event;
    }
  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this = this;

      var onKeyDown = function onKeyDown(e) {
        if (!_this._beingPressed.has(e.keyCode)) {
          var _event = _this._createEvent('keydown', e);
          _this.emit('event', _event);
          _this._beingPressed.add(e.keyCode);
        }
      };

      var onKeyUp = function onKeyUp(e) {
        var event1 = _this._createEvent('keyup', e);
        _this.emit('event', event1);

        var event2 = _this._createEvent('keypress', e);
        _this.emit('event', event2);

        _this._beingPressed['delete'](e.keyCode);
      };

      this.$el.addEventListener('keydown', onKeyDown, false);
      this.$el.addEventListener('keyup', onKeyUp, false);
    }
  }]);

  return Keyboard;
})(_eventSource2['default']);

exports['default'] = Keyboard;
module.exports = exports['default'];

},{"./event-source":40,"./wave-event":44,"babel-runtime/core-js/set":85,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],42:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _eventSource = require('./event-source');

var _eventSource2 = _interopRequireDefault(_eventSource);

var _konvaWaveEvent = require('./konva-wave-event');

var _konvaWaveEvent2 = _interopRequireDefault(_konvaWaveEvent);

/**
 * Normalizes mouse user interactions with the timeline upon the DOM
 * container element of `Track` instances. As soon as a `track` is added to a
 * `timeline`, its attached `Surface` instance will emit the mouse events.
 */

var Surface = (function (_EventSource) {
  _inherits(Surface, _EventSource);

  /**
   * @param {DOMElement} el - The DOM element to listen.
   * @todo - Add some padding to the surface.
   */

  function Surface($el) {
    _classCallCheck(this, Surface);

    _get(Object.getPrototypeOf(Surface.prototype), 'constructor', this).call(this, $el);

    /**
     * The name of the event source.
     * @type {String}
     */
    this.sourceName = 'surface';
    this._mouseDownEvent = null;
    this._lastEvent = null;
  }

  /**
   * Factory method for `Event` class
   */

  _createClass(Surface, [{
    key: '_createEvent',
    value: function _createEvent(type, e) {
      var event = new _konvaWaveEvent2['default'](this.sourceName, type, e);

      var pos = this._getRelativePosition(e);
      event.x = pos.x;
      event.y = pos.y;

      return event;
    }

    /**
     * Returns the x, y coordinates coordinates relative to the surface element.
     *
     * @param {Event} e - Raw event from listener.
     * @return {Object}
     * @todo - handle padding.
     */
  }, {
    key: '_getRelativePosition',
    value: function _getRelativePosition(e) {
      if (e instanceof MouseEvent) {
        var x = e.offsetX;
        var y = e.offsetY;
        return { x: x, y: y };
      } else {
        var x = e.evt.offsetX;
        var y = e.evt.offsetY;
        return { x: x, y: y };
      }
    }
  }, {
    key: '_defineArea',
    value: function _defineArea(e, mouseDownEvent, lastEvent) {
      if (!mouseDownEvent || !lastEvent) {
        return;
      }
      e.dx = e.x - lastEvent.x;
      e.dy = e.y - lastEvent.y;

      var left = mouseDownEvent.x < e.x ? mouseDownEvent.x : e.x;
      var top = mouseDownEvent.y < e.y ? mouseDownEvent.y : e.y;
      var width = Math.abs(Math.round(e.x - mouseDownEvent.x));
      var height = Math.abs(Math.round(e.y - mouseDownEvent.y));

      e.area = { left: left, top: top, width: width, height: height };
    }

    /**
     * Keep this private to avoid double event binding. Main logic of the surface
     * is here. Should be extended with needed events (mouseenter, mouseleave,
     * wheel ...).
     */
  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this = this;

      var onMouseDrag = function onMouseDrag(e) {

        var event = _this._createEvent('mousemove', e);
        _this._defineArea(event, _this._mouseDownEvent, _this._lastEvent);
        // Update `lastEvent` for next call
        _this._lastEvent = event;

        _this.emit('event', event);
      };

      var onMouseUp = function onMouseUp(e) {

        if (_this._lastEvent.type == 'mousemove') {

          var _event = _this._createEvent('mouseup', e);
          _this._defineArea(_event, _this._mouseDownEvent, _this._lastEvent);

          _this._mouseDownEvent = null;
          _this._lastEvent = null;
          // Remove mousemove and mouseup listeners on window
          window.removeEventListener('mousemove', onMouseDrag);
          window.removeEventListener('mouseup', onMouseUp);

          _this.emit('event', _event);
        } else if (_this._lastEvent.type == 'mousedown') {

          var event1 = _this._createEvent('mouseup', e);
          var event2 = _this._createEvent('click', e);
          event2.target = _this._mouseDownEvent.target;

          _this._mouseDownEvent = null;
          _this._lastEvent = null;

          // Remove mousemove and mouseup listeners on window
          window.removeEventListener('mousemove', onMouseDrag);
          window.removeEventListener('mouseup', onMouseUp);

          _this.emit('event', event1);
          _this.emit('event', event2);
        }
      };

      var onMouseDown = function onMouseDown(e) {
        // By removing the previous selection we prevent bypassing the mousemove events coming from SVG in Firefox.
        window.getSelection().removeAllRanges();
        var event = _this._createEvent('mousedown', e);

        _this._mouseDownEvent = event;
        _this._lastEvent = event;
        // Register mousemove and mouseup listeners on window
        window.addEventListener('mousemove', onMouseDrag, false);
        window.addEventListener('mouseup', onMouseUp, false);

        event.cancelBubble = true;

        _this.emit('event', event);
      };

      var onClick = function onClick(e) {
        var event = _this._createEvent('click', e);
        _this.emit('event', event);
      };

      var onDblClick = function onDblClick(e) {
        var event = _this._createEvent('dblclick', e);
        _this.emit('event', event);
      };

      var onMouseOver = function onMouseOver(e) {
        var event = _this._createEvent('mouseover', e);
        _this.emit('event', event);
      };

      var onMouseOut = function onMouseOut(e) {
        var event = _this._createEvent('mouseout', e);
        _this.emit('event', event);
      };

      var onMouseDownTimeline = function onMouseDownTimeline(e) {
        var event = _this._createEvent('mousedown', e);
        _this.emit('event', event);
      };

      var onDomDragStart = function onDomDragStart(e) {
        var event = _this._createEvent('dragstart', e);
        _this.emit('event', event);
      };

      var onDomDragOver = function onDomDragOver(e) {
        e.preventDefault();
        var event = _this._createEvent('dragover', e);
        _this.emit('event', event);
      };

      var onDomDrop = function onDomDrop(e) {
        e.preventDefault();
        var event = _this._createEvent('drop', e);
        _this.emit('event', event);
      };

      var onDomDragLeave = function onDomDragLeave(e) {
        var event = _this._createEvent('dragleave', e);
        _this.emit('event', event);
      };

      var onDomDragEnter = function onDomDragEnter(e) {
        var event = _this._createEvent('dragenter', e);
        _this.emit('event', event);
      };

      /*
       * When I listen for the 'click' event, there is the following issue for 'drag' sequences:
       *
       * (1) [mousedown -> mousemove -> click -> mouseup] 
       *  instead of 
       * (2) [mousedown -> mousemove -> mouseup]
       * 
       * For this reason, instead of directly listening for 'click', I adapted the 'mouseup' 
       * listener to enforce the sequence (2) and [mousedown -> mouseup -> click] .
       */

      // Bind callbacks
      // this.$el.$stage.on('contentMousedown', onMouseDownTimeline);
      this.$el.$stage.on('mousedown', onMouseDown);
      // this.$el.$stage.on('click', onClick);
      this.$el.$stage.on('dblclick', onDblClick);
      this.$el.$stage.on('mouseover', onMouseOver);
      this.$el.$stage.on('mouseout', onMouseOut);
      this.$el.$stage.on('mouseover', onMouseOver);
      this.$el.$stage.content.addEventListener('dragstart', onDomDragStart);
      this.$el.$stage.content.addEventListener('dragenter', onDomDragEnter);
      this.$el.$stage.content.addEventListener('drop', onDomDrop);
      this.$el.$stage.content.addEventListener('dragover', onDomDragOver);
      this.$el.$stage.content.addEventListener('dragleave', onDomDragLeave);
    }
  }]);

  return Surface;
})(_eventSource2['default']);

exports['default'] = Surface;
module.exports = exports['default'];

},{"./event-source":40,"./konva-wave-event":43,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],43:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _waveEvent = require('./wave-event');

var _waveEvent2 = _interopRequireDefault(_waveEvent);

/**
 * Object template for all events. Event sources should use this event template
 * in order to keep consistency with existing sources.
 */

var KonvaWaveEvent = (function (_WaveEvent) {
  _inherits(KonvaWaveEvent, _WaveEvent);

  /**
   * @param {String} source - The name of the source (`keyboard`, `surface`, ...).
   * @param {String} type - The type of the source (`mousedown`, `keyup`, ...).
   * @param {Event} originalEvent - The original event as emitted by the browser.
   */

  function KonvaWaveEvent(source, type, originalEvent) {
    _classCallCheck(this, KonvaWaveEvent);

    _get(Object.getPrototypeOf(KonvaWaveEvent.prototype), 'constructor', this).call(this, source, type, originalEvent);
    if (!(originalEvent instanceof MouseEvent)) {
      this.originalEvent = originalEvent.evt;
      this.currentTarget = originalEvent.evt.currentTarget;
    }
  }

  return KonvaWaveEvent;
})(_waveEvent2['default']);

exports['default'] = KonvaWaveEvent;
module.exports = exports['default'];

},{"./wave-event":44,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],44:[function(require,module,exports){
'use strict';

/**
 * Object template for all events. Event sources should use this event template
 * in order to keep consistency with existing sources.
 */

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var WaveEvent =
/**
 * @param {String} source - The name of the source (`keyboard`, `surface`, ...).
 * @param {String} type - The type of the source (`mousedown`, `keyup`, ...).
 * @param {Event} originalEvent - The original event as emitted by the browser.
 */
function WaveEvent(source, type, originalEvent) {
  _classCallCheck(this, WaveEvent);

  this.source = source;
  this.type = type;
  this.originalEvent = originalEvent;

  this.target = originalEvent.target;
  this.currentTarget = originalEvent.currentTarget;
};

exports['default'] = WaveEvent;
module.exports = exports['default'];

},{"babel-runtime/helpers/class-call-check":88}],45:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _dot = require('./dot');

var _dot2 = _interopRequireDefault(_dot);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var AnnotatedDot = (function (_Dot) {
	_inherits(AnnotatedDot, _Dot);

	function AnnotatedDot() {
		_classCallCheck(this, AnnotatedDot);

		_get(Object.getPrototypeOf(AnnotatedDot.prototype), 'constructor', this).apply(this, arguments);
	}

	_createClass(AnnotatedDot, [{
		key: 'destroy',
		value: function destroy() {
			this.$label.destroy();
			this.$label = null;
			_get(Object.getPrototypeOf(AnnotatedDot.prototype), 'destroy', this).call(this);
		}
	}, {
		key: 'getClassName',
		value: function getClassName() {
			return 'annotated-dot';
		}
	}, {
		key: '_getAccessorList',
		value: function _getAccessorList() {
			var list = _get(Object.getPrototypeOf(AnnotatedDot.prototype), '_getAccessorList', this).call(this);
			list.text = 'default';
			return list;
		}
	}, {
		key: 'render',
		value: function render(renderingContext) {
			if (this.$el) {
				return this.$el;
			}

			this.$el = _get(Object.getPrototypeOf(AnnotatedDot.prototype), 'render', this).call(this, renderingContext);

			this.$label = new _konva2['default'].Text({ listening: false });
			this.$label.addName('text');

			this.$el.push(this.$label);

			return this.$el;
		}
	}, {
		key: 'update',
		value: function update(renderingContext, datum) {
			var d = datum || this.datum;

			_get(Object.getPrototypeOf(AnnotatedDot.prototype), 'update', this).call(this, renderingContext, d);

			var x = renderingContext.timeToPixel(this.x(d));
			var y = renderingContext.valueToPixel(this.y(d));
			var text = this.text(d);

			this.$label.x(x + 3).y(y);
			this.$label.height(Math.min(y, renderingContext.height + 10));
			this.$label.fill('#242424');
			this.$label.fontSize(10);
			this.$label.fontFamily('monospace');
			this.$label.text(text);
		}
	}]);

	return AnnotatedDot;
})(_dot2['default']);

exports['default'] = AnnotatedDot;
module.exports = exports['default'];

},{"./dot":50,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92,"konva":180}],46:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _marker = require('./marker');

var _marker2 = _interopRequireDefault(_marker);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var AnnotatedMarker = (function (_Marker) {
  _inherits(AnnotatedMarker, _Marker);

  function AnnotatedMarker() {
    _classCallCheck(this, AnnotatedMarker);

    _get(Object.getPrototypeOf(AnnotatedMarker.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(AnnotatedMarker, [{
    key: 'destroy',
    value: function destroy() {
      this.$label.destroy();
      this.$label = null;
      _get(Object.getPrototypeOf(AnnotatedMarker.prototype), 'destroy', this).call(this);
    }
  }, {
    key: 'getClassName',
    value: function getClassName() {
      return 'annotated-segment';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      var list = _get(Object.getPrototypeOf(AnnotatedMarker.prototype), '_getAccessorList', this).call(this);
      list.text = 'default';
      return list;
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      if (this.$el) {
        return this.$el;
      }

      this.$el = _get(Object.getPrototypeOf(AnnotatedMarker.prototype), 'render', this).call(this, renderingContext);

      this.$label = new _konva2['default'].Text({ listening: false });
      this.$label.addName('text');

      this.$el.push(this.$label);

      return this.$el;
    }
  }, {
    key: 'update',
    value: function update(renderingContext, datum) {
      var d = datum || this.datum;

      _get(Object.getPrototypeOf(AnnotatedMarker.prototype), 'update', this).call(this, renderingContext, d);

      var width = renderingContext.timeToPixel(this.width(d));
      var height = Math.abs(renderingContext.valueToPixel(this.y(d) + this.height(d)) - renderingContext.valueToPixel(this.y(d)));
      var x = renderingContext.timeToPixel(this.x(d));
      var y = renderingContext.valueToPixel(this.y(d) + this.height(d));
      var text = this.text(d);

      this.$label.x(x + 3).y(y + 11);
      this.$label.height(y);
      this.$label.fill('#242424');
      this.$label.fontSize(10);
      this.$label.fontFamily('monospace');
      this.$label.text(text);
    }
  }]);

  return AnnotatedMarker;
})(_marker2['default']);

exports['default'] = AnnotatedMarker;
module.exports = exports['default'];

},{"./marker":52,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92,"konva":180}],47:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _segment = require('./segment');

var _segment2 = _interopRequireDefault(_segment);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var AnnotatedSegment = (function (_Segment) {
  _inherits(AnnotatedSegment, _Segment);

  function AnnotatedSegment() {
    _classCallCheck(this, AnnotatedSegment);

    _get(Object.getPrototypeOf(AnnotatedSegment.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(AnnotatedSegment, [{
    key: 'destroy',
    value: function destroy() {
      this.$label.destroy();
      this.$label = null;
      _get(Object.getPrototypeOf(AnnotatedSegment.prototype), 'destroy', this).call(this);
    }
  }, {
    key: 'getClassName',
    value: function getClassName() {
      return 'annotated-segment';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      var list = _get(Object.getPrototypeOf(AnnotatedSegment.prototype), '_getAccessorList', this).call(this);
      list.text = 'default';
      return list;
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      if (this.$el) {
        return this.$el;
      }

      this.$el = _get(Object.getPrototypeOf(AnnotatedSegment.prototype), 'render', this).call(this, renderingContext);

      this.$label = new _konva2['default'].Text({ listening: false });
      this.$label.addName('text');

      this.$el.push(this.$label);

      return this.$el;
    }
  }, {
    key: 'update',
    value: function update(renderingContext, datum) {
      var d = datum || this.datum;

      _get(Object.getPrototypeOf(AnnotatedSegment.prototype), 'update', this).call(this, renderingContext, d);

      var width = renderingContext.timeToPixel(this.width(d));
      var height = Math.abs(renderingContext.valueToPixel(this.y(d) + this.height(d)) - renderingContext.valueToPixel(this.y(d)));
      var x = renderingContext.timeToPixel(this.x(d));
      var y = renderingContext.valueToPixel(this.y(d) + this.height(d));
      var text = this.text(d);

      this.$label.x(x + 3).y(y + 11);
      this.$label.height(y);
      this.$label.fill('#242424');
      this.$label.fontSize(10);
      this.$label.fontFamily('monospace');
      this.$label.text(text);
    }
  }]);

  return AnnotatedSegment;
})(_segment2['default']);

exports['default'] = AnnotatedSegment;
module.exports = exports['default'];

},{"./segment":53,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92,"konva":180}],48:[function(require,module,exports){
'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _Object$defineProperty = require('babel-runtime/core-js/object/define-property')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _segment = require('./segment');

var _segment2 = _interopRequireDefault(_segment);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var BaseShape = (function () {
  /**
   * @param {Object} options - override default configuration
   */

  function BaseShape(options) {
    _classCallCheck(this, BaseShape);

    if (options === undefined) options = {};
    /** @type {Element} - Konva.Group to be returned by the `render` method. */
    this.$el = null;
    /** @type {Object} - Object containing the global parameters of the shape */
    this.params = _Object$assign({}, this._getDefaults(), options);

    this.layer = null;

    this._visible = true;
    this._highlight = false;
    this._datum = null;

    // create accessors methods and set default accessor functions
    var accessors = this._getAccessorList();
    this._createAccessors(accessors);
    this._setDefaultAccessors(accessors);
  }

  /**
   * Destroy the shape and clean references. Interface method called from the `layer`.
   */

  _createClass(BaseShape, [{
    key: 'destroy',
    value: function destroy() {
      if (this.$el instanceof Array) {
        for (var i = 0; i < this.$el.length; i++) {
          this.$el[i].shape = null;
        }
        this.$el.length = 0;
      } else if (this.$el) {
        this.$el.shape = null;
      }
      this.$el = null;
      this.$params = null;
      this._accessors = null;
      this._datum = null;
    }

    /**
     * Interface method to override when extending this base class. The method
     * is called by the `Layer~render` method. Returns the name of the shape,
     * used as a class in the element group (defaults to `'shape'`).
     *
     * @return {String}
     */
  }, {
    key: 'getClassName',
    value: function getClassName() {
      return 'shape';
    }

    /**
     * @todo not implemented
     * allow to install defs in the track svg element. Should be called when
     * adding the `Layer` to the `Track`.
     */
    // setSvgDefinition(defs) {}

    /**
     * Returns the defaults for global configuration of the shape.
     * @protected
     * @return {Object}
     */
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return {};
    }

    /**
     * Returns an object where keys are the accessors methods names to create
     * and values are the default values for each given accessor.
     *
     * @protected
     * @todo rename ?
     * @return {Object}
     */
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return {};
    }

    /**
     * Interface method called by Layer when creating a shape. Install the
     * given accessors on the shape, overriding the default accessors.
     *
     * @param {Object<String, function>} accessors
     */
  }, {
    key: 'install',
    value: function install(accessors) {
      for (var key in accessors) {
        this[key] = accessors[key];
      }
    }

    /**
     * Generic method to create accessors. Adds getters en setters to the
     * prototype if not already present.
     */
  }, {
    key: '_createAccessors',
    value: function _createAccessors(accessors) {
      this._accessors = {};
      // add it to the prototype
      var proto = Object.getPrototypeOf(this);
      // create a getter / setter for each accessors
      // setter : `this.x = callback`
      // getter : `this.x(datum)`
      _Object$keys(accessors).forEach(function (name) {
        if (proto.hasOwnProperty(name)) {
          return;
        }

        _Object$defineProperty(proto, name, {
          get: function get() {
            return this._accessors[name];
          },
          set: function set(func) {
            this._accessors[name] = func;
          }
        });
      });
    }

    /**
     * Create a function to be used as a default accessor for each accesors
     */
  }, {
    key: '_setDefaultAccessors',
    value: function _setDefaultAccessors(accessors) {
      var _this = this;

      _Object$keys(accessors).forEach(function (name) {
        var defaultValue = accessors[name];
        var accessor = function accessor(d, v) {
          if (v === undefined) v = null;
          if (v === null) {
            return d[name] || defaultValue;
          }
          d[name] = v;
        };
        // set accessor as the default one
        _this[name] = accessor;
      });
    }

    /**
     * Interface method called by `Layer~render`. Creates the DOM structure of
     * the shape.
     *
     * @param {Object} renderingContext - the renderingContext of the layer
     *    which owns this shape.
     * @return {Element} - the DOM element to insert in the item's group.
     */
  }, {
    key: 'render',
    value: function render(renderingContext) {}

    /**
     * Interface method called by `Layer~update`. Updates the DOM structure of the shape.
     *
     * @param {Object} renderingContext - The `renderingContext` of the layer
     *    which owns this shape.
     * @param {Object|Array} datum - The datum associated to the shape.
     */
  }, {
    key: 'update',
    value: function update(renderingContext, datum) {}

    /**
     *  TODO
     */
  }, {
    key: 'draw',
    value: function draw() {
      if (this.$el instanceof Array) {
        for (var i = 0; i < this.$el.length; i++) this.$el[i].draw();
      } else {
        this.$el.draw();
      }
    }

    /**
     * Interface method to override called by `Layer~getItemsInArea`. Defines if
     * the shape is considered to be the given area. Arguments are passed in pixel domain.
     *
     * @param {Object} renderingContext - the renderingContext of the layer which
     *    owns this shape.
     * @param {Object|Array} datum - The datum associated to the shape.
     * @param {Number} x1 - The x component of the top-left corner of the area to test.
     * @param {Number} y1 - The y component of the top-left corner of the area to test.
     * @param {Number} x2 - The x component of the bottom-right corner of the area to test.
     * @param {Number} y2 - The y component of the bottom-right corner of the area to test.
     * @return {Boolean} - Returns `true` if the is considered to be in the given area, `false` otherwise.
     */
  }, {
    key: 'inArea',
    value: function inArea(renderingContext, datum, x1, y1, x2, y2) {}

    /*
     * TODO
     */
  }, {
    key: 'minimize',
    value: function minimize() {}
  }, {
    key: 'maximize',
    value: function maximize() {}

    /*
     * TODO
     */
  }, {
    key: 'startDrag',
    value: function startDrag() {
      if (this.$el instanceof Array) {
        this.$el.forEach(function (el) {
          return el.startDrag();
        });
      } else {
        this.$el.startDrag();
      }
    }
  }, {
    key: 'stopDrag',
    value: function stopDrag() {
      if (this.$el instanceof Array) {
        this.$el.forEach(function (el) {
          return el.stopDrag();
        });
      } else {
        this.$el.stopDrag();
      }
    }
  }, {
    key: 'visible',
    get: function get() {
      return this._visible;
    },
    set: function set(isVisible) {
      this._visible = isVisible;
    }

    /*
     * TODO
     */
  }, {
    key: 'datum',
    get: function get() {
      return this._datum;
    },
    set: function set(datum) {
      this._datum = datum;
    }
  }]);

  return BaseShape;
})();

exports['default'] = BaseShape;
module.exports = exports['default'];

},{"./segment":53,"babel-runtime/core-js/object/assign":78,"babel-runtime/core-js/object/define-property":80,"babel-runtime/core-js/object/keys":82,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/interop-require-default":92,"konva":180}],49:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseShape = require('./base-shape');

var _baseShape2 = _interopRequireDefault(_baseShape);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

/**
 * A shape to display a cursor.
 */

var Cursor = (function (_BaseShape) {
  _inherits(Cursor, _BaseShape);

  function Cursor() {
    _classCallCheck(this, Cursor);

    _get(Object.getPrototypeOf(Cursor.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Cursor, [{
    key: 'getClassName',
    value: function getClassName() {
      return 'cursor';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return { x: 0 };
    }
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return {
        color: '#000000',
        opacity: 1,
        width: 2
      };
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      if (this.$el) {
        return this.$el;
      }

      this.$el = new _konva2['default'].Rect({});

      return this.$el;
    }
  }, {
    key: 'update',
    value: function update(renderingContext, datum) {
      // const x = Math.round(renderingContext.timeToPixel(this.x(datum))) + 0.5;
      var x = renderingContext.timeToPixel(this.x(datum));

      this.$el.x(x).y(0).width(this.params.width).height(renderingContext.height).fill(this.params.color).opacity(this.params.opacity);
    }

    /**
     * The cursor cannot be selected.
     * @return {Boolean} false
     */
  }, {
    key: 'inArea',
    value: function inArea() {
      return false;
    }
  }]);

  return Cursor;
})(_baseShape2['default']);

exports['default'] = Cursor;
module.exports = exports['default'];

},{"./base-shape":48,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92,"konva":180}],50:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _baseShape = require('./base-shape');

var _baseShape2 = _interopRequireDefault(_baseShape);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var Dot = (function (_BaseShape) {
	_inherits(Dot, _BaseShape);

	function Dot() {
		_classCallCheck(this, Dot);

		_get(Object.getPrototypeOf(Dot.prototype), 'constructor', this).apply(this, arguments);
	}

	_createClass(Dot, [{
		key: 'destroy',
		value: function destroy() {
			this.$el[0].destroy();
			_get(Object.getPrototypeOf(Dot.prototype), 'destroy', this).call(this);
		}
	}, {
		key: 'getClassName',
		value: function getClassName() {
			return 'dot';
		}

		// @TODO rename : confusion between accessors and meta-accessors
	}, {
		key: '_getAccessorList',
		value: function _getAccessorList() {
			return { x: 0, y: 0 };
		}
	}, {
		key: '_getDefaults',
		value: function _getDefaults() {
			return {
				color: 'black',
				r: 3
			};
		}
	}, {
		key: 'render',
		value: function render() {
			if (this.$el) {
				return this.$el;
			}

			this.$el = [new _konva2['default'].Circle({})];
			this.$el[0].shape = this;
			this.$el[0].perfectDrawEnabled(false);

			return this.$el;
		}
	}, {
		key: 'update',
		value: function update(renderingContext, datum) {
			var d = datum || this.datum;

			var x = renderingContext.timeToPixel(this.x(d));
			var y = renderingContext.valueToPixel(this.y(d));
			// const r	= this.r(d);
			// const color = this.color(d);
			var r = this.r(d);
			var color = this.params.color;

			this.$el[0].x(x);
			this.$el[0].y(y);
			this.$el[0].radius(r);
			this.$el[0].fill(color);
		}

		// x1, x2, y1, y2 => in pixel domain
	}, {
		key: 'inArea',
		value: function inArea(renderingContext, datum, x1, y1, x2, y2) {
			var x = this.$el[0].getAbsolutePosition().x;
			var y = this.$el[0].getAbsolutePosition().y;

			if (x >= x1 && x <= x2 && (y >= y1 && y <= y2)) {
				return true;
			}

			return false;
		}
	}]);

	return Dot;
})(_baseShape2['default']);

exports['default'] = Dot;
module.exports = exports['default'];

},{"./base-shape":48,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92,"konva":180}],51:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseShape = require('./base-shape');

var _baseShape2 = _interopRequireDefault(_baseShape);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var Line = (function (_BaseShape) {
  _inherits(Line, _BaseShape);

  function Line() {
    _classCallCheck(this, Line);

    _get(Object.getPrototypeOf(Line.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Line, [{
    key: 'destroy',
    value: function destroy() {
      this.$el.destroy();
      _get(Object.getPrototypeOf(Line.prototype), 'destroy', this).call(this);
    }
  }, {
    key: 'getClassName',
    value: function getClassName() {
      return 'line';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return { x: 0, y: 0 };
    }
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return { color: '#000000', strokeWidth: 1 };
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      if (this.$el) {
        return this.$el;
      }

      this.$el = new _konva2['default'].Path({});
      this.$el.perfectDrawEnabled(false);

      return this.$el;
    }
  }, {
    key: 'update',
    value: function update(renderingContext, data) {
      var _this = this;

      data = data.slice(0);
      data.sort(function (a, b) {
        return _this.x(a) < _this.x(b) ? -1 : 1;
      });

      this.$el.data(this._buildLine(renderingContext, data));
      this.$el.stroke(this.params.color);
      this.$el.strokeWidth(this.params.strokeWidth);

      data = null;
    }

    // builds the `path.d` attribute
    // @TODO create some ShapeHelper ?
  }, {
    key: '_buildLine',
    value: function _buildLine(renderingContext, data) {
      var _this2 = this;

      if (!data.length) {
        return '';
      }
      // sort data
      var instructions = data.map(function (datum, index) {
        var x = renderingContext.timeToPixel(_this2.x(datum));
        var y = renderingContext.valueToPixel(_this2.y(datum)) - 0.5;
        return x + ',' + y;
      });

      return 'M' + instructions.join('L');
    }
  }]);

  return Line;
})(_baseShape2['default']);

exports['default'] = Line;
module.exports = exports['default'];

},{"./base-shape":48,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92,"konva":180}],52:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseShape = require('./base-shape');

var _baseShape2 = _interopRequireDefault(_baseShape);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var Marker = (function (_BaseShape) {
  _inherits(Marker, _BaseShape);

  function Marker() {
    _classCallCheck(this, Marker);

    _get(Object.getPrototypeOf(Marker.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Marker, [{
    key: 'destroy',
    value: function destroy() {
      this.$line.destroy();
      this.$line = null;
      this.$handler.destroy();
      this.$handler = null;
      _get(Object.getPrototypeOf(Marker.prototype), 'destroy', this).call(this);
    }
  }, {
    key: 'getClassName',
    value: function getClassName() {
      return 'marker';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return {
        x: 0,
        handlerWidth: 7,
        handlerHeight: 10,
        displayHandler: true,
        opacity: 1,
        strokeWidth: 2,
        color: 'black',
        handlerColor: 'black'
      };
    }
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return {
        handlerWidth: undefined,
        handlerHeight: undefined,
        displayHandler: undefined,
        opacity: undefined,
        strokeWidth: undefined,
        color: undefined,
        handlerColor: undefined
      };
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      if (this.$el) {
        return this.$el;
      }

      this.$el = [];

      this.$line = new _konva2['default'].Rect({});
      this.$line.addName('marker');
      this.$line.shape = this;

      this.$handler = new _konva2['default'].Rect({});
      this.$handler.addName('handler');
      this.$handler.shape = this;

      this.$el.push(this.$line);
      this.$el.push(this.$handler);

      return this.$el;
    }
  }, {
    key: 'update',
    value: function update(renderingContext, datum) {
      var d = datum || this.datum;

      var displayHandler = this.params.displayHandler || this.displayHandler(d);

      this.$line.visible(this.visible);
      this.$handler.visible(this.visible && displayHandler);

      if (!this.visible) return;

      var x = renderingContext.timeToPixel(this.x(d)) - 0.5;
      var height = renderingContext.height;
      var handlerWidth = this.params.handlerWidth || this.handlerWidth(d);
      var handlerHeight = this.params.handlerHeight || this.handlerHeight(d);
      var opacity = this.params.opacity || this.opacity(d);
      var strokeWidth = this.params.strokeWidth || this.strokeWidth(d);
      var color = this.params.color || this.color(d);
      var handlerColor = this.params.handlerColor || this.handlerColor(d);

      this.$line.x(x).y(0).width(strokeWidth).height(height).fill(color).opacity(opacity);

      this.$handler.x(x).y(0).width(handlerWidth).height(handlerHeight).fill(handlerColor).opacity(opacity);
    }
  }, {
    key: 'inArea',
    value: function inArea(renderingContext, datum, x1, y1, x2, y2) {
      var d = datum || this.datum;

      // handlers only are selectable
      var x = renderingContext.timeToPixel(this.x(d));
      var handlerWidth = this.params.handlerWidth || this.handlerWidth(d);
      var handlerHeight = this.params.handlerHeight || this.handlerHeight(d);
      var shapeX1 = x - (handlerWidth - 1) / 2;
      var shapeX2 = shapeX1 + handlerWidth;
      var shapeY1 = renderingContext.height - handlerHeight;
      var shapeY2 = renderingContext.height;

      var xOverlap = Math.max(0, Math.min(x2, shapeX2) - Math.max(x1, shapeX1));
      var yOverlap = Math.max(0, Math.min(y2, shapeY2) - Math.max(y1, shapeY1));
      var area = xOverlap * yOverlap;

      return area > 0;
    }
  }]);

  return Marker;
})(_baseShape2['default']);

exports['default'] = Marker;
module.exports = exports['default'];

},{"./base-shape":48,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92,"konva":180}],53:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _baseShape = require('./base-shape');

var _baseShape2 = _interopRequireDefault(_baseShape);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var Segment = (function (_BaseShape) {
	_inherits(Segment, _BaseShape);

	function Segment() {
		_classCallCheck(this, Segment);

		_get(Object.getPrototypeOf(Segment.prototype), 'constructor', this).apply(this, arguments);
	}

	_createClass(Segment, [{
		key: 'destroy',
		value: function destroy() {
			this.$segment.destroy();
			this.$segment = null;
			this.$leftHandler.destroy();
			this.$leftHandler = null;
			this.$rightHandler.destroy();
			this.$rightHandler = null;
			this.$topHandler.destroy();
			this.$topHandler = null;
			this.$bottomHandler.destroy();
			this.$bottomHandler = null;
			_get(Object.getPrototypeOf(Segment.prototype), 'destroy', this).call(this);
		}
	}, {
		key: 'getClassName',
		value: function getClassName() {
			return 'segment';
		}
	}, {
		key: '_getAccessorList',
		value: function _getAccessorList() {
			return {
				x: 0,
				y: 0,
				width: 1,
				height: 1,

				displayHandlers: true,
				handlerWidth: 2,
				handlerOpacity: 0.8,
				opacity: 0.6,
				handlerColor: '#000000',
				color: '#000000'
			};
		}
	}, {
		key: '_getDefaults',
		value: function _getDefaults() {
			return {
				displayHandlers: undefined,
				handlerWidth: undefined,
				handlerOpacity: undefined,
				opacity: undefined,
				handlerColor: undefined,
				color: undefined
			};
		}
	}, {
		key: 'render',
		value: function render(renderingContext) {
			if (this.$el) {
				return this.$el;
			}

			this.$el = [];

			this.$segment = new _konva2['default'].Rect({});
			this.$segment.name('segment');
			this.$segment.shape = this;

			this.$el.push(this.$segment);

			this.$leftHandler = new _konva2['default'].Rect({});
			this.$leftHandler.addName('left');
			this.$leftHandler.addName('handler');
			this.$leftHandler.shape = this;

			this.$rightHandler = new _konva2['default'].Rect({});
			this.$rightHandler.addName('right');
			this.$rightHandler.addName('handler');
			this.$rightHandler.shape = this;

			this.$topHandler = new _konva2['default'].Rect({});
			this.$topHandler.addName('top');
			this.$topHandler.addName('handler');
			this.$topHandler.shape = this;

			this.$bottomHandler = new _konva2['default'].Rect({});
			this.$bottomHandler.addName('bottom');
			this.$bottomHandler.addName('handler');
			this.$bottomHandler.shape = this;

			this.$segment.perfectDrawEnabled(false);
			this.$leftHandler.perfectDrawEnabled(false);
			this.$rightHandler.perfectDrawEnabled(false);
			this.$topHandler.perfectDrawEnabled(false);
			this.$bottomHandler.perfectDrawEnabled(false);

			this.$el.push(this.$leftHandler);
			this.$el.push(this.$rightHandler);
			this.$el.push(this.$topHandler);
			this.$el.push(this.$bottomHandler);

			return this.$el;
		}
	}, {
		key: 'update',
		value: function update(renderingContext, datum) {
			var d = datum || this.datum;

			this.$segment.visible(this.visible);
			this.$leftHandler.visible(this.visible && this.params.displayHandlers);
			this.$rightHandler.visible(this.visible && this.params.displayHandlers);
			this.$topHandler.visible(this.visible && this.params.topHandler);
			this.$bottomHandler.visible(this.visible && this.params.bottomHandler);

			if (!this.visible) return;

			var width = renderingContext.timeToPixel(this.width(d));
			var height = Math.abs(renderingContext.valueToPixel(this.y(d) + this.height(d)) - renderingContext.valueToPixel(this.y(d)));
			var x = renderingContext.timeToPixel(this.x(d));
			var y = renderingContext.valueToPixel(this.y(d) + this.height(d));
			var color = this.params.color || this.color(d);
			var handlerColor = this.params.handlerColor || this.handlerColor(d);
			var opacity = this.params.opacity || this.opacity(d);
			var handlerOpacity = this.params.handlerOpacity || this.handlerOpacity(d);
			var handlerWidth = this.params.handlerWidth || this.handlerWidth(d);

			this.$segment.x(x).y(y).width(Math.max(width, 0)).height(height).fill(color).opacity(opacity);

			this.$leftHandler.x(x).y(y).width(handlerWidth).height(height).fill(handlerColor).opacity(handlerOpacity);

			this.$rightHandler.x(x + width - handlerWidth).y(y).height(height).width(handlerWidth).fill(handlerColor).opacity(handlerOpacity);

			this.$topHandler.x(x).y(y).height(handlerWidth).width(width).fill(handlerColor).opacity(handlerOpacity);

			this.$bottomHandler.x(x).y(y + height - handlerWidth).height(handlerWidth).width(width).fill(handlerColor).opacity(handlerOpacity);
		}
	}, {
		key: 'inArea',
		value: function inArea(renderingContext, datum, x1, y1, x2, y2) {
			var d = datum || this.datum;

			var shapeX1 = this.$segment.getAbsolutePosition().x;
			var shapeY1 = this.$segment.getAbsolutePosition().y;
			var shapeX2 = shapeX1 + this.$segment.width();
			var shapeY2 = shapeY1 + this.$segment.height();

			/*
    *	The segment is entirely within the provided area.
    */
			// if (x1 <= shapeX1 && x2 >= shapeX2 && y1 <= shapeY1 && y2 >= shapeY2)
			// 	return true;
			// else
			// 	return false;

			/*
    *	The segment overlaps the provided area.
    */
			var xOverlap = Math.max(0, Math.min(x2, shapeX2) - Math.max(x1, shapeX1));
			var yOverlap = Math.max(0, Math.min(y2, shapeY2) - Math.max(y1, shapeY1));
			var area = xOverlap * yOverlap;

			return area > 0;
		}
	}]);

	return Segment;
})(_baseShape2['default']);

exports['default'] = Segment;
module.exports = exports['default'];

},{"./base-shape":48,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92,"konva":180}],54:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _baseShape = require('./base-shape');

var _baseShape2 = _interopRequireDefault(_baseShape);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

/**
 * Kind of Marker for entity oriented data. Useful to display a grid.
 */

var Ticks = (function (_BaseShape) {
	_inherits(Ticks, _BaseShape);

	function Ticks() {
		_classCallCheck(this, Ticks);

		_get(Object.getPrototypeOf(Ticks.prototype), 'constructor', this).apply(this, arguments);
	}

	_createClass(Ticks, [{
		key: '_getClassName',
		value: function _getClassName() {
			return 'tick';
		}
	}, {
		key: '_getAccessorList',
		value: function _getAccessorList() {
			return { time: 0, label: '', focused: false };
		}
	}, {
		key: '_getDefaults',
		value: function _getDefaults() {
			return {
				'default': {
					color: 'steelblue',
					opacity: 0.3,
					width: 1
				},
				focused: {
					color: 'black',
					opacity: 0.8,
					width: 2
				}
			};
		}
	}, {
		key: 'render',
		value: function render(renderingContext) {
			this.$el = new _Set();

			this.$ticks = new _konva2['default'].Shape({ listening: false });
			this.$ticks.addName('ticks');
			this.$ticks.perfectDrawEnabled(false);

			this.$el.add(this.$ticks);

			return this.$el;
		}
	}, {
		key: 'update',
		value: function update(renderingContext, data) {

			var that = this;
			/*
    * Maintain the same number of ticks and labels in the Shape memory as the number of datums.
    * Destroy the remaining konva nodes.
    */
			this.$ticks.sceneFunc(function (context) {
				context.beginPath();

				data.forEach(function (datum) {

					var x = renderingContext.timeToPixel(that.time(datum));
					var height = renderingContext.height;
					var isFocused = that.focused(datum);
					var label = that.label(datum);
					var width = isFocused ? that.params.focused.width : that.params['default'].width;
					var color = isFocused ? that.params.focused.color : that.params['default'].color;

					context.moveTo(x, 0);
					context.fillStyle = color;
					context.fillRect(x, 0, width, height);

					// TODO: text
					if (label !== undefined && label !== '') {
						context.globalAlpha = 0.9;
						context.font = '10px monospace';
						context.fillStyle = '#676767';
						context.fillText(label, x + 5, 10);
					}
				});

				context.closePath();

				context.fillStrokeShape(this);
			});
		}
	}]);

	return Ticks;
})(_baseShape2['default']);

exports['default'] = Ticks;
module.exports = exports['default'];

},{"./base-shape":48,"babel-runtime/core-js/set":85,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92,"konva":180}],55:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseShape = require('./base-shape');

var _baseShape2 = _interopRequireDefault(_baseShape);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var TraceDots = (function (_BaseShape) {
  _inherits(TraceDots, _BaseShape);

  function TraceDots() {
    _classCallCheck(this, TraceDots);

    _get(Object.getPrototypeOf(TraceDots.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(TraceDots, [{
    key: 'getClassName',
    value: function getClassName() {
      return 'trace-dots';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return { x: 0, mean: 0, range: 0 };
    }
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return {
        meanRadius: 3,
        rangeRadius: 3,
        meanColor: '#232323',
        rangeColor: 'steelblue'
      };
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      if (this.$el) {
        return this.$el;
      }
      // container
      this.$el = [];
      // draw mean dot
      this.$mean = new _konva2['default'].Circle({});
      this.$mean.shape = this;

      // range dots (0 => top, 1 => bottom)
      this.$max = new _konva2['default'].Circle({});
      this.$max.shape = this;

      this.$min = new _konva2['default'].Circle({});
      this.$min.shape = this;

      this.$el.push(this.$mean);
      this.$el.push(this.$max);
      this.$el.push(this.$min);

      return this.$el;
    }

    // @TODO use accessors
  }, {
    key: 'update',
    value: function update(renderingContext, datum) {
      var mean = this.mean(datum);
      var range = this.range(datum);
      var x = this.x(datum);
      var meanPos = renderingContext.valueToPixel(mean);
      var halfRange = range / 2;
      var max = renderingContext.valueToPixel(mean + halfRange);
      var min = renderingContext.valueToPixel(mean - halfRange);
      var xPos = renderingContext.timeToPixel(x);

      this.$mean.x(xPos).y(meanPos).radius(this.params.meanRadius).stroke(this.params.rangeColor).fill('transparent').addName('mean');

      this.$max.x(xPos).y(max).radius(this.params.meanRadius).stroke(this.params.rangeColor).fill('transparent').addName('max');

      this.$min.x(xPos).y(min).radius(this.params.meanRadius).stroke(this.params.rangeColor).fill('transparent').addName('min');
    }
  }, {
    key: 'inArea',
    value: function inArea(renderingContext, datum, x1, y1, x2, y2) {
      var x = renderingContext.timeToPixel(this.x(datum));
      var mean = renderingContext.valueToPixel(this.mean(datum));
      var range = renderingContext.valueToPixel(this.range(datum));
      var min = mean - range / 2;
      var max = mean + range / 2;

      if (x > x1 && x < x2 && (min > y1 || max < y2)) {
        return true;
      }

      return false;
    }
  }]);

  return TraceDots;
})(_baseShape2['default']);

exports['default'] = TraceDots;
module.exports = exports['default'];

},{"./base-shape":48,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92,"konva":180}],56:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseShape = require('./base-shape');

var _baseShape2 = _interopRequireDefault(_baseShape);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

/**
 * A shape to display paths in a trace visualization (mean / range). (entity shape)
 *
 */

var TracePath = (function (_BaseShape) {
  _inherits(TracePath, _BaseShape);

  function TracePath() {
    _classCallCheck(this, TracePath);

    _get(Object.getPrototypeOf(TracePath.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(TracePath, [{
    key: 'getClassName',
    value: function getClassName() {
      return 'trace-common';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return { x: 0, mean: 0, range: 0 };
    }
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return {
        rangeColor: 'steelblue',
        meanColor: '#232323',
        displayMean: true
      };
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      if (this.$el) {
        return this.$el;
      }

      this.$el = [];

      this.$range = new _konva2['default'].Path({});
      this.$range.shape = this;

      this.$mean = new _konva2['default'].Path({});
      this.$mean.shape = this;

      this.$el.push(this.$range);
      this.$el.push(this.$mean);

      return this.$el;
    }
  }, {
    key: 'update',
    value: function update(renderingContext, data) {
      var _this = this;

      // order data by x position
      data = data.slice(0);
      data.sort(function (a, b) {
        return _this.x(a) < _this.x(b) ? -1 : 1;
      });

      if (this.params.displayMean) {
        this.$mean.visible(true).data(this._buildMeanLine(renderingContext, data)).stroke(this.params.meanColor).fill('none');
      } else {
        this.$mean.visible(false);
      }

      this.$range.visible(true).data(this._buildRangeZone(renderingContext, data)).stroke('none').fill(this.params.rangeColor).opacity(0.4);

      data = null;
    }
  }, {
    key: '_buildMeanLine',
    value: function _buildMeanLine(renderingContext, data) {
      var _this2 = this;

      var instructions = data.map(function (datum, index) {
        var x = renderingContext.timeToPixel(_this2.x(datum));
        var y = renderingContext.valueToPixel(_this2.mean(datum));
        return x + ',' + y;
      });

      return 'M' + instructions.join('L');
    }
  }, {
    key: '_buildRangeZone',
    value: function _buildRangeZone(renderingContext, data) {
      var length = data.length;
      // const lastIndex = data
      var instructionsStart = '';
      var instructionsEnd = '';

      for (var i = 0; i < length; i++) {
        var datum = data[i];
        var mean = this.mean(datum);
        var halfRange = this.range(datum) / 2;

        var x = renderingContext.timeToPixel(this.x(datum));
        var y0 = renderingContext.valueToPixel(mean + halfRange);
        var y1 = renderingContext.valueToPixel(mean - halfRange);

        var start = x + ',' + y0;
        var end = x + ',' + y1;

        instructionsStart = instructionsStart === '' ? start : instructionsStart + 'L' + start;

        instructionsEnd = instructionsEnd === '' ? end : end + 'L' + instructionsEnd;
      }

      var instructions = 'M' + instructionsStart + 'L' + instructionsEnd + 'Z';
      return instructions;
    }
  }]);

  return TracePath;
})(_baseShape2['default']);

exports['default'] = TracePath;
module.exports = exports['default'];

},{"./base-shape":48,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92,"konva":180}],57:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _baseShape = require('./base-shape');

var _baseShape2 = _interopRequireDefault(_baseShape);

var _utilsScales = require('../utils/scales');

var _utilsScales2 = _interopRequireDefault(_utilsScales);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var Waveform = (function (_BaseShape) {
	_inherits(Waveform, _BaseShape);

	function Waveform() {
		_classCallCheck(this, Waveform);

		_get(Object.getPrototypeOf(Waveform.prototype), 'constructor', this).apply(this, arguments);
	}

	_createClass(Waveform, [{
		key: 'destroy',
		value: function destroy() {
			this.$label.destroy();
			this.$label = null;

			this.$header.destroy();
			this.$header = null;

			this.$body.destroy();
			this.$body = null;

			this.$leftHandler.destroy();
			this.$leftHandler = null;

			this.$rightHandler.destroy();
			this.$rightHandler = null;

			this.$waveform.destroy();
			this.$waveform = null;

			_get(Object.getPrototypeOf(Waveform.prototype), 'destroy', this).call(this);
		}
	}, {
		key: 'getClassName',
		value: function getClassName() {
			return 'waveform';
		}
	}, {
		key: '_getAccessorList',
		value: function _getAccessorList() {
			// return { y: 0 };
			// TODO: delete all but sampleRate.
			return {
				data: [],
				x: 0,
				width: 10000,
				bufferStart: 0,
				bufferEnd: 0,
				sampleRate: 44100,
				color: 'black',
				text: ""
			};
		}
	}, {
		key: '_getDefaults',
		value: function _getDefaults() {
			return {
				waveformQuality: 2000,
				squaringFactor: 1,
				displayHandlers: true,
				displayBody: true,
				displayLabel: true,
				displayHeader: true,
				headerHeightRatio: 0.1, // 10% of the body height
				waveform: {
					color: '#000000',
					opacity: 1
				},
				header: {
					color: 'green',
					opacity: 0.4
				},
				body: {
					color: 'yellow',
					opacity: 0.1
				},
				handler: {
					width: 2,
					opacity: 1,
					color: 'orange'
				}
			};
		}
	}, {
		key: 'render',
		value: function render(renderingContext) {
			if (this.$el) {
				return this.$el;
			}

			this.$el = [];

			this.$header = new _konva2['default'].Rect({});
			this.$header.addName('header');
			this.$header.shape = this;
			// this.$header.on('mouseover', function() { document.body.style.cursor = 'pointer'; });
			// this.$header.on('mouseout', function() { document.body.style.cursor = 'default'; });		

			this.$body = new _konva2['default'].Rect({});
			this.$body.addName('body');
			this.$body.shape = this;
			// this.$body.on('mouseover', function() { document.body.style.cursor = 'pointer'; });
			// this.$body.on('mouseout', function() { document.body.style.cursor = 'default'; });

			this.$leftHandler = new _konva2['default'].Rect({});
			this.$leftHandler.addName('handler');
			this.$leftHandler.addName('left');
			this.$leftHandler.shape = this;
			// this.$leftHandler.on('mouseover', function() { document.body.style.cursor = 'ew-resize'; });
			// this.$leftHandler.on('mouseout', function() { document.body.style.cursor = 'default'; });

			this.$rightHandler = new _konva2['default'].Rect({});
			this.$rightHandler.addName('handler');
			this.$rightHandler.addName('right');
			this.$rightHandler.shape = this;
			// this.$rightHandler.on('mouseover', function() { document.body.style.cursor = 'ew-resize'; });
			// this.$rightHandler.on('mouseout', function() { document.body.style.cursor = 'default'; });

			this.$label = new _konva2['default'].Text({ listening: false });
			this.$label.shape = this;

			this.$waveform = new _konva2['default'].Shape({ listening: false });
			this.$waveform.shape = this;

			this.$el.push(this.$body);
			this.$el.push(this.$waveform);
			this.$el.push(this.$header);
			this.$el.push(this.$label);
			this.$el.push(this.$leftHandler);
			this.$el.push(this.$rightHandler);

			return this.$el;
		}
	}, {
		key: 'update',
		value: function update(renderingContext, datum) {
			var d = datum || this.datum;

			this.$header.visible(this.visible && this.params.displayHeader);
			this.$label.visible(this.visible && this.params.displayLabel);
			this.$body.visible(this.visible && this.params.displayBody);
			this.$leftHandler.visible(this.visible && this.params.displayHandlers);
			this.$rightHandler.visible(this.visible && this.params.displayHandlers);
			this.$waveform.visible(this.visible);

			if (!this.visible) return;

			var x = renderingContext.timeToPixel(this.x(d));
			var width = renderingContext.timeToPixel(this.width(d));
			var height = renderingContext.height;
			var color = this.params.waveform.color;

			this.$el.forEach(function (el) {
				return el.x(x).y(0);
			});

			this.$label.text(this.text(d)).x(x + 10).y(5);

			this.$header.width(Math.max(width, 0)).height(height * this.params.headerHeightRatio).fill(this.params.header.color).opacity(this.params.header.opacity);
			this.$body.width(Math.max(width, 0)).height(height).fill(this.params.body.color).opacity(this.params.body.opacity);

			this.$leftHandler.width(this.params.handler.width).height(height).fill(this.params.handler.color);

			this.$rightHandler.x(x + width - this.params.handler.width).width(this.params.handler.width).height(height).fill(this.params.handler.color);

			this.$waveform.fill(this.params.waveform.color).opacity(this.params.waveform.opacity).y(0);

			this.$waveform.perfectDrawEnabled(true);

			this.$waveform.x(x);

			// WAVEFORM PART

			// define nbr of samples per pixels
			var sliceMethod = this.data(d) instanceof Float32Array ? 'subarray' : 'slice';
			var nbrSamples = this.bufferEnd(d) - this.bufferStart(d);
			// const duration = nbrSamples / this.sampleRate(d);
			var samplesPerPixel = nbrSamples / width;

			if (!samplesPerPixel || this.data(d).length < samplesPerPixel) {
				return;
			}

			// compute/draw visible area only
			// @TODO refactor this ununderstandable mess
			// let minX = Math.max(-renderingContext.offsetX, renderingContext.timeToPixel(this.x(d)));
			// let maxX = Math.min(-renderingContext.offsetX + renderingContext.width, renderingContext.timeToPixel(this.x(d) + this.width(d)));
			var minX = 0;
			var maxX = renderingContext.timeToPixel(this.width(d));

			// get min/max per pixels, clamped to the visible area
			var invert = renderingContext.timeToPixel.invert;
			var sampleRate = this.sampleRate(d);
			var MID = 0;
			var that = this;
			var min, max, y1, y2, sample, px, i, bufferStart, bufferEnd, coef;

			bufferStart = this.bufferStart(d);
			bufferEnd = this.bufferEnd(d);
			var bufferIntervalDuration = bufferEnd - bufferStart;

			if (x < -renderingContext.offsetX) {
				// recalculate bufferStart
				coef = (-renderingContext.offsetX - x) / (x + width);
				bufferStart += coef * bufferIntervalDuration;
			}
			if (x + width > -renderingContext.offsetX + renderingContext.width) {
				// recalculate bufferEnd
				coef = (x + -renderingContext.offsetX + renderingContext.width) / (x + width);
				bufferEnd = bufferStart + coef * bufferIntervalDuration;
			}

			minX = -renderingContext.offsetX;
			maxX = minX + renderingContext.visibleWidth;

			this.$waveform.sceneFunc(function (context) {

				context.beginPath();

				context.moveTo(minX, height / 2);

				for (i = bufferStart, px = minX; i < bufferEnd && px < maxX; i += samplesPerPixel, px++) {
					var extract = that.data(d)[sliceMethod](i, Math.round(i + samplesPerPixel));

					min = Infinity;
					max = -Infinity;

					for (var j = 0, l = extract.length; j < l; j++) {
						sample = extract[j];
						if (sample < min) {
							min = sample;
						}
						if (sample > max) {
							max = sample;
						}
					}
					// disallow Infinity
					min = !isFinite(min) ? 0 : min;
					max = !isFinite(max) ? 0 : max;
					if (min === 0 && max === 0) {
						continue;
					}

					y1 = Math.round(renderingContext.valueToPixel(min));
					y2 = Math.round(renderingContext.valueToPixel(max));

					context.lineTo(px, y1 - MID);
					context.lineTo(px, y2 - MID);
				}

				context.lineTo(maxX, height / 2);

				context.closePath();

				context.fillStrokeShape(this);
			});

			// this.$waveform.cache({
			// 	x: 0,
			// 	y: 0,
			// 	width: width,
			// 	height: height,
			// 	offset: 2
			// });
		}
	}, {
		key: 'inArea',
		value: function inArea(renderingContext, datum, x1, y1, x2, y2) {
			var shapeX1 = renderingContext.timeToPixel(this.x(datum));
			var shapeX2 = renderingContext.timeToPixel(this.x(datum) + this.width(datum));
			var shapeY1 = renderingContext.valueToPixel(0);
			var shapeY2 = renderingContext.valueToPixel(renderingContext.height);

			// http://jsfiddle.net/uthyZ/ - check overlaping area
			var xOverlap = Math.max(0, Math.min(x2, shapeX2) - Math.max(x1, shapeX1));
			var yOverlap = Math.max(0, Math.min(y2, shapeY2) - Math.max(y1, shapeY1));
			var area = xOverlap * yOverlap;

			return area > 0;
		}
	}, {
		key: 'linear_interpolation',
		value: function linear_interpolation(arr, pos) {
			var first = Math.floor(pos);
			var frac = pos - first;
			var second = first + 1 < arr.length ? first + 1 : 0;

			return arr[first] * (1 - frac) + arr[second] * frac;
		}
	}]);

	return Waveform;
})(_baseShape2['default']);

exports['default'] = Waveform;
module.exports = exports['default'];

},{"../utils/scales":74,"./base-shape":48,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92,"konva":180}],58:[function(require,module,exports){
'use strict';

/**
 * `State` instances are used to define the application logic by precising
 * specific user interaction cases, and how they impact the overal temporal
 * representation. The abstractions extending this base class should be
 * considered as the main interface between the visualization and the
 * application logic. All provided states should be seen as simple examples for
 * rapid prototyping,
 *
 * States manage interactions like zooming, browsing, or editing the timeline.
 * Customized states should extend this BaseState.
 */

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var BaseState = (function () {
  /**
   * Returns timeline tracks collection.
   *
   * @type {TrackCollection}
   */

  function BaseState(timeline) {
    _classCallCheck(this, BaseState);

    /**
     * A reference to the timeline on which the state should be installed.
     * @type {Timeline}
     */
    this.timeline = timeline;
  }

  /**
   * Returns timeline tracks collection.
   *
   * @type {TrackCollection<Track>}
   */

  _createClass(BaseState, [{
    key: 'enter',

    /**
     * Called when the timeline is entering the state.
     */
    value: function enter() {}

    /**
     * Called when the timeline is leaving the state.
     */
  }, {
    key: 'exit',
    value: function exit() {}

    /**
     * Main interface method to override when creating a new `State`. Handle event
     * from mouse or keyboard, should define behavior according to the event
     * (aka. mousedown, mouseup, ...).
     *
     * @param {WaveEvent} e - the event to process.
     * @param {Array} hitLayers - the layers hit by the mouse event (if surface
     * event).
     */
  }, {
    key: 'handleEvent',
    value: function handleEvent(e, hitLayers) {}
  }, {
    key: 'tracks',
    get: function get() {
      return this.timeline.tracks;
    }

    /**
     * Returns all registered layers.
     *
     * @type {Array<Layer>}
     */
  }, {
    key: 'layers',
    get: function get() {
      return this.timeline.tracks.layers;
    }
  }]);

  return BaseState;
})();

exports['default'] = BaseState;
module.exports = exports['default'];

},{"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89}],59:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

var BreakpointState = (function (_BaseState) {
  _inherits(BreakpointState, _BaseState);

  function BreakpointState(timeline, datumGenerator) {
    _classCallCheck(this, BreakpointState);

    _get(Object.getPrototypeOf(BreakpointState.prototype), 'constructor', this).call(this, timeline);

    this.datumGenerator = datumGenerator;
    this.currentEditedLayer = null;
    this.currentTarget = null;
  }

  _createClass(BreakpointState, [{
    key: 'enter',
    value: function enter() {}
  }, {
    key: 'exit',
    value: function exit() {}
  }, {
    key: 'handleEvent',
    value: function handleEvent(e, hitLayers) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e, hitLayers);
          break;
        case 'mousemove':
          this.onMouseMove(e, hitLayers);
          break;
        case 'mouseup':
          this.onMouseUp(e, hitLayers);
          break;
      }
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e, hitLayers) {
      var _this = this;

      this.mouseDown = true;
      // keep target consistent with mouse down
      this.currentTarget = e.target;
      var updatedLayer = null;

      var layers = hitLayers;

      layers.forEach(function (layer) {
        layer.unselect();
        var item = e.target;

        if (item === null || item === undefined || layer.getDatumFromShape(item.shape) === undefined) {
          // create an item
          var time = layer.timeToPixel.invert(e.x) - _this.timeline.offset;
          var value = layer.valueToPixel.invert(e.y);
          var datum = _this.datumGenerator(time, value);

          if (datum) {
            layer.add(datum);
            updatedLayer = layer;
          }
        } else {
          // if shift is pressed, remove the item
          if (e.originalEvent.shiftKey) {
            var datum = layer.getDatumFromShape(item.shape);
            layer.remove(datum);
            updatedLayer = layer;
          } else {
            _this.currentEditedLayer = layer;
            var datum = layer.getDatumFromShape(item.shape);
            layer.select([datum]);
          }
        }

        layer.selectedDatums.forEach(function (datum) {
          layer.getShapeFromDatum(datum).stopDrag();
        });
      });

      if (updatedLayer) {
        this.timeline.tracks.update(updatedLayer);
      }
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e, hitLayers) {
      if (!this.mouseDown || !this.currentEditedLayer) {
        return;
      }

      var layer = this.currentEditedLayer;
      var datums = layer.selectedDatums;
      // the loop should be in layer to match select / unselect API
      layer.edit(datums, e.dx, e.dy, this.currentTarget);

      layer.updateShapes(datums);
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e, hitLayers) {
      var that = this;
      hitLayers.forEach(function (layer) {
        layer.selectedDatums.forEach(function (datum) {
          layer.getShapeFromDatum(datum).stopDrag();
        });
      });
      this.currentEditedLayer = null;
      this.mouseDown = false;
    }
  }]);

  return BreakpointState;
})(_baseState2['default']);

exports['default'] = BreakpointState;
module.exports = exports['default'];

},{"./base-state":58,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],60:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var BrushZoomState = (function (_BaseState) {
	_inherits(BrushZoomState, _BaseState);

	function BrushZoomState(timeline) {
		_classCallCheck(this, BrushZoomState);

		_get(Object.getPrototypeOf(BrushZoomState.prototype), 'constructor', this).call(this, timeline);
	}

	_createClass(BrushZoomState, [{
		key: 'handleEvent',
		value: function handleEvent(e) {
			switch (e.type) {
				case 'mousedown':
					this.onMouseDown(e);
					break;
				case 'mousemove':
					this.onMouseMove(e);
					break;
				case 'mouseup':
					this.onMouseUp(e);
					break;
				case 'keydown':
					this.onKeyDown(e);
					break;
			}
		}
	}, {
		key: 'onMouseDown',
		value: function onMouseDown(e) {
			var _this = this;

			this.brushes = [];
			this.startX = e.x;
			// create brush in each containers
			this.tracks.forEach(function (track) {
				var interactions = track.$interactionsLayer;

				var brush = new _konva2['default'].Rect({});
				brush.height(track.height).y(0).fill('#787878').opacity(0.2);
				brush.track = track;

				interactions.add(brush);

				_this.brushes.push(brush);

				interactions.batchDraw();
				// interactions.moveToTop();
			});
		}
	}, {
		key: 'onMouseMove',
		value: function onMouseMove(e) {
			// update brush
			var width = Math.abs(e.x - this.startX);
			var x = Math.min(e.x, this.startX);

			this.brushes.forEach(function (brush) {
				brush.x(x).width(width);
				brush.track.$interactionsLayer.batchDraw();
			});
		}
	}, {
		key: 'onMouseUp',
		value: function onMouseUp(e) {
			// remove brush
			this.brushes.forEach(function (brush) {
				brush.destroy();
				brush.track.$interactionsLayer.batchDraw();
				brush.track = null;
			});
			this.brushes.length = 0;

			// update timeContext
			var startX = this.startX;
			var endX = e.x;
			// return if no drag
			if (Math.abs(startX - endX) < 1) {
				return;
			}

			var leftX = Math.max(0, Math.min(startX, endX));
			var rightX = Math.max(startX, endX);

			var minTime = this.timeline.timeToPixel.invert(leftX);
			var maxTime = this.timeline.timeToPixel.invert(rightX);

			var deltaDuration = maxTime - minTime;
			var zoom = this.timeline.visibleDuration / deltaDuration;

			this.timeline.offset -= minTime;
			this.timeline.zoom *= zoom;

			this.tracks.update();
		}
	}, {
		key: 'onKeyDown',
		value: function onKeyDown(e) {
			// reset on space bar
			if (e.originalEvent.keyCode === 32) {
				this.timeline.offset = 0;
				this.timeline.zoom = 1;
				this.tracks.update();
			}
		}
	}]);

	return BrushZoomState;
})(_baseState2['default']);

exports['default'] = BrushZoomState;
module.exports = exports['default'];

},{"./base-state":58,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92,"konva":180}],61:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

var CenteredScrollState = (function (_BaseState) {
  _inherits(CenteredScrollState, _BaseState);

  function CenteredScrollState(timeline) {
    _classCallCheck(this, CenteredScrollState);

    _get(Object.getPrototypeOf(CenteredScrollState.prototype), 'constructor', this).call(this, timeline);
    this.currentLayer = null;
    // Set max/min zoom
    // maxZoom: 1px per sample
    // minZoom: 10 000 px per 1 hour
    // with a default to 44.1kHz sample rate
    this.maxZoom = 44100 * 1 / this.timeline.timeContext.pixelsPerSecond;
    this.minZoom = 10000 / 3600 / this.timeline.timeContext.pixelsPerSecond;
  }

  _createClass(CenteredScrollState, [{
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
      }
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {}
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      // prevent annoying text selection when dragging
      e.originalEvent.preventDefault();

      var timeContext = this.timeline.timeContext;
      var lastCenterTime = timeContext.timeToPixel.invert(e.x);

      var newCenterTime = timeContext.timeToPixel.invert(e.x);
      var delta = newCenterTime - lastCenterTime;

      // Apply new offset to keep it centered to the mouse
      timeContext.offset += delta + timeContext.timeToPixel.invert(e.dx);

      // Other possible experiments with centered-zoom-state
      //
      // Example 1: Prevent timeline.offset to be negative
      timeContext.offset = Math.min(timeContext.offset, 0);

      this.timeline.tracks.update();
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {}
  }]);

  return CenteredScrollState;
})(_baseState2['default']);

exports['default'] = CenteredScrollState;
module.exports = exports['default'];

},{"./base-state":58,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],62:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

var _utilsScales = require('../utils/scales');

var _utilsScales2 = _interopRequireDefault(_utilsScales);

var CenteredZoomState = (function (_BaseState) {
  _inherits(CenteredZoomState, _BaseState);

  function CenteredZoomState(timeline) {
    _classCallCheck(this, CenteredZoomState);

    _get(Object.getPrototypeOf(CenteredZoomState.prototype), 'constructor', this).call(this, timeline);
    this.currentLayer = null;
    // Set max/min zoom
    // maxZoom: 1px per sample
    // minZoom: 10 000 px per 1 hour
    // with a default to 44.1kHz sample rate
    this.maxZoom = 44100 * 1 / this.timeline.timeContext.pixelsPerSecond;
    this.minZoom = 10000 / 3600 / this.timeline.timeContext.pixelsPerSecond;
  }

  _createClass(CenteredZoomState, [{
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
      }
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      this.initialZoom = this.timeline.timeContext.zoom;
      this.initialY = e.y;

      this._pixelToExponent = _utilsScales2['default'].linear().domain([0, 100]) // 100px => factor 2
      .range([0, 1]);
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      // prevent annoying text selection when dragging
      e.originalEvent.preventDefault();

      var timeContext = this.timeline.timeContext;
      var lastCenterTime = timeContext.timeToPixel.invert(e.x);
      var exponent = this._pixelToExponent(e.y - this.initialY);
      var targetZoom = this.initialZoom * Math.pow(2, exponent); // -1...1 -> 1/2...2

      timeContext.zoom = Math.min(Math.max(targetZoom, this.minZoom), this.maxZoom);

      var newCenterTime = timeContext.timeToPixel.invert(e.x);
      var delta = newCenterTime - lastCenterTime;

      // Apply new offset to keep it centered to the mouse
      timeContext.offset += delta + timeContext.timeToPixel.invert(e.dx);

      // Other possible experiments with centered-zoom-state
      //
      // Example 1: Prevent timeline.offset to be negative
      // timeContext.offset = Math.min(timeContext.offset, 0);
      //
      // Example 2: Keep in container when zoomed out
      if (timeContext.stretchRatio < 1) {
        var minOffset = timeContext.timeToPixel.invert(0);
        var maxOffset = timeContext.timeToPixel.invert(view.width - timeContext.timeToPixel(timeContext.duration));
        timeContext.offset = Math.max(timeContext.offset, minOffset);
        timeContext.offset = Math.min(timeContext.offset, maxOffset);
      }

      this.timeline.tracks.update();
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {}
  }]);

  return CenteredZoomState;
})(_baseState2['default']);

exports['default'] = CenteredZoomState;
module.exports = exports['default'];

},{"../utils/scales":74,"./base-state":58,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],63:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

var ContextEditionState = (function (_BaseState) {
  _inherits(ContextEditionState, _BaseState);

  function ContextEditionState(timeline) {
    _classCallCheck(this, ContextEditionState);

    _get(Object.getPrototypeOf(ContextEditionState.prototype), 'constructor', this).call(this, timeline);
  }

  _createClass(ContextEditionState, [{
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
      }
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      this.mouseDown = true;
      this.currentTarget = e.target;
      this.currentLayer = this.currentTarget.shape ? this.currentTarget.shape.layer : undefined;
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      if (!this.mouseDown || !this.currentLayer) {
        return;
      }

      var layer = this.currentLayer;
      var target = this.currentTarget;

      // in this example the context is stretched when shift is pressed
      if (!e.originalEvent.shiftKey) {
        layer.editContext(e.dx, e.dy, target);
      } else {
        layer.stretchContext(e.dx, e.dy, target);
      }

      layer.update();
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {
      this.mouseDown = false;
      this.currentTarget = null;
      this.currentLayer = null;
    }
  }]);

  return ContextEditionState;
})(_baseState2['default']);

exports['default'] = ContextEditionState;
module.exports = exports['default'];

},{"./base-state":58,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],64:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Map = require('babel-runtime/core-js/map')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

var _helpersBrushController = require('../helpers/brush-controller');

var _helpersBrushController2 = _interopRequireDefault(_helpersBrushController);

var DragAndDropState = (function (_BaseState) {
	_inherits(DragAndDropState, _BaseState);

	function DragAndDropState(timeline) {
		_classCallCheck(this, DragAndDropState);

		_get(Object.getPrototypeOf(DragAndDropState.prototype), 'constructor', this).call(this, timeline);
		this.targetLayer = new _Map();
		this.brushController = null;
	}

	_createClass(DragAndDropState, [{
		key: 'setTargetLayerForTrack',
		value: function setTargetLayerForTrack(track, layer) {
			this.targetLayer.set(track, layer);
			this.brushController = null;
		}
	}, {
		key: 'exit',
		value: function exit() {
			this.targetLayer.clear();
		}
	}, {
		key: 'handleEvent',
		value: function handleEvent(e) {
			switch (e.type) {
				case 'dragstart':
					this.onDragStart(e);
					break;
				case 'dragend':
					this.onDragEnd(e);
					break;
				case 'dragover':
					this.onDragOver(e);
					break;
				case 'drop':
					this.onDrop(e);
					break;
				case 'dragleave':
					this.onDragLeave(e);
					break;
				case 'dragenter':
					this.onDragEnter(e);
					break;
			}
		}
	}, {
		key: 'onDragStart',
		value: function onDragStart(e) {
			// N/A
			console.log('DragAndDropState - dragStart');
		}
	}, {
		key: 'onDragEnd',
		value: function onDragEnd(e) {
			// TODO ?
			console.log('DragAndDropState - dragEnd');
		}
	}, {
		key: 'onDragEnter',
		value: function onDragEnter(e) {
			console.log('DragAndDropState - dragEnter');
			if (!this.brushController) {
				this.currentTrack = this.timeline.getTrackFromDOMElement(e.target);
				this.brushController = new _helpersBrushController2['default'](this.currentTrack);
			}
		}
	}, {
		key: 'onDragOver',
		value: function onDragOver(e) {
			this.brushController.addBrush();

			var timeToPixel = this.timeline.timeContext.timeToPixel;
			var time = -this.timeline.timeContext.offset + timeToPixel.invert(e.x);
			var data = e.originalEvent.dataTransfer.getData("text");
			var duration = this.onDataAvailable(time, data, 'drag');

			var x = timeToPixel(time);
			var width = timeToPixel(duration);

			this.brushController.brushArea = { x: x, width: width };

			console.log('DragAndDropState - dragOver');
		}
	}, {
		key: 'onDragLeave',
		value: function onDragLeave(e) {
			this.brushController.removeBrush();

			console.log('DragAndDropState - dragLeave');
		}
	}, {
		key: 'onDrop',
		value: function onDrop(e) {
			var timeToPixel = this.timeline.timeContext.timeToPixel;

			var time = -this.timeline.timeContext.offset + timeToPixel.invert(e.x);
			var data = e.originalEvent.dataTransfer.getData("text");
			this.onDataAvailable(time, data, 'drop');

			e.originalEvent.dataTransfer.clearData();

			this.brushController.removeBrush();

			console.log('DragAndDropState - drop');
		}
	}]);

	return DragAndDropState;
})(_baseState2['default']);

exports['default'] = DragAndDropState;
module.exports = exports['default'];

},{"../helpers/brush-controller":30,"./base-state":58,"babel-runtime/core-js/map":77,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],65:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

var _helpersBrushController = require('../helpers/brush-controller');

var _helpersBrushController2 = _interopRequireDefault(_helpersBrushController);

var DragToCreateIntervalState = (function (_BaseState) {
	_inherits(DragToCreateIntervalState, _BaseState);

	function DragToCreateIntervalState(timeline) {
		_classCallCheck(this, DragToCreateIntervalState);

		_get(Object.getPrototypeOf(DragToCreateIntervalState.prototype), 'constructor', this).call(this, timeline);
		this.brushController = null;
		this.currentTrack = null;
	}

	_createClass(DragToCreateIntervalState, [{
		key: 'enter',
		value: function enter() {}
	}, {
		key: 'exit',
		value: function exit() {
			this.brushController = null;
			this.currentTrack = null;
		}
	}, {
		key: 'onIntervalAvailable',
		value: function onIntervalAvailable(interval, track) {
			throw new Error('The developer must assign a proper function');
		}
	}, {
		key: 'snapInterval',
		value: function snapInterval(interval, track) {
			throw new Error('The developer must assign a proper function');
		}
	}, {
		key: 'handleEvent',
		value: function handleEvent(e) {
			switch (e.type) {
				case 'mousedown':
					this.onMouseDown(e);
					break;
				case 'mousemove':
					this.onMouseMove(e);
					break;
				case 'mouseup':
					this.onMouseUp(e);
					break;
				case 'click':
					this.onClick(e);
					break;
			}
		}
	}, {
		key: 'onMouseDown',
		value: function onMouseDown(e) {
			this.currentTrack = this.timeline.getTrackFromDOMElement(e.target.parent.parent.content);
			this.brushController = new _helpersBrushController2['default'](this.currentTrack);
			this.brushController.addBrush();
		}
	}, {
		key: 'onMouseMove',
		value: function onMouseMove(e) {
			this.brushController.updateBrush(e);
		}
	}, {
		key: 'onMouseUp',
		value: function onMouseUp(e) {
			var area = this.brushController.brushArea;

			var interval = {
				time: -this.timeline.timeContext.offset + this.timeline.timeContext.timeToPixel.invert(area.x),
				duration: this.timeline.timeContext.timeToPixel.invert(area.width)
			};

			this.onIntervalAvailable(interval, this.currentTrack);

			this.brushController.removeBrush();
		}
	}, {
		key: 'onClick',
		value: function onClick(e) {
			var interval = { time: -this.timeline.timeContext.offset + this.timeline.timeContext.timeToPixel.invert(e.x) };

			this.onIntervalAvailable(interval, this.currentTrack);
		}
	}]);

	return DragToCreateIntervalState;
})(_baseState2['default']);

exports['default'] = DragToCreateIntervalState;
module.exports = exports['default'];

},{"../helpers/brush-controller":30,"./base-state":58,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],66:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Map = require('babel-runtime/core-js/map')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

var DropAndAddState = (function (_BaseState) {
	_inherits(DropAndAddState, _BaseState);

	function DropAndAddState(timeline) {
		_classCallCheck(this, DropAndAddState);

		_get(Object.getPrototypeOf(DropAndAddState.prototype), 'constructor', this).call(this, timeline);
		this.targetLayer = new _Map();
	}

	_createClass(DropAndAddState, [{
		key: 'setTargetLayerForTrack',
		value: function setTargetLayerForTrack(track, layer) {
			this.targetLayer.set(track, layer);
		}
	}, {
		key: 'exit',
		value: function exit() {
			this.targetLayer.clear();
			// TODO: remove track highlight ?
		}
	}, {
		key: 'handleEvent',
		value: function handleEvent(e) {
			switch (e.type) {
				case 'dragstart':
					this.onDragStart(e);
					break;
				case 'dragend':
					this.onDragEnd(e);
					break;
				case 'dragover':
					this.onDragOver(e);
					break;
				case 'drop':
					this.onDrop(e);
					break;
				case 'dragleave':
					this.onDragLeave(e);
					break;
			}
		}
	}, {
		key: 'onDragStart',
		value: function onDragStart(e) {
			// N/A
		}
	}, {
		key: 'onDragEnd',
		value: function onDragEnd(e) {
			// TODO ?
		}
	}, {
		key: 'onDragOver',
		value: function onDragOver(e) {
			// TODO: highlight track ?
		}
	}, {
		key: 'onDragLeave',
		value: function onDragLeave(e) {
			// TODO: remove track highlight ?
		}
	}, {
		key: 'onDrop',
		value: function onDrop(e) {
			var offset = -this.timeline.timeContext.offset;
			var time = this.timeline.timeContext.timeToPixel.invert(e.x);
			var currentTime = offset + time;

			var track = this.timeline.getTrackFromDOMElement(e.currentTarget);
			var layer = this.targetLayer.get(track);

			if (layer) {
				var datum = document.getElementById(e.originalEvent.dataTransfer.getData("Text")).getDatum();
				datum.x = currentTime;
				layer.add(datum);
				layer.getShapeFromDatum(datum).params.color = datum.color;
				layer.update();
			}

			e.originalEvent.dataTransfer.clearData();
		}
	}]);

	return DropAndAddState;
})(_baseState2['default']);

exports['default'] = DropAndAddState;
module.exports = exports['default'];

},{"./base-state":58,"babel-runtime/core-js/map":77,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],67:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

/**
 * A state to edit shapes in the more general way. Interact only with selected shapes.
 */

var EditionState = (function (_BaseState) {
  _inherits(EditionState, _BaseState);

  function EditionState(timeline) {
    _classCallCheck(this, EditionState);

    _get(Object.getPrototypeOf(EditionState.prototype), 'constructor', this).call(this, timeline);

    this.currentEditedLayer = null;
    this.currentTarget = null;
  }

  _createClass(EditionState, [{
    key: 'enter',
    value: function enter() {}
  }, {
    key: 'exit',
    value: function exit() {}
  }, {
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
      }
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      this.currentTarget = e.target;
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      var _this = this;

      this.layers.forEach(function (layer) {
        var datums = layer.selectedDatums;

        layer.edit(datums, e.dx, e.dy, _this.currentTarget);
        layer.update(datums);
      });
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {
      this.currentEditedLayer = null;
      this.mouseDown = false;
    }
  }]);

  return EditionState;
})(_baseState2['default']);

exports['default'] = EditionState;
module.exports = exports['default'];

},{"./base-state":58,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],68:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Map = require('babel-runtime/core-js/map')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var HorizontalSelectionState = (function (_BaseState) {
  _inherits(HorizontalSelectionState, _BaseState);

  function HorizontalSelectionState(timeline /*, options = {} */) {
    _classCallCheck(this, HorizontalSelectionState);

    _get(Object.getPrototypeOf(HorizontalSelectionState.prototype), 'constructor', this).call(this, timeline /*, options */);

    this._layerSelectedItemsMap = new _Map();

    this.shiftKey = false;

    this.wasMoving = false;
  }

  _createClass(HorizontalSelectionState, [{
    key: 'enter',
    value: function enter() {
      // TODO
    }
  }, {
    key: 'exit',
    value: function exit() {
      // TODO
      var containers = this.timeline.containers;

      for (var id in containers) {
        this._removeBrush(containers[id]);
      }
    }
  }, {
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
        case 'click':
          this.onClick(e);
          break;
        case 'keydown':
          this.onKey(e);
          break;
        case 'keyup':
          this.onKey(e);
          break;
      }
    }
  }, {
    key: '_addBrush',
    value: function _addBrush(track) {
      if (track.$brush) {
        return;
      }

      var brush = new _konva2['default'].Rect({});
      brush.fill('#686868').opacity(0.5);

      track.$interactionsLayer.add(brush);
      track.$interactionsLayer.moveToTop();

      track.$brush = brush;

      track.$interactionsLayer.batchDraw();
    }
  }, {
    key: '_removeBrush',
    value: function _removeBrush(track) {
      if (track.$brush === undefined) {
        return;
      }

      this._resetBrush(track);

      track.$brush.destroy();

      track.$interactionsLayer.batchDraw();

      delete track.$brush;
    }
  }, {
    key: '_resetBrush',
    value: function _resetBrush(track) {
      var $brush = track.$brush;
      // reset brush element
      $brush.x(0).y(0).width(0).height(0);
      track.$interactionsLayer.batchDraw();
    }
  }, {
    key: '_updateBrush',
    value: function _updateBrush(e, track) {
      var $brush = track.$brush;

      $brush.x(e.area.left).y(0).width(e.area.width).height(track.height);
      track.$interactionsLayer.batchDraw();
    }
  }, {
    key: 'onKey',
    value: function onKey(e) {
      this.shiftKey = e.shiftKey;
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      var _this = this;

      this._currentTrack = this.timeline.getTrackFromDOMElement(e.currentTarget);

      if (!this._currentTrack) {
        return;
      }

      this._addBrush(this._currentTrack);

      // recreate the map
      this._layerSelectedItemsMap = new _Map();

      this._currentTrack.layers.forEach(function (layer) {

        if (!e.originalEvent.shiftKey) {
          var aux = new _Set(layer.selectedDatums);
          layer.unselect(aux);
          layer.updateShapes(aux);
        }

        _this._layerSelectedItemsMap.set(layer, new _Set(layer.selectedDatums));
      });

      this.mousedown = true;
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      var _this2 = this;

      if (!this.mousedown) return;

      this.wasMoving = true;

      e.area = { left: e.area.left, width: e.area.width, top: 0, height: this._currentTrack.height };

      var iStart = -this.timeline.offset + this.timeline.timeToPixel.invert(e.area.left);
      var iDuration = -this.timeline.offset + this.timeline.timeToPixel.invert(e.area.left + e.area.width) - iStart;
      var interval = { start: iStart, duration: iDuration };
      // console.log(interval);

      this._updateBrush(e, this._currentTrack);

      var that = this;

      this._currentTrack.layers.forEach(function (layer) {
        var currentSelection = layer.selectedDatums;
        var datumsInInterval = layer.getDatumsInInterval(iStart, iDuration);

        var toSelect;
        var toUnselect;

        // if is not pressed
        if (!e.originalEvent.shiftKey) {

          toUnselect = new _Set(currentSelection);
          toSelect = new _Set(datumsInInterval);
        } else {
          (function () {

            toSelect = new _Set();
            toUnselect = new _Set();
            // use the selection from the previous drag
            var previousSelection = _this2._layerSelectedItemsMap.get(layer);

            datumsInInterval.forEach(function (datum) {
              if (!previousSelection.has(datum)) {
                toSelect.add(datum);
              } else {
                toUnselect.add(datum);
              }
            });

            currentSelection.forEach(function (datum) {
              if (!datumsInInterval.has(datum) && !previousSelection.has(datum)) {
                toUnselect.add(datum);
              }
            });

            previousSelection.forEach(function (datum) {
              if (!datumsInInterval.has(datum)) {
                toSelect.add(datum);
              }
            });
          })();
        }

        layer.unselect(toUnselect);
        layer.select(toSelect);

        layer.updateShapes(currentSelection);
        layer.updateShapes(datumsInInterval);
      });
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {
      this._removeBrush(this._currentTrack);
      this.mousedown = false;
      this.wasMoving = false;
    }
  }, {
    key: 'onClick',
    value: function onClick(e) {
      // console.log('click');
      if (!this._currentTrack) {
        return;
      }
      var that = this;

      this._currentTrack.layers.forEach(function (layer) {

        var shape = e.target.shape;
        var datum = layer.getDatumFromShape(shape);
        var toUpdate = new _Set();

        //TODO: correct this because it is not working as I expected to. 
        if (!e.originalEvent.shiftKey) {
          toUpdate = new _Set(layer.selectedDatums);
          layer.unselect(layer.selectedDatums);
        }

        if (datum) {
          toUpdate.add(datum);
          layer.toggleSelection([datum]);
        }

        layer.updateShapes(toUpdate);
      });
    }
  }]);

  return HorizontalSelectionState;
})(_baseState2['default']);

exports['default'] = HorizontalSelectionState;
module.exports = exports['default'];

},{"./base-state":58,"babel-runtime/core-js/map":77,"babel-runtime/core-js/set":85,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92,"konva":180}],69:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Map = require('babel-runtime/core-js/map')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var SelectionState = (function (_BaseState) {
  _inherits(SelectionState, _BaseState);

  function SelectionState(timeline /*, options = {} */) {
    _classCallCheck(this, SelectionState);

    _get(Object.getPrototypeOf(SelectionState.prototype), 'constructor', this).call(this, timeline /*, options */);

    this.currentLayer = undefined;
    // need a cached
    this.selectedDatums = undefined;
    this.mouseDown = false;
    this.shiftKey = false;

    this._layerSelectedItemsMap = new _Map();
  }

  _createClass(SelectionState, [{
    key: 'enter',
    value: function enter() {}
  }, {
    key: 'exit',
    value: function exit() {
      var containers = this.timeline.containers;

      for (var id in containers) {
        this._removeBrush(containers[id]);
      }
    }
  }, {
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
        case 'click':
          this.onClick(e);
          break;
        case 'keydown':
          this.onKey(e);
          break;
        case 'keyup':
          this.onKey(e);
          break;
      }
    }
  }, {
    key: '_addBrush',
    value: function _addBrush(track) {
      if (track.$brush) {
        return;
      }

      var brush = new _konva2['default'].Rect({});
      brush.fill('#686868').opacity(0.5);

      track.$interactionsLayer.add(brush);
      track.$interactionsLayer.moveToTop();

      track.$brush = brush;

      track.$interactionsLayer.batchDraw();
    }
  }, {
    key: '_removeBrush',
    value: function _removeBrush(track) {
      if (track.$brush === undefined) {
        return;
      }

      this._resetBrush(track);

      track.$brush.destroy();

      track.$interactionsLayer.batchDraw();

      delete track.$brush;
    }
  }, {
    key: '_resetBrush',
    value: function _resetBrush(track) {
      var $brush = track.$brush;
      // reset brush element
      $brush.x(0).y(0).width(0).height(0);
      track.$interactionsLayer.batchDraw();
    }
  }, {
    key: '_updateBrush',
    value: function _updateBrush(e, track) {
      var $brush = track.$brush;

      $brush.x(e.area.left).y(e.area.top).width(e.area.width).height(e.area.height);
      track.$interactionsLayer.batchDraw();
    }
  }, {
    key: 'onKey',
    value: function onKey(e) {
      this.shiftKey = e.shiftKey;
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      var _this = this;

      this._currentTrack = this.timeline.getTrackFromDOMElement(e.currentTarget);

      if (!this._currentTrack) {
        return;
      }

      this._addBrush(this._currentTrack);

      // recreate the map
      this._layerSelectedItemsMap = new _Map();
      this._currentTrack.layers.forEach(function (layer) {
        var aux = [];
        layer.selectedDatums.forEach(function (datum) {
          aux.push(datum);
        });
        _this._layerSelectedItemsMap.set(layer, aux.slice(0));
      });
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      var _this2 = this;

      console.log(e.area);

      this._updateBrush(e, this._currentTrack);

      this._currentTrack.layers.forEach(function (layer) {
        var currentSelection = layer.selectedDatums;
        var currentItems = layer.getDatumsInArea(e.area);

        // if is not pressed
        if (!e.originalEvent.shiftKey) {
          layer.unselect(currentSelection);
          layer.select(currentItems);
        } else {
          (function () {
            var toSelect = [];
            var toUnselect = [];
            // use the selection from the previous drag
            var previousSelection = _this2._layerSelectedItemsMap.get(layer);
            // toUnselect = toUnselect.concat(previousSelectedItems);

            currentItems.forEach(function (item) {
              if (previousSelection.indexOf(item) === -1) {
                toSelect.push(item);
              } else {
                toUnselect.push(item);
              }
            });

            currentSelection.forEach(function (item) {
              if (currentItems.indexOf(item) === -1 && previousSelection.indexOf(item) === -1) {
                toUnselect.push(item);
              }
            });

            layer.unselect(toUnselect);
            layer.select(toSelect);
          })();
        }
      });
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {
      this._removeBrush(this._currentTrack);
    }
  }, {
    key: 'onClick',
    value: function onClick(e) {
      if (!this._currentTrack) {
        return;
      }

      this._currentTrack.layers.forEach(function (layer) {
        var shape = e.target.shape;
        var datum = layer.getDatumFromShape(shape);

        if (!e.originalEvent.shiftKey) {
          layer.unselect();
        }

        if (datum) {
          layer.toggleSelection([datum]);
        }
      });
    }
  }]);

  return SelectionState;
})(_baseState2['default']);

exports['default'] = SelectionState;
module.exports = exports['default'];

},{"./base-state":58,"babel-runtime/core-js/map":77,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92,"konva":180}],70:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Map = require('babel-runtime/core-js/map')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var ShapeInsertionState = (function (_BaseState) {
  _inherits(ShapeInsertionState, _BaseState);

  function ShapeInsertionState(timeline /*, options = {} */) {
    _classCallCheck(this, ShapeInsertionState);

    _get(Object.getPrototypeOf(ShapeInsertionState.prototype), 'constructor', this).call(this, timeline /*, options */);

    this._layerSelectedItemsMap = new _Map();

    this.shiftKey = false;

    this.wasMoving = false;
  }

  _createClass(ShapeInsertionState, [{
    key: 'enter',
    value: function enter() {
      // TODO
    }
  }, {
    key: 'exit',
    value: function exit() {
      // TODO
      var containers = this.timeline.containers;

      for (var id in containers) {
        this._removeBrush(containers[id]);
      }
    }
  }, {
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
        case 'click':
          this.onClick(e);
          break;
        case 'keydown':
          this.onKey(e);
          break;
        case 'keyup':
          this.onKey(e);
          break;
      }
    }
  }, {
    key: '_addBrush',
    value: function _addBrush(track) {
      if (track.$brush) {
        return;
      }

      var brush = new _konva2['default'].Rect({});
      brush.fill('#686868').opacity(0.5);

      track.$interactionsLayer.add(brush);
      track.$interactionsLayer.moveToTop();

      track.$brush = brush;

      track.$interactionsLayer.batchDraw();
    }
  }, {
    key: '_removeBrush',
    value: function _removeBrush(track) {
      if (track.$brush === undefined) {
        return;
      }

      this._resetBrush(track);

      track.$brush.destroy();

      track.$interactionsLayer.batchDraw();

      delete track.$brush;
    }
  }, {
    key: '_resetBrush',
    value: function _resetBrush(track) {
      var $brush = track.$brush;
      // reset brush element
      $brush.x(0).y(0).width(0).height(0);
      track.$interactionsLayer.batchDraw();
    }
  }, {
    key: '_updateBrush',
    value: function _updateBrush(e, track) {
      var $brush = track.$brush;

      $brush.x(e.area.left).y(0).width(e.area.width).height(track.height);
      track.$interactionsLayer.batchDraw();
    }
  }, {
    key: 'onKey',
    value: function onKey(e) {
      this.shiftKey = e.shiftKey;
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      var _this = this;

      this._currentTrack = this.timeline.getTrackFromDOMElement(e.currentTarget);

      if (!this._currentTrack) {
        return;
      }

      this._addBrush(this._currentTrack);

      // recreate the map
      this._layerSelectedItemsMap = new _Map();

      this._currentTrack.layers.forEach(function (layer) {

        if (!e.originalEvent.shiftKey) {
          var aux = new _Set(layer.selectedDatums);
          layer.unselect(aux);
          layer.updateShapes(aux);
        }

        _this._layerSelectedItemsMap.set(layer, new _Set(layer.selectedDatums));
      });
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      var _this2 = this;

      this.wasMoving = true;

      e.area = { left: e.area.left, width: e.area.width, top: 0, height: this._currentTrack.height };

      this._updateBrush(e, this._currentTrack);

      var that = this;

      this._currentTrack.layers.forEach(function (layer) {
        var currentSelection = layer.selectedDatums;
        var datumsInArea = layer.getDatumsInArea(e.area);

        var toSelect;
        var toUnselect;

        // if is not pressed
        if (!e.originalEvent.shiftKey) {

          toUnselect = new _Set(currentSelection);
          toSelect = new _Set(datumsInArea);
        } else {
          (function () {

            toSelect = new _Set();
            toUnselect = new _Set();
            // use the selection from the previous drag
            var previousSelection = _this2._layerSelectedItemsMap.get(layer);

            datumsInArea.forEach(function (datum) {
              if (!previousSelection.has(datum)) {
                toSelect.add(datum);
              } else {
                toUnselect.add(datum);
              }
            });

            currentSelection.forEach(function (datum) {
              if (!datumsInArea.has(datum) && !previousSelection.has(datum)) {
                toUnselect.add(datum);
              }
            });

            previousSelection.forEach(function (datum) {
              if (!datumsInArea.has(datum)) {
                toSelect.add(datum);
              }
            });
          })();
        }

        layer.unselect(toUnselect);
        layer.select(toSelect);

        layer.updateShapes(currentSelection);
        layer.updateShapes(datumsInArea);
      });
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {
      this._removeBrush(this._currentTrack);
      if (this.wasMoving) {
        this.wasMoving = false;
      }
    }
  }, {
    key: 'onClick',
    value: function onClick(e) {
      // console.log('click');
      if (!this._currentTrack) {
        return;
      }
      var that = this;

      this._currentTrack.layers.forEach(function (layer) {

        var shape = e.target.shape;
        var datum = layer.getDatumFromShape(shape);
        var toUpdate = new _Set();

        //TODO: correct this because it is not working as I expected to. 
        if (!e.originalEvent.shiftKey) {
          toUpdate = new _Set(layer.selectedDatums);
          layer.unselect(layer.selectedDatums);
        }

        if (datum) {
          toUpdate.add(datum);
          layer.toggleSelection([datum]);
        }

        layer.updateShapes(toUpdate);
      });
    }
  }, {
    key: 'targetLayer',
    set: function set(layer) {
      this._layer = layer;
    },
    get: function get() {
      return this._layer;
    }
  }]);

  return ShapeInsertionState;
})(_baseState2['default']);

exports['default'] = ShapeInsertionState;
module.exports = exports['default'];

},{"./base-state":58,"babel-runtime/core-js/map":77,"babel-runtime/core-js/set":85,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92,"konva":180}],71:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

/**
 * A state to select and edit shapes in a simple way. (kind of plug n play state)
 */

var SimpleEditionState = (function (_BaseState) {
  _inherits(SimpleEditionState, _BaseState);

  function SimpleEditionState(timeline, autoUpdateShapes) {
    _classCallCheck(this, SimpleEditionState);

    _get(Object.getPrototypeOf(SimpleEditionState.prototype), 'constructor', this).call(this, timeline);

    this.autoUpdateShapes = autoUpdateShapes === undefined ? true : autoUpdateShapes;
    this.currentEditedLayer = null;
    this.currentTarget = null;
  }

  _createClass(SimpleEditionState, [{
    key: 'enter',
    value: function enter() {}
  }, {
    key: 'exit',
    value: function exit() {
      this.currentEditedLayer = null;
      this.currentTarget = null;
    }
  }, {
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
      }
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      // TODO: allow shapes from multiple layers to be edited at the same time.
      // TODO: move target shapes to the drag konva layer of each layer.

      // keep target consistent with mouse down
      this.currentTarget = e.target;
      var that = this;

      if (this.currentTarget.shape && this.currentTarget.shape.isContextShape) {
        if (!e.originalEvent.shiftKey) this.timeline.getTrackFromDOMElement(e.currentTarget).layers.forEach(function (layer) {
          var aux = new _Set(layer.selectedDatums);
          layer.unselect(layer.selectedDatums);
          if (that.autoUpdateShapes) layer.updateShapes(aux);
        });
        return;
      } else if (!this.currentTarget.shape) {
        if (!e.originalEvent.shiftKey) this.timeline.getTrackFromDOMElement(e.currentTarget).layers.forEach(function (layer) {
          var aux = new _Set(layer.selectedDatums);
          layer.unselect(layer.selectedDatums);
          if (that.autoUpdateShapes) layer.updateShapes(aux);
        });
        return;
      }

      var layer = this.currentTarget.shape.layer;

      var a = new _Set(layer.selectedDatums);

      if (this.currentTarget.shape.layer) {
        if (!e.originalEvent.shiftKey) {
          this.timeline.getTrackFromDOMElement(e.currentTarget).layers.forEach(function (layer) {
            return layer.unselect(layer.selectedDatums);
          });
        }
        this.currentEditedLayer = layer;
        var datum = layer.getDatumFromShape(this.currentTarget.shape);
        if (datum !== undefined) {
          layer.select([datum]);
          a.add(datum);
        }
        if (that.autoUpdateShapes) layer.updateShapes(a);
        this.currentEditedLayer.selectedDatums.forEach(function (datum) {
          that.currentEditedLayer.getShapeFromDatum(datum).startDrag();
        });
      } else if (!e.originalEvent.shiftKey) {
        layer.unselect(layer.selectedDatums);
        if (that.autoUpdateShapes) layer.updateShapes(a);
        this.currentEditedLayer.selectedDatums.forEach(function (datum) {
          that.currentEditedLayer.getShapeFromDatum(datum).startDrag();
        });
      }
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      // TODO: allow shapes from multiple layers to be edited at the same time.
      // TODO: move target shapes to the drag konva layer of each layer.

      if (!this.currentEditedLayer) {
        return;
      }

      var layer = this.currentEditedLayer;
      var datums = layer.selectedDatums;
      var that = this;

      layer.edit(datums, e.dx, e.dy, this.currentTarget);
      if (that.autoUpdateShapes) layer.updateShapes(datums);
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {
      // TODO: allow shapes from multiple layers to be edited at the same time.
      // TODO: use Layer.allocateShapesToContentLayers to move the target shapes from the drag konva layers to a content konva layer.

      var that = this;
      var layer = this.currentEditedLayer;

      if (!layer) return;

      if (that.autoUpdateShapes) layer.updateShapes(layer.selectedDatums);
      layer.selectedDatums.forEach(function (datum) {
        layer.getShapeFromDatum(datum).stopDrag();
      });
      this.currentEditedLayer = null;
    }
  }]);

  return SimpleEditionState;
})(_baseState2['default']);

exports['default'] = SimpleEditionState;
module.exports = exports['default'];

},{"./base-state":58,"babel-runtime/core-js/set":85,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89,"babel-runtime/helpers/get":90,"babel-runtime/helpers/inherits":91,"babel-runtime/helpers/interop-require-default":92}],72:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = {
  padLeft: function padLeft(input, sign, length) {
    input += '';
    while (input.length < length) {
      input = sign + input;
    }
    return input;
  }
};
module.exports = exports['default'];

},{}],73:[function(require,module,exports){
'use strict';

/**
 * OrthogonalData transforms an object of arrays `{foo: [1, 2], bar: [3, 4]}`
 * to or from an array of objects `[{foo: 1, bar: 3}, {foo: 2, bar: 4}]`
 */

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var OrthogonalData = (function () {
  function OrthogonalData() {
    _classCallCheck(this, OrthogonalData);

    this._cols = null; // Object of arrays
    this._rows = null; // Array of objects
  }

  /**
   * Check the consistency of the data.
   */

  _createClass(OrthogonalData, [{
    key: '_checkConsistency',
    value: function _checkConsistency() {
      var size = null;

      for (var key in this._cols) {
        var col = this._cols[key];
        var colLength = col.length;

        if (size !== null && size !== colLength) {
          throw new Error(this.prototype.constructor.name + ': inconsistent data');
        } else if (size === null) {
          size = colLength;
        }
      }
    }

    /**
     * Updates array of objects from object of arrays.
     */
  }, {
    key: 'updateFromCols',
    value: function updateFromCols() {
      var _this = this;

      var keys = _Object$keys(this._cols);

      keys.forEach(function (key, i) {
        var col = _this._cols[key];

        col.forEach(function (value, index) {
          if (_this._rows[index] === undefined) _this._rows[index] = {};
          _this._rows[index][key] = value;
        });
      });

      this._checkConsistency();
    }

    /**
     * Updates object of arrays from array of objects.
     */
  }, {
    key: 'updateFromRows',
    value: function updateFromRows() {
      var _this2 = this;

      this._rows.forEach(function (obj, index) {
        for (var key in obj) {
          if (index === 0) _this2._cols[key] = [];
          _this2._cols[key].push(obj[key]);
        }
      });

      this._checkConsistency();
    }

    /**
     * Sets an object of arrays.
     *
     * @type {Object<String, Array>}
     */
  }, {
    key: 'cols',
    set: function set(obj) {
      this._cols = obj;
      this._rows = [];

      this.updateFromCols();
    },

    /**
     * Returns an object of arrays.
     *
     * @type {Object<String, Array>}
     */
    get: function get() {
      return this._cols;
    }

    /**
     * Sets an array of objects.
     *
     * @type {Array<Object>}
     */
  }, {
    key: 'rows',
    set: function set(arr) {
      this._rows = arr;
      this._cols = {};

      this.updateFromRows();
    },

    /**
     * Returns an array of objects.
     *
     * @type {Array<Object>}
     */
    get: function get() {
      return this._rows;
    }
  }]);

  return OrthogonalData;
})();

exports['default'] = OrthogonalData;
module.exports = exports['default'];

},{"babel-runtime/core-js/object/keys":82,"babel-runtime/helpers/class-call-check":88,"babel-runtime/helpers/create-class":89}],74:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = {
  linear: function linear() {
    var _domain = [0, 1];
    var _range = [0, 1];

    var _slope = 1;
    var _intercept = 0;

    function _updateCoefs() {
      _slope = (_range[1] - _range[0]) / (_domain[1] - _domain[0]);
      _intercept = _range[0] - _slope * _domain[0];
    }

    function scale(value) {
      return _slope * value + _intercept;
    }

    scale.invert = function (value) {
      return (value - _intercept) / _slope;
    };

    scale.domain = function () {
      var arr = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      if (arr === null) {
        return _domain;
      }

      _domain = arr;
      _updateCoefs();

      return scale;
    };

    scale.range = function () {
      var arr = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      if (arr === null) {
        return _range;
      }

      _range = arr;
      _updateCoefs();

      return scale;
    };

    return scale;
  }
};
module.exports = exports['default'];

},{}],75:[function(require,module,exports){
// axis
'use strict';

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _axisAxisLayer = require('./axis/axis-layer');

var _axisAxisLayer2 = _interopRequireDefault(_axisAxisLayer);

var _axisTimeAxisGenerator = require('./axis/time-axis-generator');

var _axisTimeAxisGenerator2 = _interopRequireDefault(_axisTimeAxisGenerator);

var _axisGridAxisGenerator = require('./axis/grid-axis-generator');

var _axisGridAxisGenerator2 = _interopRequireDefault(_axisGridAxisGenerator);

// behaviors

var _behaviorsBaseBehavior = require('./behaviors/base-behavior');

var _behaviorsBaseBehavior2 = _interopRequireDefault(_behaviorsBaseBehavior);

var _behaviorsSnapBaseBehavior = require('./behaviors/snap-base-behavior');

var _behaviorsSnapBaseBehavior2 = _interopRequireDefault(_behaviorsSnapBaseBehavior);

var _behaviorsBeatGridSnapSegmentBehavior = require('./behaviors/beat-grid-snap-segment-behavior');

var _behaviorsBeatGridSnapSegmentBehavior2 = _interopRequireDefault(_behaviorsBeatGridSnapSegmentBehavior);

var _behaviorsBreakpointBehavior = require('./behaviors/breakpoint-behavior');

var _behaviorsBreakpointBehavior2 = _interopRequireDefault(_behaviorsBreakpointBehavior);

var _behaviorsMarkerBehavior = require('./behaviors/marker-behavior');

var _behaviorsMarkerBehavior2 = _interopRequireDefault(_behaviorsMarkerBehavior);

var _behaviorsScrollSegmentBehavior = require('./behaviors/scroll-segment-behavior');

var _behaviorsScrollSegmentBehavior2 = _interopRequireDefault(_behaviorsScrollSegmentBehavior);

var _behaviorsSegmentBehavior = require('./behaviors/segment-behavior');

var _behaviorsSegmentBehavior2 = _interopRequireDefault(_behaviorsSegmentBehavior);

var _behaviorsSiblingLockedSegmentBehavior = require('./behaviors/sibling-locked-segment-behavior');

var _behaviorsSiblingLockedSegmentBehavior2 = _interopRequireDefault(_behaviorsSiblingLockedSegmentBehavior);

var _behaviorsSimpleSnapSegmentBehavior = require('./behaviors/simple-snap-segment-behavior');

var _behaviorsSimpleSnapSegmentBehavior2 = _interopRequireDefault(_behaviorsSimpleSnapSegmentBehavior);

var _behaviorsTimeContextBehavior = require('./behaviors/time-context-behavior');

var _behaviorsTimeContextBehavior2 = _interopRequireDefault(_behaviorsTimeContextBehavior);

var _behaviorsTraceBehavior = require('./behaviors/trace-behavior');

var _behaviorsTraceBehavior2 = _interopRequireDefault(_behaviorsTraceBehavior);

var _behaviorsWaveformBehavior = require('./behaviors/waveform-behavior');

var _behaviorsWaveformBehavior2 = _interopRequireDefault(_behaviorsWaveformBehavior);

var _behaviorsNoBehavior = require('./behaviors/no-behavior');

var _behaviorsNoBehavior2 = _interopRequireDefault(_behaviorsNoBehavior);

var _behaviorsNoHorizontalOverlappingSegmentsBehavior = require('./behaviors/no-horizontal-overlapping-segments-behavior');

var _behaviorsNoHorizontalOverlappingSegmentsBehavior2 = _interopRequireDefault(_behaviorsNoHorizontalOverlappingSegmentsBehavior);

// core

var _coreLayerTimeContext = require('./core/layer-time-context');

var _coreLayerTimeContext2 = _interopRequireDefault(_coreLayerTimeContext);

var _coreLayer = require('./core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _coreTimelineTimeContext = require('./core/timeline-time-context');

var _coreTimelineTimeContext2 = _interopRequireDefault(_coreTimelineTimeContext);

var _coreTimeline = require('./core/timeline');

var _coreTimeline2 = _interopRequireDefault(_coreTimeline);

var _coreTrackCollection = require('./core/track-collection');

var _coreTrackCollection2 = _interopRequireDefault(_coreTrackCollection);

var _coreTrack = require('./core/track');

var _coreTrack2 = _interopRequireDefault(_coreTrack);

// helpers

var _helpersAnnotatedMarkerLayer = require('./helpers/annotated-marker-layer');

var _helpersAnnotatedMarkerLayer2 = _interopRequireDefault(_helpersAnnotatedMarkerLayer);

var _helpersAnnotatedSegmentLayer = require('./helpers/annotated-segment-layer');

var _helpersAnnotatedSegmentLayer2 = _interopRequireDefault(_helpersAnnotatedSegmentLayer);

var _helpersBreakpointLayer = require('./helpers/breakpoint-layer');

var _helpersBreakpointLayer2 = _interopRequireDefault(_helpersBreakpointLayer);

var _helpersCursorLayer = require('./helpers/cursor-layer');

var _helpersCursorLayer2 = _interopRequireDefault(_helpersCursorLayer);

var _helpersGridAxisLayer = require('./helpers/grid-axis-layer');

var _helpersGridAxisLayer2 = _interopRequireDefault(_helpersGridAxisLayer);

var _helpersMarkerLayer = require('./helpers/marker-layer');

var _helpersMarkerLayer2 = _interopRequireDefault(_helpersMarkerLayer);

var _helpersSegmentLayer = require('./helpers/segment-layer');

var _helpersSegmentLayer2 = _interopRequireDefault(_helpersSegmentLayer);

var _helpersTickLayer = require('./helpers/tick-layer');

var _helpersTickLayer2 = _interopRequireDefault(_helpersTickLayer);

var _helpersTimeAxisLayer = require('./helpers/time-axis-layer');

var _helpersTimeAxisLayer2 = _interopRequireDefault(_helpersTimeAxisLayer);

var _helpersTraceLayer = require('./helpers/trace-layer');

var _helpersTraceLayer2 = _interopRequireDefault(_helpersTraceLayer);

var _helpersWaveformLayer = require('./helpers/waveform-layer');

var _helpersWaveformLayer2 = _interopRequireDefault(_helpersWaveformLayer);

var _helpersBeatGridLayer = require('./helpers/beat-grid-layer');

var _helpersBeatGridLayer2 = _interopRequireDefault(_helpersBeatGridLayer);

var _helpersScroller = require('./helpers/scroller');

var _helpersScroller2 = _interopRequireDefault(_helpersScroller);

var _helpersBeatGridAxisLayer = require('./helpers/beat-grid-axis-layer');

var _helpersBeatGridAxisLayer2 = _interopRequireDefault(_helpersBeatGridAxisLayer);

var _helpersBrushController = require('./helpers/brush-controller');

var _helpersBrushController2 = _interopRequireDefault(_helpersBrushController);

// interactions

var _interactionsEventSource = require('./interactions/event-source');

var _interactionsEventSource2 = _interopRequireDefault(_interactionsEventSource);

var _interactionsKeyboard = require('./interactions/keyboard');

var _interactionsKeyboard2 = _interopRequireDefault(_interactionsKeyboard);

var _interactionsKonvaSurface = require('./interactions/konva-surface');

var _interactionsKonvaSurface2 = _interopRequireDefault(_interactionsKonvaSurface);

var _interactionsKonvaWaveEvent = require('./interactions/konva-wave-event');

var _interactionsKonvaWaveEvent2 = _interopRequireDefault(_interactionsKonvaWaveEvent);

var _interactionsWaveEvent = require('./interactions/wave-event');

var _interactionsWaveEvent2 = _interopRequireDefault(_interactionsWaveEvent);

// shapes
// import AnnotatedMarker from './shapes/annotated-marker';

var _shapesAnnotatedSegment = require('./shapes/annotated-segment');

var _shapesAnnotatedSegment2 = _interopRequireDefault(_shapesAnnotatedSegment);

var _shapesAnnotatedDot = require('./shapes/annotated-dot');

var _shapesAnnotatedDot2 = _interopRequireDefault(_shapesAnnotatedDot);

var _shapesBaseShape = require('./shapes/base-shape');

var _shapesBaseShape2 = _interopRequireDefault(_shapesBaseShape);

var _shapesCursor = require('./shapes/cursor');

var _shapesCursor2 = _interopRequireDefault(_shapesCursor);

var _shapesDot = require('./shapes/dot');

var _shapesDot2 = _interopRequireDefault(_shapesDot);

var _shapesLine = require('./shapes/line');

var _shapesLine2 = _interopRequireDefault(_shapesLine);

var _shapesMarker = require('./shapes/marker');

var _shapesMarker2 = _interopRequireDefault(_shapesMarker);

var _shapesSegment = require('./shapes/segment');

var _shapesSegment2 = _interopRequireDefault(_shapesSegment);

var _shapesTicks = require('./shapes/ticks');

var _shapesTicks2 = _interopRequireDefault(_shapesTicks);

var _shapesTraceDots = require('./shapes/trace-dots');

var _shapesTraceDots2 = _interopRequireDefault(_shapesTraceDots);

var _shapesTracePath = require('./shapes/trace-path');

var _shapesTracePath2 = _interopRequireDefault(_shapesTracePath);

var _shapesWaveform = require('./shapes/waveform');

var _shapesWaveform2 = _interopRequireDefault(_shapesWaveform);

// states

var _statesBaseState = require('./states/base-state');

var _statesBaseState2 = _interopRequireDefault(_statesBaseState);

var _statesBreakpointState = require('./states/breakpoint-state');

var _statesBreakpointState2 = _interopRequireDefault(_statesBreakpointState);

var _statesBrushZoomState = require('./states/brush-zoom-state');

var _statesBrushZoomState2 = _interopRequireDefault(_statesBrushZoomState);

var _statesCenteredZoomState = require('./states/centered-zoom-state');

var _statesCenteredZoomState2 = _interopRequireDefault(_statesCenteredZoomState);

var _statesCenteredScrollState = require('./states/centered-scroll-state');

var _statesCenteredScrollState2 = _interopRequireDefault(_statesCenteredScrollState);

var _statesContextEditionState = require('./states/context-edition-state');

var _statesContextEditionState2 = _interopRequireDefault(_statesContextEditionState);

var _statesDropAndAddState = require('./states/drop-and-add-state');

var _statesDropAndAddState2 = _interopRequireDefault(_statesDropAndAddState);

var _statesEditionState = require('./states/edition-state');

var _statesEditionState2 = _interopRequireDefault(_statesEditionState);

var _statesHorizontalSelectionState = require('./states/horizontal-selection-state');

var _statesHorizontalSelectionState2 = _interopRequireDefault(_statesHorizontalSelectionState);

var _statesSelectionState = require('./states/selection-state');

var _statesSelectionState2 = _interopRequireDefault(_statesSelectionState);

var _statesShapeInsertionState = require('./states/shape-insertion-state');

var _statesShapeInsertionState2 = _interopRequireDefault(_statesShapeInsertionState);

var _statesSimpleEditionState = require('./states/simple-edition-state');

var _statesSimpleEditionState2 = _interopRequireDefault(_statesSimpleEditionState);

var _statesDragToCreateIntervalState = require('./states/drag-to-create-interval-state');

var _statesDragToCreateIntervalState2 = _interopRequireDefault(_statesDragToCreateIntervalState);

// import BeatGridEditorInteractionsState from './states/beat-grid-interactions-state';

var _statesDragAndDropState = require('./states/drag-and-drop-state');

var _statesDragAndDropState2 = _interopRequireDefault(_statesDragAndDropState);

// utils

var _utilsFormat = require('./utils/format');

var _utilsFormat2 = _interopRequireDefault(_utilsFormat);

var _utilsOrthogonalData = require('./utils/orthogonal-data');

var _utilsOrthogonalData2 = _interopRequireDefault(_utilsOrthogonalData);

var _utilsScales = require('./utils/scales');

var _utilsScales2 = _interopRequireDefault(_utilsScales);

exports['default'] = {
  axis: {
    AxisLayer: _axisAxisLayer2['default'], timeAxisGenerator: _axisTimeAxisGenerator2['default'], gridAxisGenerator: _axisGridAxisGenerator2['default']
  },

  behaviors: {
    BaseBehavior: _behaviorsBaseBehavior2['default'], SnapBaseBehavior: _behaviorsSnapBaseBehavior2['default'], BeatGridSnapSegmentBehavior: _behaviorsBeatGridSnapSegmentBehavior2['default'],
    BreakpointBehavior: _behaviorsBreakpointBehavior2['default'], MarkerBehavior: _behaviorsMarkerBehavior2['default'],
    ScrollSegmentBehavior: _behaviorsScrollSegmentBehavior2['default'], SegmentBehavior: _behaviorsSegmentBehavior2['default'],
    SiblingLockedSegmentBehavior: _behaviorsSiblingLockedSegmentBehavior2['default'], SimpleSnapSegmentBehavior: _behaviorsSimpleSnapSegmentBehavior2['default'],
    TimeContextBehavior: _behaviorsTimeContextBehavior2['default'], TraceBehavior: _behaviorsTraceBehavior2['default'], WaveformBehavior: _behaviorsWaveformBehavior2['default'],
    NoBehavior: _behaviorsNoBehavior2['default'], NoHorizontalOverlappingSegmentsBehavior: _behaviorsNoHorizontalOverlappingSegmentsBehavior2['default']
  },

  core: {
    LayerTimeContext: _coreLayerTimeContext2['default'], Layer: _coreLayer2['default'], TimelineTimeContext: _coreTimelineTimeContext2['default'], Timeline: _coreTimeline2['default'],
    TrackCollection: _coreTrackCollection2['default'], Track: _coreTrack2['default']
  },

  helpers: {
    BeatGridAxisLayer: _helpersBeatGridAxisLayer2['default'],
    AnnotatedMarkerLayer: _helpersAnnotatedMarkerLayer2['default'],
    AnnotatedSegmentLayer: _helpersAnnotatedSegmentLayer2['default'],
    BreakpointLayer: _helpersBreakpointLayer2['default'],
    CursorLayer: _helpersCursorLayer2['default'],
    GridAxisLayer: _helpersGridAxisLayer2['default'],
    MarkerLayer: _helpersMarkerLayer2['default'],
    SegmentLayer: _helpersSegmentLayer2['default'],
    TickLayer: _helpersTickLayer2['default'],
    TimeAxisLayer: _helpersTimeAxisLayer2['default'],
    TraceLayer: _helpersTraceLayer2['default'],
    WaveformLayer: _helpersWaveformLayer2['default'],
    BeatGridLayer: _helpersBeatGridLayer2['default'],
    Scroller: _helpersScroller2['default'],
    BrushController: _helpersBrushController2['default']
  },

  interactions: {
    EventSource: _interactionsEventSource2['default'], Keyboard: _interactionsKeyboard2['default'],
    Surface: _interactionsKonvaSurface2['default'], KonvaWaveEvent: _interactionsKonvaWaveEvent2['default'], WaveEvent: _interactionsWaveEvent2['default']
  },

  shapes: {
    // AnnotatedMarker,
    AnnotatedSegment: _shapesAnnotatedSegment2['default'], AnnotatedDot: _shapesAnnotatedDot2['default'], BaseShape: _shapesBaseShape2['default'], Cursor: _shapesCursor2['default'],
    Dot: _shapesDot2['default'], Line: _shapesLine2['default'], Marker: _shapesMarker2['default'], Segment: _shapesSegment2['default'],
    Ticks: _shapesTicks2['default'], TraceDots: _shapesTraceDots2['default'], TracePath: _shapesTracePath2['default'], Waveform: _shapesWaveform2['default']
  },

  states: {
    BaseState: _statesBaseState2['default'], BreakpointState: _statesBreakpointState2['default'], BrushZoomState: _statesBrushZoomState2['default'], CenteredZoomState: _statesCenteredZoomState2['default'],
    CenteredScrollState: _statesCenteredScrollState2['default'], ContextEditionState: _statesContextEditionState2['default'], DropAndAddState: _statesDropAndAddState2['default'], EditionState: _statesEditionState2['default'],
    SelectionState: _statesSelectionState2['default'], HorizontalSelectionState: _statesHorizontalSelectionState2['default'], ShapeInsertionState: _statesShapeInsertionState2['default'], SimpleEditionState: _statesSimpleEditionState2['default'],
    DragToCreateIntervalState: _statesDragToCreateIntervalState2['default'], DragAndDropState: _statesDragAndDropState2['default']
  },

  utils: {
    format: _utilsFormat2['default'], OrthogonalData: _utilsOrthogonalData2['default'], scales: _utilsScales2['default']
  }
};
module.exports = exports['default'];

},{"./axis/axis-layer":1,"./axis/grid-axis-generator":3,"./axis/time-axis-generator":4,"./behaviors/base-behavior":5,"./behaviors/beat-grid-snap-segment-behavior":6,"./behaviors/breakpoint-behavior":7,"./behaviors/marker-behavior":8,"./behaviors/no-behavior":9,"./behaviors/no-horizontal-overlapping-segments-behavior":10,"./behaviors/scroll-segment-behavior":11,"./behaviors/segment-behavior":12,"./behaviors/sibling-locked-segment-behavior":13,"./behaviors/simple-snap-segment-behavior":14,"./behaviors/snap-base-behavior":15,"./behaviors/time-context-behavior":16,"./behaviors/trace-behavior":17,"./behaviors/waveform-behavior":18,"./core/layer":20,"./core/layer-time-context":19,"./core/timeline":22,"./core/timeline-time-context":21,"./core/track":24,"./core/track-collection":23,"./helpers/annotated-marker-layer":25,"./helpers/annotated-segment-layer":26,"./helpers/beat-grid-axis-layer":27,"./helpers/beat-grid-layer":28,"./helpers/breakpoint-layer":29,"./helpers/brush-controller":30,"./helpers/cursor-layer":31,"./helpers/grid-axis-layer":32,"./helpers/marker-layer":33,"./helpers/scroller":34,"./helpers/segment-layer":35,"./helpers/tick-layer":36,"./helpers/time-axis-layer":37,"./helpers/trace-layer":38,"./helpers/waveform-layer":39,"./interactions/event-source":40,"./interactions/keyboard":41,"./interactions/konva-surface":42,"./interactions/konva-wave-event":43,"./interactions/wave-event":44,"./shapes/annotated-dot":45,"./shapes/annotated-segment":47,"./shapes/base-shape":48,"./shapes/cursor":49,"./shapes/dot":50,"./shapes/line":51,"./shapes/marker":52,"./shapes/segment":53,"./shapes/ticks":54,"./shapes/trace-dots":55,"./shapes/trace-path":56,"./shapes/waveform":57,"./states/base-state":58,"./states/breakpoint-state":59,"./states/brush-zoom-state":60,"./states/centered-scroll-state":61,"./states/centered-zoom-state":62,"./states/context-edition-state":63,"./states/drag-and-drop-state":64,"./states/drag-to-create-interval-state":65,"./states/drop-and-add-state":66,"./states/edition-state":67,"./states/horizontal-selection-state":68,"./states/selection-state":69,"./states/shape-insertion-state":70,"./states/simple-edition-state":71,"./utils/format":72,"./utils/orthogonal-data":73,"./utils/scales":74,"babel-runtime/helpers/interop-require-default":92}],76:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/get-iterator"), __esModule: true };
},{"core-js/library/fn/get-iterator":93}],77:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/map"), __esModule: true };
},{"core-js/library/fn/map":94}],78:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":95}],79:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
},{"core-js/library/fn/object/create":96}],80:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
},{"core-js/library/fn/object/define-property":97}],81:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-own-property-descriptor"), __esModule: true };
},{"core-js/library/fn/object/get-own-property-descriptor":98}],82:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/keys"), __esModule: true };
},{"core-js/library/fn/object/keys":99}],83:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/set-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/set-prototype-of":100}],84:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/promise"), __esModule: true };
},{"core-js/library/fn/promise":101}],85:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/set"), __esModule: true };
},{"core-js/library/fn/set":102}],86:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":103}],87:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol/iterator"), __esModule: true };
},{"core-js/library/fn/symbol/iterator":104}],88:[function(require,module,exports){
"use strict";

exports["default"] = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

exports.__esModule = true;
},{}],89:[function(require,module,exports){
"use strict";

var _Object$defineProperty = require("babel-runtime/core-js/object/define-property")["default"];

exports["default"] = (function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;

      _Object$defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
})();

exports.__esModule = true;
},{"babel-runtime/core-js/object/define-property":80}],90:[function(require,module,exports){
"use strict";

var _Object$getOwnPropertyDescriptor = require("babel-runtime/core-js/object/get-own-property-descriptor")["default"];

exports["default"] = function get(_x, _x2, _x3) {
  var _again = true;

  _function: while (_again) {
    var object = _x,
        property = _x2,
        receiver = _x3;
    _again = false;
    if (object === null) object = Function.prototype;

    var desc = _Object$getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        _x = parent;
        _x2 = property;
        _x3 = receiver;
        _again = true;
        desc = parent = undefined;
        continue _function;
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  }
};

exports.__esModule = true;
},{"babel-runtime/core-js/object/get-own-property-descriptor":81}],91:[function(require,module,exports){
"use strict";

var _Object$create = require("babel-runtime/core-js/object/create")["default"];

var _Object$setPrototypeOf = require("babel-runtime/core-js/object/set-prototype-of")["default"];

exports["default"] = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = _Object$create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

exports.__esModule = true;
},{"babel-runtime/core-js/object/create":79,"babel-runtime/core-js/object/set-prototype-of":83}],92:[function(require,module,exports){
"use strict";

exports["default"] = function (obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
};

exports.__esModule = true;
},{}],93:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.get-iterator');
},{"../modules/core.get-iterator":163,"../modules/es6.string.iterator":173,"../modules/web.dom.iterable":177}],94:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.map');
require('../modules/es7.map.to-json');
module.exports = require('../modules/$.core').Map;
},{"../modules/$.core":113,"../modules/es6.map":165,"../modules/es6.object.to-string":170,"../modules/es6.string.iterator":173,"../modules/es7.map.to-json":175,"../modules/web.dom.iterable":177}],95:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/$.core').Object.assign;
},{"../../modules/$.core":113,"../../modules/es6.object.assign":166}],96:[function(require,module,exports){
var $ = require('../../modules/$');
module.exports = function create(P, D){
  return $.create(P, D);
};
},{"../../modules/$":138}],97:[function(require,module,exports){
var $ = require('../../modules/$');
module.exports = function defineProperty(it, key, desc){
  return $.setDesc(it, key, desc);
};
},{"../../modules/$":138}],98:[function(require,module,exports){
var $ = require('../../modules/$');
require('../../modules/es6.object.get-own-property-descriptor');
module.exports = function getOwnPropertyDescriptor(it, key){
  return $.getDesc(it, key);
};
},{"../../modules/$":138,"../../modules/es6.object.get-own-property-descriptor":167}],99:[function(require,module,exports){
require('../../modules/es6.object.keys');
module.exports = require('../../modules/$.core').Object.keys;
},{"../../modules/$.core":113,"../../modules/es6.object.keys":168}],100:[function(require,module,exports){
require('../../modules/es6.object.set-prototype-of');
module.exports = require('../../modules/$.core').Object.setPrototypeOf;
},{"../../modules/$.core":113,"../../modules/es6.object.set-prototype-of":169}],101:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.promise');
module.exports = require('../modules/$.core').Promise;
},{"../modules/$.core":113,"../modules/es6.object.to-string":170,"../modules/es6.promise":171,"../modules/es6.string.iterator":173,"../modules/web.dom.iterable":177}],102:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.set');
require('../modules/es7.set.to-json');
module.exports = require('../modules/$.core').Set;
},{"../modules/$.core":113,"../modules/es6.object.to-string":170,"../modules/es6.set":172,"../modules/es6.string.iterator":173,"../modules/es7.set.to-json":176,"../modules/web.dom.iterable":177}],103:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
module.exports = require('../../modules/$.core').Symbol;
},{"../../modules/$.core":113,"../../modules/es6.object.to-string":170,"../../modules/es6.symbol":174}],104:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/web.dom.iterable');
module.exports = require('../../modules/$.wks')('iterator');
},{"../../modules/$.wks":161,"../../modules/es6.string.iterator":173,"../../modules/web.dom.iterable":177}],105:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],106:[function(require,module,exports){
module.exports = function(){ /* empty */ };
},{}],107:[function(require,module,exports){
var isObject = require('./$.is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./$.is-object":131}],108:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./$.cof')
  , TAG = require('./$.wks')('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};
},{"./$.cof":109,"./$.wks":161}],109:[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],110:[function(require,module,exports){
'use strict';
var $            = require('./$')
  , hide         = require('./$.hide')
  , redefineAll  = require('./$.redefine-all')
  , ctx          = require('./$.ctx')
  , strictNew    = require('./$.strict-new')
  , defined      = require('./$.defined')
  , forOf        = require('./$.for-of')
  , $iterDefine  = require('./$.iter-define')
  , step         = require('./$.iter-step')
  , ID           = require('./$.uid')('id')
  , $has         = require('./$.has')
  , isObject     = require('./$.is-object')
  , setSpecies   = require('./$.set-species')
  , DESCRIPTORS  = require('./$.descriptors')
  , isExtensible = Object.isExtensible || isObject
  , SIZE         = DESCRIPTORS ? '_s' : 'size'
  , id           = 0;

var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!$has(it, ID)){
    // can't set id to frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add id
    if(!create)return 'E';
    // add missing object id
    hide(it, ID, ++id);
  // return object id with prefix
  } return 'O' + it[ID];
};

var getEntry = function(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      strictNew(that, C, NAME);
      that._i = $.create(null); // index
      that._f = undefined;      // first entry
      that._l = undefined;      // last entry
      that[SIZE] = 0;           // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(DESCRIPTORS)$.setDesc(C.prototype, 'size', {
      get: function(){
        return defined(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};
},{"./$":138,"./$.ctx":114,"./$.defined":115,"./$.descriptors":116,"./$.for-of":121,"./$.has":124,"./$.hide":125,"./$.is-object":131,"./$.iter-define":134,"./$.iter-step":136,"./$.redefine-all":145,"./$.set-species":149,"./$.strict-new":153,"./$.uid":160}],111:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var forOf   = require('./$.for-of')
  , classof = require('./$.classof');
module.exports = function(NAME){
  return function toJSON(){
    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    var arr = [];
    forOf(this, false, arr.push, arr);
    return arr;
  };
};
},{"./$.classof":108,"./$.for-of":121}],112:[function(require,module,exports){
'use strict';
var $              = require('./$')
  , global         = require('./$.global')
  , $export        = require('./$.export')
  , fails          = require('./$.fails')
  , hide           = require('./$.hide')
  , redefineAll    = require('./$.redefine-all')
  , forOf          = require('./$.for-of')
  , strictNew      = require('./$.strict-new')
  , isObject       = require('./$.is-object')
  , setToStringTag = require('./$.set-to-string-tag')
  , DESCRIPTORS    = require('./$.descriptors');

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
  } else {
    C = wrapper(function(target, iterable){
      strictNew(target, C, NAME);
      target._c = new Base;
      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
    });
    $.each.call('add,clear,delete,forEach,get,has,set,keys,values,entries'.split(','),function(KEY){
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    if('size' in proto)$.setDesc(C.prototype, 'size', {
      get: function(){
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};
},{"./$":138,"./$.descriptors":116,"./$.export":119,"./$.fails":120,"./$.for-of":121,"./$.global":123,"./$.hide":125,"./$.is-object":131,"./$.redefine-all":145,"./$.set-to-string-tag":150,"./$.strict-new":153}],113:[function(require,module,exports){
var core = module.exports = {version: '1.2.6'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],114:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./$.a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./$.a-function":105}],115:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],116:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./$.fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./$.fails":120}],117:[function(require,module,exports){
var isObject = require('./$.is-object')
  , document = require('./$.global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./$.global":123,"./$.is-object":131}],118:[function(require,module,exports){
// all enumerable object keys, includes symbols
var $ = require('./$');
module.exports = function(it){
  var keys       = $.getKeys(it)
    , getSymbols = $.getSymbols;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = $.isEnum
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);
  }
  return keys;
};
},{"./$":138}],119:[function(require,module,exports){
var global    = require('./$.global')
  , core      = require('./$.core')
  , ctx       = require('./$.ctx')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && key in target;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(param){
        return this instanceof C ? new C(param) : C(param);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
  }
};
// type bitmap
$export.F = 1;  // forced
$export.G = 2;  // global
$export.S = 4;  // static
$export.P = 8;  // proto
$export.B = 16; // bind
$export.W = 32; // wrap
module.exports = $export;
},{"./$.core":113,"./$.ctx":114,"./$.global":123}],120:[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],121:[function(require,module,exports){
var ctx         = require('./$.ctx')
  , call        = require('./$.iter-call')
  , isArrayIter = require('./$.is-array-iter')
  , anObject    = require('./$.an-object')
  , toLength    = require('./$.to-length')
  , getIterFn   = require('./core.get-iterator-method');
module.exports = function(iterable, entries, fn, that){
  var iterFn = getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    call(iterator, f, step.value, entries);
  }
};
},{"./$.an-object":107,"./$.ctx":114,"./$.is-array-iter":129,"./$.iter-call":132,"./$.to-length":158,"./core.get-iterator-method":162}],122:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./$.to-iobject')
  , getNames  = require('./$').getNames
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return getNames(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.get = function getOwnPropertyNames(it){
  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);
  return getNames(toIObject(it));
};
},{"./$":138,"./$.to-iobject":157}],123:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],124:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],125:[function(require,module,exports){
var $          = require('./$')
  , createDesc = require('./$.property-desc');
module.exports = require('./$.descriptors') ? function(object, key, value){
  return $.setDesc(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./$":138,"./$.descriptors":116,"./$.property-desc":144}],126:[function(require,module,exports){
module.exports = require('./$.global').document && document.documentElement;
},{"./$.global":123}],127:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};
},{}],128:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./$.cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./$.cof":109}],129:[function(require,module,exports){
// check on default Array iterator
var Iterators  = require('./$.iterators')
  , ITERATOR   = require('./$.wks')('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};
},{"./$.iterators":137,"./$.wks":161}],130:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./$.cof');
module.exports = Array.isArray || function(arg){
  return cof(arg) == 'Array';
};
},{"./$.cof":109}],131:[function(require,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],132:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./$.an-object');
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};
},{"./$.an-object":107}],133:[function(require,module,exports){
'use strict';
var $              = require('./$')
  , descriptor     = require('./$.property-desc')
  , setToStringTag = require('./$.set-to-string-tag')
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./$.hide')(IteratorPrototype, require('./$.wks')('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};
},{"./$":138,"./$.hide":125,"./$.property-desc":144,"./$.set-to-string-tag":150,"./$.wks":161}],134:[function(require,module,exports){
'use strict';
var LIBRARY        = require('./$.library')
  , $export        = require('./$.export')
  , redefine       = require('./$.redefine')
  , hide           = require('./$.hide')
  , has            = require('./$.has')
  , Iterators      = require('./$.iterators')
  , $iterCreate    = require('./$.iter-create')
  , setToStringTag = require('./$.set-to-string-tag')
  , getProto       = require('./$').getProto
  , ITERATOR       = require('./$.wks')('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , methods, key;
  // Fix native
  if($native){
    var IteratorPrototype = getProto($default.call(new Base));
    // Set @@toStringTag to native iterators
    setToStringTag(IteratorPrototype, TAG, true);
    // FF fix
    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    // fix Array#{values, @@iterator}.name in V8 / FF
    if(DEF_VALUES && $native.name !== VALUES){
      VALUES_BUG = true;
      $default = function values(){ return $native.call(this); };
    }
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES  ? $default : getMethod(VALUES),
      keys:    IS_SET      ? $default : getMethod(KEYS),
      entries: !DEF_VALUES ? $default : getMethod('entries')
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};
},{"./$":138,"./$.export":119,"./$.has":124,"./$.hide":125,"./$.iter-create":133,"./$.iterators":137,"./$.library":140,"./$.redefine":146,"./$.set-to-string-tag":150,"./$.wks":161}],135:[function(require,module,exports){
var ITERATOR     = require('./$.wks')('iterator')
  , SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR]();
    iter.next = function(){ safe = true; };
    arr[ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
},{"./$.wks":161}],136:[function(require,module,exports){
module.exports = function(done, value){
  return {value: value, done: !!done};
};
},{}],137:[function(require,module,exports){
module.exports = {};
},{}],138:[function(require,module,exports){
var $Object = Object;
module.exports = {
  create:     $Object.create,
  getProto:   $Object.getPrototypeOf,
  isEnum:     {}.propertyIsEnumerable,
  getDesc:    $Object.getOwnPropertyDescriptor,
  setDesc:    $Object.defineProperty,
  setDescs:   $Object.defineProperties,
  getKeys:    $Object.keys,
  getNames:   $Object.getOwnPropertyNames,
  getSymbols: $Object.getOwnPropertySymbols,
  each:       [].forEach
};
},{}],139:[function(require,module,exports){
var $         = require('./$')
  , toIObject = require('./$.to-iobject');
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = $.getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
},{"./$":138,"./$.to-iobject":157}],140:[function(require,module,exports){
module.exports = true;
},{}],141:[function(require,module,exports){
var global    = require('./$.global')
  , macrotask = require('./$.task').set
  , Observer  = global.MutationObserver || global.WebKitMutationObserver
  , process   = global.process
  , Promise   = global.Promise
  , isNode    = require('./$.cof')(process) == 'process'
  , head, last, notify;

var flush = function(){
  var parent, domain, fn;
  if(isNode && (parent = process.domain)){
    process.domain = null;
    parent.exit();
  }
  while(head){
    domain = head.domain;
    fn     = head.fn;
    if(domain)domain.enter();
    fn(); // <- currently we use it only for Promise - try / catch not required
    if(domain)domain.exit();
    head = head.next;
  } last = undefined;
  if(parent)parent.enter();
};

// Node.js
if(isNode){
  notify = function(){
    process.nextTick(flush);
  };
// browsers with MutationObserver
} else if(Observer){
  var toggle = 1
    , node   = document.createTextNode('');
  new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
  notify = function(){
    node.data = toggle = -toggle;
  };
// environments with maybe non-completely correct, but existent Promise
} else if(Promise && Promise.resolve){
  notify = function(){
    Promise.resolve().then(flush);
  };
// for other environments - macrotask based on:
// - setImmediate
// - MessageChannel
// - window.postMessag
// - onreadystatechange
// - setTimeout
} else {
  notify = function(){
    // strange IE + webpack dev server bug - use .call(global)
    macrotask.call(global, flush);
  };
}

module.exports = function asap(fn){
  var task = {fn: fn, next: undefined, domain: isNode && process.domain};
  if(last)last.next = task;
  if(!head){
    head = task;
    notify();
  } last = task;
};
},{"./$.cof":109,"./$.global":123,"./$.task":155}],142:[function(require,module,exports){
// 19.1.2.1 Object.assign(target, source, ...)
var $        = require('./$')
  , toObject = require('./$.to-object')
  , IObject  = require('./$.iobject');

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = require('./$.fails')(function(){
  var a = Object.assign
    , A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , $$    = arguments
    , $$len = $$.length
    , index = 1
    , getKeys    = $.getKeys
    , getSymbols = $.getSymbols
    , isEnum     = $.isEnum;
  while($$len > index){
    var S      = IObject($$[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  }
  return T;
} : Object.assign;
},{"./$":138,"./$.fails":120,"./$.iobject":128,"./$.to-object":159}],143:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./$.export')
  , core    = require('./$.core')
  , fails   = require('./$.fails');
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};
},{"./$.core":113,"./$.export":119,"./$.fails":120}],144:[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],145:[function(require,module,exports){
var redefine = require('./$.redefine');
module.exports = function(target, src){
  for(var key in src)redefine(target, key, src[key]);
  return target;
};
},{"./$.redefine":146}],146:[function(require,module,exports){
module.exports = require('./$.hide');
},{"./$.hide":125}],147:[function(require,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y){
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};
},{}],148:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var getDesc  = require('./$').getDesc
  , isObject = require('./$.is-object')
  , anObject = require('./$.an-object');
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = require('./$.ctx')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};
},{"./$":138,"./$.an-object":107,"./$.ctx":114,"./$.is-object":131}],149:[function(require,module,exports){
'use strict';
var core        = require('./$.core')
  , $           = require('./$')
  , DESCRIPTORS = require('./$.descriptors')
  , SPECIES     = require('./$.wks')('species');

module.exports = function(KEY){
  var C = core[KEY];
  if(DESCRIPTORS && C && !C[SPECIES])$.setDesc(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};
},{"./$":138,"./$.core":113,"./$.descriptors":116,"./$.wks":161}],150:[function(require,module,exports){
var def = require('./$').setDesc
  , has = require('./$.has')
  , TAG = require('./$.wks')('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};
},{"./$":138,"./$.has":124,"./$.wks":161}],151:[function(require,module,exports){
var global = require('./$.global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./$.global":123}],152:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject  = require('./$.an-object')
  , aFunction = require('./$.a-function')
  , SPECIES   = require('./$.wks')('species');
module.exports = function(O, D){
  var C = anObject(O).constructor, S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};
},{"./$.a-function":105,"./$.an-object":107,"./$.wks":161}],153:[function(require,module,exports){
module.exports = function(it, Constructor, name){
  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
  return it;
};
},{}],154:[function(require,module,exports){
var toInteger = require('./$.to-integer')
  , defined   = require('./$.defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
},{"./$.defined":115,"./$.to-integer":156}],155:[function(require,module,exports){
var ctx                = require('./$.ctx')
  , invoke             = require('./$.invoke')
  , html               = require('./$.html')
  , cel                = require('./$.dom-create')
  , global             = require('./$.global')
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
var run = function(){
  var id = +this;
  if(queue.hasOwnProperty(id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listner = function(event){
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!setTask || !clearTask){
  setTask = function setImmediate(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(require('./$.cof')(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if(MessageChannel){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listner;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
    defer = function(id){
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listner, false);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};
},{"./$.cof":109,"./$.ctx":114,"./$.dom-create":117,"./$.global":123,"./$.html":126,"./$.invoke":127}],156:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],157:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./$.iobject')
  , defined = require('./$.defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./$.defined":115,"./$.iobject":128}],158:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./$.to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./$.to-integer":156}],159:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./$.defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./$.defined":115}],160:[function(require,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],161:[function(require,module,exports){
var store  = require('./$.shared')('wks')
  , uid    = require('./$.uid')
  , Symbol = require('./$.global').Symbol;
module.exports = function(name){
  return store[name] || (store[name] =
    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
};
},{"./$.global":123,"./$.shared":151,"./$.uid":160}],162:[function(require,module,exports){
var classof   = require('./$.classof')
  , ITERATOR  = require('./$.wks')('iterator')
  , Iterators = require('./$.iterators');
module.exports = require('./$.core').getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};
},{"./$.classof":108,"./$.core":113,"./$.iterators":137,"./$.wks":161}],163:[function(require,module,exports){
var anObject = require('./$.an-object')
  , get      = require('./core.get-iterator-method');
module.exports = require('./$.core').getIterator = function(it){
  var iterFn = get(it);
  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};
},{"./$.an-object":107,"./$.core":113,"./core.get-iterator-method":162}],164:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./$.add-to-unscopables')
  , step             = require('./$.iter-step')
  , Iterators        = require('./$.iterators')
  , toIObject        = require('./$.to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./$.iter-define')(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
},{"./$.add-to-unscopables":106,"./$.iter-define":134,"./$.iter-step":136,"./$.iterators":137,"./$.to-iobject":157}],165:[function(require,module,exports){
'use strict';
var strong = require('./$.collection-strong');

// 23.1 Map Objects
require('./$.collection')('Map', function(get){
  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);
},{"./$.collection":112,"./$.collection-strong":110}],166:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./$.export');

$export($export.S + $export.F, 'Object', {assign: require('./$.object-assign')});
},{"./$.export":119,"./$.object-assign":142}],167:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./$.to-iobject');

require('./$.object-sap')('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor){
  return function getOwnPropertyDescriptor(it, key){
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});
},{"./$.object-sap":143,"./$.to-iobject":157}],168:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./$.to-object');

require('./$.object-sap')('keys', function($keys){
  return function keys(it){
    return $keys(toObject(it));
  };
});
},{"./$.object-sap":143,"./$.to-object":159}],169:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./$.export');
$export($export.S, 'Object', {setPrototypeOf: require('./$.set-proto').set});
},{"./$.export":119,"./$.set-proto":148}],170:[function(require,module,exports){

},{}],171:[function(require,module,exports){
'use strict';
var $          = require('./$')
  , LIBRARY    = require('./$.library')
  , global     = require('./$.global')
  , ctx        = require('./$.ctx')
  , classof    = require('./$.classof')
  , $export    = require('./$.export')
  , isObject   = require('./$.is-object')
  , anObject   = require('./$.an-object')
  , aFunction  = require('./$.a-function')
  , strictNew  = require('./$.strict-new')
  , forOf      = require('./$.for-of')
  , setProto   = require('./$.set-proto').set
  , same       = require('./$.same-value')
  , SPECIES    = require('./$.wks')('species')
  , speciesConstructor = require('./$.species-constructor')
  , asap       = require('./$.microtask')
  , PROMISE    = 'Promise'
  , process    = global.process
  , isNode     = classof(process) == 'process'
  , P          = global[PROMISE]
  , Wrapper;

var testResolve = function(sub){
  var test = new P(function(){});
  if(sub)test.constructor = Object;
  return P.resolve(test) === test;
};

var USE_NATIVE = function(){
  var works = false;
  function P2(x){
    var self = new P(x);
    setProto(self, P2.prototype);
    return self;
  }
  try {
    works = P && P.resolve && testResolve();
    setProto(P2, P);
    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
    // actual Firefox has broken subclass support, test that
    if(!(P2.resolve(5).then(function(){}) instanceof P2)){
      works = false;
    }
    // actual V8 bug, https://code.google.com/p/v8/issues/detail?id=4162
    if(works && require('./$.descriptors')){
      var thenableThenGotten = false;
      P.resolve($.setDesc({}, 'then', {
        get: function(){ thenableThenGotten = true; }
      }));
      works = thenableThenGotten;
    }
  } catch(e){ works = false; }
  return works;
}();

// helpers
var sameConstructor = function(a, b){
  // library wrapper special case
  if(LIBRARY && a === P && b === Wrapper)return true;
  return same(a, b);
};
var getConstructor = function(C){
  var S = anObject(C)[SPECIES];
  return S != undefined ? S : C;
};
var isThenable = function(it){
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var PromiseCapability = function(C){
  var resolve, reject;
  this.promise = new C(function($$resolve, $$reject){
    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject  = $$reject;
  });
  this.resolve = aFunction(resolve),
  this.reject  = aFunction(reject)
};
var perform = function(exec){
  try {
    exec();
  } catch(e){
    return {error: e};
  }
};
var notify = function(record, isReject){
  if(record.n)return;
  record.n = true;
  var chain = record.c;
  asap(function(){
    var value = record.v
      , ok    = record.s == 1
      , i     = 0;
    var run = function(reaction){
      var handler = ok ? reaction.ok : reaction.fail
        , resolve = reaction.resolve
        , reject  = reaction.reject
        , result, then;
      try {
        if(handler){
          if(!ok)record.h = true;
          result = handler === true ? value : handler(value);
          if(result === reaction.promise){
            reject(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(result)){
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch(e){
        reject(e);
      }
    };
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    chain.length = 0;
    record.n = false;
    if(isReject)setTimeout(function(){
      var promise = record.p
        , handler, console;
      if(isUnhandled(promise)){
        if(isNode){
          process.emit('unhandledRejection', value, promise);
        } else if(handler = global.onunhandledrejection){
          handler({promise: promise, reason: value});
        } else if((console = global.console) && console.error){
          console.error('Unhandled promise rejection', value);
        }
      } record.a = undefined;
    }, 1);
  });
};
var isUnhandled = function(promise){
  var record = promise._d
    , chain  = record.a || record.c
    , i      = 0
    , reaction;
  if(record.h)return false;
  while(chain.length > i){
    reaction = chain[i++];
    if(reaction.fail || !isUnhandled(reaction.promise))return false;
  } return true;
};
var $reject = function(value){
  var record = this;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  record.v = value;
  record.s = 2;
  record.a = record.c.slice();
  notify(record, true);
};
var $resolve = function(value){
  var record = this
    , then;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  try {
    if(record.p === value)throw TypeError("Promise can't be resolved itself");
    if(then = isThenable(value)){
      asap(function(){
        var wrapper = {r: record, d: false}; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch(e){
          $reject.call(wrapper, e);
        }
      });
    } else {
      record.v = value;
      record.s = 1;
      notify(record, false);
    }
  } catch(e){
    $reject.call({r: record, d: false}, e); // wrap
  }
};

// constructor polyfill
if(!USE_NATIVE){
  // 25.4.3.1 Promise(executor)
  P = function Promise(executor){
    aFunction(executor);
    var record = this._d = {
      p: strictNew(this, P, PROMISE),         // <- promise
      c: [],                                  // <- awaiting reactions
      a: undefined,                           // <- checked in isUnhandled reactions
      s: 0,                                   // <- state
      d: false,                               // <- done
      v: undefined,                           // <- value
      h: false,                               // <- handled rejection
      n: false                                // <- notify
    };
    try {
      executor(ctx($resolve, record, 1), ctx($reject, record, 1));
    } catch(err){
      $reject.call(record, err);
    }
  };
  require('./$.redefine-all')(P.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var reaction = new PromiseCapability(speciesConstructor(this, P))
        , promise  = reaction.promise
        , record   = this._d;
      reaction.ok   = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      record.c.push(reaction);
      if(record.a)record.a.push(reaction);
      if(record.s)notify(record, false);
      return promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: P});
require('./$.set-to-string-tag')(P, PROMISE);
require('./$.set-species')(PROMISE);
Wrapper = require('./$.core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    var capability = new PromiseCapability(this)
      , $$reject   = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
    if(x instanceof P && sameConstructor(x.constructor, this))return x;
    var capability = new PromiseCapability(this)
      , $$resolve  = capability.resolve;
    $$resolve(x);
    return capability.promise;
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./$.iter-detect')(function(iter){
  P.all(iter)['catch'](function(){});
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C          = getConstructor(this)
      , capability = new PromiseCapability(C)
      , resolve    = capability.resolve
      , reject     = capability.reject
      , values     = [];
    var abrupt = perform(function(){
      forOf(iterable, false, values.push, values);
      var remaining = values.length
        , results   = Array(remaining);
      if(remaining)$.each.call(values, function(promise, index){
        var alreadyCalled = false;
        C.resolve(promise).then(function(value){
          if(alreadyCalled)return;
          alreadyCalled = true;
          results[index] = value;
          --remaining || resolve(results);
        }, reject);
      });
      else resolve(results);
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C          = getConstructor(this)
      , capability = new PromiseCapability(C)
      , reject     = capability.reject;
    var abrupt = perform(function(){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  }
});
},{"./$":138,"./$.a-function":105,"./$.an-object":107,"./$.classof":108,"./$.core":113,"./$.ctx":114,"./$.descriptors":116,"./$.export":119,"./$.for-of":121,"./$.global":123,"./$.is-object":131,"./$.iter-detect":135,"./$.library":140,"./$.microtask":141,"./$.redefine-all":145,"./$.same-value":147,"./$.set-proto":148,"./$.set-species":149,"./$.set-to-string-tag":150,"./$.species-constructor":152,"./$.strict-new":153,"./$.wks":161}],172:[function(require,module,exports){
'use strict';
var strong = require('./$.collection-strong');

// 23.2 Set Objects
require('./$.collection')('Set', function(get){
  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);
},{"./$.collection":112,"./$.collection-strong":110}],173:[function(require,module,exports){
'use strict';
var $at  = require('./$.string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./$.iter-define')(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});
},{"./$.iter-define":134,"./$.string-at":154}],174:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var $              = require('./$')
  , global         = require('./$.global')
  , has            = require('./$.has')
  , DESCRIPTORS    = require('./$.descriptors')
  , $export        = require('./$.export')
  , redefine       = require('./$.redefine')
  , $fails         = require('./$.fails')
  , shared         = require('./$.shared')
  , setToStringTag = require('./$.set-to-string-tag')
  , uid            = require('./$.uid')
  , wks            = require('./$.wks')
  , keyOf          = require('./$.keyof')
  , $names         = require('./$.get-names')
  , enumKeys       = require('./$.enum-keys')
  , isArray        = require('./$.is-array')
  , anObject       = require('./$.an-object')
  , toIObject      = require('./$.to-iobject')
  , createDesc     = require('./$.property-desc')
  , getDesc        = $.getDesc
  , setDesc        = $.setDesc
  , _create        = $.create
  , getNames       = $names.get
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , setter         = false
  , HIDDEN         = wks('_hidden')
  , isEnum         = $.isEnum
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , useNative      = typeof $Symbol == 'function'
  , ObjectProto    = Object.prototype;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(setDesc({}, 'a', {
    get: function(){ return setDesc(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = getDesc(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  setDesc(it, key, D);
  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
} : setDesc;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol.prototype);
  sym._k = tag;
  DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
    configurable: true,
    set: function(value){
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    }
  });
  return sym;
};

var isSymbol = function(it){
  return typeof it == 'symbol';
};

var $defineProperty = function defineProperty(it, key, D){
  if(D && has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return setDesc(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key);
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
    ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  var D = getDesc(it = toIObject(it), key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = getNames(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
  return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var names  = getNames(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
  return result;
};
var $stringify = function stringify(it){
  if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
  var args = [it]
    , i    = 1
    , $$   = arguments
    , replacer, $replacer;
  while($$.length > i)args.push($$[i++]);
  replacer = args[1];
  if(typeof replacer == 'function')$replacer = replacer;
  if($replacer || !isArray(replacer))replacer = function(key, value){
    if($replacer)value = $replacer.call(this, key, value);
    if(!isSymbol(value))return value;
  };
  args[1] = replacer;
  return _stringify.apply($JSON, args);
};
var buggyJSON = $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
});

// 19.4.1.1 Symbol([description])
if(!useNative){
  $Symbol = function Symbol(){
    if(isSymbol(this))throw TypeError('Symbol is not a constructor');
    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
  };
  redefine($Symbol.prototype, 'toString', function toString(){
    return this._k;
  });

  isSymbol = function(it){
    return it instanceof $Symbol;
  };

  $.create     = $create;
  $.isEnum     = $propertyIsEnumerable;
  $.getDesc    = $getOwnPropertyDescriptor;
  $.setDesc    = $defineProperty;
  $.setDescs   = $defineProperties;
  $.getNames   = $names.get = $getOwnPropertyNames;
  $.getSymbols = $getOwnPropertySymbols;

  if(DESCRIPTORS && !require('./$.library')){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }
}

var symbolStatics = {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    return keyOf(SymbolRegistry, key);
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
};
// 19.4.2.2 Symbol.hasInstance
// 19.4.2.3 Symbol.isConcatSpreadable
// 19.4.2.4 Symbol.iterator
// 19.4.2.6 Symbol.match
// 19.4.2.8 Symbol.replace
// 19.4.2.9 Symbol.search
// 19.4.2.10 Symbol.species
// 19.4.2.11 Symbol.split
// 19.4.2.12 Symbol.toPrimitive
// 19.4.2.13 Symbol.toStringTag
// 19.4.2.14 Symbol.unscopables
$.each.call((
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
  'species,split,toPrimitive,toStringTag,unscopables'
).split(','), function(it){
  var sym = wks(it);
  symbolStatics[it] = useNative ? sym : wrap(sym);
});

setter = true;

$export($export.G + $export.W, {Symbol: $Symbol});

$export($export.S, 'Symbol', symbolStatics);

$export($export.S + $export.F * !useNative, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});

// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);
},{"./$":138,"./$.an-object":107,"./$.descriptors":116,"./$.enum-keys":118,"./$.export":119,"./$.fails":120,"./$.get-names":122,"./$.global":123,"./$.has":124,"./$.is-array":130,"./$.keyof":139,"./$.library":140,"./$.property-desc":144,"./$.redefine":146,"./$.set-to-string-tag":150,"./$.shared":151,"./$.to-iobject":157,"./$.uid":160,"./$.wks":161}],175:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = require('./$.export');

$export($export.P, 'Map', {toJSON: require('./$.collection-to-json')('Map')});
},{"./$.collection-to-json":111,"./$.export":119}],176:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = require('./$.export');

$export($export.P, 'Set', {toJSON: require('./$.collection-to-json')('Set')});
},{"./$.collection-to-json":111,"./$.export":119}],177:[function(require,module,exports){
require('./es6.array.iterator');
var Iterators = require('./$.iterators');
Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
},{"./$.iterators":137,"./es6.array.iterator":164}],178:[function(require,module,exports){
(function (global){
// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g =
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this;

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = require("./runtime");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

module.exports = { "default": module.exports, __esModule: true };

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./runtime":179}],179:[function(require,module,exports){
(function (process,global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

"use strict";

var _Symbol = require("babel-runtime/core-js/symbol")["default"];

var _Object$create = require("babel-runtime/core-js/object/create")["default"];

var _Object$setPrototypeOf = require("babel-runtime/core-js/object/set-prototype-of")["default"];

var _Promise = require("babel-runtime/core-js/promise")["default"];

!(function (global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof _Symbol === "function" ? _Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided, then outerFn.prototype instanceof Generator.
    var generator = _Object$create((outerFn || Generator).prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction ||
    // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    if (_Object$setPrototypeOf) {
      _Object$setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = _Object$create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `value instanceof AwaitArgument` to determine if the yielded value is
  // meant to be awaited. Some may consider the name of this method too
  // cutesy, but they are curmudgeons.
  runtime.awrap = function (arg) {
    return new AwaitArgument(arg);
  };

  function AwaitArgument(arg) {
    this.arg = arg;
  }

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value instanceof AwaitArgument) {
          return _Promise.resolve(value.arg).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return _Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new _Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
      // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
      // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          if (method === "return" || method === "throw" && delegate.iterator[method] === undefined) {
            // A return or throw (when the delegate iterator has no throw
            // method) always terminates the yield* loop.
            context.delegate = null;

            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            var returnMethod = delegate.iterator["return"];
            if (returnMethod) {
              var record = tryCatch(returnMethod, delegate.iterator, arg);
              if (record.type === "throw") {
                // If the return method threw an exception, let that
                // exception prevail over the original return or throw.
                method = "throw";
                arg = record.arg;
                continue;
              }
            }

            if (method === "return") {
              // Continue with the outer return, now that the delegate
              // iterator has been terminated.
              continue;
            }
          }

          var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;
            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            context.sent = undefined;
          }
        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }
        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }
        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(arg) call above.
          method = "throw";
          arg = record.arg;
        }
      }
    };
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp[toStringTagSymbol] = "Generator";

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      this.sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function stop() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }
    },

    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
// Among the various tricks for obtaining a reference to the global
// object, this seems to be the most reliable technique that does not
// use indirect eval (which violates Content Security Policy).
typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : undefined);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":183,"babel-runtime/core-js/object/create":79,"babel-runtime/core-js/object/set-prototype-of":83,"babel-runtime/core-js/promise":84,"babel-runtime/core-js/symbol":86}],180:[function(require,module,exports){

/*
 * Konva JavaScript Framework v0.11.1
 * http://konvajs.github.io/
 * Licensed under the MIT or GPL Version 2 licenses.
 * Date: Sat Jan 16 2016
 *
 * Original work Copyright (C) 2011 - 2013 by Eric Rowell (KineticJS)
 * Modified work Copyright (C) 2014 - 2015 by Anton Lavrenov (Konva)
 *
 * @license
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

// runtime check for already included Konva
(function(){
    'use strict';
    /**
     * @namespace Konva
     */

    var PI_OVER_180 = Math.PI / 180;

    var Konva = {
        // public
        version: '0.11.1',

        // private
        stages: [],
        idCounter: 0,
        ids: {},
        names: {},
        shapes: {},
        listenClickTap: false,
        inDblClickWindow: false,

        // configurations
        enableTrace: false,
        traceArrMax: 100,
        dblClickWindow: 400,
        /**
         * Global pixel ratio configuration. KonvaJS automatically detect pixel ratio of current device.
         * But you may override such property, if you want to use your value.
         * @property pixelRatio
         * @default undefined
         * @memberof Konva
         * @example
         * Konva.pixelRatio = 1;
         */
        pixelRatio: undefined,
        /**
         * Drag distance property. If you start to drag a node you may want to wait until pointer is moved to some distance from start point,
         * only then start dragging.
         * @property dragDistance
         * @default 0
         * @memberof Konva
         * @example
         * Konva.dragDistance = 10;
         */
        dragDistance: 0,
        /**
         * Use degree values for angle properties. You may set this property to false if you want to use radiant values.
         * @property angleDeg
         * @default true
         * @memberof Konva
         * @example
         * node.rotation(45); // 45 degrees
         * Konva.angleDeg = false;
         * node.rotation(Math.PI / 2); // PI/2 radian
         */
        angleDeg: true,
         /**
         * Show different warnings about errors or wrong API usage
         * @property showWarnings
         * @default true
         * @memberof Konva
         * @example
         * Konva.showWarnings = false;
         */
        showWarnings: true,



        /**
         * @namespace Filters
         * @memberof Konva
         */
        Filters: {},

        /**
         * returns whether or not drag and drop is currently active
         * @method
         * @memberof Konva
         */
        isDragging: function() {
            var dd = Konva.DD;

            // if DD is not included with the build, then
            // drag and drop is not even possible
            if (dd) {
                return dd.isDragging;
            }
            return false;
        },
        /**
        * returns whether or not a drag and drop operation is ready, but may
        *  not necessarily have started
        * @method
        * @memberof Konva
        */
        isDragReady: function() {
            var dd = Konva.DD;

            // if DD is not included with the build, then
            // drag and drop is not even possible
            if (dd) {
                return !!dd.node;
            }
            return false;
        },
        _addId: function(node, id) {
            if(id !== undefined) {
                this.ids[id] = node;
            }
        },
        _removeId: function(id) {
            if(id !== undefined) {
                delete this.ids[id];
            }
        },
        _addName: function(node, name) {
            if(name) {
                if(!this.names[name]) {
                    this.names[name] = [];
                }
                this.names[name].push(node);
            }
        },
        _removeName: function(name, _id) {
            if(!name) {
                return;
            }
            var nodes = this.names[name];
            if(!nodes) {
                return;
            }
            for(var n = 0; n < nodes.length; n++) {
                var no = nodes[n];
                if(no._id === _id) {
                    nodes.splice(n, 1);
                }
            }
            if(nodes.length === 0) {
                delete this.names[name];
            }
        },
        getAngle: function(angle) {
            return this.angleDeg ? angle * PI_OVER_180 : angle;
        },
        _parseUA: function(userAgent) {
            var ua = userAgent.toLowerCase(),
                // jQuery UA regex
                match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
                /(webkit)[ \/]([\w.]+)/.exec( ua ) ||
                /(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
                /(msie) ([\w.]+)/.exec( ua ) ||
                ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
                [],

                // adding mobile flag as well
                mobile = !!(userAgent.match(/Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile/i)),
                ieMobile = !!(userAgent.match(/IEMobile/i));

            return {
                browser: match[ 1 ] || '',
                version: match[ 2 ] || '0',

                // adding mobile flab
                mobile: mobile,
                ieMobile: ieMobile  // If this is true (i.e., WP8), then Konva touch events are executed instead of equivalent Konva mouse events
            };
        },
        // user agent
        UA: undefined
    };

    var global =
        typeof window !== 'undefined' ? window :
        typeof global !== 'undefined' ? global :
        typeof WorkerGlobalScope !== 'undefined' ? self : {};


    Konva.UA = Konva._parseUA((global.navigator && global.navigator.userAgent) || '');

    if (global.Konva) {
        console.error(
            'Konva instance is already exist in current eviroment. ' +
            'Please use only one instance.'
        );
    }
    global.Konva = Konva;
    Konva.global = global;


    if( typeof exports === 'object') {
        // runtime-check for browserify and nw.js (node-webkit)
        if(global.window && global.window.document) {
            Konva.document = global.window.document;
            Konva.window = global.window;
        } else {
            // Node. Does not work with strict CommonJS, but
            // only CommonJS-like enviroments that support module.exports,
            // like Node.
            var Canvas = require('canvas');
            var jsdom = require('jsdom').jsdom;

            Konva.document = jsdom('<!DOCTYPE html><html><head></head><body></body></html>');
            Konva.window = Konva.document.parentWindow;
            Konva.window.Image = Canvas.Image;
            Konva._nodeCanvas = Canvas;
        }
        module.exports = Konva;
        return;
    }
    else if( typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(function() {
            return Konva;
        });
    }
    Konva.document = document;
    Konva.window = window;
})();

/*eslint-disable  eqeqeq, no-cond-assign, no-empty*/
(function() {
    'use strict';
    /**
     * Collection constructor.  Collection extends
     *  Array.  This class is used in conjunction with {@link Konva.Container#get}
     * @constructor
     * @memberof Konva
     */
    Konva.Collection = function() {
        var args = [].slice.call(arguments), length = args.length, i = 0;

        this.length = length;
        for(; i < length; i++) {
            this[i] = args[i];
        }
        return this;
    };
    Konva.Collection.prototype = [];
    /**
     * iterate through node array and run a function for each node.
     *  The node and index is passed into the function
     * @method
     * @memberof Konva.Collection.prototype
     * @param {Function} func
     * @example
     * // get all nodes with name foo inside layer, and set x to 10 for each
     * layer.get('.foo').each(function(shape, n) {
     *   shape.setX(10);
     * });
     */
    Konva.Collection.prototype.each = function(func) {
        for(var n = 0; n < this.length; n++) {
            func(this[n], n);
        }
    };
    /**
     * convert collection into an array
     * @method
     * @memberof Konva.Collection.prototype
     */
    Konva.Collection.prototype.toArray = function() {
        var arr = [],
            len = this.length,
            n;

        for(n = 0; n < len; n++) {
            arr.push(this[n]);
        }
        return arr;
    };
    /**
     * convert array into a collection
     * @method
     * @memberof Konva.Collection
     * @param {Array} arr
     */
    Konva.Collection.toCollection = function(arr) {
        var collection = new Konva.Collection(),
            len = arr.length,
            n;

        for(n = 0; n < len; n++) {
            collection.push(arr[n]);
        }
        return collection;
    };

    // map one method by it's name
    Konva.Collection._mapMethod = function(methodName) {
        Konva.Collection.prototype[methodName] = function() {
            var len = this.length,
                i;

            var args = [].slice.call(arguments);
            for(i = 0; i < len; i++) {
                this[i][methodName].apply(this[i], args);
            }

            return this;
        };
    };

    Konva.Collection.mapMethods = function(constructor) {
        var prot = constructor.prototype;
        for(var methodName in prot) {
            Konva.Collection._mapMethod(methodName);
        }
    };

    /*
    * Last updated November 2011
    * By Simon Sarris
    * www.simonsarris.com
    * sarris@acm.org
    *
    * Free to use and distribute at will
    * So long as you are nice to people, etc
    */

    /*
    * The usage of this class was inspired by some of the work done by a forked
    * project, KineticJS-Ext by Wappworks, which is based on Simon's Transform
    * class.  Modified by Eric Rowell
    */

    /**
     * Transform constructor
     * @constructor
     * @param {Array} [m] Optional six-element matrix
     * @memberof Konva
     */
    Konva.Transform = function(m) {
        this.m = (m && m.slice()) || [1, 0, 0, 1, 0, 0];
    };

    Konva.Transform.prototype = {
        /**
         * Copy Konva.Transform object
         * @method
         * @memberof Konva.Transform.prototype
         * @returns {Konva.Transform}
         */
        copy: function() {
            return new Konva.Transform(this.m);
        },
        /**
         * Transform point
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Object} point 2D point(x, y)
         * @returns {Object} 2D point(x, y)
         */
        point: function(point) {
            var m = this.m;
            return {
                x: m[0] * point.x + m[2] * point.y + m[4],
                y: m[1] * point.x + m[3] * point.y + m[5]
            };
        },
        /**
         * Apply translation
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Number} x
         * @param {Number} y
         * @returns {Konva.Transform}
         */
        translate: function(x, y) {
            this.m[4] += this.m[0] * x + this.m[2] * y;
            this.m[5] += this.m[1] * x + this.m[3] * y;
            return this;
        },
        /**
         * Apply scale
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Number} sx
         * @param {Number} sy
         * @returns {Konva.Transform}
         */
        scale: function(sx, sy) {
            this.m[0] *= sx;
            this.m[1] *= sx;
            this.m[2] *= sy;
            this.m[3] *= sy;
            return this;
        },
        /**
         * Apply rotation
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Number} rad  Angle in radians
         * @returns {Konva.Transform}
         */
        rotate: function(rad) {
            var c = Math.cos(rad);
            var s = Math.sin(rad);
            var m11 = this.m[0] * c + this.m[2] * s;
            var m12 = this.m[1] * c + this.m[3] * s;
            var m21 = this.m[0] * -s + this.m[2] * c;
            var m22 = this.m[1] * -s + this.m[3] * c;
            this.m[0] = m11;
            this.m[1] = m12;
            this.m[2] = m21;
            this.m[3] = m22;
            return this;
        },
        /**
         * Returns the translation
         * @method
         * @memberof Konva.Transform.prototype
         * @returns {Object} 2D point(x, y)
         */
        getTranslation: function() {
            return {
                x: this.m[4],
                y: this.m[5]
            };
        },
        /**
         * Apply skew
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Number} sx
         * @param {Number} sy
         * @returns {Konva.Transform}
         */
        skew: function(sx, sy) {
            var m11 = this.m[0] + this.m[2] * sy;
            var m12 = this.m[1] + this.m[3] * sy;
            var m21 = this.m[2] + this.m[0] * sx;
            var m22 = this.m[3] + this.m[1] * sx;
            this.m[0] = m11;
            this.m[1] = m12;
            this.m[2] = m21;
            this.m[3] = m22;
            return this;
         },
        /**
         * Transform multiplication
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Konva.Transform} matrix
         * @returns {Konva.Transform}
         */
        multiply: function(matrix) {
            var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
            var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];

            var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
            var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];

            var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
            var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];

            this.m[0] = m11;
            this.m[1] = m12;
            this.m[2] = m21;
            this.m[3] = m22;
            this.m[4] = dx;
            this.m[5] = dy;
            return this;
        },
        /**
         * Invert the matrix
         * @method
         * @memberof Konva.Transform.prototype
         * @returns {Konva.Transform}
         */
        invert: function() {
            var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
            var m0 = this.m[3] * d;
            var m1 = -this.m[1] * d;
            var m2 = -this.m[2] * d;
            var m3 = this.m[0] * d;
            var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
            var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
            this.m[0] = m0;
            this.m[1] = m1;
            this.m[2] = m2;
            this.m[3] = m3;
            this.m[4] = m4;
            this.m[5] = m5;
            return this;
        },
        /**
         * return matrix
         * @method
         * @memberof Konva.Transform.prototype
         */
        getMatrix: function() {
            return this.m;
        },
        /**
         * set to absolute position via translation
         * @method
         * @memberof Konva.Transform.prototype
         * @returns {Konva.Transform}
         * @author ericdrowell
         */
        setAbsolutePosition: function(x, y) {
            var m0 = this.m[0],
                m1 = this.m[1],
                m2 = this.m[2],
                m3 = this.m[3],
                m4 = this.m[4],
                m5 = this.m[5],
                yt = ((m0 * (y - m5)) - (m1 * (x - m4))) / ((m0 * m3) - (m1 * m2)),
                xt = (x - m4 - (m2 * yt)) / m0;

            return this.translate(xt, yt);
        }
    };

    // CONSTANTS
    var CONTEXT_2D = '2d',
        OBJECT_ARRAY = '[object Array]',
        OBJECT_NUMBER = '[object Number]',
        OBJECT_STRING = '[object String]',
        PI_OVER_DEG180 = Math.PI / 180,
        DEG180_OVER_PI = 180 / Math.PI,
        HASH = '#',
        EMPTY_STRING = '',
        ZERO = '0',
        KONVA_WARNING = 'Konva warning: ',
        KONVA_ERROR = 'Konva error: ',
        RGB_PAREN = 'rgb(',
        COLORS = {
            aliceblue: [240, 248, 255],
            antiquewhite: [250, 235, 215],
            aqua: [0, 255, 255],
            aquamarine: [127, 255, 212],
            azure: [240, 255, 255],
            beige: [245, 245, 220],
            bisque: [255, 228, 196],
            black: [0, 0, 0],
            blanchedalmond: [255, 235, 205],
            blue: [0, 0, 255],
            blueviolet: [138, 43, 226],
            brown: [165, 42, 42],
            burlywood: [222, 184, 135],
            cadetblue: [95, 158, 160],
            chartreuse: [127, 255, 0],
            chocolate: [210, 105, 30],
            coral: [255, 127, 80],
            cornflowerblue: [100, 149, 237],
            cornsilk: [255, 248, 220],
            crimson: [220, 20, 60],
            cyan: [0, 255, 255],
            darkblue: [0, 0, 139],
            darkcyan: [0, 139, 139],
            darkgoldenrod: [184, 132, 11],
            darkgray: [169, 169, 169],
            darkgreen: [0, 100, 0],
            darkgrey: [169, 169, 169],
            darkkhaki: [189, 183, 107],
            darkmagenta: [139, 0, 139],
            darkolivegreen: [85, 107, 47],
            darkorange: [255, 140, 0],
            darkorchid: [153, 50, 204],
            darkred: [139, 0, 0],
            darksalmon: [233, 150, 122],
            darkseagreen: [143, 188, 143],
            darkslateblue: [72, 61, 139],
            darkslategray: [47, 79, 79],
            darkslategrey: [47, 79, 79],
            darkturquoise: [0, 206, 209],
            darkviolet: [148, 0, 211],
            deeppink: [255, 20, 147],
            deepskyblue: [0, 191, 255],
            dimgray: [105, 105, 105],
            dimgrey: [105, 105, 105],
            dodgerblue: [30, 144, 255],
            firebrick: [178, 34, 34],
            floralwhite: [255, 255, 240],
            forestgreen: [34, 139, 34],
            fuchsia: [255, 0, 255],
            gainsboro: [220, 220, 220],
            ghostwhite: [248, 248, 255],
            gold: [255, 215, 0],
            goldenrod: [218, 165, 32],
            gray: [128, 128, 128],
            green: [0, 128, 0],
            greenyellow: [173, 255, 47],
            grey: [128, 128, 128],
            honeydew: [240, 255, 240],
            hotpink: [255, 105, 180],
            indianred: [205, 92, 92],
            indigo: [75, 0, 130],
            ivory: [255, 255, 240],
            khaki: [240, 230, 140],
            lavender: [230, 230, 250],
            lavenderblush: [255, 240, 245],
            lawngreen: [124, 252, 0],
            lemonchiffon: [255, 250, 205],
            lightblue: [173, 216, 230],
            lightcoral: [240, 128, 128],
            lightcyan: [224, 255, 255],
            lightgoldenrodyellow: [250, 250, 210],
            lightgray: [211, 211, 211],
            lightgreen: [144, 238, 144],
            lightgrey: [211, 211, 211],
            lightpink: [255, 182, 193],
            lightsalmon: [255, 160, 122],
            lightseagreen: [32, 178, 170],
            lightskyblue: [135, 206, 250],
            lightslategray: [119, 136, 153],
            lightslategrey: [119, 136, 153],
            lightsteelblue: [176, 196, 222],
            lightyellow: [255, 255, 224],
            lime: [0, 255, 0],
            limegreen: [50, 205, 50],
            linen: [250, 240, 230],
            magenta: [255, 0, 255],
            maroon: [128, 0, 0],
            mediumaquamarine: [102, 205, 170],
            mediumblue: [0, 0, 205],
            mediumorchid: [186, 85, 211],
            mediumpurple: [147, 112, 219],
            mediumseagreen: [60, 179, 113],
            mediumslateblue: [123, 104, 238],
            mediumspringgreen: [0, 250, 154],
            mediumturquoise: [72, 209, 204],
            mediumvioletred: [199, 21, 133],
            midnightblue: [25, 25, 112],
            mintcream: [245, 255, 250],
            mistyrose: [255, 228, 225],
            moccasin: [255, 228, 181],
            navajowhite: [255, 222, 173],
            navy: [0, 0, 128],
            oldlace: [253, 245, 230],
            olive: [128, 128, 0],
            olivedrab: [107, 142, 35],
            orange: [255, 165, 0],
            orangered: [255, 69, 0],
            orchid: [218, 112, 214],
            palegoldenrod: [238, 232, 170],
            palegreen: [152, 251, 152],
            paleturquoise: [175, 238, 238],
            palevioletred: [219, 112, 147],
            papayawhip: [255, 239, 213],
            peachpuff: [255, 218, 185],
            peru: [205, 133, 63],
            pink: [255, 192, 203],
            plum: [221, 160, 203],
            powderblue: [176, 224, 230],
            purple: [128, 0, 128],
            rebeccapurple: [102, 51, 153],
            red: [255, 0, 0],
            rosybrown: [188, 143, 143],
            royalblue: [65, 105, 225],
            saddlebrown: [139, 69, 19],
            salmon: [250, 128, 114],
            sandybrown: [244, 164, 96],
            seagreen: [46, 139, 87],
            seashell: [255, 245, 238],
            sienna: [160, 82, 45],
            silver: [192, 192, 192],
            skyblue: [135, 206, 235],
            slateblue: [106, 90, 205],
            slategray: [119, 128, 144],
            slategrey: [119, 128, 144],
            snow: [255, 255, 250],
            springgreen: [0, 255, 127],
            steelblue: [70, 130, 180],
            tan: [210, 180, 140],
            teal: [0, 128, 128],
            thistle: [216, 191, 216],
            transparent: [255, 255, 255, 0],
            tomato: [255, 99, 71],
            turquoise: [64, 224, 208],
            violet: [238, 130, 238],
            wheat: [245, 222, 179],
            white: [255, 255, 255],
            whitesmoke: [245, 245, 245],
            yellow: [255, 255, 0],
            yellowgreen: [154, 205, 5]
        },

        RGB_REGEX = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/;

    /**
     * @namespace Util
     * @memberof Konva
     */
    Konva.Util = {
        /*
         * cherry-picked utilities from underscore.js
         */
        _isElement: function(obj) {
            return !!(obj && obj.nodeType == 1);
        },
        _isFunction: function(obj) {
            return !!(obj && obj.constructor && obj.call && obj.apply);
        },
        _isObject: function(obj) {
            return (!!obj && obj.constructor === Object);
        },
        _isArray: function(obj) {
            return Object.prototype.toString.call(obj) === OBJECT_ARRAY;
        },
        _isNumber: function(obj) {
            return Object.prototype.toString.call(obj) === OBJECT_NUMBER;
        },
        _isString: function(obj) {
            return Object.prototype.toString.call(obj) === OBJECT_STRING;
        },
        // Returns a function, that, when invoked, will only be triggered at most once
        // during a given window of time. Normally, the throttled function will run
        // as much as it can, without ever going more than once per `wait` duration;
        // but if you'd like to disable the execution on the leading edge, pass
        // `{leading: false}`. To disable execution on the trailing edge, ditto.
        _throttle: function(func, wait, opts) {
            var context, args, result;
            var timeout = null;
            var previous = 0;
            var options = opts || {};
            var later = function() {
                previous = options.leading === false ? 0 : new Date().getTime();
                timeout = null;
                result = func.apply(context, args);
                context = args = null;
            };
            return function() {
                var now = new Date().getTime();
                if (!previous && options.leading === false) {
                    previous = now;
                }
                var remaining = wait - (now - previous);
                context = this;
                args = arguments;
                if (remaining <= 0) {
                  clearTimeout(timeout);
                  timeout = null;
                  previous = now;
                  result = func.apply(context, args);
                  context = args = null;
                } else if (!timeout && options.trailing !== false) {
                  timeout = setTimeout(later, remaining);
                }
                return result;
            };
        },
        /*
         * other utils
         */
        _hasMethods: function(obj) {
            var names = [],
                key;

            for(key in obj) {
                if (!obj.hasOwnProperty(key)) {
                    continue;
                }
                if(this._isFunction(obj[key])) {
                    names.push(key);
                }
            }
            return names.length > 0;
        },
        isValidSelector: function(selector) {
            if (typeof selector !== 'string') {
                return false;
            }
            var firstChar = selector[0];
            return firstChar === '#' || firstChar === '.' || firstChar === firstChar.toUpperCase();
        },
        createCanvasElement: function() {
            var canvas = Konva.document.createElement('canvas');
            // on some environments canvas.style is readonly
            try {
                canvas.style = canvas.style || {};
            } catch (e) {
            }
            return canvas;
        },
        isBrowser: function() {
            return (typeof exports !== 'object');
        },
        _isInDocument: function(el) {
            while(el = el.parentNode) {
                if(el == Konva.document) {
                    return true;
                }
            }
            return false;
        },
        _simplifyArray: function(arr) {
            var retArr = [],
                len = arr.length,
                util = Konva.Util,
                n, val;

            for (n = 0; n < len; n++) {
                val = arr[n];
                if (util._isNumber(val)) {
                    val = Math.round(val * 1000) / 1000;
                }
                else if (!util._isString(val)) {
                    val = val.toString();
                }

                retArr.push(val);
            }

            return retArr;
        },
        /*
         * arg can be an image object or image data
         */
        _getImage: function(arg, callback) {
            var imageObj, canvas;

            // if arg is null or undefined
            if(!arg) {
                callback(null);
            }

            // if arg is already an image object
            else if(this._isElement(arg)) {
                callback(arg);
            }

            // if arg is a string, then it's a data url
            else if(this._isString(arg)) {
                imageObj = new Konva.window.Image();
                imageObj.onload = function() {
                    callback(imageObj);
                };
                imageObj.src = arg;
            }

            //if arg is an object that contains the data property, it's an image object
            else if(arg.data) {
                canvas = Konva.Util.createCanvasElement();
                canvas.width = arg.width;
                canvas.height = arg.height;
                var _context = canvas.getContext(CONTEXT_2D);
                _context.putImageData(arg, 0, 0);
                this._getImage(canvas.toDataURL(), callback);
            }
            else {
                callback(null);
            }
        },
        _getRGBAString: function(obj) {
            var red = obj.red || 0,
                green = obj.green || 0,
                blue = obj.blue || 0,
                alpha = obj.alpha || 1;

            return [
                'rgba(',
                red,
                ',',
                green,
                ',',
                blue,
                ',',
                alpha,
                ')'
            ].join(EMPTY_STRING);
        },
        _rgbToHex: function(r, g, b) {
            return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        },
        _hexToRgb: function(hex) {
            hex = hex.replace(HASH, EMPTY_STRING);
            var bigint = parseInt(hex, 16);
            return {
                r: (bigint >> 16) & 255,
                g: (bigint >> 8) & 255,
                b: bigint & 255
            };
        },
        /**
         * return random hex color
         * @method
         * @memberof Konva.Util.prototype
         */
        getRandomColor: function() {
            var randColor = (Math.random() * 0xFFFFFF << 0).toString(16);
            while (randColor.length < 6) {
                randColor = ZERO + randColor;
            }
            return HASH + randColor;
        },
        /**
         * return value with default fallback
         * @method
         * @memberof Konva.Util.prototype
         */
        get: function(val, def) {
            if (val === undefined) {
                return def;
            }
            else {
                return val;
            }
        },
        /**
         * get RGB components of a color
         * @method
         * @memberof Konva.Util.prototype
         * @param {String} color
         * @example
         * // each of the following examples return {r:0, g:0, b:255}
         * var rgb = Konva.Util.getRGB('blue');
         * var rgb = Konva.Util.getRGB('#0000ff');
         * var rgb = Konva.Util.getRGB('rgb(0,0,255)');
         */
        getRGB: function(color) {
            var rgb;
            // color string
            if (color in COLORS) {
                rgb = COLORS[color];
                return {
                    r: rgb[0],
                    g: rgb[1],
                    b: rgb[2]
                };
            }
            // hex
            else if (color[0] === HASH) {
                return this._hexToRgb(color.substring(1));
            }
            // rgb string
            else if (color.substr(0, 4) === RGB_PAREN) {
                rgb = RGB_REGEX.exec(color.replace(/ /g, ''));
                return {
                    r: parseInt(rgb[1], 10),
                    g: parseInt(rgb[2], 10),
                    b: parseInt(rgb[3], 10)
                };
            }
            // default
            else {
                return {
                    r: 0,
                    g: 0,
                    b: 0
                };
            }
        },
        // convert any color string to RGBA object
        // from https://github.com/component/color-parser
        colorToRGBA: function(str) {
            str = str || 'black';
            return Konva.Util._namedColorToRBA(str)
                || Konva.Util._hex3ColorToRGBA(str)
                || Konva.Util._hex6ColorToRGBA(str)
                || Konva.Util._rgbColorToRGBA(str)
                || Konva.Util._rgbaColorToRGBA(str);
        },
        // Parse named css color. Like "green"
        _namedColorToRBA: function(str) {
            var c = COLORS[str.toLowerCase()];
            if (!c) {
                return null;
            }
            return {
                r: c[0],
                g: c[1],
                b: c[2],
                a: 1
            };
        },
        // Parse rgb(n, n, n)
        _rgbColorToRGBA: function(str) {
            if (str.indexOf('rgb(') === 0) {
                str = str.match(/rgb\(([^)]+)\)/)[1];
                var parts = str.split(/ *, */).map(Number);
                return {
                    r: parts[0],
                    g: parts[1],
                    b: parts[2],
                    a: 1
                };
            }
        },
        // Parse rgba(n, n, n, n)
        _rgbaColorToRGBA: function(str) {
            if (str.indexOf('rgba(') === 0) {
                str = str.match(/rgba\(([^)]+)\)/)[1];
                var parts = str.split(/ *, */).map(Number);
                return {
                    r: parts[0],
                    g: parts[1],
                    b: parts[2],
                    a: parts[3]
                };
            }

        },
        // Parse #nnnnnn
        _hex6ColorToRGBA: function(str) {
            if ((str[0] === '#') && (str.length === 7)) {
                return {
                    r: parseInt(str.slice(1, 3), 16),
                    g: parseInt(str.slice(3, 5), 16),
                    b: parseInt(str.slice(5, 7), 16),
                    a: 1
                };
            }
        },
        // Parse #nnn
        _hex3ColorToRGBA: function(str) {
            if ((str[0] === '#') && (str.length === 4)) {
                return {
                    r: parseInt(str[1] + str[1], 16),
                    g: parseInt(str[2] + str[2], 16),
                    b: parseInt(str[3] + str[3], 16),
                    a: 1
                };
            }
        },
        // o1 takes precedence over o2
        _merge: function(o1, o2) {
            var retObj = this._clone(o2);
            for(var key in o1) {
                if(this._isObject(o1[key])) {
                    retObj[key] = this._merge(o1[key], retObj[key]);
                }
                else {
                    retObj[key] = o1[key];
                }
            }
            return retObj;
        },
        cloneObject: function(obj) {
            var retObj = {};
            for(var key in obj) {
                if(this._isObject(obj[key])) {
                    retObj[key] = this.cloneObject(obj[key]);
                }
                else if (this._isArray(obj[key])) {
                    retObj[key] = this.cloneArray(obj[key]);
                } else {
                    retObj[key] = obj[key];
                }
            }
            return retObj;
        },
        cloneArray: function(arr) {
            return arr.slice(0);
        },
        _degToRad: function(deg) {
            return deg * PI_OVER_DEG180;
        },
        _radToDeg: function(rad) {
            return rad * DEG180_OVER_PI;
        },
        _capitalize: function(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        },
        throw: function(str) {
            throw new Error(KONVA_ERROR + str);
        },
        error: function(str) {
          console.error(KONVA_ERROR + str);
        },
        warn: function(str) {
            /*
             * IE9 on Windows7 64bit will throw a JS error
             * if we don't use window.console in the conditional
             */
            if(Konva.global.console && console.warn && Konva.showWarnings) {
                console.warn(KONVA_WARNING + str);
            }
        },
        extend: function(child, parent) {
            function Ctor() {
                this.constructor = child;
            }
            Ctor.prototype = parent.prototype;
            var oldProto = child.prototype;
            child.prototype = new Ctor();
            for (var key in oldProto) {
                if (oldProto.hasOwnProperty(key)) {
                    child.prototype[key] = oldProto[key];
                }
            }
            child.__super__ = parent.prototype;
            // create reference to parent
            child.super = parent;
        },
        /**
         * adds methods to a constructor prototype
         * @method
         * @memberof Konva.Util.prototype
         * @param {Function} constructor
         * @param {Object} methods
         */
        addMethods: function(constructor, methods) {
            var key;

            for (key in methods) {
                constructor.prototype[key] = methods[key];
            }
        },
        _getControlPoints: function(x0, y0, x1, y1, x2, y2, t) {
            var d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)),
                d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)),
                fa = t * d01 / (d01 + d12),
                fb = t * d12 / (d01 + d12),
                p1x = x1 - fa * (x2 - x0),
                p1y = y1 - fa * (y2 - y0),
                p2x = x1 + fb * (x2 - x0),
                p2y = y1 + fb * (y2 - y0);

            return [p1x, p1y, p2x, p2y];
        },
        _expandPoints: function(p, tension) {
            var len = p.length,
                allPoints = [],
                n, cp;

            for (n = 2; n < len - 2; n += 2) {
                cp = Konva.Util._getControlPoints(p[n - 2], p[n - 1], p[n], p[n + 1], p[n + 2], p[n + 3], tension);
                allPoints.push(cp[0]);
                allPoints.push(cp[1]);
                allPoints.push(p[n]);
                allPoints.push(p[n + 1]);
                allPoints.push(cp[2]);
                allPoints.push(cp[3]);
            }

            return allPoints;
        },
        _removeLastLetter: function(str) {
            return str.substring(0, str.length - 1);
        },
        each: function(obj, func) {
            for (var key in obj) {
                func(key, obj[key]);
            }
        },
        _getProjectionToSegment: function(x1, y1, x2, y2, x3, y3) {
            var x, y, dist;

            var pd2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
            if(pd2 == 0) {
                x = x1;
                y = y1;
                dist = (x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2);
            } else {
                var u = ((x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1)) / pd2;
                if(u < 0) {
                    x = x1;
                    y = y1;
                    dist = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3);
                } else if (u > 1.0) {
                    x = x2;
                    y = y2;
                    dist = (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3);
                } else {
                    x = x1 + u * (x2 - x1);
                    y = y1 + u * (y2 - y1);
                    dist = (x - x3) * (x - x3) + (y - y3) * (y - y3);
                }
            }
            return [x, y, dist];
        },
        // line as array of points.
        // line might be closed
        _getProjectionToLine: function(pt, line, isClosed) {
            var pc = Konva.Util.cloneObject(pt);
            var dist = Number.MAX_VALUE;
            line.forEach(function(p1, i) {
                if (!isClosed && i === line.length - 1) {
                    return;
                }
                var p2 = line[(i + 1) % line.length];
                var proj = Konva.Util._getProjectionToSegment(p1.x, p1.y, p2.x, p2.y, pt.x, pt.y);
                var px = proj[0], py = proj[1], pdist = proj[2];
                if (pdist < dist) {
                    pc.x = px;
                    pc.y = py;
                    dist = pdist;
                }
            });
            return pc;
        },
        _prepareArrayForTween: function(startArray, endArray, isClosed) {
            var n, start = [], end = [];
            if (startArray.length > endArray.length) {
                var temp = endArray;
                endArray = startArray;
                startArray = temp;
            }
            for (n = 0; n < startArray.length; n += 2) {
                start.push({
                    x: startArray[n],
                    y: startArray[n + 1]
                });
            }
            for (n = 0; n < endArray.length; n += 2) {
                end.push({
                    x: endArray[n],
                    y: endArray[n + 1]
                });
            }


            var newStart = [];
            end.forEach(function(point) {
                var pr = Konva.Util._getProjectionToLine(point, start, isClosed);
                newStart.push(pr.x);
                newStart.push(pr.y);
            });
            return newStart;
        }
    };
})();

(function() {
    'use strict';
    // calculate pixel ratio
    var canvas = Konva.Util.createCanvasElement(),
        context = canvas.getContext('2d'),
        _pixelRatio = (function(){
            var devicePixelRatio = Konva.window.devicePixelRatio || 1,
            backingStoreRatio = context.webkitBackingStorePixelRatio
                || context.mozBackingStorePixelRatio
                || context.msBackingStorePixelRatio
                || context.oBackingStorePixelRatio
                || context.backingStorePixelRatio
                || 1;
            return devicePixelRatio / backingStoreRatio;
        })();

    /**
     * Canvas Renderer constructor
     * @constructor
     * @abstract
     * @memberof Konva
     * @param {Object} config
     * @param {Number} config.width
     * @param {Number} config.height
     * @param {Number} config.pixelRatio KonvaJS automatically handles pixel ratio adjustments in order to render crisp drawings
     *  on all devices. Most desktops, low end tablets, and low end phones, have device pixel ratios
     *  of 1.  Some high end tablets and phones, like iPhones and iPads (not the mini) have a device pixel ratio
     *  of 2.  Some Macbook Pros, and iMacs also have a device pixel ratio of 2.  Some high end Android devices have pixel
     *  ratios of 2 or 3.  Some browsers like Firefox allow you to configure the pixel ratio of the viewport.  Unless otherwise
     *  specified, the pixel ratio will be defaulted to the actual device pixel ratio.  You can override the device pixel
     *  ratio for special situations, or, if you don't want the pixel ratio to be taken into account, you can set it to 1.
     */
    Konva.Canvas = function(config) {
        this.init(config);
    };

    Konva.Canvas.prototype = {
        init: function(config) {
            var conf = config || {};

            var pixelRatio = conf.pixelRatio || Konva.pixelRatio || _pixelRatio;

            this.pixelRatio = pixelRatio;
            this._canvas = Konva.Util.createCanvasElement();

            // set inline styles
            this._canvas.style.padding = 0;
            this._canvas.style.margin = 0;
            this._canvas.style.border = 0;
            this._canvas.style.background = 'transparent';
            this._canvas.style.position = 'absolute';
            this._canvas.style.top = 0;
            this._canvas.style.left = 0;
        },
        /**
         * get canvas context
         * @method
         * @memberof Konva.Canvas.prototype
         * @returns {CanvasContext} context
         */
        getContext: function() {
            return this.context;
        },
        /**
         * get pixel ratio
         * @method
         * @memberof Konva.Canvas.prototype
         * @returns {Number} pixel ratio
         */
        getPixelRatio: function() {
            return this.pixelRatio;
        },
        /**
         * get pixel ratio
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {Number} pixelRatio KonvaJS automatically handles pixel ratio adustments in order to render crisp drawings
         *  on all devices. Most desktops, low end tablets, and low end phones, have device pixel ratios
         *  of 1.  Some high end tablets and phones, like iPhones and iPads have a device pixel ratio
         *  of 2.  Some Macbook Pros, and iMacs also have a device pixel ratio of 2.  Some high end Android devices have pixel
         *  ratios of 2 or 3.  Some browsers like Firefox allow you to configure the pixel ratio of the viewport.  Unless otherwise
         *  specificed, the pixel ratio will be defaulted to the actual device pixel ratio.  You can override the device pixel
         *  ratio for special situations, or, if you don't want the pixel ratio to be taken into account, you can set it to 1.
         */
        setPixelRatio: function(pixelRatio) {
            var previousRatio = this.pixelRatio;
            this.pixelRatio = pixelRatio;
            this.setSize(this.getWidth() / previousRatio, this.getHeight() / previousRatio);
        },
        /**
         * set width
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {Number} width
         */
        setWidth: function(width) {
            // take into account pixel ratio
            this.width = this._canvas.width = width * this.pixelRatio;
            this._canvas.style.width = width + 'px';

            var pixelRatio = this.pixelRatio,
                _context = this.getContext()._context;
            _context.scale(pixelRatio, pixelRatio);
        },
        /**
         * set height
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {Number} height
         */
        setHeight: function(height) {
            // take into account pixel ratio
            this.height = this._canvas.height = height * this.pixelRatio;
            this._canvas.style.height = height + 'px';
            var pixelRatio = this.pixelRatio,
                _context = this.getContext()._context;
            _context.scale(pixelRatio, pixelRatio);
        },
        /**
         * get width
         * @method
         * @memberof Konva.Canvas.prototype
         * @returns {Number} width
         */
        getWidth: function() {
            return this.width;
        },
        /**
         * get height
         * @method
         * @memberof Konva.Canvas.prototype
         * @returns {Number} height
         */
        getHeight: function() {
            return this.height;
        },
        /**
         * set size
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {Number} width
         * @param {Number} height
         */
        setSize: function(width, height) {
            this.setWidth(width);
            this.setHeight(height);
        },
        /**
         * to data url
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {String} mimeType
         * @param {Number} quality between 0 and 1 for jpg mime types
         * @returns {String} data url string
         */
        toDataURL: function(mimeType, quality) {
            try {
                // If this call fails (due to browser bug, like in Firefox 3.6),
                // then revert to previous no-parameter image/png behavior
                return this._canvas.toDataURL(mimeType, quality);
            }
            catch(e) {
                try {
                    return this._canvas.toDataURL();
                }
                catch(err) {
                    Konva.Util.warn('Unable to get data URL. ' + err.message);
                    return '';
                }
            }
        }
    };

    Konva.SceneCanvas = function(config) {
        var conf = config || {};
        var width = conf.width || 0,
            height = conf.height || 0;

        Konva.Canvas.call(this, conf);
        this.context = new Konva.SceneContext(this);
        this.setSize(width, height);
    };

    Konva.Util.extend(Konva.SceneCanvas, Konva.Canvas);

    Konva.HitCanvas = function(config) {
        var conf = config || {};
        var width = conf.width || 0,
            height = conf.height || 0;

        Konva.Canvas.call(this, conf);
        this.context = new Konva.HitContext(this);
        this.setSize(width, height);
        this.hitCanvas = true;
    };
    Konva.Util.extend(Konva.HitCanvas, Konva.Canvas);

})();

(function() {
    'use strict';
    var COMMA = ',',
        OPEN_PAREN = '(',
        CLOSE_PAREN = ')',
        OPEN_PAREN_BRACKET = '([',
        CLOSE_BRACKET_PAREN = '])',
        SEMICOLON = ';',
        DOUBLE_PAREN = '()',
        // EMPTY_STRING = '',
        EQUALS = '=',
        // SET = 'set',
        CONTEXT_METHODS = [
            'arc',
            'arcTo',
            'beginPath',
            'bezierCurveTo',
            'clearRect',
            'clip',
            'closePath',
            'createLinearGradient',
            'createPattern',
            'createRadialGradient',
            'drawImage',
            'fill',
            'fillText',
            'getImageData',
            'createImageData',
            'lineTo',
            'moveTo',
            'putImageData',
            'quadraticCurveTo',
            'rect',
            'restore',
            'rotate',
            'save',
            'scale',
            'setLineDash',
            'setTransform',
            'stroke',
            'strokeText',
            'transform',
            'translate'
        ];

    var CONTEXT_PROPERTIES = ['fillStyle', 'strokeStyle', 'shadowColor', 'shadowBlur', 'shadowOffsetX',
        'shadowOffsetY', 'lineCap', 'lineJoin', 'lineWidth', 'miterLimit', 'font', 'textAlign', 'textBaseline',
        'globalAlpha', 'globalCompositeOperation'];

    /**
     * Canvas Context constructor
     * @constructor
     * @abstract
     * @memberof Konva
     */
    Konva.Context = function(canvas) {
        this.init(canvas);
    };

    Konva.Context.prototype = {
        init: function(canvas) {
            this.canvas = canvas;
            this._context = canvas._canvas.getContext('2d');

            if (Konva.enableTrace) {
                this.traceArr = [];
                this._enableTrace();
            }
        },
        /**
         * fill shape
         * @method
         * @memberof Konva.Context.prototype
         * @param {Konva.Shape} shape
         */
        fillShape: function(shape) {
            if(shape.getFillEnabled()) {
                this._fill(shape);
            }
        },
        /**
         * stroke shape
         * @method
         * @memberof Konva.Context.prototype
         * @param {Konva.Shape} shape
         */
        strokeShape: function(shape) {
            if(shape.getStrokeEnabled()) {
                this._stroke(shape);
            }
        },
        /**
         * fill then stroke
         * @method
         * @memberof Konva.Context.prototype
         * @param {Konva.Shape} shape
         */
        fillStrokeShape: function(shape) {
            var fillEnabled = shape.getFillEnabled();
            if(fillEnabled) {
                this._fill(shape);
            }
            if(shape.getStrokeEnabled()) {
                this._stroke(shape);
            }
        },
        /**
         * get context trace if trace is enabled
         * @method
         * @memberof Konva.Context.prototype
         * @param {Boolean} relaxed if false, return strict context trace, which includes method names, method parameters
         *  properties, and property values.  If true, return relaxed context trace, which only returns method names and
         *  properites.
         * @returns {String}
         */
        getTrace: function(relaxed) {
            var traceArr = this.traceArr,
                len = traceArr.length,
                str = '',
                n, trace, method, args;

            for (n = 0; n < len; n++) {
                trace = traceArr[n];
                method = trace.method;

                // methods
                if (method) {
                    args = trace.args;
                    str += method;
                    if (relaxed) {
                        str += DOUBLE_PAREN;
                    }
                    else {
                        if (Konva.Util._isArray(args[0])) {
                            str += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;
                        }
                        else {
                            str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;
                        }
                    }
                }
                // properties
                else {
                    str += trace.property;
                    if (!relaxed) {
                        str += EQUALS + trace.val;
                    }
                }

                str += SEMICOLON;
            }

            return str;
        },
        /**
         * clear trace if trace is enabled
         * @method
         * @memberof Konva.Context.prototype
         */
        clearTrace: function() {
            this.traceArr = [];
        },
        _trace: function(str) {
            var traceArr = this.traceArr,
                len;

            traceArr.push(str);
            len = traceArr.length;

            if (len >= Konva.traceArrMax) {
                traceArr.shift();
            }
        },
        /**
         * reset canvas context transform
         * @method
         * @memberof Konva.Context.prototype
         */
        reset: function() {
            var pixelRatio = this.getCanvas().getPixelRatio();
            this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);
        },
        /**
         * get canvas
         * @method
         * @memberof Konva.Context.prototype
         * @returns {Konva.Canvas}
         */
        getCanvas: function() {
            return this.canvas;
        },
        /**
         * clear canvas
         * @method
         * @memberof Konva.Context.prototype
         * @param {Object} [bounds]
         * @param {Number} [bounds.x]
         * @param {Number} [bounds.y]
         * @param {Number} [bounds.width]
         * @param {Number} [bounds.height]
         */
        clear: function(bounds) {
            var canvas = this.getCanvas();

            if (bounds) {
                this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0);
            }
            else {
                this.clearRect(0, 0, canvas.getWidth() / canvas.pixelRatio, canvas.getHeight() / canvas.pixelRatio);
            }
        },
        _applyLineCap: function(shape) {
            var lineCap = shape.getLineCap();
            if(lineCap) {
                this.setAttr('lineCap', lineCap);
            }
        },
        _applyOpacity: function(shape) {
            var absOpacity = shape.getAbsoluteOpacity();
            if(absOpacity !== 1) {
                this.setAttr('globalAlpha', absOpacity);
            }
        },
        _applyLineJoin: function(shape) {
            var lineJoin = shape.getLineJoin();
            if(lineJoin) {
                this.setAttr('lineJoin', lineJoin);
            }
        },
        setAttr: function(attr, val) {
            this._context[attr] = val;
        },

        // context pass through methods
        arc: function() {
            var a = arguments;
            this._context.arc(a[0], a[1], a[2], a[3], a[4], a[5]);
        },
        beginPath: function() {
            this._context.beginPath();
        },
        bezierCurveTo: function() {
            var a = arguments;
            this._context.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5]);
        },
        clearRect: function() {
            var a = arguments;
            this._context.clearRect(a[0], a[1], a[2], a[3]);
        },
        clip: function() {
            this._context.clip();
        },
        closePath: function() {
            this._context.closePath();
        },
        createImageData: function() {
            var a = arguments;
            if(a.length === 2) {
                return this._context.createImageData(a[0], a[1]);
            }
            else if(a.length === 1) {
                return this._context.createImageData(a[0]);
            }
        },
        createLinearGradient: function() {
            var a = arguments;
            return this._context.createLinearGradient(a[0], a[1], a[2], a[3]);
        },
        createPattern: function() {
            var a = arguments;
            return this._context.createPattern(a[0], a[1]);
        },
        createRadialGradient: function() {
            var a = arguments;
            return this._context.createRadialGradient(a[0], a[1], a[2], a[3], a[4], a[5]);
        },
        drawImage: function() {
            var a = arguments,
                _context = this._context;

            if(a.length === 3) {
                _context.drawImage(a[0], a[1], a[2]);
            }
            else if(a.length === 5) {
                _context.drawImage(a[0], a[1], a[2], a[3], a[4]);
            }
            else if(a.length === 9) {
                _context.drawImage(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
            }
        },
        isPointInPath: function(x, y) {
            return this._context.isPointInPath(x, y);
        },
        fill: function() {
            this._context.fill();
        },
        fillRect: function(x, y, width, height) {
            this._context.fillRect(x, y, width, height);
        },
        strokeRect: function(x, y, width, height) {
            this._context.strokeRect(x, y, width, height);
        },
        fillText: function() {
            var a = arguments;
            this._context.fillText(a[0], a[1], a[2]);
        },
        measureText: function(text) {
            return this._context.measureText(text);
        },
        getImageData: function() {
            var a = arguments;
            return this._context.getImageData(a[0], a[1], a[2], a[3]);
        },
        lineTo: function() {
            var a = arguments;
            this._context.lineTo(a[0], a[1]);
        },
        moveTo: function() {
            var a = arguments;
            this._context.moveTo(a[0], a[1]);
        },
        rect: function() {
            var a = arguments;
            this._context.rect(a[0], a[1], a[2], a[3]);
        },
        putImageData: function() {
            var a = arguments;
            this._context.putImageData(a[0], a[1], a[2]);
        },
        quadraticCurveTo: function() {
            var a = arguments;
            this._context.quadraticCurveTo(a[0], a[1], a[2], a[3]);
        },
        restore: function() {
            this._context.restore();
        },
        rotate: function() {
            var a = arguments;
            this._context.rotate(a[0]);
        },
        save: function() {
            this._context.save();
        },
        scale: function() {
            var a = arguments;
            this._context.scale(a[0], a[1]);
        },
        setLineDash: function() {
            var a = arguments,
                _context = this._context;

            // works for Chrome and IE11
            if(this._context.setLineDash) {
                _context.setLineDash(a[0]);
            }
            // verified that this works in firefox
            else if('mozDash' in _context) {
                _context.mozDash = a[0];
            }
            // does not currently work for Safari
            else if('webkitLineDash' in _context) {
                _context.webkitLineDash = a[0];
            }

            // no support for IE9 and IE10
        },
        getLineDash: function() {
            return this._context.getLineDash();
        },
        setTransform: function() {
            var a = arguments;
            this._context.setTransform(a[0], a[1], a[2], a[3], a[4], a[5]);
        },
        stroke: function() {
            this._context.stroke();
        },
        strokeText: function() {
            var a = arguments;
            this._context.strokeText(a[0], a[1], a[2]);
        },
        transform: function() {
            var a = arguments;
            this._context.transform(a[0], a[1], a[2], a[3], a[4], a[5]);
        },
        translate: function() {
            var a = arguments;
            this._context.translate(a[0], a[1]);
        },
        _enableTrace: function() {
            var that = this,
                len = CONTEXT_METHODS.length,
                _simplifyArray = Konva.Util._simplifyArray,
                origSetter = this.setAttr,
                n, args;

            // to prevent creating scope function at each loop
            var func = function(methodName) {
                    var origMethod = that[methodName],
                        ret;

                    that[methodName] = function() {
                        args = _simplifyArray(Array.prototype.slice.call(arguments, 0));
                        ret = origMethod.apply(that, arguments);

                        if (methodName === 'clearRect') {
                            args[2] = args[2] / that.canvas.getPixelRatio();
                            args[3] = args[3] / that.canvas.getPixelRatio();
                        }
                        that._trace({
                            method: methodName,
                            args: args
                        });

                        return ret;
                    };
            };
            // methods
            for (n = 0; n < len; n++) {
                func(CONTEXT_METHODS[n]);
            }

            // attrs
            that.setAttr = function() {
                origSetter.apply(that, arguments);
                that._trace({
                    property: arguments[0],
                    val: arguments[1]
                });
            };
        }
    };

    CONTEXT_PROPERTIES.forEach(function(prop) {
        Object.defineProperty(Konva.Context.prototype, prop, {
            get: function () {
                return this._context[prop];
            },
            set: function (val) {
                this._context[prop] = val;
            }
        });
    });

    Konva.SceneContext = function(canvas) {
        Konva.Context.call(this, canvas);
    };

    Konva.SceneContext.prototype = {
        _fillColor: function(shape) {
            var fill = shape.fill();

            this.setAttr('fillStyle', fill);
            shape._fillFunc(this);
        },
        _fillPattern: function(shape) {
            var fillPatternX = shape.getFillPatternX(),
                fillPatternY = shape.getFillPatternY(),
                fillPatternScale = shape.getFillPatternScale(),
                fillPatternRotation = Konva.getAngle(shape.getFillPatternRotation()),
                fillPatternOffset = shape.getFillPatternOffset();

            if(fillPatternX || fillPatternY) {
                this.translate(fillPatternX || 0, fillPatternY || 0);
            }
            if(fillPatternRotation) {
                this.rotate(fillPatternRotation);
            }
            if(fillPatternScale) {
                this.scale(fillPatternScale.x, fillPatternScale.y);
            }
            if(fillPatternOffset) {
                this.translate(-1 * fillPatternOffset.x, -1 * fillPatternOffset.y);
            }

            this.setAttr('fillStyle', this.createPattern(shape.getFillPatternImage(), shape.getFillPatternRepeat() || 'repeat'));
            this.fill();
        },
        _fillLinearGradient: function(shape) {
            var start = shape.getFillLinearGradientStartPoint(),
                end = shape.getFillLinearGradientEndPoint(),
                colorStops = shape.getFillLinearGradientColorStops(),
                grd = this.createLinearGradient(start.x, start.y, end.x, end.y);

            if (colorStops) {
                // build color stops
                for(var n = 0; n < colorStops.length; n += 2) {
                    grd.addColorStop(colorStops[n], colorStops[n + 1]);
                }
                this.setAttr('fillStyle', grd);
                shape._fillFunc(this);
            }
        },
        _fillRadialGradient: function(shape) {
            var start = shape.getFillRadialGradientStartPoint(),
                end = shape.getFillRadialGradientEndPoint(),
                startRadius = shape.getFillRadialGradientStartRadius(),
                endRadius = shape.getFillRadialGradientEndRadius(),
                colorStops = shape.getFillRadialGradientColorStops(),
                grd = this.createRadialGradient(start.x, start.y, startRadius, end.x, end.y, endRadius);

            // build color stops
            for(var n = 0; n < colorStops.length; n += 2) {
                grd.addColorStop(colorStops[n], colorStops[n + 1]);
            }
            this.setAttr('fillStyle', grd);
            this.fill();
        },
        _fill: function(shape) {
            var hasColor = shape.fill(),
                hasPattern = shape.getFillPatternImage(),
                hasLinearGradient = shape.getFillLinearGradientColorStops(),
                hasRadialGradient = shape.getFillRadialGradientColorStops(),
                fillPriority = shape.getFillPriority();

            // priority fills
            if(hasColor && fillPriority === 'color') {
                this._fillColor(shape);
            }
            else if(hasPattern && fillPriority === 'pattern') {
                this._fillPattern(shape);
            }
            else if(hasLinearGradient && fillPriority === 'linear-gradient') {
                this._fillLinearGradient(shape);
            }
            else if(hasRadialGradient && fillPriority === 'radial-gradient') {
                this._fillRadialGradient(shape);
            }
            // now just try and fill with whatever is available
            else if(hasColor) {
                this._fillColor(shape);
            }
            else if(hasPattern) {
                this._fillPattern(shape);
            }
            else if(hasLinearGradient) {
                this._fillLinearGradient(shape);
            }
            else if(hasRadialGradient) {
                this._fillRadialGradient(shape);
            }
        },
        _stroke: function(shape) {
            var dash = shape.dash(),
                // ignore strokeScaleEnabled for Text
                strokeScaleEnabled = (shape.getStrokeScaleEnabled() || (shape instanceof Konva.Text));

            if(shape.hasStroke()) {
                if (!strokeScaleEnabled) {
                    this.save();
                    this.setTransform(1, 0, 0, 1, 0, 0);
                }

                this._applyLineCap(shape);
                if(dash && shape.dashEnabled()) {
                    this.setLineDash(dash);
                }

                this.setAttr('lineWidth', shape.strokeWidth());
                this.setAttr('strokeStyle', shape.stroke());

                if (!shape.getShadowForStrokeEnabled()) {
                    this.setAttr('shadowColor', 'rgba(0,0,0,0)');
                }
                shape._strokeFunc(this);

                if (!strokeScaleEnabled) {
                    this.restore();
                }
            }
        },
        _applyShadow: function(shape) {
            var util = Konva.Util,
                color = util.get(shape.getShadowRGBA(), 'black'),
                blur = util.get(shape.getShadowBlur(), 5),
                offset = util.get(shape.getShadowOffset(), {
                    x: 0,
                    y: 0
                }),
                m = shape.getAbsoluteTransform().m,
                scaleX = m[0],
                scaleY = m[3];

            this.setAttr('shadowColor', color);
            this.setAttr('shadowBlur', blur);
            this.setAttr('shadowOffsetX', offset.x * scaleX);
            this.setAttr('shadowOffsetY', offset.y * scaleY);
        }
    };
    Konva.Util.extend(Konva.SceneContext, Konva.Context);

    Konva.HitContext = function(canvas) {
        Konva.Context.call(this, canvas);
    };

    Konva.HitContext.prototype = {
        _fill: function(shape) {
            this.save();
            this.setAttr('fillStyle', shape.colorKey);
            shape._fillFuncHit(this);
            this.restore();
        },
        _stroke: function(shape) {
            if(shape.hasStroke() && shape.strokeHitEnabled()) {
                // ignore strokeScaleEnabled for Text
                var strokeScaleEnabled = (shape.getStrokeScaleEnabled() || (shape instanceof Konva.Text));
                if (!strokeScaleEnabled) {
                    this.save();
                    this.setTransform(1, 0, 0, 1, 0, 0);
                }
                this._applyLineCap(shape);
                this.setAttr('lineWidth', shape.strokeWidth());
                this.setAttr('strokeStyle', shape.colorKey);
                shape._strokeFuncHit(this);
                if (!strokeScaleEnabled) {
                    this.restore();
                }
            }
        }
    };
    Konva.Util.extend(Konva.HitContext, Konva.Context);
})();

(function() {
    'use strict';
    // CONSTANTS
    var GET = 'get',
        SET = 'set';

    Konva.Factory = {
        addGetterSetter: function(constructor, attr, def, validator, after) {
            this.addGetter(constructor, attr, def);
            this.addSetter(constructor, attr, validator, after);
            this.addOverloadedGetterSetter(constructor, attr);
        },
        addGetter: function(constructor, attr, def) {
            var method = GET + Konva.Util._capitalize(attr);

            constructor.prototype[method] = function() {
                var val = this.attrs[attr];
                return val === undefined ? def : val;
            };
        },
        addSetter: function(constructor, attr, validator, after) {
            var method = SET + Konva.Util._capitalize(attr);

            constructor.prototype[method] = function(val) {
                if (validator) {
                    val = validator.call(this, val);
                }

                this._setAttr(attr, val);

                if (after) {
                    after.call(this);
                }

                return this;
            };
        },
        addComponentsGetterSetter: function(constructor, attr, components, validator, after) {
            var len = components.length,
                capitalize = Konva.Util._capitalize,
                getter = GET + capitalize(attr),
                setter = SET + capitalize(attr),
                n, component;

            // getter
            constructor.prototype[getter] = function() {
                var ret = {};

                for (n = 0; n < len; n++) {
                    component = components[n];
                    ret[component] = this.getAttr(attr + capitalize(component));
                }

                return ret;
            };

            // setter
            constructor.prototype[setter] = function(val) {
                var oldVal = this.attrs[attr],
                    key;

                if (validator) {
                    val = validator.call(this, val);
                }

                for (key in val) {
                    if (!val.hasOwnProperty(key)) {
                        continue;
                    }
                    this._setAttr(attr + capitalize(key), val[key]);
                }

                this._fireChangeEvent(attr, oldVal, val);

                if (after) {
                    after.call(this);
                }

                return this;
            };

            this.addOverloadedGetterSetter(constructor, attr);
        },
        addOverloadedGetterSetter: function(constructor, attr) {
            var capitalizedAttr = Konva.Util._capitalize(attr),
                setter = SET + capitalizedAttr,
                getter = GET + capitalizedAttr;

            constructor.prototype[attr] = function() {
                // setting
                if (arguments.length) {
                    this[setter](arguments[0]);
                    return this;
                }
                // getting
                return this[getter]();
            };
        },
        addDeprecatedGetterSetter: function(constructor, attr, def, validator) {
            var method = GET + Konva.Util._capitalize(attr);
            var message = attr + ' property is deprecated and will be removed soon. Look at Konva change log for more information.';
            constructor.prototype[method] = function() {
                Konva.Util.error(message);
                var val = this.attrs[attr];
                return val === undefined ? def : val;
            };
            this.addSetter(constructor, attr, validator, function() {
              Konva.Util.error(message);
            });
            this.addOverloadedGetterSetter(constructor, attr);
        },
        backCompat: function(constructor, methods) {
            Konva.Util.each(methods, function(oldMethodName, newMethodName) {
                var method = constructor.prototype[newMethodName];
                constructor.prototype[oldMethodName] = function(){
                    method.apply(this, arguments);
                    Konva.Util.error(oldMethodName + ' method is deprecated and will be removed soon. Use ' + newMethodName + ' instead');
                };
            });
        },
        afterSetFilter: function() {
            this._filterUpToDate = false;
        }
    };

    Konva.Validators = {
        /**
         * @return {number}
         */
        RGBComponent: function(val) {
            if (val > 255) {
                return 255;
            } else if (val < 0) {
                return 0;
            }
            return Math.round(val);
        },
        alphaComponent: function(val) {
            if (val > 1) {
                return 1;
            }
            // chrome does not honor alpha values of 0
            else if (val < 0.0001) {
                return 0.0001;
            }

            return val;
        }
    };
})();

(function(Konva) {
    'use strict';
    // CONSTANTS
    var ABSOLUTE_OPACITY = 'absoluteOpacity',
        ABSOLUTE_TRANSFORM = 'absoluteTransform',
        CHANGE = 'Change',
        CHILDREN = 'children',
        DOT = '.',
        EMPTY_STRING = '',
        GET = 'get',
        ID = 'id',
        KONVA = 'konva',
        LISTENING = 'listening',
        MOUSEENTER = 'mouseenter',
        MOUSELEAVE = 'mouseleave',
        NAME = 'name',
        SET = 'set',
        SHAPE = 'Shape',
        SPACE = ' ',
        STAGE = 'stage',
        TRANSFORM = 'transform',
        UPPER_STAGE = 'Stage',
        VISIBLE = 'visible',
        CLONE_BLACK_LIST = ['id'],

        TRANSFORM_CHANGE_STR = [
            'xChange.konva',
            'yChange.konva',
            'scaleXChange.konva',
            'scaleYChange.konva',
            'skewXChange.konva',
            'skewYChange.konva',
            'rotationChange.konva',
            'offsetXChange.konva',
            'offsetYChange.konva',
            'transformsEnabledChange.konva'
        ].join(SPACE);

    /**
     * Node constructor. Nodes are entities that can be transformed, layered,
     * and have bound events. The stage, layers, groups, and shapes all extend Node.
     * @constructor
     * @memberof Konva
     * @abstract
     * @param {Object} config
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     */
    Konva.Node = function(config) {
        this._init(config);
    };

    Konva.Util.addMethods(Konva.Node, {
        _init: function(config) {
            var that = this;
            this._id = Konva.idCounter++;
            this.eventListeners = {};
            this.attrs = {};
            this._cache = {};
            this._filterUpToDate = false;
            this.setAttrs(config);

            // event bindings for cache handling
            this.on(TRANSFORM_CHANGE_STR, function() {
                this._clearCache(TRANSFORM);
                that._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
            });
            this.on('visibleChange.konva', function() {
                that._clearSelfAndDescendantCache(VISIBLE);
            });
            this.on('listeningChange.konva', function() {
                that._clearSelfAndDescendantCache(LISTENING);
            });
            this.on('opacityChange.konva', function() {
                that._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
            });
        },
        _clearCache: function(attr){
            if (attr) {
                delete this._cache[attr];
            }
            else {
                this._cache = {};
            }
        },
        _getCache: function(attr, privateGetter){
            var cache = this._cache[attr];

            // if not cached, we need to set it using the private getter method.
            if (cache === undefined) {
                this._cache[attr] = privateGetter.call(this);
            }

            return this._cache[attr];
        },
        /*
         * when the logic for a cached result depends on ancestor propagation, use this
         * method to clear self and children cache
         */
        _clearSelfAndDescendantCache: function(attr) {
            this._clearCache(attr);

            if (this.children) {
                this.getChildren().each(function(node) {
                    node._clearSelfAndDescendantCache(attr);
                });
            }
        },
        /**
        * clear cached canvas
        * @method
        * @memberof Konva.Node.prototype
        * @returns {Konva.Node}
        * @example
        * node.clearCache();
        */
        clearCache: function() {
            delete this._cache.canvas;
            this._filterUpToDate = false;
            return this;
        },
        /**
        *  cache node to improve drawing performance, apply filters, or create more accurate
        *  hit regions. For all basic shapes size of cache canvas will be automatically detected.
        *  If you need to cache your custom `Konva.Shape` instance you have to pass shape's bounding box
        *  properties. Look at [link to demo page](link to demo page) for more information.
        * @method
        * @memberof Konva.Node.prototype
        * @param {Object} [config]
        * @param {Number} [config.x]
        * @param {Number} [config.y]
        * @param {Number} [config.width]
        * @param {Number} [config.height]
        * @param {Number} [config.offset]  increase canvas size by `offset` pixel in all directions.
        * @param {Boolean} [config.drawBorder] when set to true, a red border will be drawn around the cached
        *  region for debugging purposes
        * @returns {Konva.Node}
        * @example
        * // cache a shape with the x,y position of the bounding box at the center and
        * // the width and height of the bounding box equal to the width and height of
        * // the shape obtained from shape.width() and shape.height()
        * image.cache();
        *
        * // cache a node and define the bounding box position and size
        * node.cache({
        *   x: -30,
        *   y: -30,
        *   width: 100,
        *   height: 200
        * });
        *
        * // cache a node and draw a red border around the bounding box
        * // for debugging purposes
        * node.cache({
        *   x: -30,
        *   y: -30,
        *   width: 100,
        *   height: 200,
        *   offset : 10,
        *   drawBorder: true
        * });
        */
        cache: function(config) {
            var conf = config || {},
                rect = this.getClientRect(true),
                width = conf.width || rect.width,
                height = conf.height || rect.height,
                x = conf.x || rect.x,
                y = conf.y || rect.y,
                offset = conf.offset || 0,
                drawBorder = conf.drawBorder || false;

            if (!width || !height) {
                throw new Error('Width or height of caching configuration equals 0.');
            }

            width += offset * 2;
            height += offset * 2;

            x -= offset;
            y -= offset;


            var cachedSceneCanvas = new Konva.SceneCanvas({
                width: width,
                height: height
            }),
            cachedFilterCanvas = new Konva.SceneCanvas({
                width: width,
                height: height
            }),
            cachedHitCanvas = new Konva.HitCanvas({
                pixelRatio: 1,
                width: width,
                height: height
            }),
            sceneContext = cachedSceneCanvas.getContext(),
            hitContext = cachedHitCanvas.getContext();

            cachedHitCanvas.isCache = true;

            this.clearCache();

            sceneContext.save();
            hitContext.save();

            sceneContext.translate(-x, -y);
            hitContext.translate(-x, -y);

            this.drawScene(cachedSceneCanvas, this, true);
            this.drawHit(cachedHitCanvas, this, true);

            sceneContext.restore();
            hitContext.restore();

            // this will draw a red border around the cached box for
            // debugging purposes
            if (drawBorder) {
                sceneContext.save();
                sceneContext.beginPath();
                sceneContext.rect(0, 0, width, height);
                sceneContext.closePath();
                sceneContext.setAttr('strokeStyle', 'red');
                sceneContext.setAttr('lineWidth', 5);
                sceneContext.stroke();
                sceneContext.restore();
            }

            this._cache.canvas = {
                scene: cachedSceneCanvas,
                filter: cachedFilterCanvas,
                hit: cachedHitCanvas,
                x: x,
                y: y
            };

            return this;
        },
        /**
         * Return client rectangle {x, y, width, height} of node. This rectangle also include all styling (strokes, shadows, etc).
         * The rectangle position is relative to parent container.
         * @method
         * @memberof Konva.Node.prototype
         * @param {Boolean} [skipTransform] flag should we skip transformation to rectangle
         * @returns {Object} rect with {x, y, width, height} properties
         * @example
         * var rect = new Konva.Rect({
         *      width : 100,
         *      height : 100,
         *      x : 50,
         *      y : 50,
         *      strokeWidth : 4,
         *      stroke : 'black',
         *      offsetX : 50,
         *      scaleY : 2
         * });
         *
         * // get client rect without think off transformations (position, rotation, scale, offset, etc)
         * rect.getClientRect(true);
         * // returns {
         * //     x : -2,   // two pixels for stroke / 2
         * //     y : -2,
         * //     width : 104, // increased by 4 for stroke
         * //     height : 104
         * //}
         *
         * // get client rect with transformation applied
         * rect.getClientRect();
         * // returns Object {x: -2, y: 46, width: 104, height: 208}
         */
        getClientRect: function() {
            // abstract method
            // redefine in Container and Shape
            throw new Error('abstract "getClientRect" method call');
        },
        _transformedRect: function(rect) {
            var points = [
                {x: rect.x, y: rect.y},
                {x: rect.x + rect.width, y: rect.y},
                {x: rect.x + rect.width, y: rect.y + rect.height},
                {x: rect.x, y: rect.y + rect.height}
            ];
            var minX, minY, maxX, maxY;
            var trans = this.getTransform();
            points.forEach(function(point) {
                var transformed = trans.point(point);
                if (minX === undefined) {
                    minX = maxX = transformed.x;
                    minY = maxY = transformed.y;
                }
                minX = Math.min(minX, transformed.x);
                minY = Math.min(minY, transformed.y);
                maxX = Math.max(maxX, transformed.x);
                maxY = Math.max(maxY, transformed.y);
            });
            return {
                x: Math.round(minX),
                y: Math.round(minY),
                width: Math.round(maxX - minX),
                height: Math.round(maxY - minY)
            };
        },
        _drawCachedSceneCanvas: function(context) {
            context.save();
            context._applyOpacity(this);
            context.translate(
                this._cache.canvas.x,
                this._cache.canvas.y
            );

            var cacheCanvas = this._getCachedSceneCanvas();
            var ratio = cacheCanvas.pixelRatio;

            context.drawImage(cacheCanvas._canvas, 0, 0, cacheCanvas.width / ratio, cacheCanvas.height / ratio);
            context.restore();
        },
        _drawCachedHitCanvas: function(context) {
            var cachedCanvas = this._cache.canvas,
                hitCanvas = cachedCanvas.hit;
            context.save();
            context.translate(
                this._cache.canvas.x,
                this._cache.canvas.y
            );
            context.drawImage(hitCanvas._canvas, 0, 0);
            context.restore();
        },
        _getCachedSceneCanvas: function() {
            var filters = this.filters(),
                cachedCanvas = this._cache.canvas,
                sceneCanvas = cachedCanvas.scene,
                filterCanvas = cachedCanvas.filter,
                filterContext = filterCanvas.getContext(),
                len, imageData, n, filter;

            if (filters) {
                if (!this._filterUpToDate) {
                    var ratio = sceneCanvas.pixelRatio;

                    try {
                        len = filters.length;
                        filterContext.clear();

                        // copy cached canvas onto filter context
                        filterContext.drawImage(sceneCanvas._canvas, 0, 0, sceneCanvas.getWidth() / ratio, sceneCanvas.getHeight() / ratio);
                        imageData = filterContext.getImageData(0, 0, filterCanvas.getWidth(), filterCanvas.getHeight());

                        // apply filters to filter context
                        for (n = 0; n < len; n++) {
                            filter = filters[n];
                            filter.call(this, imageData);
                            filterContext.putImageData(imageData, 0, 0);
                        }
                    }
                    catch(e) {
                        Konva.Util.warn('Unable to apply filter. ' + e.message);
                    }

                    this._filterUpToDate = true;
                }

                return filterCanvas;
            }
            return sceneCanvas;
        },
        /**
         * bind events to the node. KonvaJS supports mouseover, mousemove,
         *  mouseout, mouseenter, mouseleave, mousedown, mouseup, mousewheel, click, dblclick, touchstart, touchmove,
         *  touchend, tap, dbltap, dragstart, dragmove, and dragend events. The Konva Stage supports
         *  contentMouseover, contentMousemove, contentMouseout, contentMousedown, contentMouseup,
         *  contentClick, contentDblclick, contentTouchstart, contentTouchmove, contentTouchend, contentTap,
         *  and contentDblTap.  Pass in a string of events delimmited by a space to bind multiple events at once
         *  such as 'mousedown mouseup mousemove'. Include a namespace to bind an
         *  event by name such as 'click.foobar'.
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} evtStr e.g. 'click', 'mousedown touchstart', 'mousedown.foo touchstart.foo'
         * @param {Function} handler The handler function is passed an event object
         * @returns {Konva.Node}
         * @example
         * // add click listener
         * node.on('click', function() {
         *   console.log('you clicked me!');
         * });
         *
         * // get the target node
         * node.on('click', function(evt) {
         *   console.log(evt.target);
         * });
         *
         * // stop event propagation
         * node.on('click', function(evt) {
         *   evt.cancelBubble = true;
         * });
         *
         * // bind multiple listeners
         * node.on('click touchstart', function() {
         *   console.log('you clicked/touched me!');
         * });
         *
         * // namespace listener
         * node.on('click.foo', function() {
         *   console.log('you clicked/touched me!');
         * });
         *
         * // get the event type
         * node.on('click tap', function(evt) {
         *   var eventType = evt.type;
         * });
         *
         * // get native event object
         * node.on('click tap', function(evt) {
         *   var nativeEvent = evt.evt;
         * });
         *
         * // for change events, get the old and new val
         * node.on('xChange', function(evt) {
         *   var oldVal = evt.oldVal;
         *   var newVal = evt.newVal;
         * });
         *
         * // get event targets
         * // with event delegations
         * layer.on('click', 'Group', function(evt) {
         *   var shape = evt.target;
         *   var group = evtn.currentTarger;
         * });
         */
        on: function(evtStr, handler) {
            if (arguments.length === 3) {
                return this._delegate.apply(this, arguments);
            }
            var events = evtStr.split(SPACE),
                len = events.length,
                n, event, parts, baseEvent, name;

             /*
             * loop through types and attach event listeners to
             * each one.  eg. 'click mouseover.namespace mouseout'
             * will create three event bindings
             */
            for(n = 0; n < len; n++) {
                event = events[n];
                parts = event.split(DOT);
                baseEvent = parts[0];
                name = parts[1] || EMPTY_STRING;

                // create events array if it doesn't exist
                if(!this.eventListeners[baseEvent]) {
                    this.eventListeners[baseEvent] = [];
                }

                this.eventListeners[baseEvent].push({
                    name: name,
                    handler: handler
                });
            }

            return this;
        },
        /**
         * remove event bindings from the node. Pass in a string of
         *  event types delimmited by a space to remove multiple event
         *  bindings at once such as 'mousedown mouseup mousemove'.
         *  include a namespace to remove an event binding by name
         *  such as 'click.foobar'. If you only give a name like '.foobar',
         *  all events in that namespace will be removed.
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} evtStr e.g. 'click', 'mousedown touchstart', '.foobar'
         * @returns {Konva.Node}
         * @example
         * // remove listener
         * node.off('click');
         *
         * // remove multiple listeners
         * node.off('click touchstart');
         *
         * // remove listener by name
         * node.off('click.foo');
         */
        off: function(evtStr) {
            var events = (evtStr || '').split(SPACE),
                len = events.length,
                n, t, event, parts, baseEvent, name;

            if (!evtStr) {
                // remove all events
                for(t in this.eventListeners) {
                    this._off(t);
                }
            }
            for(n = 0; n < len; n++) {
                event = events[n];
                parts = event.split(DOT);
                baseEvent = parts[0];
                name = parts[1];

                if(baseEvent) {
                    if(this.eventListeners[baseEvent]) {
                        this._off(baseEvent, name);
                    }
                }
                else {
                    for(t in this.eventListeners) {
                        this._off(t, name);
                    }
                }
            }
            return this;
        },
        // some event aliases for third party integration like HammerJS
        dispatchEvent: function(evt) {
            var e = {
              target: this,
              type: evt.type,
              evt: evt
            };
            this.fire(evt.type, e);
            return this;
        },
        addEventListener: function(type, handler) {
            // we have to pass native event to handler
            this.on(type, function(evt){
                handler.call(this, evt.evt);
            });
            return this;
        },
        removeEventListener: function(type) {
            this.off(type);
            return this;
        },
        // like node.on
        _delegate: function(event, selector, handler) {
            var stopNode = this;
            this.on(event, function(evt) {
                var targets = evt.target.findAncestors(selector, true, stopNode);
                for(var i = 0; i < targets.length; i++) {
                    evt = Konva.Util.cloneObject(evt);
                    evt.currentTarget = targets[i];
                    handler.call(targets[i], evt);
                }
            });
        },
        /**
         * remove self from parent, but don't destroy
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Node}
         * @example
         * node.remove();
         */
        remove: function() {
            var parent = this.getParent();

            if(parent && parent.children) {
                parent.children.splice(this.index, 1);
                parent._setChildrenIndices();
                delete this.parent;
            }

            // every cached attr that is calculated via node tree
            // traversal must be cleared when removing a node
            this._clearSelfAndDescendantCache(STAGE);
            this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
            this._clearSelfAndDescendantCache(VISIBLE);
            this._clearSelfAndDescendantCache(LISTENING);
            this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);

            return this;
        },
        /**
         * remove and destroy self
         * @method
         * @memberof Konva.Node.prototype
         * @example
         * node.destroy();
         */
        destroy: function() {
            // remove from ids and names hashes
            Konva._removeId(this.getId());
            Konva._removeName(this.getName(), this._id);

            this.remove();
            return this;
        },
        /**
         * get attr
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} attr
         * @returns {Integer|String|Object|Array}
         * @example
         * var x = node.getAttr('x');
         */
        getAttr: function(attr) {
            var method = GET + Konva.Util._capitalize(attr);
            if(Konva.Util._isFunction(this[method])) {
                return this[method]();
            }
            // otherwise get directly
            return this.attrs[attr];
        },
        /**
        * get ancestors
        * @method
        * @memberof Konva.Node.prototype
        * @returns {Konva.Collection}
        * @example
        * shape.getAncestors().each(function(node) {
        *   console.log(node.getId());
        * })
        */
        getAncestors: function() {
            var parent = this.getParent(),
                ancestors = new Konva.Collection();

            while (parent) {
                ancestors.push(parent);
                parent = parent.getParent();
            }

            return ancestors;
        },
        /**
         * get attrs object literal
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Object}
         */
        getAttrs: function() {
            return this.attrs || {};
        },
        /**
         * set multiple attrs at once using an object literal
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} config object containing key value pairs
         * @returns {Konva.Node}
         * @example
         * node.setAttrs({
         *   x: 5,
         *   fill: 'red'
         * });
         */
        setAttrs: function(config) {
            var key, method;

            if(!config) {
                return this;
            }
            for(key in config) {
                if (key === CHILDREN) {
                    continue;
                }
                method = SET + Konva.Util._capitalize(key);
                // use setter if available
                if(Konva.Util._isFunction(this[method])) {
                    this[method](config[key]);
                }
                // otherwise set directly
                else {
                    this._setAttr(key, config[key]);
                }
            }
            return this;
        },
        /**
         * determine if node is listening for events by taking into account ancestors.
         *
         * Parent    | Self      | isListening
         * listening | listening |
         * ----------+-----------+------------
         * T         | T         | T
         * T         | F         | F
         * F         | T         | T
         * F         | F         | F
         * ----------+-----------+------------
         * T         | I         | T
         * F         | I         | F
         * I         | I         | T
         *
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
        isListening: function() {
            return this._getCache(LISTENING, this._isListening);
        },
        _isListening: function() {
            var listening = this.getListening(),
                parent = this.getParent();

            // the following conditions are a simplification of the truth table above.
            // please modify carefully
            if (listening === 'inherit') {
                if (parent) {
                    return parent.isListening();
                }
                else {
                    return true;
                }
            }
            else {
                return listening;
            }
        },
        /**
         * determine if node is visible by taking into account ancestors.
         *
         * Parent    | Self      | isVisible
         * visible   | visible   |
         * ----------+-----------+------------
         * T         | T         | T
         * T         | F         | F
         * F         | T         | T
         * F         | F         | F
         * ----------+-----------+------------
         * T         | I         | T
         * F         | I         | F
         * I         | I         | T

         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
        isVisible: function() {
            return this._getCache(VISIBLE, this._isVisible);
        },
        _isVisible: function() {
            var visible = this.getVisible(),
                parent = this.getParent();

            // the following conditions are a simplification of the truth table above.
            // please modify carefully
            if (visible === 'inherit') {
                if (parent) {
                    return parent.isVisible();
                }
                else {
                    return true;
                }
            }
            else {
                return visible;
            }
        },
        /**
         * determine if listening is enabled by taking into account descendants.  If self or any children
         * have _isListeningEnabled set to true, then self also has listening enabled.
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
        shouldDrawHit: function(canvas) {
            var layer = this.getLayer();
            return (canvas && canvas.isCache) || (layer && layer.hitGraphEnabled())
                && this.isListening() && this.isVisible();
        },
        /**
         * show node
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Node}
         */
        show: function() {
            this.setVisible(true);
            return this;
        },
        /**
         * hide node.  Hidden nodes are no longer detectable
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Node}
         */
        hide: function() {
            this.setVisible(false);
            return this;
        },
        /**
         * get zIndex relative to the node's siblings who share the same parent
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Integer}
         */
        getZIndex: function() {
            return this.index || 0;
        },
        /**
         * get absolute z-index which takes into account sibling
         *  and ancestor indices
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Integer}
         */
        getAbsoluteZIndex: function() {
            var depth = this.getDepth(),
                that = this,
                index = 0,
                nodes, len, n, child;

            function addChildren(children) {
                nodes = [];
                len = children.length;
                for(n = 0; n < len; n++) {
                    child = children[n];
                    index++;

                    if(child.nodeType !== SHAPE) {
                        nodes = nodes.concat(child.getChildren().toArray());
                    }

                    if(child._id === that._id) {
                        n = len;
                    }
                }

                if(nodes.length > 0 && nodes[0].getDepth() <= depth) {
                    addChildren(nodes);
                }
            }
            if(that.nodeType !== UPPER_STAGE) {
                addChildren(that.getStage().getChildren());
            }

            return index;
        },
        /**
         * get node depth in node tree.  Returns an integer.
         *  e.g. Stage depth will always be 0.  Layers will always be 1.  Groups and Shapes will always
         *  be >= 2
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Integer}
         */
        getDepth: function() {
            var depth = 0,
                parent = this.parent;

            while(parent) {
                depth++;
                parent = parent.parent;
            }
            return depth;
        },
        setPosition: function(pos) {
            this.setX(pos.x);
            this.setY(pos.y);
            return this;
        },
        getPosition: function() {
            return {
                x: this.getX(),
                y: this.getY()
            };
        },
        /**
         * get absolute position relative to the top left corner of the stage container div
         * or relative to passed node
         * @method
         * @param {Object} [top] optional parent node
         * @memberof Konva.Node.prototype
         * @returns {Object}
         */
        getAbsolutePosition: function(top) {
            var absoluteMatrix = this.getAbsoluteTransform(top).getMatrix(),
                absoluteTransform = new Konva.Transform(),
                offset = this.offset();

            // clone the matrix array
            absoluteTransform.m = absoluteMatrix.slice();
            absoluteTransform.translate(offset.x, offset.y);

            return absoluteTransform.getTranslation();
        },
        /**
         * set absolute position
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} pos
         * @param {Number} pos.x
         * @param {Number} pos.y
         * @returns {Konva.Node}
         */
        setAbsolutePosition: function(pos) {
            var origTrans = this._clearTransform(),
                it;

            // don't clear translation
            this.attrs.x = origTrans.x;
            this.attrs.y = origTrans.y;
            delete origTrans.x;
            delete origTrans.y;

            // unravel transform
            it = this.getAbsoluteTransform();

            it.invert();
            it.translate(pos.x, pos.y);
            pos = {
                x: this.attrs.x + it.getTranslation().x,
                y: this.attrs.y + it.getTranslation().y
            };

            this.setPosition({x: pos.x, y: pos.y});
            this._setTransform(origTrans);

            return this;
        },
        _setTransform: function(trans) {
            var key;

            for(key in trans) {
                this.attrs[key] = trans[key];
            }

            this._clearCache(TRANSFORM);
            this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
        },
        _clearTransform: function() {
            var trans = {
                x: this.getX(),
                y: this.getY(),
                rotation: this.getRotation(),
                scaleX: this.getScaleX(),
                scaleY: this.getScaleY(),
                offsetX: this.getOffsetX(),
                offsetY: this.getOffsetY(),
                skewX: this.getSkewX(),
                skewY: this.getSkewY()
            };

            this.attrs.x = 0;
            this.attrs.y = 0;
            this.attrs.rotation = 0;
            this.attrs.scaleX = 1;
            this.attrs.scaleY = 1;
            this.attrs.offsetX = 0;
            this.attrs.offsetY = 0;
            this.attrs.skewX = 0;
            this.attrs.skewY = 0;

            this._clearCache(TRANSFORM);
            this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);

            // return original transform
            return trans;
        },
        /**
         * move node by an amount relative to its current position
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} change
         * @param {Number} change.x
         * @param {Number} change.y
         * @returns {Konva.Node}
         * @example
         * // move node in x direction by 1px and y direction by 2px
         * node.move({
         *   x: 1,
         *   y: 2)
         * });
         */
        move: function(change) {
            var changeX = change.x,
                changeY = change.y,
                x = this.getX(),
                y = this.getY();

            if(changeX !== undefined) {
                x += changeX;
            }

            if(changeY !== undefined) {
                y += changeY;
            }

            this.setPosition({x: x, y: y});
            return this;
        },
        _eachAncestorReverse: function(func, top) {
            var family = [],
                parent = this.getParent(),
                len, n;

            // if top node is defined, and this node is top node,
            // there's no need to build a family tree.  just execute
            // func with this because it will be the only node
            if (top && top._id === this._id) {
                func(this);
                return true;
            }

            family.unshift(this);

            while(parent && (!top || parent._id !== top._id)) {
                family.unshift(parent);
                parent = parent.parent;
            }

            len = family.length;
            for(n = 0; n < len; n++) {
                func(family[n]);
            }
        },
        /**
         * rotate node by an amount in degrees relative to its current rotation
         * @method
         * @memberof Konva.Node.prototype
         * @param {Number} theta
         * @returns {Konva.Node}
         */
        rotate: function(theta) {
            this.setRotation(this.getRotation() + theta);
            return this;
        },
        /**
         * move node to the top of its siblings
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
        moveToTop: function() {
            if (!this.parent) {
                Konva.Util.warn('Node has no parent. moveToTop function is ignored.');
                return false;
            }
            var index = this.index;
            this.parent.children.splice(index, 1);
            this.parent.children.push(this);
            this.parent._setChildrenIndices();
            return true;
        },
        /**
         * move node up
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean} flag is moved or not
         */
        moveUp: function() {
            if (!this.parent) {
                Konva.Util.warn('Node has no parent. moveUp function is ignored.');
                return false;
            }
            var index = this.index,
                len = this.parent.getChildren().length;
            if(index < len - 1) {
                this.parent.children.splice(index, 1);
                this.parent.children.splice(index + 1, 0, this);
                this.parent._setChildrenIndices();
                return true;
            }
            return false;
        },
        /**
         * move node down
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
        moveDown: function() {
            if (!this.parent) {
                Konva.Util.warn('Node has no parent. moveDown function is ignored.');
                return false;
            }
            var index = this.index;
            if(index > 0) {
                this.parent.children.splice(index, 1);
                this.parent.children.splice(index - 1, 0, this);
                this.parent._setChildrenIndices();
                return true;
            }
            return false;
        },
        /**
         * move node to the bottom of its siblings
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
        moveToBottom: function() {
            if (!this.parent) {
                Konva.Util.warn('Node has no parent. moveToBottom function is ignored.');
                return false;
            }
            var index = this.index;
            if(index > 0) {
                this.parent.children.splice(index, 1);
                this.parent.children.unshift(this);
                this.parent._setChildrenIndices();
                return true;
            }
            return false;
        },
        /**
         * set zIndex relative to siblings
         * @method
         * @memberof Konva.Node.prototype
         * @param {Integer} zIndex
         * @returns {Konva.Node}
         */
        setZIndex: function(zIndex) {
            if (!this.parent) {
                Konva.Util.warn('Node has no parent. zIndex parameter is ignored.');
                return false;
            }
            var index = this.index;
            this.parent.children.splice(index, 1);
            this.parent.children.splice(zIndex, 0, this);
            this.parent._setChildrenIndices();
            return this;
        },
        /**
         * get absolute opacity
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Number}
         */
        getAbsoluteOpacity: function() {
            return this._getCache(ABSOLUTE_OPACITY, this._getAbsoluteOpacity);
        },
        _getAbsoluteOpacity: function() {
            var absOpacity = this.getOpacity();
            if(this.getParent()) {
                absOpacity *= this.getParent().getAbsoluteOpacity();
            }
            return absOpacity;
        },
        /**
         * move node to another container
         * @method
         * @memberof Konva.Node.prototype
         * @param {Container} newContainer
         * @returns {Konva.Node}
         * @example
         * // move node from current layer into layer2
         * node.moveTo(layer2);
         */
        moveTo: function(newContainer) {
            // do nothing if new container is already parent
            if (this.getParent() !== newContainer) {
                this.remove();
                newContainer.add(this);
            }
            return this;
        },
        /**
         * convert Node into an object for serialization.  Returns an object.
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Object}
         */
        toObject: function() {
            var obj = {},
                attrs = this.getAttrs(),
                key, val, getter, defaultValue;

            obj.attrs = {};

            for(key in attrs) {
                val = attrs[key];
                // serialize only attributes that are not function, image, DOM, or objects with methods
                if (Konva.Util._isFunction(val) || Konva.Util._isElement(val) ||
                    (Konva.Util._isObject(val) || Konva.Util._hasMethods(val))) {
                    continue;
                }
                getter = this[key];
                // remove attr value so that we can extract the default value from the getter
                delete attrs[key];
                defaultValue = getter ? getter.call(this) : null;
                // restore attr value
                attrs[key] = val;
                if (defaultValue !== val) {
                    obj.attrs[key] = val;
                }
            }

            obj.className = this.getClassName();
            return obj;
        },
        /**
         * convert Node into a JSON string.  Returns a JSON string.
         * @method
         * @memberof Konva.Node.prototype
         * @returns {String}}
         */
        toJSON: function() {
            return JSON.stringify(this.toObject());
        },
        /**
         * get parent container
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Node}
         */
        getParent: function() {
            return this.parent;
        },
        /**
         * get all ancestros (parent then parent of the parent, etc) of the node
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} [selector] selector for search
         * @param {Boolean} [includeSelf] show we think that node is ancestro itself?
         * @param {Konva.Node} [stopNode] optional node where we need to stop searching (one of ancestors)
         * @returns {Array} [ancestors]
         * @example
         * // get one of the parent group
         * var parentGroups = node.findAncestors('Group');
         */
        findAncestors: function(selector, includeSelf, stopNode) {
            var res = [];

            if (includeSelf && this._isMatch(selector)) {
                res.push(this);
            }
            var ancestor = this.parent;
            while(ancestor) {
                if (ancestor === stopNode) {
                    return res;
                }
                if (ancestor._isMatch(selector)) {
                    res.push(ancestor);
                }
                ancestor = ancestor.parent;
            }
            return res;
        },
        /**
         * get ancestor (parent or parent of the parent, etc) of the node that match passed selector
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} [selector] selector for search
         * @param {Boolean} [includeSelf] show we think that node is ancestro itself?
         * @param {Konva.Node} [stopNode] optional node where we need to stop searching (one of ancestors)
         * @returns {Konva.Node} ancestor
         * @example
         * // get one of the parent group
         * var group = node.findAncestors('.mygroup');
         */
        findAncestor: function(selector, includeSelf, stopNode) {
            return this.findAncestors(selector, includeSelf, stopNode)[0];
        },
        // is current node match passed selector?
        _isMatch: function(selector) {
            if (!selector) {
                return false;
            }
            var selectorArr = selector.replace(/ /g, '').split(','),
                len = selectorArr.length,
                n, sel;

            for (n = 0; n < len; n++) {
                sel = selectorArr[n];
                if (!Konva.Util.isValidSelector(sel)) {
                    Konva.Util.warn('Selector "' + sel + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".');
                    Konva.Util.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".');
                    Konva.Util.warn('Konva is awesome, right?');
                }
                // id selector
                if(sel.charAt(0) === '#') {
                    if (this.id() === sel.slice(1)) {
                        return true;
                    }
                }
                // name selector
                else if(sel.charAt(0) === '.') {
                    if (this.hasName(sel.slice(1))) {
                        return true;
                    }
                } else if (this._get(sel).length !== 0) {
                    return true;
                }
            }
            return false;
        },
        /**
         * get layer ancestor
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Layer}
         */
        getLayer: function() {
            var parent = this.getParent();
            return parent ? parent.getLayer() : null;
        },
        /**
         * get stage ancestor
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Stage}
         */
        getStage: function() {
            return this._getCache(STAGE, this._getStage);
        },
        _getStage: function() {
            var parent = this.getParent();
            if(parent) {
                return parent.getStage();
            }
            else {
                return undefined;
            }
        },
        /**
         * fire event
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} eventType event type.  can be a regular event, like click, mouseover, or mouseout, or it can be a custom event, like myCustomEvent
         * @param {Event} [evt] event object
         * @param {Boolean} [bubble] setting the value to false, or leaving it undefined, will result in the event
         *  not bubbling.  Setting the value to true will result in the event bubbling.
         * @returns {Konva.Node}
         * @example
         * // manually fire click event
         * node.fire('click');
         *
         * // fire custom event
         * node.fire('foo');
         *
         * // fire custom event with custom event object
         * node.fire('foo', {
         *   bar: 10
         * });
         *
         * // fire click event that bubbles
         * node.fire('click', null, true);
         */
        fire: function(eventType, evt, bubble) {
            evt = evt || {};
            evt.target = evt.target || this;
            // bubble
            if (bubble) {
                this._fireAndBubble(eventType, evt);
            }
            // no bubble
            else {
                this._fire(eventType, evt);
            }
            return this;
        },
        /**
         * get absolute transform of the node which takes into
         *  account its ancestor transforms
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Transform}
         */
        getAbsoluteTransform: function(top) {
            // if using an argument, we can't cache the result.
            if (top) {
                return this._getAbsoluteTransform(top);
            }
            // if no argument, we can cache the result
            else {
                return this._getCache(ABSOLUTE_TRANSFORM, this._getAbsoluteTransform);
            }
        },
        _getAbsoluteTransform: function(top) {
            var at = new Konva.Transform(),
                transformsEnabled, trans;

            // start with stage and traverse downwards to self
            this._eachAncestorReverse(function(node) {
                transformsEnabled = node.transformsEnabled();
                trans = node.getTransform();

                if (transformsEnabled === 'all') {
                    at.multiply(trans);
                }
                else if (transformsEnabled === 'position') {
                    at.translate(node.x(), node.y());
                }
            }, top);
            return at;
        },
        /**
         * get transform of the node
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Transform}
         */
        getTransform: function() {
            return this._getCache(TRANSFORM, this._getTransform);
        },
        _getTransform: function() {
            var m = new Konva.Transform(),
                x = this.getX(),
                y = this.getY(),
                rotation = Konva.getAngle(this.getRotation()),
                scaleX = this.getScaleX(),
                scaleY = this.getScaleY(),
                skewX = this.getSkewX(),
                skewY = this.getSkewY(),
                offsetX = this.getOffsetX(),
                offsetY = this.getOffsetY();

            if(x !== 0 || y !== 0) {
                m.translate(x, y);
            }
            if(rotation !== 0) {
                m.rotate(rotation);
            }
            if(skewX !== 0 || skewY !== 0) {
                m.skew(skewX, skewY);
            }
            if(scaleX !== 1 || scaleY !== 1) {
                m.scale(scaleX, scaleY);
            }
            if(offsetX !== 0 || offsetY !== 0) {
                m.translate(-1 * offsetX, -1 * offsetY);
            }

            return m;
        },
        /**
         * clone node.  Returns a new Node instance with identical attributes.  You can also override
         *  the node properties with an object literal, enabling you to use an existing node as a template
         *  for another node
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} obj override attrs
         * @returns {Konva.Node}
         * @example
         * // simple clone
         * var clone = node.clone();
         *
         * // clone a node and override the x position
         * var clone = rect.clone({
         *   x: 5
         * });
         */
        clone: function(obj) {
            // instantiate new node
            var attrs = Konva.Util.cloneObject(this.attrs),
                key, allListeners, len, n, listener;
            // filter black attrs
            for (var i in CLONE_BLACK_LIST) {
                var blockAttr = CLONE_BLACK_LIST[i];
                delete attrs[blockAttr];
            }
            // apply attr overrides
            for (key in obj) {
                attrs[key] = obj[key];
            }

            var node = new this.constructor(attrs);
            // copy over listeners
            for(key in this.eventListeners) {
                allListeners = this.eventListeners[key];
                len = allListeners.length;
                for(n = 0; n < len; n++) {
                    listener = allListeners[n];
                    /*
                     * don't include konva namespaced listeners because
                     *  these are generated by the constructors
                     */
                    if(listener.name.indexOf(KONVA) < 0) {
                        // if listeners array doesn't exist, then create it
                        if(!node.eventListeners[key]) {
                            node.eventListeners[key] = [];
                        }
                        node.eventListeners[key].push(listener);
                    }
                }
            }
            return node;
        },
        /**
         * Creates a composite data URL. If MIME type is not
         * specified, then "image/png" will result. For "image/jpeg", specify a quality
         * level as quality (range 0.0 - 1.0)
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} config
         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
         *  "image/png" is the default
         * @param {Number} [config.x] x position of canvas section
         * @param {Number} [config.y] y position of canvas section
         * @param {Number} [config.width] width of canvas section
         * @param {Number} [config.height] height of canvas section
         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
         *  is very high quality
         * @paremt {Number} [config.pixelRatio] pixelRatio of ouput image url. Default is 1
         * @returns {String}
         */
        toDataURL: function(config) {
            config = config || {};

            var mimeType = config.mimeType || null,
                quality = config.quality || null,
                stage = this.getStage(),
                x = config.x || 0,
                y = config.y || 0,
                pixelRatio = config.pixelRatio || 1,
                canvas = new Konva.SceneCanvas({
                    width: config.width || this.getWidth() || (stage ? stage.getWidth() : 0),
                    height: config.height || this.getHeight() || (stage ? stage.getHeight() : 0),
                    pixelRatio: pixelRatio
                }),
                context = canvas.getContext();

            context.save();

            if(x || y) {
                context.translate(-1 * x, -1 * y);
            }

            this.drawScene(canvas);
            context.restore();

            return canvas.toDataURL(mimeType, quality);
        },
        /**
         * converts node into an image.  Since the toImage
         *  method is asynchronous, a callback is required.  toImage is most commonly used
         *  to cache complex drawings as an image so that they don't have to constantly be redrawn
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} config
         * @param {Function} config.callback function executed when the composite has completed
         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
         *  "image/png" is the default
         * @param {Number} [config.x] x position of canvas section
         * @param {Number} [config.y] y position of canvas section
         * @param {Number} [config.width] width of canvas section
         * @param {Number} [config.height] height of canvas section
         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
         *  is very high quality
         * @paremt {Number} [config.pixelRatio] pixelRatio of ouput image.  Default is 1.
         * @example
         * var image = node.toImage({
         *   callback: function(img) {
         *     // do stuff with img
         *   }
         * });
         */
        toImage: function(config) {
            if (!config || !config.callback) {
                throw 'callback required for toImage method config argument';
            }
            Konva.Util._getImage(this.toDataURL(config), function(img) {
                config.callback(img);
            });
        },
        setSize: function(size) {
            this.setWidth(size.width);
            this.setHeight(size.height);
            return this;
        },
        getSize: function() {
            return {
                width: this.getWidth(),
                height: this.getHeight()
            };
        },
        getWidth: function() {
            return this.attrs.width || 0;
        },
        getHeight: function() {
            return this.attrs.height || 0;
        },
        /**
         * get class name, which may return Stage, Layer, Group, or shape class names like Rect, Circle, Text, etc.
         * @method
         * @memberof Konva.Node.prototype
         * @returns {String}
         */
        getClassName: function() {
            return this.className || this.nodeType;
        },
        /**
         * get the node type, which may return Stage, Layer, Group, or Node
         * @method
         * @memberof Konva.Node.prototype
         * @returns {String}
         */
        getType: function() {
            return this.nodeType;
        },
        getDragDistance: function() {
            // compare with undefined because we need to track 0 value
            if (this.attrs.dragDistance !== undefined) {
                return this.attrs.dragDistance;
            } else if (this.parent) {
                return this.parent.getDragDistance();
            } else {
                return Konva.dragDistance;
            }
        },
        _get: function(selector) {
            return this.className === selector || this.nodeType === selector ? [this] : [];
        },
        _off: function(type, name) {
            var evtListeners = this.eventListeners[type],
                i, evtName;

            for(i = 0; i < evtListeners.length; i++) {
                evtName = evtListeners[i].name;
                // the following two conditions must be true in order to remove a handler:
                // 1) the current event name cannot be konva unless the event name is konva
                //    this enables developers to force remove a konva specific listener for whatever reason
                // 2) an event name is not specified, or if one is specified, it matches the current event name
                if((evtName !== 'konva' || name === 'konva') && (!name || evtName === name)) {
                    evtListeners.splice(i, 1);
                    if(evtListeners.length === 0) {
                        delete this.eventListeners[type];
                        break;
                    }
                    i--;
                }
            }
        },
        _fireChangeEvent: function(attr, oldVal, newVal) {
            this._fire(attr + CHANGE, {
                oldVal: oldVal,
                newVal: newVal
            });
        },
        setId: function(id) {
            var oldId = this.getId();

            Konva._removeId(oldId);
            Konva._addId(this, id);
            this._setAttr(ID, id);
            return this;
        },
        setName: function(name) {
            var oldNames = (this.getName() || '').split(/\s/g);
            var newNames = (name || '').split(/\s/g);
            var subname, i;
            // remove all subnames
            for(i = 0; i < oldNames.length; i++) {
                subname = oldNames[i];
                if ((newNames.indexOf(subname)) === -1 && subname) {
                    Konva._removeName(subname, this._id);
                }
            }

            // add new names
            for(i = 0; i < newNames.length; i++) {
                subname = newNames[i];
                if ((oldNames.indexOf(subname) === -1) && subname) {
                    Konva._addName(this, subname);
                }
            }

            this._setAttr(NAME, name);
            return this;
        },
        // naming methods
        /**
         * add name to node
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} name
         * @returns {Konva.Node}
         * @example
         * node.name('red');
         * node.addName('selected');
         * node.name(); // return 'red selected'
         */
        addName: function(name) {
            if (!this.hasName(name)) {
                var oldName = this.name();
                var newName = oldName ? (oldName + ' ' + name) : name;
                this.setName(newName);
            }
            return this;
        },
        /**
         * check is node has name
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} name
         * @returns {Boolean}
         * @example
         * node.name('red');
         * node.hasName('red');   // return true
         * node.hasName('selected'); // return false
         */
        hasName: function(name) {
            var names = (this.name() || '').split(/\s/g);
            return names.indexOf(name) !== -1;
        },
        /**
         * remove name from node
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} name
         * @returns {Konva.Node}
         * @example
         * node.name('red selected');
         * node.removeName('selected');
         * node.hasName('selected'); // return false
         * node.name(); // return 'red'
         */
        removeName: function(name) {
            var names = (this.name() || '').split(/\s/g);
            var index = names.indexOf(name);
            if (index !== -1) {
                names.splice(index, 1);
                this.setName(names.join(' '));
            }
            return this;
        },
        /**
         * set attr
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} attr
         * @param {*} val
         * @returns {Konva.Node}
         * @example
         * node.setAttr('x', 5);
         */
        setAttr: function(attr, val) {
            var method = SET + Konva.Util._capitalize(attr),
                func = this[method];

            if(Konva.Util._isFunction(func)) {
                func.call(this, val);
            }
            // otherwise set directly
            else {
                this._setAttr(attr, val);
            }
            return this;
        },
        _setAttr: function(key, val) {
            var oldVal;
            if(val !== undefined) {
                oldVal = this.attrs[key];
                if (oldVal === val) {
                    return;
                }
                this.attrs[key] = val;
                this._fireChangeEvent(key, oldVal, val);
            }
        },
        _setComponentAttr: function(key, component, val) {
            var oldVal;
            if(val !== undefined) {
                oldVal = this.attrs[key];

                if (!oldVal) {
                    // set value to default value using getAttr
                    this.attrs[key] = this.getAttr(key);
                }

                this.attrs[key][component] = val;
                this._fireChangeEvent(key, oldVal, val);
            }
        },
        _fireAndBubble: function(eventType, evt, compareShape) {
            var okayToRun = true;

            if(evt && this.nodeType === SHAPE) {
                evt.target = this;
            }

            if(eventType === MOUSEENTER && compareShape && (this._id === compareShape._id || (this.isAncestorOf && this.isAncestorOf(compareShape)))) {
                okayToRun = false;
            }
            else if(eventType === MOUSELEAVE && compareShape && (this._id === compareShape._id || (this.isAncestorOf && this.isAncestorOf(compareShape)))) {
                okayToRun = false;
            }
            if(okayToRun) {
                this._fire(eventType, evt);

                // simulate event bubbling
                var stopBubble = (eventType === MOUSEENTER || eventType === MOUSELEAVE) && ((compareShape && compareShape.isAncestorOf && compareShape.isAncestorOf(this)) || !!(compareShape && compareShape.isAncestorOf));
                if((evt && !evt.cancelBubble || !evt) && this.parent && this.parent.isListening() && (!stopBubble)) {
                    if(compareShape && compareShape.parent) {
                        this._fireAndBubble.call(this.parent, eventType, evt, compareShape.parent);
                    }
                    else {
                        this._fireAndBubble.call(this.parent, eventType, evt);
                    }
                }
            }
        },
        _fire: function(eventType, evt) {
            var events = this.eventListeners[eventType],
                i;

            evt = Konva.Util.cloneObject(evt || {});
            evt.currentTarget = this;
            evt.type = eventType;

            if (events) {
                for(i = 0; i < events.length; i++) {
                    events[i].handler.call(this, evt);
                }
            }
        },
        /**
         * draw both scene and hit graphs.  If the node being drawn is the stage, all of the layers will be cleared and redrawn
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Node}
         */
        draw: function() {
            this.drawScene();
            this.drawHit();
            return this;
        }
    });

    /**
     * create node with JSON string or an Object.  De-serializtion does not generate custom
     *  shape drawing functions, images, or event handlers (this would make the
     *  serialized object huge).  If your app uses custom shapes, images, and
     *  event handlers (it probably does), then you need to select the appropriate
     *  shapes after loading the stage and set these properties via on(), setDrawFunc(),
     *  and setImage() methods
     * @method
     * @memberof Konva.Node
     * @param {String|Object} json string or object
     * @param {Element} [container] optional container dom element used only if you're
     *  creating a stage node
     */
    Konva.Node.create = function(data, container) {
        if (Konva.Util._isString(data)) {
            data = JSON.parse(data);
        }
        return this._createNode(data, container);
    };
    Konva.Node._createNode = function(obj, container) {
        var className = Konva.Node.prototype.getClassName.call(obj),
            children = obj.children,
            no, len, n;

        // if container was passed in, add it to attrs
        if(container) {
            obj.attrs.container = container;
        }

        no = new Konva[className](obj.attrs);
        if(children) {
            len = children.length;
            for(n = 0; n < len; n++) {
                no.add(this._createNode(children[n]));
            }
        }

        return no;
    };


    // =========================== add getters setters ===========================

    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'position');
    /**
     * get/set node position relative to parent
     * @name position
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} pos
     * @param {Number} pos.x
     * @param {Number} pos.y
     * @returns {Object}
     * @example
     * // get position
     * var position = node.position();
     *
     * // set position
     * node.position({
     *   x: 5
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'x', 0);

    /**
     * get/set x position
     * @name x
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} x
     * @returns {Object}
     * @example
     * // get x
     * var x = node.x();
     *
     * // set x
     * node.x(5);
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'y', 0);

    /**
     * get/set y position
     * @name y
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} y
     * @returns {Integer}
     * @example
     * // get y
     * var y = node.y();
     *
     * // set y
     * node.y(5);
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'opacity', 1);

    /**
     * get/set opacity.  Opacity values range from 0 to 1.
     *  A node with an opacity of 0 is fully transparent, and a node
     *  with an opacity of 1 is fully opaque
     * @name opacity
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} opacity
     * @returns {Number}
     * @example
     * // get opacity
     * var opacity = node.opacity();
     *
     * // set opacity
     * node.opacity(0.5);
     */

    Konva.Factory.addGetter(Konva.Node, 'name');
    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'name');

    /**
     * get/set name
     * @name name
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} name
     * @returns {String}
     * @example
     * // get name
     * var name = node.name();
     *
     * // set name
     * node.name('foo');
     *
     * // also node may have multiple names (as css classes)
     * node.name('foo bar');
     */

    Konva.Factory.addGetter(Konva.Node, 'id');
    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'id');

    /**
     * get/set id. Id is global for whole page.
     * @name id
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} id
     * @returns {String}
     * @example
     * // get id
     * var name = node.id();
     *
     * // set id
     * node.id('foo');
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'rotation', 0);

    /**
     * get/set rotation in degrees
     * @name rotation
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} rotation
     * @returns {Number}
     * @example
     * // get rotation in degrees
     * var rotation = node.rotation();
     *
     * // set rotation in degrees
     * node.rotation(45);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Node, 'scale', ['x', 'y']);

    /**
     * get/set scale
     * @name scale
     * @param {Object} scale
     * @param {Number} scale.x
     * @param {Number} scale.y
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Object}
     * @example
     * // get scale
     * var scale = node.scale();
     *
     * // set scale
     * shape.scale({
     *   x: 2
     *   y: 3
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'scaleX', 1);

    /**
     * get/set scale x
     * @name scaleX
     * @param {Number} x
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Number}
     * @example
     * // get scale x
     * var scaleX = node.scaleX();
     *
     * // set scale x
     * node.scaleX(2);
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'scaleY', 1);

    /**
     * get/set scale y
     * @name scaleY
     * @param {Number} y
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Number}
     * @example
     * // get scale y
     * var scaleY = node.scaleY();
     *
     * // set scale y
     * node.scaleY(2);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Node, 'skew', ['x', 'y']);

    /**
     * get/set skew
     * @name skew
     * @param {Object} skew
     * @param {Number} skew.x
     * @param {Number} skew.y
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Object}
     * @example
     * // get skew
     * var skew = node.skew();
     *
     * // set skew
     * node.skew({
     *   x: 20
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'skewX', 0);

    /**
     * get/set skew x
     * @name skewX
     * @param {Number} x
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Number}
     * @example
     * // get skew x
     * var skewX = node.skewX();
     *
     * // set skew x
     * node.skewX(3);
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'skewY', 0);

    /**
     * get/set skew y
     * @name skewY
     * @param {Number} y
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Number}
     * @example
     * // get skew y
     * var skewY = node.skewY();
     *
     * // set skew y
     * node.skewY(3);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Node, 'offset', ['x', 'y']);

    /**
     * get/set offset.  Offsets the default position and rotation point
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} offset
     * @param {Number} offset.x
     * @param {Number} offset.y
     * @returns {Object}
     * @example
     * // get offset
     * var offset = node.offset();
     *
     * // set offset
     * node.offset({
     *   x: 20
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'offsetX', 0);

    /**
     * get/set offset x
     * @name offsetX
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get offset x
     * var offsetX = node.offsetX();
     *
     * // set offset x
     * node.offsetX(3);
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'offsetY', 0);

    /**
     * get/set offset y
     * @name offsetY
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get offset y
     * var offsetY = node.offsetY();
     *
     * // set offset y
     * node.offsetY(3);
     */

    Konva.Factory.addSetter(Konva.Node, 'dragDistance');
    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'dragDistance');

    /**
     * get/set drag distance
     * @name dragDistance
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} distance
     * @returns {Number}
     * @example
     * // get drag distance
     * var dragDistance = node.dragDistance();
     *
     * // set distance
     * // node starts dragging only if pointer moved more then 3 pixels
     * node.dragDistance(3);
     * // or set globally
     * Konva.dragDistance = 3;
     */


    Konva.Factory.addSetter(Konva.Node, 'width', 0);
    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'width');
    /**
     * get/set width
     * @name width
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} width
     * @returns {Number}
     * @example
     * // get width
     * var width = node.width();
     *
     * // set width
     * node.width(100);
     */

    Konva.Factory.addSetter(Konva.Node, 'height', 0);
    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'height');
    /**
     * get/set height
     * @name height
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} height
     * @returns {Number}
     * @example
     * // get height
     * var height = node.height();
     *
     * // set height
     * node.height(100);
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'listening', 'inherit');
    /**
     * get/set listenig attr.  If you need to determine if a node is listening or not
     *   by taking into account its parents, use the isListening() method
     * @name listening
     * @method
     * @memberof Konva.Node.prototype
     * @param {Boolean|String} listening Can be "inherit", true, or false.  The default is "inherit".
     * @returns {Boolean|String}
     * @example
     * // get listening attr
     * var listening = node.listening();
     *
     * // stop listening for events
     * node.listening(false);
     *
     * // listen for events
     * node.listening(true);
     *
     * // listen to events according to the parent
     * node.listening('inherit');
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'filters', undefined, function(val) {this._filterUpToDate = false; return val; });
    /**
     * get/set filters.  Filters are applied to cached canvases
     * @name filters
     * @method
     * @memberof Konva.Node.prototype
     * @param {Array} filters array of filters
     * @returns {Array}
     * @example
     * // get filters
     * var filters = node.filters();
     *
     * // set a single filter
     * node.cache();
     * node.filters([Konva.Filters.Blur]);
     *
     * // set multiple filters
     * node.cache();
     * node.filters([
     *   Konva.Filters.Blur,
     *   Konva.Filters.Sepia,
     *   Konva.Filters.Invert
     * ]);
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'visible', 'inherit');
    /**
     * get/set visible attr.  Can be "inherit", true, or false.  The default is "inherit".
     *   If you need to determine if a node is visible or not
     *   by taking into account its parents, use the isVisible() method
     * @name visible
     * @method
     * @memberof Konva.Node.prototype
     * @param {Boolean|String} visible
     * @returns {Boolean|String}
     * @example
     * // get visible attr
     * var visible = node.visible();
     *
     * // make invisible
     * node.visible(false);
     *
     * // make visible
     * node.visible(true);
     *
     * // make visible according to the parent
     * node.visible('inherit');
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'transformsEnabled', 'all');

    /**
     * get/set transforms that are enabled.  Can be "all", "none", or "position".  The default
     *  is "all"
     * @name transformsEnabled
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} enabled
     * @returns {String}
     * @example
     * // enable position transform only to improve draw performance
     * node.transformsEnabled('position');
     *
     * // enable all transforms
     * node.transformsEnabled('all');
     */



    /**
     * get/set node size
     * @name size
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} size
     * @param {Number} size.width
     * @param {Number} size.height
     * @returns {Object}
     * @example
     * // get node size
     * var size = node.size();
     * var x = size.x;
     * var y = size.y;
     *
     * // set size
     * node.size({
     *   width: 100,
     *   height: 200
     * });
     */
    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'size');

    Konva.Factory.backCompat(Konva.Node, {
        rotateDeg: 'rotate',
        setRotationDeg: 'setRotation',
        getRotationDeg: 'getRotation'
    });

    Konva.Collection.mapMethods(Konva.Node);
})(Konva);

(function() {
    'use strict';
    /**
    * Grayscale Filter
    * @function
    * @memberof Konva.Filters
    * @param {Object} imageData
    * @example
    * node.cache();
    * node.filters([Konva.Filters.Grayscale]);
    */
    Konva.Filters.Grayscale = function(imageData) {
        var data = imageData.data,
            len = data.length,
            i, brightness;

        for(i = 0; i < len; i += 4) {
            brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
            // red
            data[i] = brightness;
            // green
            data[i + 1] = brightness;
            // blue
            data[i + 2] = brightness;
        }
    };
})();

(function() {
    'use strict';
    /**
     * Brighten Filter.
     * @function
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Brighten]);
     * node.brightness(0.8);
     */
    Konva.Filters.Brighten = function(imageData) {
        var brightness = this.brightness() * 255,
            data = imageData.data,
            len = data.length,
            i;

        for(i = 0; i < len; i += 4) {
            // red
            data[i] += brightness;
            // green
            data[i + 1] += brightness;
            // blue
            data[i + 2] += brightness;
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'brightness', 0, null, Konva.Factory.afterSetFilter);
    /**
    * get/set filter brightness.  The brightness is a number between -1 and 1.&nbsp; Positive values
    *  brighten the pixels and negative values darken them. Use with {@link Konva.Filters.Brighten} filter.
    * @name brightness
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} brightness value between -1 and 1
    * @returns {Number}
    */

})();

(function() {
    'use strict';
    /**
    * Invert Filter
    * @function
    * @memberof Konva.Filters
    * @param {Object} imageData
    * @example
    * node.cache();
    * node.filters([Konva.Filters.Invert]);
    */
    Konva.Filters.Invert = function(imageData) {
        var data = imageData.data,
            len = data.length,
            i;

        for(i = 0; i < len; i += 4) {
            // red
            data[i] = 255 - data[i];
            // green
            data[i + 1] = 255 - data[i + 1];
            // blue
            data[i + 2] = 255 - data[i + 2];
        }
    };
})();

/*
 the Gauss filter
 master repo: https://github.com/pavelpower/kineticjsGaussFilter
*/
(function() {
    'use strict';
    /*

     StackBlur - a fast almost Gaussian Blur For Canvas

     Version:   0.5
     Author:    Mario Klingemann
     Contact:   mario@quasimondo.com
     Website:   http://www.quasimondo.com/StackBlurForCanvas
     Twitter:   @quasimondo

     In case you find this class useful - especially in commercial projects -
     I am not totally unhappy for a small donation to my PayPal account
     mario@quasimondo.de

     Or support me on flattr:
     https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

     Copyright (c) 2010 Mario Klingemann

     Permission is hereby granted, free of charge, to any person
     obtaining a copy of this software and associated documentation
     files (the "Software"), to deal in the Software without
     restriction, including without limitation the rights to use,
     copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the
     Software is furnished to do so, subject to the following
     conditions:

     The above copyright notice and this permission notice shall be
     included in all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
     OTHER DEALINGS IN THE SOFTWARE.
     */

    function BlurStack() {
        this.r = 0;
        this.g = 0;
        this.b = 0;
        this.a = 0;
        this.next = null;
    }

    var mul_table = [
        512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512,
        454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512,
        482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456,
        437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512,
        497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328,
        320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456,
        446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335,
        329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512,
        505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405,
        399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328,
        324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271,
        268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456,
        451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388,
        385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335,
        332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292,
        289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259
    ];

    var shg_table = [
        9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17,
        17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,
        19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
        20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
        21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
        21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,
        22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
        22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23,
        23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
        23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
        23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
        23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24
    ];

    function filterGaussBlurRGBA( imageData, radius) {

        var pixels = imageData.data,
            width = imageData.width,
            height = imageData.height;

        var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum,
            r_out_sum, g_out_sum, b_out_sum, a_out_sum,
            r_in_sum, g_in_sum, b_in_sum, a_in_sum,
            pr, pg, pb, pa, rbs;

        var div = radius + radius + 1,
            widthMinus1 = width - 1,
            heightMinus1 = height - 1,
            radiusPlus1 = radius + 1,
            sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2,
            stackStart = new BlurStack(),
            stackEnd = null,
            stack = stackStart,
            stackIn = null,
            stackOut = null,
            mul_sum = mul_table[radius],
            shg_sum = shg_table[radius];

        for ( i = 1; i < div; i++ ) {
            stack = stack.next = new BlurStack();
            if ( i === radiusPlus1 ){
                stackEnd = stack;
            }
        }

        stack.next = stackStart;

        yw = yi = 0;

        for ( y = 0; y < height; y++ )
        {
            r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;

            r_out_sum = radiusPlus1 * ( pr = pixels[yi] );
            g_out_sum = radiusPlus1 * ( pg = pixels[yi + 1] );
            b_out_sum = radiusPlus1 * ( pb = pixels[yi + 2] );
            a_out_sum = radiusPlus1 * ( pa = pixels[yi + 3] );

            r_sum += sumFactor * pr;
            g_sum += sumFactor * pg;
            b_sum += sumFactor * pb;
            a_sum += sumFactor * pa;

            stack = stackStart;

            for( i = 0; i < radiusPlus1; i++ )
            {
                stack.r = pr;
                stack.g = pg;
                stack.b = pb;
                stack.a = pa;
                stack = stack.next;
            }

            for( i = 1; i < radiusPlus1; i++ )
            {
                p = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );
                r_sum += ( stack.r = ( pr = pixels[p])) * ( rbs = radiusPlus1 - i );
                g_sum += ( stack.g = ( pg = pixels[p + 1])) * rbs;
                b_sum += ( stack.b = ( pb = pixels[p + 2])) * rbs;
                a_sum += ( stack.a = ( pa = pixels[p + 3])) * rbs;

                r_in_sum += pr;
                g_in_sum += pg;
                b_in_sum += pb;
                a_in_sum += pa;

                stack = stack.next;
            }


            stackIn = stackStart;
            stackOut = stackEnd;
            for ( x = 0; x < width; x++ )
            {
                pixels[yi + 3] = pa = (a_sum * mul_sum) >> shg_sum;
                if ( pa !== 0 )
                {
                    pa = 255 / pa;
                    pixels[yi] = ((r_sum * mul_sum) >> shg_sum) * pa;
                    pixels[yi + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
                    pixels[yi + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
                } else {
                    pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
                }

                r_sum -= r_out_sum;
                g_sum -= g_out_sum;
                b_sum -= b_out_sum;
                a_sum -= a_out_sum;

                r_out_sum -= stackIn.r;
                g_out_sum -= stackIn.g;
                b_out_sum -= stackIn.b;
                a_out_sum -= stackIn.a;

                p = (yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;

                r_in_sum += ( stackIn.r = pixels[p]);
                g_in_sum += ( stackIn.g = pixels[p + 1]);
                b_in_sum += ( stackIn.b = pixels[p + 2]);
                a_in_sum += ( stackIn.a = pixels[p + 3]);

                r_sum += r_in_sum;
                g_sum += g_in_sum;
                b_sum += b_in_sum;
                a_sum += a_in_sum;

                stackIn = stackIn.next;

                r_out_sum += ( pr = stackOut.r );
                g_out_sum += ( pg = stackOut.g );
                b_out_sum += ( pb = stackOut.b );
                a_out_sum += ( pa = stackOut.a );

                r_in_sum -= pr;
                g_in_sum -= pg;
                b_in_sum -= pb;
                a_in_sum -= pa;

                stackOut = stackOut.next;

                yi += 4;
            }
            yw += width;
        }


        for ( x = 0; x < width; x++ )
        {
            g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;

            yi = x << 2;
            r_out_sum = radiusPlus1 * ( pr = pixels[yi]);
            g_out_sum = radiusPlus1 * ( pg = pixels[yi + 1]);
            b_out_sum = radiusPlus1 * ( pb = pixels[yi + 2]);
            a_out_sum = radiusPlus1 * ( pa = pixels[yi + 3]);

            r_sum += sumFactor * pr;
            g_sum += sumFactor * pg;
            b_sum += sumFactor * pb;
            a_sum += sumFactor * pa;

            stack = stackStart;

            for( i = 0; i < radiusPlus1; i++ )
            {
                stack.r = pr;
                stack.g = pg;
                stack.b = pb;
                stack.a = pa;
                stack = stack.next;
            }

            yp = width;

            for( i = 1; i <= radius; i++ )
            {
                yi = ( yp + x ) << 2;

                r_sum += ( stack.r = ( pr = pixels[yi])) * ( rbs = radiusPlus1 - i );
                g_sum += ( stack.g = ( pg = pixels[yi + 1])) * rbs;
                b_sum += ( stack.b = ( pb = pixels[yi + 2])) * rbs;
                a_sum += ( stack.a = ( pa = pixels[yi + 3])) * rbs;

                r_in_sum += pr;
                g_in_sum += pg;
                b_in_sum += pb;
                a_in_sum += pa;

                stack = stack.next;

                if( i < heightMinus1 )
                {
                    yp += width;
                }
            }

            yi = x;
            stackIn = stackStart;
            stackOut = stackEnd;
            for ( y = 0; y < height; y++ )
            {
                p = yi << 2;
                pixels[p + 3] = pa = (a_sum * mul_sum) >> shg_sum;
                if ( pa > 0 )
                {
                    pa = 255 / pa;
                    pixels[p] = ((r_sum * mul_sum) >> shg_sum ) * pa;
                    pixels[p + 1] = ((g_sum * mul_sum) >> shg_sum ) * pa;
                    pixels[p + 2] = ((b_sum * mul_sum) >> shg_sum ) * pa;
                } else {
                    pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
                }

                r_sum -= r_out_sum;
                g_sum -= g_out_sum;
                b_sum -= b_out_sum;
                a_sum -= a_out_sum;

                r_out_sum -= stackIn.r;
                g_out_sum -= stackIn.g;
                b_out_sum -= stackIn.b;
                a_out_sum -= stackIn.a;

                p = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;

                r_sum += ( r_in_sum += ( stackIn.r = pixels[p]));
                g_sum += ( g_in_sum += ( stackIn.g = pixels[p + 1]));
                b_sum += ( b_in_sum += ( stackIn.b = pixels[p + 2]));
                a_sum += ( a_in_sum += ( stackIn.a = pixels[p + 3]));

                stackIn = stackIn.next;

                r_out_sum += ( pr = stackOut.r );
                g_out_sum += ( pg = stackOut.g );
                b_out_sum += ( pb = stackOut.b );
                a_out_sum += ( pa = stackOut.a );

                r_in_sum -= pr;
                g_in_sum -= pg;
                b_in_sum -= pb;
                a_in_sum -= pa;

                stackOut = stackOut.next;

                yi += width;
            }
        }
    }

    /**
     * Blur Filter
     * @function
     * @name Blur
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Blur]);
     * node.blurRadius(10);
     */
    Konva.Filters.Blur = function Blur(imageData) {
        var radius = Math.round(this.blurRadius());

        if (radius > 0) {
            filterGaussBlurRGBA(imageData, radius);
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'blurRadius', 0, null, Konva.Factory.afterSetFilter);

    /**
    * get/set blur radius. Use with {@link Konva.Filters.Blur} filter
    * @name blurRadius
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} radius
    * @returns {Integer}
    */
})();

/*eslint-disable  max-depth */
(function() {
	'use strict';
	function pixelAt(idata, x, y) {
		var idx = (y * idata.width + x) * 4;
		var d = [];
		d.push(idata.data[idx++], idata.data[idx++], idata.data[idx++], idata.data[idx++]);
		return d;
	}

	function rgbDistance(p1, p2) {
		return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2) + Math.pow(p1[2] - p2[2], 2));
	}

	function rgbMean(pTab) {
		var m = [0, 0, 0];

		for (var i = 0; i < pTab.length; i++) {
			m[0] += pTab[i][0];
			m[1] += pTab[i][1];
			m[2] += pTab[i][2];
		}

		m[0] /= pTab.length;
		m[1] /= pTab.length;
		m[2] /= pTab.length;

		return m;
	}

	function backgroundMask(idata, threshold) {
		var rgbv_no = pixelAt(idata, 0, 0);
		var rgbv_ne = pixelAt(idata, idata.width - 1, 0);
		var rgbv_so = pixelAt(idata, 0, idata.height - 1);
		var rgbv_se = pixelAt(idata, idata.width - 1, idata.height - 1);


		var thres = threshold || 10;
		if (rgbDistance(rgbv_no, rgbv_ne) < thres && rgbDistance(rgbv_ne, rgbv_se) < thres && rgbDistance(rgbv_se, rgbv_so) < thres && rgbDistance(rgbv_so, rgbv_no) < thres) {

			// Mean color
			var mean = rgbMean([rgbv_ne, rgbv_no, rgbv_se, rgbv_so]);

			// Mask based on color distance
			var mask = [];
			for (var i = 0; i < idata.width * idata.height; i++) {
				var d = rgbDistance(mean, [idata.data[i * 4], idata.data[i * 4 + 1], idata.data[i * 4 + 2]]);
				mask[i] = (d < thres) ? 0 : 255;
			}

			return mask;
		}
	}

	function applyMask(idata, mask) {
		for (var i = 0; i < idata.width * idata.height; i++) {
			idata.data[4 * i + 3] = mask[i];
		}
	}

	function erodeMask(mask, sw, sh) {

		var weights = [1, 1, 1, 1, 0, 1, 1, 1, 1];
		var side = Math.round(Math.sqrt(weights.length));
		var halfSide = Math.floor(side / 2);

		var maskResult = [];
		for (var y = 0; y < sh; y++) {
			for (var x = 0; x < sw; x++) {

				var so = y * sw + x;
				var a = 0;
				for (var cy = 0; cy < side; cy++) {
					for (var cx = 0; cx < side; cx++) {
						var scy = y + cy - halfSide;
						var scx = x + cx - halfSide;

						if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {

							var srcOff = scy * sw + scx;
							var wt = weights[cy * side + cx];

							a += mask[srcOff] * wt;
						}
					}
				}

				maskResult[so] = (a === 255 * 8) ? 255 : 0;
			}
		}

		return maskResult;
	}

	function dilateMask(mask, sw, sh) {

		var weights = [1, 1, 1, 1, 1, 1, 1, 1, 1];
		var side = Math.round(Math.sqrt(weights.length));
		var halfSide = Math.floor(side / 2);

		var maskResult = [];
		for (var y = 0; y < sh; y++) {
			for (var x = 0; x < sw; x++) {

				var so = y * sw + x;
				var a = 0;
				for (var cy = 0; cy < side; cy++) {
					for (var cx = 0; cx < side; cx++) {
						var scy = y + cy - halfSide;
						var scx = x + cx - halfSide;

						if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {

							var srcOff = scy * sw + scx;
							var wt = weights[cy * side + cx];

							a += mask[srcOff] * wt;
						}
					}
				}

				maskResult[so] = (a >= 255 * 4) ? 255 : 0;
			}
		}

		return maskResult;
	}

	function smoothEdgeMask(mask, sw, sh) {

		var weights = [1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9];
		var side = Math.round(Math.sqrt(weights.length));
		var halfSide = Math.floor(side / 2);

		var maskResult = [];
		for (var y = 0; y < sh; y++) {
			for (var x = 0; x < sw; x++) {

				var so = y * sw + x;
				var a = 0;
				for (var cy = 0; cy < side; cy++) {
					for (var cx = 0; cx < side; cx++) {
						var scy = y + cy - halfSide;
						var scx = x + cx - halfSide;

						if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {

							var srcOff = scy * sw + scx;
							var wt = weights[cy * side + cx];

							a += mask[srcOff] * wt;
						}
					}
				}

				maskResult[so] = a;
			}
		}

		return maskResult;
	}

	/**
	 * Mask Filter
	 * @function
	 * @name Mask
	 * @memberof Konva.Filters
	 * @param {Object} imageData
	 * @example
     * node.cache();
     * node.filters([Konva.Filters.Mask]);
     * node.threshold(200);
	 */
	Konva.Filters.Mask = function(imageData) {
		// Detect pixels close to the background color
		var threshold = this.threshold(),
        mask = backgroundMask(imageData, threshold);
		if (mask) {
			// Erode
			mask = erodeMask(mask, imageData.width, imageData.height);

			// Dilate
			mask = dilateMask(mask, imageData.width, imageData.height);

			// Gradient
			mask = smoothEdgeMask(mask, imageData.width, imageData.height);

			// Apply mask
			applyMask(imageData, mask);

			// todo : Update hit region function according to mask
		}

		return imageData;
	};

	Konva.Factory.addGetterSetter(Konva.Node, 'threshold', 0, null, Konva.Factory.afterSetFilter);
})();

(function () {
    'use strict';
    /**
     * RGB Filter
     * @function
     * @name RGB
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author ippo615
     * @example
     * node.cache();
     * node.filters([Konva.Filters.RGB]);
     * node.blue(120);
     * node.green(200);
     */
    Konva.Filters.RGB = function (imageData) {
        var data = imageData.data,
            nPixels = data.length,
            red = this.red(),
            green = this.green(),
            blue = this.blue(),
            i, brightness;

        for (i = 0; i < nPixels; i += 4) {
            brightness = (0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2]) / 255;
            data[i] = brightness * red; // r
            data[i + 1] = brightness * green; // g
            data[i + 2] = brightness * blue; // b
            data[i + 3] = data[i + 3]; // alpha
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'red', 0, function(val) {
        this._filterUpToDate = false;
        if (val > 255) {
            return 255;
        }
        else if (val < 0) {
            return 0;
        }
        else {
            return Math.round(val);
        }
    });
    /**
    * get/set filter red value. Use with {@link Konva.Filters.RGB} filter.
    * @name red
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} red value between 0 and 255
    * @returns {Integer}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'green', 0, function(val) {
        this._filterUpToDate = false;
        if (val > 255) {
            return 255;
        }
        else if (val < 0) {
            return 0;
        }
        else {
            return Math.round(val);
        }
    });
    /**
    * get/set filter green value. Use with {@link Konva.Filters.RGB} filter.
    * @name green
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} green value between 0 and 255
    * @returns {Integer}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'blue', 0, Konva.Validators.RGBComponent, Konva.Factory.afterSetFilter);
    /**
    * get/set filter blue value. Use with {@link Konva.Filters.RGB} filter.
    * @name blue
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} blue value between 0 and 255
    * @returns {Integer}
    */
})();

(function () {
    'use strict';
    /**
     * RGBA Filter
     * @function
     * @name RGBA
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author codefo
     * @example
     * node.cache();
     * node.filters([Konva.Filters.RGBA]);
     * node.blue(120);
     * node.green(200);
     * node.alpha(0.3);
     */
    Konva.Filters.RGBA = function (imageData) {
        var data = imageData.data,
            nPixels = data.length,
            red = this.red(),
            green = this.green(),
            blue = this.blue(),
            alpha = this.alpha(),
            i, ia;

        for (i = 0; i < nPixels; i += 4) {
            ia = 1 - alpha;

            data[i] = red * alpha + data[i] * ia; // r
            data[i + 1] = green * alpha + data[i + 1] * ia; // g
            data[i + 2] = blue * alpha + data[i + 2] * ia; // b
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'red', 0, function(val) {
        this._filterUpToDate = false;
        if (val > 255) {
            return 255;
        }
        else if (val < 0) {
            return 0;
        }
        else {
            return Math.round(val);
        }
    });
    /**
    * get/set filter red value. Use with {@link Konva.Filters.RGBA} filter.
    * @name red
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} red value between 0 and 255
    * @returns {Integer}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'green', 0, function(val) {
        this._filterUpToDate = false;
        if (val > 255) {
            return 255;
        }
        else if (val < 0) {
            return 0;
        }
        else {
            return Math.round(val);
        }
    });
    /**
    * get/set filter green value. Use with {@link Konva.Filters.RGBA} filter.
    * @name green
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} green value between 0 and 255
    * @returns {Integer}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'blue', 0, Konva.Validators.RGBComponent, Konva.Factory.afterSetFilter);
    /**
    * get/set filter blue value. Use with {@link Konva.Filters.RGBA} filter.
    * @name blue
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} blue value between 0 and 255
    * @returns {Integer}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'alpha', 1, function(val) {
        this._filterUpToDate = false;
        if (val > 1) {
            return 1;
        }
        else if (val < 0) {
            return 0;
        }
        else {
            return val;
        }
    });
    /**
     * get/set filter alpha value. Use with {@link Konva.Filters.RGBA} filter.
     * @name alpha
     * @method
     * @memberof Konva.Node.prototype
     * @param {Float} alpha value between 0 and 1
     * @returns {Float}
     */
})();

(function () {
    'use strict';
    /**
    * HSV Filter. Adjusts the hue, saturation and value
    * @function
    * @name HSV
    * @memberof Konva.Filters
    * @param {Object} imageData
    * @author ippo615
    * @example
    * image.filters([Konva.Filters.HSV]);
    * image.value(200);
    */

    Konva.Filters.HSV = function (imageData) {
        var data = imageData.data,
            nPixels = data.length,
            v = Math.pow(2, this.value()),
            s = Math.pow(2, this.saturation()),
            h = Math.abs((this.hue()) + 360) % 360,
            i;

        // Basis for the technique used:
        // http://beesbuzz.biz/code/hsv_color_transforms.php
        // V is the value multiplier (1 for none, 2 for double, 0.5 for half)
        // S is the saturation multiplier (1 for none, 2 for double, 0.5 for half)
        // H is the hue shift in degrees (0 to 360)
        // vsu = V*S*cos(H*PI/180);
        // vsw = V*S*sin(H*PI/180);
        //[ .299V+.701vsu+.168vsw    .587V-.587vsu+.330vsw    .114V-.114vsu-.497vsw ] [R]
        //[ .299V-.299vsu-.328vsw    .587V+.413vsu+.035vsw    .114V-.114vsu+.292vsw ]*[G]
        //[ .299V-.300vsu+1.25vsw    .587V-.588vsu-1.05vsw    .114V+.886vsu-.203vsw ] [B]

        // Precompute the values in the matrix:
        var vsu = v * s * Math.cos(h * Math.PI / 180),
            vsw = v * s * Math.sin(h * Math.PI / 180);
        // (result spot)(source spot)
        var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw,
            rg = 0.587 * v - 0.587 * vsu + 0.330 * vsw,
            rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
        var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw,
            gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw,
            gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
        var br = 0.299 * v - 0.300 * vsu + 1.250 * vsw,
            bg = 0.587 * v - 0.586 * vsu - 1.050 * vsw,
            bb = 0.114 * v + 0.886 * vsu - 0.200 * vsw;

        var r, g, b, a;

        for (i = 0; i < nPixels; i += 4) {
            r = data[i + 0];
            g = data[i + 1];
            b = data[i + 2];
            a = data[i + 3];

            data[i + 0] = rr * r + rg * g + rb * b;
            data[i + 1] = gr * r + gg * g + gb * b;
            data[i + 2] = br * r + bg * g + bb * b;
            data[i + 3] = a; // alpha
        }

    };

    Konva.Factory.addGetterSetter(Konva.Node, 'hue', 0, null, Konva.Factory.afterSetFilter);
    /**
    * get/set hsv hue in degrees. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
    * @name hue
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} hue value between 0 and 359
    * @returns {Number}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'saturation', 0, null, Konva.Factory.afterSetFilter);
    /**
    * get/set hsv saturation. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
    * @name saturation
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} saturation 0 is no change, -1.0 halves the saturation, 1.0 doubles, etc..
    * @returns {Number}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'value', 0, null, Konva.Factory.afterSetFilter);
    /**
    * get/set hsv value. Use with {@link Konva.Filters.HSV} filter.
    * @name value
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} value 0 is no change, -1.0 halves the value, 1.0 doubles, etc..
    * @returns {Number}
    */

})();

(function () {
    'use strict';

    Konva.Factory.addGetterSetter(Konva.Node, 'hue', 0, null, Konva.Factory.afterSetFilter);
    /**
    * get/set hsv hue in degrees. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
    * @name hue
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} hue value between 0 and 359
    * @returns {Number}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'saturation', 0, null, Konva.Factory.afterSetFilter);
    /**
    * get/set hsv saturation. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
    * @name saturation
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} saturation 0 is no change, -1.0 halves the saturation, 1.0 doubles, etc..
    * @returns {Number}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'luminance', 0, null, Konva.Factory.afterSetFilter);
    /**
    * get/set hsl luminance. Use with {@link Konva.Filters.HSL} filter.
    * @name value
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} value 0 is no change, -1.0 halves the value, 1.0 doubles, etc..
    * @returns {Number}
    */

    /**
    * HSL Filter. Adjusts the hue, saturation and luminance (or lightness)
    * @function
    * @memberof Konva.Filters
    * @param {Object} imageData
    * @author ippo615
    * @example
    * image.filters([Konva.Filters.HSL]);
    * image.luminance(200);
    */

    Konva.Filters.HSL = function (imageData) {
        var data = imageData.data,
            nPixels = data.length,
            v = 1,
            s = Math.pow(2, this.saturation()),
            h = Math.abs((this.hue()) + 360) % 360,
            l = this.luminance() * 127,
            i;

        // Basis for the technique used:
        // http://beesbuzz.biz/code/hsv_color_transforms.php
        // V is the value multiplier (1 for none, 2 for double, 0.5 for half)
        // S is the saturation multiplier (1 for none, 2 for double, 0.5 for half)
        // H is the hue shift in degrees (0 to 360)
        // vsu = V*S*cos(H*PI/180);
        // vsw = V*S*sin(H*PI/180);
        //[ .299V+.701vsu+.168vsw    .587V-.587vsu+.330vsw    .114V-.114vsu-.497vsw ] [R]
        //[ .299V-.299vsu-.328vsw    .587V+.413vsu+.035vsw    .114V-.114vsu+.292vsw ]*[G]
        //[ .299V-.300vsu+1.25vsw    .587V-.588vsu-1.05vsw    .114V+.886vsu-.203vsw ] [B]

        // Precompute the values in the matrix:
        var vsu = v * s * Math.cos(h * Math.PI / 180),
            vsw = v * s * Math.sin(h * Math.PI / 180);
        // (result spot)(source spot)
        var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw,
            rg = 0.587 * v - 0.587 * vsu + 0.330 * vsw,
            rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
        var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw,
            gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw,
            gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
        var br = 0.299 * v - 0.300 * vsu + 1.250 * vsw,
            bg = 0.587 * v - 0.586 * vsu - 1.050 * vsw,
            bb = 0.114 * v + 0.886 * vsu - 0.200 * vsw;

        var r, g, b, a;

        for (i = 0; i < nPixels; i += 4) {
            r = data[i + 0];
            g = data[i + 1];
            b = data[i + 2];
            a = data[i + 3];

            data[i + 0] = rr * r + rg * g + rb * b + l;
            data[i + 1] = gr * r + gg * g + gb * b + l;
            data[i + 2] = br * r + bg * g + bb * b + l;
            data[i + 3] = a; // alpha
        }
    };
})();

(function () {
    'use strict';
    /**
     * Emboss Filter.
     * Pixastic Lib - Emboss filter - v0.1.0
     * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
     * License: [http://www.pixastic.com/lib/license.txt]
     * @function
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Emboss]);
     * node.embossStrength(0.8);
     * node.embossWhiteLevel(0.3);
     * node.embossDirection('right');
     * node.embossBlend(true);
     */
    Konva.Filters.Emboss = function (imageData) {

        // pixastic strength is between 0 and 10.  I want it between 0 and 1
        // pixastic greyLevel is between 0 and 255.  I want it between 0 and 1.  Also,
        // a max value of greyLevel yields a white emboss, and the min value yields a black
        // emboss.  Therefore, I changed greyLevel to whiteLevel
        var strength = this.embossStrength() * 10,
            greyLevel = this.embossWhiteLevel() * 255,
            direction = this.embossDirection(),
            blend = this.embossBlend(),
            dirY = 0,
            dirX = 0,
            data = imageData.data,
            w = imageData.width,
            h = imageData.height,
            w4 = w * 4,
            y = h;

        switch (direction) {
            case 'top-left':
                dirY = -1;
                dirX = -1;
                break;
            case 'top':
                dirY = -1;
                dirX = 0;
                break;
            case 'top-right':
                dirY = -1;
                dirX = 1;
                break;
            case 'right':
                dirY = 0;
                dirX = 1;
                break;
            case 'bottom-right':
                dirY = 1;
                dirX = 1;
                break;
            case 'bottom':
                dirY = 1;
                dirX = 0;
                break;
            case 'bottom-left':
                dirY = 1;
                dirX = -1;
                break;
            case 'left':
                dirY = 0;
                dirX = -1;
                break;
        }

        do {
            var offsetY = (y - 1) * w4;

            var otherY = dirY;
            if (y + otherY < 1){
                otherY = 0;
            }
            if (y + otherY > h) {
                otherY = 0;
            }

            var offsetYOther = (y - 1 + otherY) * w * 4;

            var x = w;
            do {
                var offset = offsetY + (x - 1) * 4;

                var otherX = dirX;
                if (x + otherX < 1){
                    otherX = 0;
                }
                if (x + otherX > w) {
                    otherX = 0;
                }

                var offsetOther = offsetYOther + (x - 1 + otherX) * 4;

                var dR = data[offset] - data[offsetOther];
                var dG = data[offset + 1] - data[offsetOther + 1];
                var dB = data[offset + 2] - data[offsetOther + 2];

                var dif = dR;
                var absDif = dif > 0 ? dif : -dif;

                var absG = dG > 0 ? dG : -dG;
                var absB = dB > 0 ? dB : -dB;

                if (absG > absDif) {
                    dif = dG;
                }
                if (absB > absDif) {
                    dif = dB;
                }

                dif *= strength;

                if (blend) {
                    var r = data[offset] + dif;
                    var g = data[offset + 1] + dif;
                    var b = data[offset + 2] + dif;

                    data[offset] = (r > 255) ? 255 : (r < 0 ? 0 : r);
                    data[offset + 1] = (g > 255) ? 255 : (g < 0 ? 0 : g);
                    data[offset + 2] = (b > 255) ? 255 : (b < 0 ? 0 : b);
                } else {
                    var grey = greyLevel - dif;
                    if (grey < 0) {
                        grey = 0;
                    } else if (grey > 255) {
                        grey = 255;
                    }

                    data[offset] = data[offset + 1] = data[offset + 2] = grey;
                }

            } while (--x);
        } while (--y);
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'embossStrength', 0.5, null, Konva.Factory.afterSetFilter);
    /**
    * get/set emboss strength. Use with {@link Konva.Filters.Emboss} filter.
    * @name embossStrength
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} level between 0 and 1.  Default is 0.5
    * @returns {Number}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'embossWhiteLevel', 0.5, null, Konva.Factory.afterSetFilter);
    /**
    * get/set emboss white level. Use with {@link Konva.Filters.Emboss} filter.
    * @name embossWhiteLevel
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} embossWhiteLevel between 0 and 1.  Default is 0.5
    * @returns {Number}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'embossDirection', 'top-left', null, Konva.Factory.afterSetFilter);
    /**
    * get/set emboss direction. Use with {@link Konva.Filters.Emboss} filter.
    * @name embossDirection
    * @method
    * @memberof Konva.Node.prototype
    * @param {String} embossDirection can be top-left, top, top-right, right, bottom-right, bottom, bottom-left or left
    *   The default is top-left
    * @returns {String}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'embossBlend', false, null, Konva.Factory.afterSetFilter);
    /**
    * get/set emboss blend. Use with {@link Konva.Filters.Emboss} filter.
    * @name embossBlend
    * @method
    * @memberof Konva.Node.prototype
    * @param {Boolean} embossBlend
    * @returns {Boolean}
    */
})();

(function () {
    'use strict';
    function remap(fromValue, fromMin, fromMax, toMin, toMax) {
        // Compute the range of the data
        var fromRange = fromMax - fromMin,
          toRange = toMax - toMin,
          toValue;

        // If either range is 0, then the value can only be mapped to 1 value
        if (fromRange === 0) {
            return toMin + toRange / 2;
        }
        if (toRange === 0) {
            return toMin;
        }

        // (1) untranslate, (2) unscale, (3) rescale, (4) retranslate
        toValue = (fromValue - fromMin) / fromRange;
        toValue = (toRange * toValue) + toMin;

        return toValue;
    }


    /**
    * Enhance Filter. Adjusts the colors so that they span the widest
    *  possible range (ie 0-255). Performs w*h pixel reads and w*h pixel
    *  writes.
    * @function
    * @name Enhance
    * @memberof Konva.Filters
    * @param {Object} imageData
    * @author ippo615
    * @example
    * node.cache();
    * node.filters([Konva.Filters.Enhance]);
    * node.enhance(0.4);
    */
    Konva.Filters.Enhance = function (imageData) {
        var data = imageData.data,
            nSubPixels = data.length,
            rMin = data[0], rMax = rMin, r,
            gMin = data[1], gMax = gMin, g,
            bMin = data[2], bMax = bMin, b,
            i;

        // If we are not enhancing anything - don't do any computation
        var enhanceAmount = this.enhance();
        if( enhanceAmount === 0 ){ return; }

        // 1st Pass - find the min and max for each channel:
        for (i = 0; i < nSubPixels; i += 4) {
            r = data[i + 0];
            if (r < rMin) { rMin = r; }
            else if (r > rMax) { rMax = r; }
            g = data[i + 1];
            if (g < gMin) { gMin = g; } else
            if (g > gMax) { gMax = g; }
            b = data[i + 2];
            if (b < bMin) { bMin = b; } else
            if (b > bMax) { bMax = b; }
            //a = data[i + 3];
            //if (a < aMin) { aMin = a; } else
            //if (a > aMax) { aMax = a; }
        }

        // If there is only 1 level - don't remap
        if( rMax === rMin ){ rMax = 255; rMin = 0; }
        if( gMax === gMin ){ gMax = 255; gMin = 0; }
        if( bMax === bMin ){ bMax = 255; bMin = 0; }

        var rMid, rGoalMax, rGoalMin,
            gMid, gGoalMax, gGoalMin,
            bMid, bGoalMax, bGoalMin;

        // If the enhancement is positive - stretch the histogram
        if ( enhanceAmount > 0 ){
            rGoalMax = rMax + enhanceAmount * (255 - rMax);
            rGoalMin = rMin - enhanceAmount * (rMin - 0);
            gGoalMax = gMax + enhanceAmount * (255 - gMax);
            gGoalMin = gMin - enhanceAmount * (gMin - 0);
            bGoalMax = bMax + enhanceAmount * (255 - bMax);
            bGoalMin = bMin - enhanceAmount * (bMin - 0);
        // If the enhancement is negative -   compress the histogram
        } else {
            rMid = (rMax + rMin) * 0.5;
            rGoalMax = rMax + enhanceAmount * (rMax - rMid);
            rGoalMin = rMin + enhanceAmount * (rMin - rMid);
            gMid = (gMax + gMin) * 0.5;
            gGoalMax = gMax + enhanceAmount * (gMax - gMid);
            gGoalMin = gMin + enhanceAmount * (gMin - gMid);
            bMid = (bMax + bMin) * 0.5;
            bGoalMax = bMax + enhanceAmount * (bMax - bMid);
            bGoalMin = bMin + enhanceAmount * (bMin - bMid);
        }

        // Pass 2 - remap everything, except the alpha
        for (i = 0; i < nSubPixels; i += 4) {
            data[i + 0] = remap(data[i + 0], rMin, rMax, rGoalMin, rGoalMax);
            data[i + 1] = remap(data[i + 1], gMin, gMax, gGoalMin, gGoalMax);
            data[i + 2] = remap(data[i + 2], bMin, bMax, bGoalMin, bGoalMax);
            //data[i + 3] = remap(data[i + 3], aMin, aMax, aGoalMin, aGoalMax);
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'enhance', 0, null, Konva.Factory.afterSetFilter);

    /**
    * get/set enhance. Use with {@link Konva.Filters.Enhance} filter.
    * @name enhance
    * @method
    * @memberof Konva.Node.prototype
    * @param {Float} amount
    * @returns {Float}
    */
})();

(function () {
    'use strict';
    /**
     * Posterize Filter. Adjusts the channels so that there are no more
     *  than n different values for that channel. This is also applied
     *  to the alpha channel.
     * @function
     * @name Posterize
     * @author ippo615
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Posterize]);
     * node.levels(0.8);
     */

    Konva.Filters.Posterize = function (imageData) {
        // level must be between 1 and 255
        var levels = Math.round(this.levels() * 254) + 1,
            data = imageData.data,
            len = data.length,
            scale = (255 / levels),
            i;

        for (i = 0; i < len; i += 1) {
            data[i] = Math.floor(data[i] / scale) * scale;
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'levels', 0.5, null, Konva.Factory.afterSetFilter);

    /**
    * get/set levels.  Must be a number between 0 and 1.  Use with {@link Konva.Filters.Posterize} filter.
    * @name levels
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} level between 0 and 1
    * @returns {Number}
    */
})();

(function () {
    'use strict';

    /**
     * Noise Filter. Randomly adds or substracts to the color channels
     * @function
     * @name Noise
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author ippo615
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Noise]);
     * node.noise(0.8);
     */
    Konva.Filters.Noise = function (imageData) {
        var amount = this.noise() * 255,
            data = imageData.data,
            nPixels = data.length,
            half = amount / 2,
            i;

        for (i = 0; i < nPixels; i += 4) {
            data[i + 0] += half - 2 * half * Math.random();
            data[i + 1] += half - 2 * half * Math.random();
            data[i + 2] += half - 2 * half * Math.random();
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'noise', 0.2, null, Konva.Factory.afterSetFilter);

    /**
    * get/set noise amount.  Must be a value between 0 and 1. Use with {@link Konva.Filters.Noise} filter.
    * @name noise
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} noise
    * @returns {Number}
    */
})();

/*eslint-disable max-depth */
(function () {
    'use strict';
    /**
     * Pixelate Filter. Averages groups of pixels and redraws
     *  them as larger pixels
     * @function
     * @name Pixelate
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author ippo615
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Pixelate]);
     * node.pixelSize(10);
     */

    Konva.Filters.Pixelate = function (imageData) {

        var pixelSize = Math.ceil(this.pixelSize()),
            width = imageData.width,
            height = imageData.height,
            x, y, i,
            //pixelsPerBin = pixelSize * pixelSize,
            red, green, blue, alpha,
            nBinsX = Math.ceil(width / pixelSize),
            nBinsY = Math.ceil(height / pixelSize),
            xBinStart, xBinEnd, yBinStart, yBinEnd,
            xBin, yBin, pixelsInBin;
        imageData = imageData.data;

        for (xBin = 0; xBin < nBinsX; xBin += 1) {
            for (yBin = 0; yBin < nBinsY; yBin += 1) {

                // Initialize the color accumlators to 0
                red = 0;
                green = 0;
                blue = 0;
                alpha = 0;

                // Determine which pixels are included in this bin
                xBinStart = xBin * pixelSize;
                xBinEnd = xBinStart + pixelSize;
                yBinStart = yBin * pixelSize;
                yBinEnd = yBinStart + pixelSize;

                // Add all of the pixels to this bin!
                pixelsInBin = 0;
                for (x = xBinStart; x < xBinEnd; x += 1) {
                    if( x >= width ){ continue; }
                    for (y = yBinStart; y < yBinEnd; y += 1) {
                        if( y >= height ){ continue; }
                        i = (width * y + x) * 4;
                        red += imageData[i + 0];
                        green += imageData[i + 1];
                        blue += imageData[i + 2];
                        alpha += imageData[i + 3];
                        pixelsInBin += 1;
                    }
                }

                // Make sure the channels are between 0-255
                red = red / pixelsInBin;
                green = green / pixelsInBin;
                blue = blue / pixelsInBin;

                // Draw this bin
                for (x = xBinStart; x < xBinEnd; x += 1) {
                    if( x >= width ){ continue; }
                    for (y = yBinStart; y < yBinEnd; y += 1) {
                        if( y >= height ){ continue; }
                        i = (width * y + x) * 4;
                        imageData[i + 0] = red;
                        imageData[i + 1] = green;
                        imageData[i + 2] = blue;
                        imageData[i + 3] = alpha;
                    }
                }
            }
        }

    };

    Konva.Factory.addGetterSetter(Konva.Node, 'pixelSize', 8, null, Konva.Factory.afterSetFilter);

    /**
    * get/set pixel size. Use with {@link Konva.Filters.Pixelate} filter.
    * @name pixelSize
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} pixelSize
    * @returns {Integer}
    */
})();

(function () {
    'use strict';
    /**
     * Threshold Filter. Pushes any value above the mid point to
     *  the max and any value below the mid point to the min.
     *  This affects the alpha channel.
     * @function
     * @name Threshold
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author ippo615
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Threshold]);
     * node.threshold(0.1);
     */

    Konva.Filters.Threshold = function (imageData) {
        var level = this.threshold() * 255,
            data = imageData.data,
            len = data.length,
            i;

        for (i = 0; i < len; i += 1) {
            data[i] = data[i] < level ? 0 : 255;
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'threshold', 0.5, null, Konva.Factory.afterSetFilter);

    /**
    * get/set threshold.  Must be a value between 0 and 1. Use with {@link Konva.Filters.Threshold} or {@link Konva.Filters.Mask} filter.
    * @name threshold
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} threshold
    * @returns {Number}
    */
})();

(function() {
    'use strict';
    /**
     * Sepia Filter
     * Based on: Pixastic Lib - Sepia filter - v0.1.0
     * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
     * @function
     * @name Sepia
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author Jacob Seidelin <jseidelin@nihilogic.dk>
     * @license MPL v1.1 [http://www.pixastic.com/lib/license.txt]
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Sepia]);
     */
    Konva.Filters.Sepia = function (imageData) {
        var data = imageData.data,
            w = imageData.width,
            y = imageData.height,
            w4 = w * 4,
            offsetY, x, offset, or, og, ob, r, g, b;

        do {
            offsetY = (y - 1) * w4;
            x = w;
            do {
                offset = offsetY + (x - 1) * 4;

                or = data[offset];
                og = data[offset + 1];
                ob = data[offset + 2];

                r = or * 0.393 + og * 0.769 + ob * 0.189;
                g = or * 0.349 + og * 0.686 + ob * 0.168;
                b = or * 0.272 + og * 0.534 + ob * 0.131;

                data[offset] = r > 255 ? 255 : r;
                data[offset + 1] = g > 255 ? 255 : g;
                data[offset + 2] = b > 255 ? 255 : b;
                data[offset + 3] = data[offset + 3];
            } while (--x);
        } while (--y);
    };
})();

(function () {
    'use strict';
    /**
     * Solarize Filter
     * Pixastic Lib - Solarize filter - v0.1.0
     * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
     * License: [http://www.pixastic.com/lib/license.txt]
     * @function
     * @name Solarize
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Solarize]);
     */
    Konva.Filters.Solarize = function (imageData) {
        var data = imageData.data,
            w = imageData.width,
            h = imageData.height,
            w4 = w * 4,
            y = h;

        do {
            var offsetY = (y - 1) * w4;
            var x = w;
            do {
                var offset = offsetY + (x - 1) * 4;
                var r = data[offset];
                var g = data[offset + 1];
                var b = data[offset + 2];

                if (r > 127) {
                    r = 255 - r;
                }
                if (g > 127) {
                    g = 255 - g;
                }
                if (b > 127) {
                    b = 255 - b;
                }

                data[offset] = r;
                data[offset + 1] = g;
                data[offset + 2] = b;
            } while (--x);
        } while (--y);
    };
})();



(function () {
    'use strict';

  /*
   * ToPolar Filter. Converts image data to polar coordinates. Performs
   *  w*h*4 pixel reads and w*h pixel writes. The r axis is placed along
   *  what would be the y axis and the theta axis along the x axis.
   * @function
   * @author ippo615
   * @memberof Konva.Filters
   * @param {ImageData} src, the source image data (what will be transformed)
   * @param {ImageData} dst, the destination image data (where it will be saved)
   * @param {Object} opt
   * @param {Number} [opt.polarCenterX] horizontal location for the center of the circle,
   *  default is in the middle
   * @param {Number} [opt.polarCenterY] vertical location for the center of the circle,
   *  default is in the middle
   */

    var ToPolar = function(src, dst, opt){

        var srcPixels = src.data,
            dstPixels = dst.data,
            xSize = src.width,
            ySize = src.height,
            xMid = opt.polarCenterX || xSize / 2,
            yMid = opt.polarCenterY || ySize / 2,
            i, x, y, r = 0, g = 0, b = 0, a = 0;

        // Find the largest radius
        var rad, rMax = Math.sqrt( xMid * xMid + yMid * yMid );
        x = xSize - xMid;
        y = ySize - yMid;
        rad = Math.sqrt( x * x + y * y );
        rMax = (rad > rMax) ? rad : rMax;

        // We'll be uisng y as the radius, and x as the angle (theta=t)
        var rSize = ySize,
            tSize = xSize,
            radius, theta;

        // We want to cover all angles (0-360) and we need to convert to
        // radians (*PI/180)
        var conversion = 360 / tSize * Math.PI / 180, sin, cos;

        // var x1, x2, x1i, x2i, y1, y2, y1i, y2i, scale;

        for( theta = 0; theta < tSize; theta += 1 ){
            sin = Math.sin(theta * conversion);
            cos = Math.cos(theta * conversion);
            for( radius = 0; radius < rSize; radius += 1 ){
                x = Math.floor(xMid + rMax * radius / rSize * cos);
                y = Math.floor(yMid + rMax * radius / rSize * sin);
                i = (y * xSize + x) * 4;
                r = srcPixels[i + 0];
                g = srcPixels[i + 1];
                b = srcPixels[i + 2];
                a = srcPixels[i + 3];

                // Store it
                //i = (theta * xSize  +  radius) * 4;
                i = (theta + radius * xSize) * 4;
                dstPixels[i + 0] = r;
                dstPixels[i + 1] = g;
                dstPixels[i + 2] = b;
                dstPixels[i + 3] = a;

            }
        }
    };

    /*
     * FromPolar Filter. Converts image data from polar coordinates back to rectangular.
     *  Performs w*h*4 pixel reads and w*h pixel writes.
     * @function
     * @author ippo615
     * @memberof Konva.Filters
     * @param {ImageData} src, the source image data (what will be transformed)
     * @param {ImageData} dst, the destination image data (where it will be saved)
     * @param {Object} opt
     * @param {Number} [opt.polarCenterX] horizontal location for the center of the circle,
     *  default is in the middle
     * @param {Number} [opt.polarCenterY] vertical location for the center of the circle,
     *  default is in the middle
     * @param {Number} [opt.polarRotation] amount to rotate the image counterclockwis,
     *  0 is no rotation, 360 degrees is a full rotation
     */

    var FromPolar = function(src, dst, opt){

        var srcPixels = src.data,
            dstPixels = dst.data,
            xSize = src.width,
            ySize = src.height,
            xMid = opt.polarCenterX || xSize / 2,
            yMid = opt.polarCenterY || ySize / 2,
            i, x, y, dx, dy, r = 0, g = 0, b = 0, a = 0;


        // Find the largest radius
        var rad, rMax = Math.sqrt( xMid * xMid + yMid * yMid );
        x = xSize - xMid;
        y = ySize - yMid;
        rad = Math.sqrt( x * x + y * y );
        rMax = (rad > rMax) ? rad : rMax;

        // We'll be uisng x as the radius, and y as the angle (theta=t)
        var rSize = ySize,
        tSize = xSize,
        radius, theta,
        phaseShift = opt.polarRotation || 0;

        // We need to convert to degrees and we need to make sure
        // it's between (0-360)
        // var conversion = tSize/360*180/Math.PI;
        //var conversion = tSize/360*180/Math.PI;

        var x1, y1;

        for( x = 0; x < xSize; x += 1 ){
            for( y = 0; y < ySize; y += 1 ){
                dx = x - xMid;
                dy = y - yMid;
                radius = Math.sqrt(dx * dx + dy * dy) * rSize / rMax;
                theta = (Math.atan2(dy, dx) * 180 / Math.PI + 360 + phaseShift) % 360;
                theta = theta * tSize / 360;
                x1 = Math.floor(theta);
                y1 = Math.floor(radius);
                i = (y1 * xSize + x1) * 4;
                r = srcPixels[i + 0];
                g = srcPixels[i + 1];
                b = srcPixels[i + 2];
                a = srcPixels[i + 3];

                // Store it
                i = (y * xSize + x) * 4;
                dstPixels[i + 0] = r;
                dstPixels[i + 1] = g;
                dstPixels[i + 2] = b;
                dstPixels[i + 3] = a;
            }
        }

    };

    //Konva.Filters.ToPolar = Konva.Util._FilterWrapDoubleBuffer(ToPolar);
    //Konva.Filters.FromPolar = Konva.Util._FilterWrapDoubleBuffer(FromPolar);

    // create a temporary canvas for working - shared between multiple calls
    var tempCanvas = Konva.Util.createCanvasElement();

    /*
     * Kaleidoscope Filter.
     * @function
     * @name Kaleidoscope
     * @author ippo615
     * @memberof Konva.Filters
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Kaleidoscope]);
     * node.kaleidoscopePower(3);
     * node.kaleidoscopeAngle(45);
     */
    Konva.Filters.Kaleidoscope = function(imageData){
        var xSize = imageData.width,
            ySize = imageData.height;

        var x, y, xoff, i, r, g, b, a, srcPos, dstPos;
        var power = Math.round( this.kaleidoscopePower() );
        var angle = Math.round( this.kaleidoscopeAngle() );
        var offset = Math.floor(xSize * (angle % 360) / 360);

        if( power < 1 ){return; }

        // Work with our shared buffer canvas
        tempCanvas.width = xSize;
        tempCanvas.height = ySize;
        var scratchData = tempCanvas.getContext('2d').getImageData(0, 0, xSize, ySize);

        // Convert thhe original to polar coordinates
        ToPolar( imageData, scratchData, {
            polarCenterX: xSize / 2,
            polarCenterY: ySize / 2
        });

        // Determine how big each section will be, if it's too small
        // make it bigger
        var minSectionSize = xSize / Math.pow(2, power);
        while( minSectionSize <= 8){
            minSectionSize = minSectionSize * 2;
            power -= 1;
        }
        minSectionSize = Math.ceil(minSectionSize);
        var sectionSize = minSectionSize;

        // Copy the offset region to 0
        // Depending on the size of filter and location of the offset we may need
        // to copy the section backwards to prevent it from rewriting itself
        var xStart = 0,
          xEnd = sectionSize,
          xDelta = 1;
        if( offset + minSectionSize > xSize ){
            xStart = sectionSize;
            xEnd = 0;
            xDelta = -1;
        }
        for( y = 0; y < ySize; y += 1 ){
            for( x = xStart; x !== xEnd; x += xDelta ){
                xoff = Math.round(x + offset) % xSize;
                srcPos = (xSize * y + xoff) * 4;
                r = scratchData.data[srcPos + 0];
                g = scratchData.data[srcPos + 1];
                b = scratchData.data[srcPos + 2];
                a = scratchData.data[srcPos + 3];
                dstPos = (xSize * y + x) * 4;
                scratchData.data[dstPos + 0] = r;
                scratchData.data[dstPos + 1] = g;
                scratchData.data[dstPos + 2] = b;
                scratchData.data[dstPos + 3] = a;
            }
        }

        // Perform the actual effect
        for( y = 0; y < ySize; y += 1 ){
            sectionSize = Math.floor( minSectionSize );
            for( i = 0; i < power; i += 1 ){
                for( x = 0; x < sectionSize + 1; x += 1 ){
                    srcPos = (xSize * y + x) * 4;
                    r = scratchData.data[srcPos + 0];
                    g = scratchData.data[srcPos + 1];
                    b = scratchData.data[srcPos + 2];
                    a = scratchData.data[srcPos + 3];
                    dstPos = (xSize * y + sectionSize * 2 - x - 1) * 4;
                    scratchData.data[dstPos + 0] = r;
                    scratchData.data[dstPos + 1] = g;
                    scratchData.data[dstPos + 2] = b;
                    scratchData.data[dstPos + 3] = a;
                }
                sectionSize *= 2;
            }
        }

        // Convert back from polar coordinates
        FromPolar(scratchData, imageData, {polarRotation: 0});
    };

    /**
    * get/set kaleidoscope power. Use with {@link Konva.Filters.Kaleidoscope} filter.
    * @name kaleidoscopePower
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} power of kaleidoscope
    * @returns {Integer}
    */
    Konva.Factory.addGetterSetter(Konva.Node, 'kaleidoscopePower', 2, null, Konva.Factory.afterSetFilter);

    /**
    * get/set kaleidoscope angle. Use with {@link Konva.Filters.Kaleidoscope} filter.
    * @name kaleidoscopeAngle
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} degrees
    * @returns {Integer}
    */
    Konva.Factory.addGetterSetter(Konva.Node, 'kaleidoscopeAngle', 0, null, Konva.Factory.afterSetFilter);

})();

(function() {
    'use strict';
    /**
     * Container constructor.&nbsp; Containers are used to contain nodes or other containers
     * @constructor
     * @memberof Konva
     * @augments Konva.Node
     * @abstract
     * @param {Object} config
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height

     */
    Konva.Container = function(config) {
        this.__init(config);
    };

    Konva.Util.addMethods(Konva.Container, {
        __init: function(config) {
            this.children = new Konva.Collection();
            Konva.Node.call(this, config);
        },
        /**
         * returns a {@link Konva.Collection} of direct descendant nodes
         * @method
         * @memberof Konva.Container.prototype
         * @param {Function} [filterFunc] filter function
         * @returns {Konva.Collection}
         * @example
         * // get all children
         * var children = layer.getChildren();
         *
         * // get only circles
         * var circles = layer.getChildren(function(node){
         *    return node.getClassName() === 'Circle';
         * });
         */
        getChildren: function(filterFunc) {
            if (!filterFunc) {
                return this.children;
            }

            var results = new Konva.Collection();
            this.children.each(function(child){
                if (filterFunc(child)) {
                    results.push(child);
                }
            });
            return results;
        },
        /**
         * determine if node has children
         * @method
         * @memberof Konva.Container.prototype
         * @returns {Boolean}
         */
        hasChildren: function() {
            return this.getChildren().length > 0;
        },
        /**
         * remove all children
         * @method
         * @memberof Konva.Container.prototype
         */
        removeChildren: function() {
            var children = Konva.Collection.toCollection(this.children);
            var child;
            for (var i = 0; i < children.length; i++) {
                child = children[i];
                // reset parent to prevent many _setChildrenIndices calls
                delete child.parent;
                child.index = 0;
                if (child.hasChildren()) {
                    child.removeChildren();
                }
                child.remove();
            }
            children = null;
            this.children = new Konva.Collection();
            return this;
        },
        /**
         * destroy all children
         * @method
         * @memberof Konva.Container.prototype
         */
        destroyChildren: function() {
           var children = Konva.Collection.toCollection(this.children);
            var child;
            for (var i = 0; i < children.length; i++) {
                child = children[i];
                // reset parent to prevent many _setChildrenIndices calls
                delete child.parent;
                child.index = 0;
                child.destroy();
            }
            children = null;
            this.children = new Konva.Collection();
            return this;
        },
        /**
         * Add node or nodes to container.
         * @method
         * @memberof Konva.Container.prototype
         * @param {...Konva.Node} child
         * @returns {Container}
         * @example
         * layer.add(shape1, shape2, shape3);
         */
        add: function(child) {
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) {
                    this.add(arguments[i]);
                }
                return this;
            }
            if (child.getParent()) {
                child.moveTo(this);
                return this;
            }
            var children = this.children;
            this._validateAdd(child);
            child.index = children.length;
            child.parent = this;
            children.push(child);
            this._fire('add', {
                child: child
            });

            // if node under drag we need to update drag animation
            if (Konva.DD && child.isDragging()) {
                Konva.DD.anim.setLayers(child.getLayer());
            }

            // chainable
            return this;
        },
        destroy: function() {
            // destroy children
            if (this.hasChildren()) {
                this.destroyChildren();
            }
            // then destroy self
            Konva.Node.prototype.destroy.call(this);
            return this;
        },
        /**
         * return a {@link Konva.Collection} of nodes that match the selector.  Use '#' for id selections
         * and '.' for name selections.  You can also select by type or class name. Pass multiple selectors
         * separated by a space.
         * @method
         * @memberof Konva.Container.prototype
         * @param {String} selector
         * @returns {Collection}
         * @example
         * // select node with id foo
         * var node = stage.find('#foo');
         *
         * // select nodes with name bar inside layer
         * var nodes = layer.find('.bar');
         *
         * // select all groups inside layer
         * var nodes = layer.find('Group');
         *
         * // select all rectangles inside layer
         * var nodes = layer.find('Rect');
         *
         * // select node with an id of foo or a name of bar inside layer
         * var nodes = layer.find('#foo, .bar');
         */
        find: function(selector) {
            var retArr = [],
                selectorArr = selector.replace(/ /g, '').split(','),
                len = selectorArr.length,
                n, i, sel, arr, node, children, clen;

            for (n = 0; n < len; n++) {
                sel = selectorArr[n];
                if (!Konva.Util.isValidSelector(sel)) {
                    Konva.Util.warn('Selector "' + sel + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".');
                    Konva.Util.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".');
                    Konva.Util.warn('Konva is awesome, right?');
                }
                // id selector
                if(sel.charAt(0) === '#') {
                    node = this._getNodeById(sel.slice(1));
                    if(node) {
                        retArr.push(node);
                    }
                }
                // name selector
                else if(sel.charAt(0) === '.') {
                    arr = this._getNodesByName(sel.slice(1));
                    retArr = retArr.concat(arr);
                }
                // unrecognized selector, pass to children
                else {
                    children = this.getChildren();
                    clen = children.length;
                    for(i = 0; i < clen; i++) {
                        retArr = retArr.concat(children[i]._get(sel));
                    }
                }
            }

            return Konva.Collection.toCollection(retArr);
        },
        /**
         * return a first node from `find` method
         * @method
         * @memberof Konva.Container.prototype
         * @param {String} selector
         * @returns {Konva.Node}
         * @example
         * // select node with id foo
         * var node = stage.findOne('#foo');
         *
         * // select node with name bar inside layer
         * var nodes = layer.findOne('.bar');
         */
        findOne: function(selector) {
            return this.find(selector)[0];
        },
        _getNodeById: function(key) {
            var node = Konva.ids[key];

            if(node !== undefined && this.isAncestorOf(node)) {
                return node;
            }
            return null;
        },
        _getNodesByName: function(key) {
            var arr = Konva.names[key] || [];
            return this._getDescendants(arr);
        },
        _get: function(selector) {
            var retArr = Konva.Node.prototype._get.call(this, selector);
            var children = this.getChildren();
            var len = children.length;
            for(var n = 0; n < len; n++) {
                retArr = retArr.concat(children[n]._get(selector));
            }
            return retArr;
        },
        // extenders
        toObject: function() {
            var obj = Konva.Node.prototype.toObject.call(this);

            obj.children = [];

            var children = this.getChildren();
            var len = children.length;
            for(var n = 0; n < len; n++) {
                var child = children[n];
                obj.children.push(child.toObject());
            }

            return obj;
        },
        _getDescendants: function(arr) {
            var retArr = [];
            var len = arr.length;
            for(var n = 0; n < len; n++) {
                var node = arr[n];
                if(this.isAncestorOf(node)) {
                    retArr.push(node);
                }
            }

            return retArr;
        },
        /**
         * determine if node is an ancestor
         * of descendant
         * @method
         * @memberof Konva.Container.prototype
         * @param {Konva.Node} node
         */
        isAncestorOf: function(node) {
            var parent = node.getParent();
            while(parent) {
                if(parent._id === this._id) {
                    return true;
                }
                parent = parent.getParent();
            }

            return false;
        },
        clone: function(obj) {
            // call super method
            var node = Konva.Node.prototype.clone.call(this, obj);

            this.getChildren().each(function(no) {
                node.add(no.clone());
            });
            return node;
        },
        /**
         * get all shapes that intersect a point.  Note: because this method must clear a temporary
         * canvas and redraw every shape inside the container, it should only be used for special sitations
         * because it performs very poorly.  Please use the {@link Konva.Stage#getIntersection} method if at all possible
         * because it performs much better
         * @method
         * @memberof Konva.Container.prototype
         * @param {Object} pos
         * @param {Number} pos.x
         * @param {Number} pos.y
         * @returns {Array} array of shapes
         */
        getAllIntersections: function(pos) {
            var arr = [];

            this.find('Shape').each(function(shape) {
                if(shape.isVisible() && shape.intersects(pos)) {
                    arr.push(shape);
                }
            });

            return arr;
        },
        _setChildrenIndices: function() {
            this.children.each(function(child, n) {
                child.index = n;
            });
        },
        drawScene: function(can, top, caching) {
            var layer = this.getLayer(),
                canvas = can || (layer && layer.getCanvas()),
                context = canvas && canvas.getContext(),
                cachedCanvas = this._cache.canvas,
                cachedSceneCanvas = cachedCanvas && cachedCanvas.scene;

            if (this.isVisible()) {
                if (!caching && cachedSceneCanvas) {
                    context.save();
                    layer._applyTransform(this, context, top);
                    this._drawCachedSceneCanvas(context);
                    context.restore();
                }
                else {
                    this._drawChildren(canvas, 'drawScene', top, false, caching);
                }
            }
            return this;
        },
        drawHit: function(can, top, caching) {
            var layer = this.getLayer(),
                canvas = can || (layer && layer.hitCanvas),
                context = canvas && canvas.getContext(),
                cachedCanvas = this._cache.canvas,
                cachedHitCanvas = cachedCanvas && cachedCanvas.hit;

            if (this.shouldDrawHit(canvas)) {
                if (layer) {
                    layer.clearHitCache();
                }
                if (!caching && cachedHitCanvas) {
                    context.save();
                    layer._applyTransform(this, context, top);
                    this._drawCachedHitCanvas(context);
                    context.restore();
                }
                else {
                    this._drawChildren(canvas, 'drawHit', top);
                }
            }
            return this;
        },
        _drawChildren: function(canvas, drawMethod, top, caching, skipBuffer) {
            var layer = this.getLayer(),
                context = canvas && canvas.getContext(),
                clipWidth = this.getClipWidth(),
                clipHeight = this.getClipHeight(),
                hasClip = clipWidth && clipHeight,
                clipX, clipY;

            if (hasClip && layer) {
                clipX = this.getClipX();
                clipY = this.getClipY();

                context.save();
                layer._applyTransform(this, context);
                context.beginPath();
                context.rect(clipX, clipY, clipWidth, clipHeight);
                context.clip();
                context.reset();
            }

            this.children.each(function(child) {
                child[drawMethod](canvas, top, caching, skipBuffer);
            });

            if (hasClip) {
                context.restore();
            }
        },
        shouldDrawHit: function(canvas) {
            var layer = this.getLayer();
            var dd = Konva.DD;
            var layerUnderDrag = dd && Konva.isDragging() && (Konva.DD.anim.getLayers().indexOf(layer) !== -1);
            return (canvas && canvas.isCache) || (layer && layer.hitGraphEnabled())
                && this.isVisible() && !layerUnderDrag;
        },
        getClientRect: function(skipTransform) {
            var minX, minY, maxX, maxY;
            var selfRect = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            };
            this.children.each(function(child) {
                var rect = child.getClientRect();

                // skip invisible children (like empty groups)
                // or don't skip... hmmm...
                // if (rect.width === 0 && rect.height === 0) {
                //     return;
                // }

                if (minX === undefined) { // initial value for first child
                    minX = rect.x;
                    minY = rect.y;
                    maxX = rect.x + rect.width;
                    maxY = rect.y + rect.height;
                } else {
                    minX = Math.min(minX, rect.x);
                    minY = Math.min(minY, rect.y);
                    maxX = Math.max(maxX, rect.x + rect.width);
                    maxY = Math.max(maxY, rect.y + rect.height);
                }

            });

            if (this.children.length !== 0) {
                selfRect = {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            }

            if (!skipTransform) {
                return this._transformedRect(selfRect);
            }
            return selfRect;
        }
    });

    Konva.Util.extend(Konva.Container, Konva.Node);
    // deprecated methods
    Konva.Container.prototype.get = Konva.Container.prototype.find;

    // add getters setters
    Konva.Factory.addComponentsGetterSetter(Konva.Container, 'clip', ['x', 'y', 'width', 'height']);
    /**
     * get/set clip
     * @method
     * @name clip
     * @memberof Konva.Container.prototype
     * @param {Object} clip
     * @param {Number} clip.x
     * @param {Number} clip.y
     * @param {Number} clip.width
     * @param {Number} clip.height
     * @returns {Object}
     * @example
     * // get clip
     * var clip = container.clip();
     *
     * // set clip
     * container.setClip({
     *   x: 20,
     *   y: 20,
     *   width: 20,
     *   height: 20
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Container, 'clipX');
    /**
     * get/set clip x
     * @name clipX
     * @method
     * @memberof Konva.Container.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get clip x
     * var clipX = container.clipX();
     *
     * // set clip x
     * container.clipX(10);
     */

    Konva.Factory.addGetterSetter(Konva.Container, 'clipY');
    /**
     * get/set clip y
     * @name clipY
     * @method
     * @memberof Konva.Container.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get clip y
     * var clipY = container.clipY();
     *
     * // set clip y
     * container.clipY(10);
     */

    Konva.Factory.addGetterSetter(Konva.Container, 'clipWidth');
    /**
     * get/set clip width
     * @name clipWidth
     * @method
     * @memberof Konva.Container.prototype
     * @param {Number} width
     * @returns {Number}
     * @example
     * // get clip width
     * var clipWidth = container.clipWidth();
     *
     * // set clip width
     * container.clipWidth(100);
     */

    Konva.Factory.addGetterSetter(Konva.Container, 'clipHeight');
    /**
     * get/set clip height
     * @name clipHeight
     * @method
     * @memberof Konva.Container.prototype
     * @param {Number} height
     * @returns {Number}
     * @example
     * // get clip height
     * var clipHeight = container.clipHeight();
     *
     * // set clip height
     * container.clipHeight(100);
     */

    Konva.Collection.mapMethods(Konva.Container);
})();

(function(Konva) {
    'use strict';
    var HAS_SHADOW = 'hasShadow';
    var SHADOW_RGBA = 'shadowRGBA';

    function _fillFunc(context) {
        context.fill();
    }
    function _strokeFunc(context) {
        context.stroke();
    }
    function _fillFuncHit(context) {
        context.fill();
    }
    function _strokeFuncHit(context) {
        context.stroke();
    }

    function _clearHasShadowCache() {
        this._clearCache(HAS_SHADOW);
    }

    function _clearGetShadowRGBACache() {
        this._clearCache(SHADOW_RGBA);
    }

    /**
     * Shape constructor.  Shapes are primitive objects such as rectangles,
     *  circles, text, lines, etc.
     * @constructor
     * @memberof Konva
     * @augments Konva.Node
     * @param {Object} config
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var customShape = new Konva.Shape({
         *   x: 5,
         *   y: 10,
         *   fill: 'red',
         *   // a Konva.Canvas renderer is passed into the drawFunc function
         *   drawFunc: function(context) {
         *     context.beginPath();
         *     context.moveTo(200, 50);
         *     context.lineTo(420, 80);
         *     context.quadraticCurveTo(300, 100, 260, 170);
         *     context.closePath();
         *     context.fillStrokeShape(this);
         *   }
         *});
     */
    Konva.Shape = function(config) {
        this.__init(config);
    };

    Konva.Util.addMethods(Konva.Shape, {
        __init: function(config) {
            this.nodeType = 'Shape';
            this._fillFunc = _fillFunc;
            this._strokeFunc = _strokeFunc;
            this._fillFuncHit = _fillFuncHit;
            this._strokeFuncHit = _strokeFuncHit;

            // set colorKey
            var shapes = Konva.shapes;
            var key;

            while(true) {
                key = Konva.Util.getRandomColor();
                if(key && !( key in shapes)) {
                    break;
                }
            }

            this.colorKey = key;
            shapes[key] = this;

            // call super constructor
            Konva.Node.call(this, config);

            this.on('shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearHasShadowCache);

            this.on('shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearGetShadowRGBACache);
        },
        hasChildren: function() {
            return false;
        },
        getChildren: function() {
            return [];
        },
        /**
         * get canvas context tied to the layer
         * @method
         * @memberof Konva.Shape.prototype
         * @returns {Konva.Context}
         */
        getContext: function() {
            return this.getLayer().getContext();
        },
        /**
         * get canvas renderer tied to the layer.  Note that this returns a canvas renderer, not a canvas element
         * @method
         * @memberof Konva.Shape.prototype
         * @returns {Konva.Canvas}
         */
        getCanvas: function() {
            return this.getLayer().getCanvas();
        },
        /**
         * returns whether or not a shadow will be rendered
         * @method
         * @memberof Konva.Shape.prototype
         * @returns {Boolean}
         */
        hasShadow: function() {
            return this._getCache(HAS_SHADOW, this._hasShadow);
        },
        _hasShadow: function() {
            return this.getShadowEnabled() && (this.getShadowOpacity() !== 0 && !!(this.getShadowColor() || this.getShadowBlur() || this.getShadowOffsetX() || this.getShadowOffsetY()));
        },
        getShadowRGBA: function() {
            return this._getCache(SHADOW_RGBA, this._getShadowRGBA);
        },
        _getShadowRGBA: function() {
            if (this.hasShadow()) {
                var rgba = Konva.Util.colorToRGBA(this.shadowColor());
                return 'rgba(' + rgba.r + ',' + rgba.g + ',' + rgba.b + ',' + (rgba.a * (this.getShadowOpacity() || 1)) + ')';
            }
        },
        /**
         * returns whether or not the shape will be filled
         * @method
         * @memberof Konva.Shape.prototype
         * @returns {Boolean}
         */
        hasFill: function() {
            return !!(this.getFill() || this.getFillPatternImage() || this.getFillLinearGradientColorStops() || this.getFillRadialGradientColorStops());
        },
        /**
         * returns whether or not the shape will be stroked
         * @method
         * @memberof Konva.Shape.prototype
         * @returns {Boolean}
         */
        hasStroke: function() {
            return !!(this.stroke());
        },
        /**
         * determines if point is in the shape, regardless if other shapes are on top of it.  Note: because
         *  this method clears a temporary canvas and then redraws the shape, it performs very poorly if executed many times
         *  consecutively.  Please use the {@link Konva.Stage#getIntersection} method if at all possible
         *  because it performs much better
         * @method
         * @memberof Konva.Shape.prototype
         * @param {Object} point
         * @param {Number} point.x
         * @param {Number} point.y
         * @returns {Boolean}
         */
        intersects: function(point) {
            var stage = this.getStage(),
                bufferHitCanvas = stage.bufferHitCanvas,
                p;

            bufferHitCanvas.getContext().clear();
            this.drawScene(bufferHitCanvas);
            p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;
            return p[3] > 0;
        },
        // extends Node.prototype.destroy
        destroy: function() {
            Konva.Node.prototype.destroy.call(this);
            delete Konva.shapes[this.colorKey];
            return this;
        },
        _useBufferCanvas: function(caching) {
            return !caching && (this.perfectDrawEnabled() && (this.getAbsoluteOpacity() !== 1) && this.hasFill() && this.hasStroke() && this.getStage()) ||
                   (this.perfectDrawEnabled() && this.hasShadow() && (this.getAbsoluteOpacity() !== 1) && this.hasFill() && this.hasStroke() && this.getStage());
        },
        /**
         * return self rectangle (x, y, width, height) of shape.
         * This method are not taken into account transformation and styles.
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Object} rect with {x, y, width, height} properties
         * @example
         *
         * rect.getSelfRect();  // return {x:0, y:0, width:rect.width(), height:rect.height()}
         * circle.getSelfRect();  // return {x: - circle.width() / 2, y: - circle.height() / 2, width:circle.width(), height:circle.height()}
         *
         */
        getSelfRect: function() {
            var size = this.getSize();
            return {
                x: this._centroid ? Math.round(-size.width / 2) : 0,
                y: this._centroid ? Math.round(-size.height / 2) : 0,
                width: size.width,
                height: size.height
            };
        },
        getClientRect: function(skipTransform) {
            var fillRect = this.getSelfRect();

            var strokeWidth = (this.hasStroke() && this.strokeWidth()) || 0;
            var fillAndStrokeWidth = fillRect.width + strokeWidth;
            var fillAndStrokeHeight = fillRect.height + strokeWidth;

            var shadowOffsetX = this.shadowOffsetX();
            var shadowOffsetY = this.shadowOffsetY();

            var preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);
            var preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);

            var blurRadius = (this.hasShadow() && this.shadowBlur() || 0);

            var width = preWidth + blurRadius * 2;
            var height = preHeight + blurRadius * 2;

            // if stroke, for example = 3
            // we need to set x to 1.5, but after Math.round it will be 2
            // as we have additional offset we need to increase width and height by 1 pixel
            var roundingOffset = 0;
            if (Math.round(strokeWidth / 2) !== strokeWidth / 2) {
                roundingOffset = 1;
            }
            var rect = {
                width: width + roundingOffset,
                height: height + roundingOffset,
                x: -Math.round(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetX, 0) + fillRect.x,
                y: -Math.round(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetY, 0) + fillRect.y
            };
            if (!skipTransform) {
                return this._transformedRect(rect);
            }
            return rect;
        },
        drawScene: function(can, top, caching, skipBuffer) {
            var layer = this.getLayer(),
                canvas = can || layer.getCanvas(),
                context = canvas.getContext(),
                cachedCanvas = this._cache.canvas,
                drawFunc = this.sceneFunc(),
                hasShadow = this.hasShadow(),
                hasStroke = this.hasStroke(),
                stage, bufferCanvas, bufferContext;

            if(!this.isVisible()) {
                return this;
            }
            if (cachedCanvas) {
                context.save();
                layer._applyTransform(this, context, top);
                this._drawCachedSceneCanvas(context);
                context.restore();
                return this;
            }
            if (!drawFunc) {
                return this;
            }
            context.save();
            // if buffer canvas is needed
            if (this._useBufferCanvas(caching) && !skipBuffer) {
                stage = this.getStage();
                bufferCanvas = stage.bufferCanvas;
                bufferContext = bufferCanvas.getContext();
                bufferContext.clear();
                bufferContext.save();
                bufferContext._applyLineJoin(this);
                // layer might be undefined if we are using cache before adding to layer
                if (!caching) {
                    if (layer) {
                        layer._applyTransform(this, bufferContext, top);
                    } else {
                        var m = this.getAbsoluteTransform(top).getMatrix();
                        context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
                    }
                }

                drawFunc.call(this, bufferContext);
                bufferContext.restore();

                if (hasShadow && !canvas.hitCanvas) {
                        context.save();
                        context._applyShadow(this);
                        context._applyOpacity(this);
                        context.drawImage(bufferCanvas._canvas, 0, 0);
                        context.restore();
                } else {
                    context._applyOpacity(this);
                    context.drawImage(bufferCanvas._canvas, 0, 0);
                }
            }
            // if buffer canvas is not needed
            else {
                context._applyLineJoin(this);
                // layer might be undefined if we are using cache before adding to layer
                if (!caching) {
                    if (layer) {
                        layer._applyTransform(this, context, top);
                    } else {
                        var o = this.getAbsoluteTransform(top).getMatrix();
                        context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
                    }
                }

                if (hasShadow && hasStroke && !canvas.hitCanvas) {
                    context.save();
                    // apply shadow
                    if (!caching) {
                        context._applyOpacity(this);
                    }
                    context._applyShadow(this);
                    drawFunc.call(this, context);
                    context.restore();
                    // if shape has stroke we need to redraw shape
                    // otherwise we will see a shadow under stroke (and over fill)
                    // but I think this is unexpected behavior
                    if (this.hasFill() && this.getShadowForStrokeEnabled()) {
                        drawFunc.call(this, context);
                    }
                } else if (hasShadow && !canvas.hitCanvas) {
                    context.save();
                    if (!caching) {
                        context._applyOpacity(this);
                    }
                    context._applyShadow(this);
                    drawFunc.call(this, context);
                    context.restore();
                } else {
                    if (!caching) {
                        context._applyOpacity(this);
                    }
                    drawFunc.call(this, context);
                }
            }
            context.restore();
            return this;
        },
        drawHit: function(can, top, caching) {
            var layer = this.getLayer(),
                canvas = can || layer.hitCanvas,
                context = canvas.getContext(),
                drawFunc = this.hitFunc() || this.sceneFunc(),
                cachedCanvas = this._cache.canvas,
                cachedHitCanvas = cachedCanvas && cachedCanvas.hit;

            if(!this.shouldDrawHit(canvas)) {
                return this;
            }
            if (layer) {
                layer.clearHitCache();
            }
            if (cachedHitCanvas) {
                context.save();
                layer._applyTransform(this, context, top);
                this._drawCachedHitCanvas(context);
                context.restore();
                return this;
            }
            if (!drawFunc) {
                return this;
            }
            context.save();
            context._applyLineJoin(this);
            if (!caching) {
                if (layer) {
                    layer._applyTransform(this, context, top);
                } else {
                    var o = this.getAbsoluteTransform(top).getMatrix();
                    context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
                }
            }
            drawFunc.call(this, context);
            context.restore();
            return this;
        },
        /**
        * draw hit graph using the cached scene canvas
        * @method
        * @memberof Konva.Shape.prototype
        * @param {Integer} alphaThreshold alpha channel threshold that determines whether or not
        *  a pixel should be drawn onto the hit graph.  Must be a value between 0 and 255.
        *  The default is 0
        * @returns {Konva.Shape}
        * @example
        * shape.cache();
        * shape.drawHitFromCache();
        */
        drawHitFromCache: function(alphaThreshold) {
            var threshold = alphaThreshold || 0,
                cachedCanvas = this._cache.canvas,
                sceneCanvas = this._getCachedSceneCanvas(),
                hitCanvas = cachedCanvas.hit,
                hitContext = hitCanvas.getContext(),
                hitWidth = hitCanvas.getWidth(),
                hitHeight = hitCanvas.getHeight(),
                hitImageData, hitData, len, rgbColorKey, i, alpha;

            hitContext.clear();
            hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);

            try {
                hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);
                hitData = hitImageData.data;
                len = hitData.length;
                rgbColorKey = Konva.Util._hexToRgb(this.colorKey);

                // replace non transparent pixels with color key
                for(i = 0; i < len; i += 4) {
                    alpha = hitData[i + 3];
                    if (alpha > threshold) {
                        hitData[i] = rgbColorKey.r;
                        hitData[i + 1] = rgbColorKey.g;
                        hitData[i + 2] = rgbColorKey.b;
                        hitData[i + 3] = 255;
                    }
                    else {
                        hitData[i + 3] = 0;
                    }
                }
                hitContext.putImageData(hitImageData, 0, 0);
            }
            catch(e) {
                Konva.Util.error('Unable to draw hit graph from cached scene canvas. ' + e.message);
            }

            return this;
        }
    });
    Konva.Util.extend(Konva.Shape, Konva.Node);

    // add getters and setters
    Konva.Factory.addGetterSetter(Konva.Shape, 'stroke');

    /**
     * get/set stroke color
     * @name stroke
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} color
     * @returns {String}
     * @example
     * // get stroke color
     * var stroke = shape.stroke();
     *
     * // set stroke color with color string
     * shape.stroke('green');
     *
     * // set stroke color with hex
     * shape.stroke('#00ff00');
     *
     * // set stroke color with rgb
     * shape.stroke('rgb(0,255,0)');
     *
     * // set stroke color with rgba and make it 50% opaque
     * shape.stroke('rgba(0,255,0,0.5');
     */

    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'strokeRed', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'strokeGreen', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'strokeBlue', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'strokeAlpha', 1, Konva.Validators.alphaComponent);


    Konva.Factory.addGetterSetter(Konva.Shape, 'strokeWidth', 2);

    /**
     * get/set stroke width
     * @name strokeWidth
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} strokeWidth
     * @returns {Number}
     * @example
     * // get stroke width
     * var strokeWidth = shape.strokeWidth();
     *
     * // set stroke width
     * shape.strokeWidth();
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'strokeHitEnabled', true);

    /**
     * get/set strokeHitEnabled property. Useful for performance optimization.
     * You may set `shape.strokeHitEnabled(false)`. In this case stroke will be no draw on hit canvas, so hit area
     * of shape will be decreased (by lineWidth / 2). Remember that non closed line with `strokeHitEnabled = false`
     * will be not drawn on hit canvas, that is mean line will no trigger pointer events (like mouseover)
     * Default value is true
     * @name strokeHitEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} strokeHitEnabled
     * @returns {Boolean}
     * @example
     * // get strokeHitEnabled
     * var strokeHitEnabled = shape.strokeHitEnabled();
     *
     * // set strokeHitEnabled
     * shape.strokeHitEnabled();
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'perfectDrawEnabled', true);

    /**
     * get/set perfectDrawEnabled. If a shape has fill, stroke and opacity you may set `perfectDrawEnabled` to improve performance.
     * See http://konvajs.github.io/docs/performance/Disable_Perfect_Draw.html for more information.
     * Default value is true
     * @name perfectDrawEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} perfectDrawEnabled
     * @returns {Boolean}
     * @example
     * // get perfectDrawEnabled
     * var perfectDrawEnabled = shape.perfectDrawEnabled();
     *
     * // set perfectDrawEnabled
     * shape.perfectDrawEnabled();
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowForStrokeEnabled', true);

    /**
     * get/set shadowForStrokeEnabled. Useful for performance optimization.
     * You may set `shape.shadowForStrokeEnabled(false)`. In this case stroke will be no draw shadow for stroke.
     * Remember if you set `shadowForStrokeEnabled = false` for non closed line - that line with have no shadow!.
     * Default value is true
     * @name shadowForStrokeEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} shadowForStrokeEnabled
     * @returns {Boolean}
     * @example
     * // get shadowForStrokeEnabled
     * var shadowForStrokeEnabled = shape.shadowForStrokeEnabled();
     *
     * // set shadowForStrokeEnabled
     * shape.shadowForStrokeEnabled();
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'lineJoin');

    /**
     * get/set line join.  Can be miter, round, or bevel.  The
     *  default is miter
     * @name lineJoin
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} lineJoin
     * @returns {String}
     * @example
     * // get line join
     * var lineJoin = shape.lineJoin();
     *
     * // set line join
     * shape.lineJoin('round');
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'lineCap');

    /**
     * get/set line cap.  Can be butt, round, or square
     * @name lineCap
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} lineCap
     * @returns {String}
     * @example
     * // get line cap
     * var lineCap = shape.lineCap();
     *
     * // set line cap
     * shape.lineCap('round');
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'sceneFunc');

    /**
     * get/set scene draw function
     * @name sceneFunc
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Function} drawFunc drawing function
     * @returns {Function}
     * @example
     * // get scene draw function
     * var sceneFunc = shape.sceneFunc();
     *
     * // set scene draw function
     * shape.sceneFunc(function(context) {
     *   context.beginPath();
     *   context.rect(0, 0, this.width(), this.height());
     *   context.closePath();
     *   context.fillStrokeShape(this);
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'hitFunc');

    /**
     * get/set hit draw function
     * @name hitFunc
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Function} drawFunc drawing function
     * @returns {Function}
     * @example
     * // get hit draw function
     * var hitFunc = shape.hitFunc();
     *
     * // set hit draw function
     * shape.hitFunc(function(context) {
     *   context.beginPath();
     *   context.rect(0, 0, this.width(), this.height());
     *   context.closePath();
     *   context.fillStrokeShape(this);
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'dash');

    /**
     * get/set dash array for stroke.
     * @name dash
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Array} dash
     * @returns {Array}
     * @example
     *  // apply dashed stroke that is 10px long and 5 pixels apart
     *  line.dash([10, 5]);
     *  // apply dashed stroke that is made up of alternating dashed
     *  // lines that are 10px long and 20px apart, and dots that have
     *  // a radius of 5px and are 20px apart
     *  line.dash([10, 20, 0.001, 20]);
     */


    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowColor');

    /**
     * get/set shadow color
     * @name shadowColor
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} color
     * @returns {String}
     * @example
     * // get shadow color
     * var shadow = shape.shadowColor();
     *
     * // set shadow color with color string
     * shape.shadowColor('green');
     *
     * // set shadow color with hex
     * shape.shadowColor('#00ff00');
     *
     * // set shadow color with rgb
     * shape.shadowColor('rgb(0,255,0)');
     *
     * // set shadow color with rgba and make it 50% opaque
     * shape.shadowColor('rgba(0,255,0,0.5');
     */

    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'shadowRed', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'shadowGreen', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'shadowBlue', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'shadowAlpha', 1, Konva.Validators.alphaComponent);

    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowBlur');

    /**
     * get/set shadow blur
     * @name shadowBlur
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} blur
     * @returns {Number}
     * @example
     * // get shadow blur
     * var shadowBlur = shape.shadowBlur();
     *
     * // set shadow blur
     * shape.shadowBlur(10);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowOpacity');

    /**
     * get/set shadow opacity.  must be a value between 0 and 1
     * @name shadowOpacity
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} opacity
     * @returns {Number}
     * @example
     * // get shadow opacity
     * var shadowOpacity = shape.shadowOpacity();
     *
     * // set shadow opacity
     * shape.shadowOpacity(0.5);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'shadowOffset', ['x', 'y']);

    /**
     * get/set shadow offset
     * @name shadowOffset
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} offset
     * @param {Number} offset.x
     * @param {Number} offset.y
     * @returns {Object}
     * @example
     * // get shadow offset
     * var shadowOffset = shape.shadowOffset();
     *
     * // set shadow offset
     * shape.shadowOffset({
     *   x: 20
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowOffsetX', 0);

     /**
     * get/set shadow offset x
     * @name shadowOffsetX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get shadow offset x
     * var shadowOffsetX = shape.shadowOffsetX();
     *
     * // set shadow offset x
     * shape.shadowOffsetX(5);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowOffsetY', 0);

     /**
     * get/set shadow offset y
     * @name shadowOffsetY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get shadow offset y
     * var shadowOffsetY = shape.shadowOffsetY();
     *
     * // set shadow offset y
     * shape.shadowOffsetY(5);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternImage');

    /**
     * get/set fill pattern image
     * @name fillPatternImage
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Image} image object
     * @returns {Image}
     * @example
     * // get fill pattern image
     * var fillPatternImage = shape.fillPatternImage();
     *
     * // set fill pattern image
     * var imageObj = new Image();
     * imageObj.onload = function() {
     *   shape.fillPatternImage(imageObj);
     * };
     * imageObj.src = 'path/to/image/jpg';
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fill');

    /**
     * get/set fill color
     * @name fill
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} color
     * @returns {String}
     * @example
     * // get fill color
     * var fill = shape.fill();
     *
     * // set fill color with color string
     * shape.fill('green');
     *
     * // set fill color with hex
     * shape.fill('#00ff00');
     *
     * // set fill color with rgb
     * shape.fill('rgb(0,255,0)');
     *
     * // set fill color with rgba and make it 50% opaque
     * shape.fill('rgba(0,255,0,0.5');
     *
     * // shape without fill
     * shape.fill(null);
     */

    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'fillRed', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'fillGreen', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'fillBlue', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'fillAlpha', 1, Konva.Validators.alphaComponent);

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternX', 0);

    /**
     * get/set fill pattern x
     * @name fillPatternX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill pattern x
     * var fillPatternX = shape.fillPatternX();
     * // set fill pattern x
     * shape.fillPatternX(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternY', 0);

    /**
     * get/set fill pattern y
     * @name fillPatternY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill pattern y
     * var fillPatternY = shape.fillPatternY();
     * // set fill pattern y
     * shape.fillPatternY(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientColorStops');

    /**
     * get/set fill linear gradient color stops
     * @name fillLinearGradientColorStops
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Array} colorStops
     * @returns {Array} colorStops
     * @example
     * // get fill linear gradient color stops
     * var colorStops = shape.fillLinearGradientColorStops();
     *
     * // create a linear gradient that starts with red, changes to blue
     * // halfway through, and then changes to green
     * shape.fillLinearGradientColorStops(0, 'red', 0.5, 'blue', 1, 'green');
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientStartRadius', 0);

    /**
     * get/set fill radial gradient start radius
     * @name fillRadialGradientStartRadius
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} radius
     * @returns {Number}
     * @example
     * // get radial gradient start radius
     * var startRadius = shape.fillRadialGradientStartRadius();
     *
     * // set radial gradient start radius
     * shape.fillRadialGradientStartRadius(0);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientEndRadius', 0);

    /**
     * get/set fill radial gradient end radius
     * @name fillRadialGradientEndRadius
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} radius
     * @returns {Number}
     * @example
     * // get radial gradient end radius
     * var endRadius = shape.fillRadialGradientEndRadius();
     *
     * // set radial gradient end radius
     * shape.fillRadialGradientEndRadius(100);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientColorStops');

    /**
     * get/set fill radial gradient color stops
     * @name fillRadialGradientColorStops
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} colorStops
     * @returns {Array}
     * @example
     * // get fill radial gradient color stops
     * var colorStops = shape.fillRadialGradientColorStops();
     *
     * // create a radial gradient that starts with red, changes to blue
     * // halfway through, and then changes to green
     * shape.fillRadialGradientColorStops(0, 'red', 0.5, 'blue', 1, 'green');
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternRepeat', 'repeat');

    /**
     * get/set fill pattern repeat.  Can be 'repeat', 'repeat-x', 'repeat-y', or 'no-repeat'.  The default is 'repeat'
     * @name fillPatternRepeat
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} repeat
     * @returns {String}
     * @example
     * // get fill pattern repeat
     * var repeat = shape.fillPatternRepeat();
     *
     * // repeat pattern in x direction only
     * shape.fillPatternRepeat('repeat-x');
     *
     * // do not repeat the pattern
     * shape.fillPatternRepeat('no repeat');
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillEnabled', true);

    /**
     * get/set fill enabled flag
     * @name fillEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get fill enabled flag
     * var fillEnabled = shape.fillEnabled();
     *
     * // disable fill
     * shape.fillEnabled(false);
     *
     * // enable fill
     * shape.fillEnabled(true);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'strokeEnabled', true);

    /**
     * get/set stroke enabled flag
     * @name strokeEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get stroke enabled flag
     * var strokeEnabled = shape.strokeEnabled();
     *
     * // disable stroke
     * shape.strokeEnabled(false);
     *
     * // enable stroke
     * shape.strokeEnabled(true);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowEnabled', true);

    /**
     * get/set shadow enabled flag
     * @name shadowEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get shadow enabled flag
     * var shadowEnabled = shape.shadowEnabled();
     *
     * // disable shadow
     * shape.shadowEnabled(false);
     *
     * // enable shadow
     * shape.shadowEnabled(true);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'dashEnabled', true);

    /**
     * get/set dash enabled flag
     * @name dashEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get dash enabled flag
     * var dashEnabled = shape.dashEnabled();
     *
     * // disable dash
     * shape.dashEnabled(false);
     *
     * // enable dash
     * shape.dashEnabled(true);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'strokeScaleEnabled', true);

    /**
     * get/set strokeScale enabled flag
     * @name strokeScaleEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get stroke scale enabled flag
     * var strokeScaleEnabled = shape.strokeScaleEnabled();
     *
     * // disable stroke scale
     * shape.strokeScaleEnabled(false);
     *
     * // enable stroke scale
     * shape.strokeScaleEnabled(true);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPriority', 'color');

    /**
     * get/set fill priority.  can be color, pattern, linear-gradient, or radial-gradient.  The default is color.
     *   This is handy if you want to toggle between different fill types.
     * @name fillPriority
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} priority
     * @returns {String}
     * @example
     * // get fill priority
     * var fillPriority = shape.fillPriority();
     *
     * // set fill priority
     * shape.fillPriority('linear-gradient');
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillPatternOffset', ['x', 'y']);

    /**
     * get/set fill pattern offset
     * @name fillPatternOffset
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} offset
     * @param {Number} offset.x
     * @param {Number} offset.y
     * @returns {Object}
     * @example
     * // get fill pattern offset
     * var patternOffset = shape.fillPatternOffset();
     *
     * // set fill pattern offset
     * shape.fillPatternOffset({
     *   x: 20
     *   y: 10
     * });
     */


    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternOffsetX', 0);
    /**
     * get/set fill pattern offset x
     * @name fillPatternOffsetX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill pattern offset x
     * var patternOffsetX = shape.fillPatternOffsetX();
     *
     * // set fill pattern offset x
     * shape.fillPatternOffsetX(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternOffsetY', 0);
    /**
     * get/set fill pattern offset y
     * @name fillPatternOffsetY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill pattern offset y
     * var patternOffsetY = shape.fillPatternOffsetY();
     *
     * // set fill pattern offset y
     * shape.fillPatternOffsetY(10);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillPatternScale', ['x', 'y']);

    /**
     * get/set fill pattern scale
     * @name fillPatternScale
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} scale
     * @param {Number} scale.x
     * @param {Number} scale.y
     * @returns {Object}
     * @example
     * // get fill pattern scale
     * var patternScale = shape.fillPatternScale();
     *
     * // set fill pattern scale
     * shape.fillPatternScale({
     *   x: 2
     *   y: 2
     * });
     */


    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternScaleX', 1);
    /**
     * get/set fill pattern scale x
     * @name fillPatternScaleX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill pattern scale x
     * var patternScaleX = shape.fillPatternScaleX();
     *
     * // set fill pattern scale x
     * shape.fillPatternScaleX(2);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternScaleY', 1);
    /**
     * get/set fill pattern scale y
     * @name fillPatternScaleY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill pattern scale y
     * var patternScaleY = shape.fillPatternScaleY();
     *
     * // set fill pattern scale y
     * shape.fillPatternScaleY(2);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillLinearGradientStartPoint', ['x', 'y']);

    /**
     * get/set fill linear gradient start point
     * @name fillLinearGradientStartPoint
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} startPoint
     * @param {Number} startPoint.x
     * @param {Number} startPoint.y
     * @returns {Object}
     * @example
     * // get fill linear gradient start point
     * var startPoint = shape.fillLinearGradientStartPoint();
     *
     * // set fill linear gradient start point
     * shape.fillLinearGradientStartPoint({
     *   x: 20
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientStartPointX', 0);
    /**
     * get/set fill linear gradient start point x
     * @name fillLinearGradientStartPointX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill linear gradient start point x
     * var startPointX = shape.fillLinearGradientStartPointX();
     *
     * // set fill linear gradient start point x
     * shape.fillLinearGradientStartPointX(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientStartPointY', 0);
    /**
     * get/set fill linear gradient start point y
     * @name fillLinearGradientStartPointY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill linear gradient start point y
     * var startPointY = shape.fillLinearGradientStartPointY();
     *
     * // set fill linear gradient start point y
     * shape.fillLinearGradientStartPointY(20);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillLinearGradientEndPoint', ['x', 'y']);

    /**
     * get/set fill linear gradient end point
     * @name fillLinearGradientEndPoint
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} endPoint
     * @param {Number} endPoint.x
     * @param {Number} endPoint.y
     * @returns {Object}
     * @example
     * // get fill linear gradient end point
     * var endPoint = shape.fillLinearGradientEndPoint();
     *
     * // set fill linear gradient end point
     * shape.fillLinearGradientEndPoint({
     *   x: 20
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientEndPointX', 0);
    /**
     * get/set fill linear gradient end point x
     * @name fillLinearGradientEndPointX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill linear gradient end point x
     * var endPointX = shape.fillLinearGradientEndPointX();
     *
     * // set fill linear gradient end point x
     * shape.fillLinearGradientEndPointX(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientEndPointY', 0);
    /**
     * get/set fill linear gradient end point y
     * @name fillLinearGradientEndPointY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill linear gradient end point y
     * var endPointY = shape.fillLinearGradientEndPointY();
     *
     * // set fill linear gradient end point y
     * shape.fillLinearGradientEndPointY(20);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillRadialGradientStartPoint', ['x', 'y']);

    /**
     * get/set fill radial gradient start point
     * @name fillRadialGradientStartPoint
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} startPoint
     * @param {Number} startPoint.x
     * @param {Number} startPoint.y
     * @returns {Object}
     * @example
     * // get fill radial gradient start point
     * var startPoint = shape.fillRadialGradientStartPoint();
     *
     * // set fill radial gradient start point
     * shape.fillRadialGradientStartPoint({
     *   x: 20
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientStartPointX', 0);
    /**
     * get/set fill radial gradient start point x
     * @name fillRadialGradientStartPointX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill radial gradient start point x
     * var startPointX = shape.fillRadialGradientStartPointX();
     *
     * // set fill radial gradient start point x
     * shape.fillRadialGradientStartPointX(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientStartPointY', 0);
    /**
     * get/set fill radial gradient start point y
     * @name fillRadialGradientStartPointY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill radial gradient start point y
     * var startPointY = shape.fillRadialGradientStartPointY();
     *
     * // set fill radial gradient start point y
     * shape.fillRadialGradientStartPointY(20);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillRadialGradientEndPoint', ['x', 'y']);

    /**
     * get/set fill radial gradient end point
     * @name fillRadialGradientEndPoint
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} endPoint
     * @param {Number} endPoint.x
     * @param {Number} endPoint.y
     * @returns {Object}
     * @example
     * // get fill radial gradient end point
     * var endPoint = shape.fillRadialGradientEndPoint();
     *
     * // set fill radial gradient end point
     * shape.fillRadialGradientEndPoint({
     *   x: 20
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientEndPointX', 0);
    /**
     * get/set fill radial gradient end point x
     * @name fillRadialGradientEndPointX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill radial gradient end point x
     * var endPointX = shape.fillRadialGradientEndPointX();
     *
     * // set fill radial gradient end point x
     * shape.fillRadialGradientEndPointX(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientEndPointY', 0);
    /**
     * get/set fill radial gradient end point y
     * @name fillRadialGradientEndPointY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill radial gradient end point y
     * var endPointY = shape.fillRadialGradientEndPointY();
     *
     * // set fill radial gradient end point y
     * shape.fillRadialGradientEndPointY(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternRotation', 0);

    /**
     * get/set fill pattern rotation in degrees
     * @name fillPatternRotation
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} rotation
     * @returns {Konva.Shape}
     * @example
     * // get fill pattern rotation
     * var patternRotation = shape.fillPatternRotation();
     *
     * // set fill pattern rotation
     * shape.fillPatternRotation(20);
     */


    Konva.Factory.backCompat(Konva.Shape, {
        dashArray: 'dash',
        getDashArray: 'getDash',
        setDashArray: 'getDash',

        drawFunc: 'sceneFunc',
        getDrawFunc: 'getSceneFunc',
        setDrawFunc: 'setSceneFunc',

        drawHitFunc: 'hitFunc',
        getDrawHitFunc: 'getHitFunc',
        setDrawHitFunc: 'setHitFunc'
    });

    Konva.Collection.mapMethods(Konva.Shape);
})(Konva);

(function() {
    'use strict';
    // CONSTANTS
    var STAGE = 'Stage',
        STRING = 'string',
        PX = 'px',

        MOUSEOUT = 'mouseout',
        MOUSELEAVE = 'mouseleave',
        MOUSEOVER = 'mouseover',
        MOUSEENTER = 'mouseenter',
        MOUSEMOVE = 'mousemove',
        MOUSEDOWN = 'mousedown',
        MOUSEUP = 'mouseup',
        CLICK = 'click',
        DBL_CLICK = 'dblclick',
        TOUCHSTART = 'touchstart',
        TOUCHEND = 'touchend',
        TAP = 'tap',
        DBL_TAP = 'dbltap',
        TOUCHMOVE = 'touchmove',
        DOMMOUSESCROLL = 'DOMMouseScroll',
        MOUSEWHEEL = 'mousewheel',
        WHEEL = 'wheel',

        CONTENT_MOUSEOUT = 'contentMouseout',
        CONTENT_MOUSEOVER = 'contentMouseover',
        CONTENT_MOUSEMOVE = 'contentMousemove',
        CONTENT_MOUSEDOWN = 'contentMousedown',
        CONTENT_MOUSEUP = 'contentMouseup',
        CONTENT_CLICK = 'contentClick',
        CONTENT_DBL_CLICK = 'contentDblclick',
        CONTENT_TOUCHSTART = 'contentTouchstart',
        CONTENT_TOUCHEND = 'contentTouchend',
        CONTENT_DBL_TAP = 'contentDbltap',
        CONTENT_TAP = 'contentTap',
        CONTENT_TOUCHMOVE = 'contentTouchmove',

        DIV = 'div',
        RELATIVE = 'relative',
        KONVA_CONTENT = 'konvajs-content',
        SPACE = ' ',
        UNDERSCORE = '_',
        CONTAINER = 'container',
        EMPTY_STRING = '',
        EVENTS = [MOUSEDOWN, MOUSEMOVE, MOUSEUP, MOUSEOUT, TOUCHSTART, TOUCHMOVE, TOUCHEND, MOUSEOVER, DOMMOUSESCROLL, MOUSEWHEEL, WHEEL],

        // cached variables
        eventsLength = EVENTS.length;

    function addEvent(ctx, eventName) {
        ctx.content.addEventListener(eventName, function(evt) {
            ctx[UNDERSCORE + eventName](evt);
        }, false);
    }

    /**
     * Stage constructor.  A stage is used to contain multiple layers
     * @constructor
     * @memberof Konva
     * @augments Konva.Container
     * @param {Object} config
     * @param {String|Element} config.container Container id or DOM element
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var stage = new Konva.Stage({
         *   width: 500,
         *   height: 800,
         *   container: 'containerId'
         * });
     */
    Konva.Stage = function(config) {
        this.___init(config);
    };

    Konva.Util.addMethods(Konva.Stage, {
        ___init: function(config) {
            this.nodeType = STAGE;
            // call super constructor
            Konva.Container.call(this, config);
            this._id = Konva.idCounter++;
            this._buildDOM();
            this._bindContentEvents();
            this._enableNestedTransforms = false;
            Konva.stages.push(this);
        },
        _validateAdd: function(child) {
            if (child.getType() !== 'Layer') {
                Konva.Util.throw('You may only add layers to the stage.');
            }
        },
        /**
         * set container dom element which contains the stage wrapper div element
         * @method
         * @memberof Konva.Stage.prototype
         * @param {DomElement} container can pass in a dom element or id string
         */
        setContainer: function(container) {
            if( typeof container === STRING) {
                var id = container;
                container = Konva.document.getElementById(container);
                if (!container) {
                    throw 'Can not find container in document with id ' + id;
                }
            }
            this._setAttr(CONTAINER, container);
            return this;
        },
        shouldDrawHit: function() {
            return true;
        },
        draw: function() {
            Konva.Node.prototype.draw.call(this);
            return this;
        },
        /**
         * draw layer scene graphs
         * @name draw
         * @method
         * @memberof Konva.Stage.prototype
         */

        /**
         * draw layer hit graphs
         * @name drawHit
         * @method
         * @memberof Konva.Stage.prototype
         */

        /**
         * set height
         * @method
         * @memberof Konva.Stage.prototype
         * @param {Number} height
         */
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            this._resizeDOM();
            return this;
        },
        /**
         * set width
         * @method
         * @memberof Konva.Stage.prototype
         * @param {Number} width
         */
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            this._resizeDOM();
            return this;
        },
        /**
         * clear all layers
         * @method
         * @memberof Konva.Stage.prototype
         */
        clear: function() {
            var layers = this.children,
                len = layers.length,
                n;

            for(n = 0; n < len; n++) {
                layers[n].clear();
            }
            return this;
        },
        clone: function(obj) {
            if (!obj) {
                obj = {};
            }
            obj.container = Konva.document.createElement(DIV);
            return Konva.Container.prototype.clone.call(this, obj);
        },
        /**
         * destroy stage
         * @method
         * @memberof Konva.Stage.prototype
         */
        destroy: function() {
            var content = this.content;
            Konva.Container.prototype.destroy.call(this);

            if(content && Konva.Util._isInDocument(content)) {
                this.getContainer().removeChild(content);
            }
            var index = Konva.stages.indexOf(this);
            if (index > -1) {
                Konva.stages.splice(index, 1);
            }
            return this;
        },
        /**
         * get pointer position which can be a touch position or mouse position
         * @method
         * @memberof Konva.Stage.prototype
         * @returns {Object}
         */
        getPointerPosition: function() {
            return this.pointerPos;
        },
        getStage: function() {
            return this;
        },
        /**
         * get stage content div element which has the
         *  the class name "konvajs-content"
         * @method
         * @memberof Konva.Stage.prototype
         */
        getContent: function() {
            return this.content;
        },
        /**
         * Creates a composite data URL
         * @method
         * @memberof Konva.Stage.prototype
         * @param {Object} config
         * @param {Function} [config.callback] function executed when the composite has completed. Deprecated as method is sync now.
         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
         *  "image/png" is the default
         * @param {Number} [config.x] x position of canvas section
         * @param {Number} [config.y] y position of canvas section
         * @param {Number} [config.width] width of canvas section
         * @param {Number} [config.height] height of canvas section
         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
         *  is very high quality
         */
        toDataURL: function(config) {
            config = config || {};

            var mimeType = config.mimeType || null,
                quality = config.quality || null,
                x = config.x || 0,
                y = config.y || 0,
                canvas = new Konva.SceneCanvas({
                    width: config.width || this.getWidth(),
                    height: config.height || this.getHeight(),
                    pixelRatio: config.pixelRatio
                }),
                _context = canvas.getContext()._context,
                layers = this.children;

            if(x || y) {
                _context.translate(-1 * x, -1 * y);
            }


            layers.each(function(layer) {
                var width = layer.getCanvas().getWidth();
                var height = layer.getCanvas().getHeight();
                var ratio = layer.getCanvas().getPixelRatio();
                _context.drawImage(layer.getCanvas()._canvas, 0, 0, width / ratio, height / ratio);
            });
            var src = canvas.toDataURL(mimeType, quality);

            if (config.callback) {
                config.callback(src);
            }

            return src;
        },
        /**
         * converts stage into an image.
         * @method
         * @memberof Konva.Stage.prototype
         * @param {Object} config
         * @param {Function} config.callback function executed when the composite has completed
         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
         *  "image/png" is the default
         * @param {Number} [config.x] x position of canvas section
         * @param {Number} [config.y] y position of canvas section
         * @param {Number} [config.width] width of canvas section
         * @param {Number} [config.height] height of canvas section
         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
         *  is very high quality
         */
        toImage: function(config) {
            var cb = config.callback;

            config.callback = function(dataUrl) {
                Konva.Util._getImage(dataUrl, function(img) {
                    cb(img);
                });
            };
            this.toDataURL(config);
        },
        /**
         * get visible intersection shape. This is the preferred
         *  method for determining if a point intersects a shape or not
         * @method
         * @memberof Konva.Stage.prototype
         * @param {Object} pos
         * @param {Number} pos.x
         * @param {Number} pos.y
         * @param {String} [selector]
         * @returns {Konva.Node}
         * @example
         * var shape = stage.getIntersection({x: 50, y: 50});
         * // or if you interested in shape parent:
         * var group = stage.getIntersection({x: 50, y: 50}, 'Group');
         */
        getIntersection: function(pos, selector) {
            var layers = this.getChildren(),
                len = layers.length,
                end = len - 1,
                n, shape;

            for(n = end; n >= 0; n--) {
                shape = layers[n].getIntersection(pos, selector);
                if (shape) {
                    return shape;
                }
            }

            return null;
        },
        _resizeDOM: function() {
            if(this.content) {
                var width = this.getWidth(),
                    height = this.getHeight(),
                    layers = this.getChildren(),
                    len = layers.length,
                    n, layer;

                // set content dimensions
                this.content.style.width = width + PX;
                this.content.style.height = height + PX;

                this.bufferCanvas.setSize(width, height);
                this.bufferHitCanvas.setSize(width, height);

                // set layer dimensions
                for(n = 0; n < len; n++) {
                    layer = layers[n];
                    layer.setSize(width, height);
                    layer.draw();
                }
            }
        },
        /**
         * add layer or layers to stage
         * @method
         * @memberof Konva.Stage.prototype
         * @param {...Konva.Layer} layer
         * @example
         * stage.add(layer1, layer2, layer3);
         */
        add: function(layer) {
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) {
                    this.add(arguments[i]);
                }
                return this;
            }
            Konva.Container.prototype.add.call(this, layer);
            layer._setCanvasSize(this.width(), this.height());

            // draw layer and append canvas to container
            layer.draw();
            this.content.appendChild(layer.canvas._canvas);

            // chainable
            return this;
        },
        getParent: function() {
            return null;
        },
        getLayer: function() {
            return null;
        },
        /**
         * returns a {@link Konva.Collection} of layers
         * @method
         * @memberof Konva.Stage.prototype
         */
        getLayers: function() {
            return this.getChildren();
        },
        _bindContentEvents: function() {
            for (var n = 0; n < eventsLength; n++) {
                addEvent(this, EVENTS[n]);
            }
        },
        _mouseover: function(evt) {
            if (!Konva.UA.mobile) {
                this._setPointerPosition(evt);
                this._fire(CONTENT_MOUSEOVER, {evt: evt});
            }
        },
        _mouseout: function(evt) {
            if (!Konva.UA.mobile) {
                this._setPointerPosition(evt);
                var targetShape = this.targetShape;

                if(targetShape && !Konva.isDragging()) {
                    targetShape._fireAndBubble(MOUSEOUT, {evt: evt});
                    targetShape._fireAndBubble(MOUSELEAVE, {evt: evt});
                    this.targetShape = null;
                }
                this.pointerPos = undefined;

                this._fire(CONTENT_MOUSEOUT, {evt: evt});
            }
        },
        _mousemove: function(evt) {
            // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event
            if (Konva.UA.ieMobile) {
                return this._touchmove(evt);
            }
            // workaround fake mousemove event in chrome browser https://code.google.com/p/chromium/issues/detail?id=161464
            if ((typeof evt.movementX !== 'undefined' || typeof evt.movementY !== 'undefined') && evt.movementY === 0 && evt.movementX === 0) {
                return null;
            }
            if (Konva.UA.mobile) {
                return null;
            }
            this._setPointerPosition(evt);
            var shape;

            if (!Konva.isDragging()) {
                shape = this.getIntersection(this.getPointerPosition());
                if(shape && shape.isListening()) {
                    if(!Konva.isDragging() && (!this.targetShape || this.targetShape._id !== shape._id)) {
                        if(this.targetShape) {
                            this.targetShape._fireAndBubble(MOUSEOUT, {evt: evt}, shape);
                            this.targetShape._fireAndBubble(MOUSELEAVE, {evt: evt}, shape);
                        }
                        shape._fireAndBubble(MOUSEOVER, {evt: evt}, this.targetShape);
                        shape._fireAndBubble(MOUSEENTER, {evt: evt}, this.targetShape);
                        this.targetShape = shape;
                    }
                    else {
                        shape._fireAndBubble(MOUSEMOVE, {evt: evt});
                    }
                }
                /*
                 * if no shape was detected, clear target shape and try
                 * to run mouseout from previous target shape
                 */
                else {
                    if(this.targetShape && !Konva.isDragging()) {
                        this.targetShape._fireAndBubble(MOUSEOUT, {evt: evt});
                        this.targetShape._fireAndBubble(MOUSELEAVE, {evt: evt});
                        this.targetShape = null;
                    }

                }

                // content event
                this._fire(CONTENT_MOUSEMOVE, {evt: evt});
            }

            // always call preventDefault for desktop events because some browsers
            // try to drag and drop the canvas element
            if (evt.preventDefault) {
                evt.preventDefault();
            }
        },
        _mousedown: function(evt) {
            // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event
            if (Konva.UA.ieMobile) {
                return this._touchstart(evt);
            }
            if (!Konva.UA.mobile) {
                this._setPointerPosition(evt);
                var shape = this.getIntersection(this.getPointerPosition());

                Konva.listenClickTap = true;

                if (shape && shape.isListening()) {
                    this.clickStartShape = shape;
                    shape._fireAndBubble(MOUSEDOWN, {evt: evt});
                }

                // content event
                this._fire(CONTENT_MOUSEDOWN, {evt: evt});
            }

            // always call preventDefault for desktop events because some browsers
            // try to drag and drop the canvas element
            if (evt.preventDefault) {
                evt.preventDefault();
            }
        },
        _mouseup: function(evt) {

            // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event
            if (Konva.UA.ieMobile) {
                return this._touchend(evt);
            }
            if (!Konva.UA.mobile) {
                this._setPointerPosition(evt);
                var shape = this.getIntersection(this.getPointerPosition()),
                    clickStartShape = this.clickStartShape,
                    fireDblClick = false,
                    dd = Konva.DD;

                if(Konva.inDblClickWindow) {
                    fireDblClick = true;
                    Konva.inDblClickWindow = false;
                }
                // don't set inDblClickWindow after dragging
                else if (!dd || !dd.justDragged) {
                    Konva.inDblClickWindow = true;
                } else if (dd) {
                    dd.justDragged = false;
                }

                setTimeout(function() {
                    Konva.inDblClickWindow = false;
                }, Konva.dblClickWindow);

                if (shape && shape.isListening()) {
                    shape._fireAndBubble(MOUSEUP, {evt: evt});

                    // detect if click or double click occurred
                    if(Konva.listenClickTap && clickStartShape && clickStartShape._id === shape._id) {
                        shape._fireAndBubble(CLICK, {evt: evt});

                        if(fireDblClick) {
                            shape._fireAndBubble(DBL_CLICK, {evt: evt});
                        }
                    }
                }
                // content events
                this._fire(CONTENT_MOUSEUP, {evt: evt});
                if (Konva.listenClickTap) {
                    this._fire(CONTENT_CLICK, {evt: evt});
                    if(fireDblClick) {
                        this._fire(CONTENT_DBL_CLICK, {evt: evt});
                    }
                }

                Konva.listenClickTap = false;
            }

            // always call preventDefault for desktop events because some browsers
            // try to drag and drop the canvas element
            if (evt.preventDefault) {
                evt.preventDefault();
            }
        },
        _touchstart: function(evt) {
            this._setPointerPosition(evt);
            var shape = this.getIntersection(this.getPointerPosition());

            Konva.listenClickTap = true;

            if (shape && shape.isListening()) {
                this.tapStartShape = shape;
                shape._fireAndBubble(TOUCHSTART, {evt: evt});

                // only call preventDefault if the shape is listening for events
                if (shape.isListening() && evt.preventDefault) {
                    evt.preventDefault();
                }
            }
            // content event
            this._fire(CONTENT_TOUCHSTART, {evt: evt});
        },
        _touchend: function(evt) {
            this._setPointerPosition(evt);
            var shape = this.getIntersection(this.getPointerPosition()),
                fireDblClick = false;

            if(Konva.inDblClickWindow) {
                fireDblClick = true;
                Konva.inDblClickWindow = false;
            }
            else {
                Konva.inDblClickWindow = true;
            }

            setTimeout(function() {
                Konva.inDblClickWindow = false;
            }, Konva.dblClickWindow);

            if (shape && shape.isListening()) {
                shape._fireAndBubble(TOUCHEND, {evt: evt});

                // detect if tap or double tap occurred
                if(Konva.listenClickTap && shape._id === this.tapStartShape._id) {
                    shape._fireAndBubble(TAP, {evt: evt});

                    if(fireDblClick) {
                        shape._fireAndBubble(DBL_TAP, {evt: evt});
                    }
                }
                // only call preventDefault if the shape is listening for events
                if (shape.isListening() && evt.preventDefault) {
                    evt.preventDefault();
                }
            }
            // content events
            this._fire(CONTENT_TOUCHEND, {evt: evt});
            if (Konva.listenClickTap) {
                this._fire(CONTENT_TAP, {evt: evt});
                if(fireDblClick) {
                    this._fire(CONTENT_DBL_TAP, {evt: evt});
                }
            }

            Konva.listenClickTap = false;
        },
        _touchmove: function(evt) {
            this._setPointerPosition(evt);
            var dd = Konva.DD,
                shape;
            if (!Konva.isDragging()) {
                shape = this.getIntersection(this.getPointerPosition());
                if (shape && shape.isListening()) {
                    shape._fireAndBubble(TOUCHMOVE, {evt: evt});
                    // only call preventDefault if the shape is listening for events
                    if (shape.isListening() && evt.preventDefault) {
                        evt.preventDefault();
                    }
                }
                this._fire(CONTENT_TOUCHMOVE, {evt: evt});
            }
            if(dd) {
                if (Konva.isDragging()) {
                    evt.preventDefault();
                }
            }
        },
        _DOMMouseScroll: function(evt) {
            this._mousewheel(evt);
        },
        _mousewheel: function(evt) {
            this._setPointerPosition(evt);
            var shape = this.getIntersection(this.getPointerPosition());

            if (shape && shape.isListening()) {
                shape._fireAndBubble(MOUSEWHEEL, {evt: evt});
            }
        },
        _wheel: function(evt) {
            this._mousewheel(evt);
        },
        _setPointerPosition: function(evt) {
            var contentPosition = this._getContentPosition(),
                x = null,
                y = null;
            evt = evt ? evt : window.event;

            // touch events
            if(evt.touches !== undefined) {
                // currently, only handle one finger
                if (evt.touches.length > 0) {

                    var touch = evt.touches[0];
                    // get the information for finger #1
                    x = touch.clientX - contentPosition.left;
                    y = touch.clientY - contentPosition.top;
                }
            }
            // mouse events
            else {
                x = evt.clientX - contentPosition.left;
                y = evt.clientY - contentPosition.top;
            }
            if (x !== null && y !== null) {
                this.pointerPos = {
                    x: x,
                    y: y
                };
            }
        },
        _getContentPosition: function() {
            var rect = this.content.getBoundingClientRect ? this.content.getBoundingClientRect() : { top: 0, left: 0 };
            return {
                top: rect.top,
                left: rect.left
            };
        },
        _buildDOM: function() {
            var container = this.getContainer();
            if (!container) {
                if (Konva.Util.isBrowser()) {
                    throw 'Stage has no container. A container is required.';
                } else {
                    // automatically create element for jsdom in nodejs env
                    container = Konva.document.createElement(DIV);
                }
            }
            // clear content inside container
            container.innerHTML = EMPTY_STRING;

            // content
            this.content = Konva.document.createElement(DIV);
            this.content.style.position = RELATIVE;
            this.content.className = KONVA_CONTENT;
            this.content.setAttribute('role', 'presentation');
            container.appendChild(this.content);

            // the buffer canvas pixel ratio must be 1 because it is used as an
            // intermediate canvas before copying the result onto a scene canvas.
            // not setting it to 1 will result in an over compensation
            this.bufferCanvas = new Konva.SceneCanvas({
                pixelRatio: 1
            });
            this.bufferHitCanvas = new Konva.HitCanvas();

            this._resizeDOM();
        },
        _onContent: function(typesStr, handler) {
            var types = typesStr.split(SPACE),
                len = types.length,
                n, baseEvent;

            for(n = 0; n < len; n++) {
                baseEvent = types[n];
                this.content.addEventListener(baseEvent, handler, false);
            }
        },
        // currently cache function is now working for stage, because stage has no its own canvas element
        // TODO: may be it is better to cache all children layers?
        cache: function() {
            Konva.Util.warn('Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.');
        },
        clearCache: function() {
        }
    });
    Konva.Util.extend(Konva.Stage, Konva.Container);

    // add getters and setters
    Konva.Factory.addGetter(Konva.Stage, 'container');
    Konva.Factory.addOverloadedGetterSetter(Konva.Stage, 'container');

    /**
     * get container DOM element
     * @name container
     * @method
     * @memberof Konva.Stage.prototype
     * @returns {DomElement} container
     * @example
     * // get container
     * var container = stage.container();
     * // set container
     * var container = document.createElement('div');
     * body.appendChild(container);
     * stage.container(container);
     */

})();

(function() {
    'use strict';
    /**
     * BaseLayer constructor.
     * @constructor
     * @memberof Konva
     * @augments Konva.Container
     * @param {Object} config
     * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
     * to clear the canvas before each layer draw.  The default value is true.
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height

     * @example
     * var layer = new Konva.Layer();
     */
    Konva.BaseLayer = function(config) {
        this.___init(config);
    };

    Konva.Util.addMethods(Konva.BaseLayer, {
        ___init: function(config) {
            this.nodeType = 'Layer';
            Konva.Container.call(this, config);
        },
        createPNGStream: function() {
            return this.canvas._canvas.createPNGStream();
        },
        /**
         * get layer canvas
         * @method
         * @memberof Konva.BaseLayer.prototype
         */
        getCanvas: function() {
            return this.canvas;
        },
        /**
         * get layer hit canvas
         * @method
         * @memberof Konva.BaseLayer.prototype
         */
        getHitCanvas: function() {
            return this.hitCanvas;
        },
        /**
         * get layer canvas context
         * @method
         * @memberof Konva.BaseLayer.prototype
         */
        getContext: function() {
            return this.getCanvas().getContext();
        },
        /**
         * clear scene and hit canvas contexts tied to the layer
         * @method
         * @memberof Konva.BaseLayer.prototype
         * @param {Object} [bounds]
         * @param {Number} [bounds.x]
         * @param {Number} [bounds.y]
         * @param {Number} [bounds.width]
         * @param {Number} [bounds.height]
         * @example
         * layer.clear();
         * layer.clear({
         *   x : 0,
         *   y : 0,
         *   width : 100,
         *   height : 100
         * });
         */
        clear: function(bounds) {
            this.getContext().clear(bounds);
            return this;
        },
        clearHitCache: function() {
            this._hitImageData = undefined;
        },
        // extend Node.prototype.setZIndex
        setZIndex: function(index) {
            Konva.Node.prototype.setZIndex.call(this, index);
            var stage = this.getStage();
            if(stage) {
                stage.content.removeChild(this.getCanvas()._canvas);

                if(index < stage.getChildren().length - 1) {
                    stage.content.insertBefore(this.getCanvas()._canvas, stage.getChildren()[index + 1].getCanvas()._canvas);
                }
                else {
                    stage.content.appendChild(this.getCanvas()._canvas);
                }
            }
            return this;
        },
        // extend Node.prototype.moveToTop
        moveToTop: function() {
            Konva.Node.prototype.moveToTop.call(this);
            var stage = this.getStage();
            if(stage) {
                stage.content.removeChild(this.getCanvas()._canvas);
                stage.content.appendChild(this.getCanvas()._canvas);
            }
            return this;
        },
        // extend Node.prototype.moveUp
        moveUp: function() {
            var moved = Konva.Node.prototype.moveUp.call(this);
            if (!moved){
                return this;
            }
            var stage = this.getStage();
            if(!stage) {
                return this;
            }
            stage.content.removeChild(this.getCanvas()._canvas);

            if(this.index < stage.getChildren().length - 1) {
                stage.content.insertBefore(this.getCanvas()._canvas, stage.getChildren()[this.index + 1].getCanvas()._canvas);
            } else {
                stage.content.appendChild(this.getCanvas()._canvas);
            }
            return this;
        },
        // extend Node.prototype.moveDown
        moveDown: function() {
            if(Konva.Node.prototype.moveDown.call(this)) {
                var stage = this.getStage();
                if(stage) {
                    var children = stage.getChildren();
                    stage.content.removeChild(this.getCanvas()._canvas);
                    stage.content.insertBefore(this.getCanvas()._canvas, children[this.index + 1].getCanvas()._canvas);
                }
            }
            return this;
        },
        // extend Node.prototype.moveToBottom
        moveToBottom: function() {
            if(Konva.Node.prototype.moveToBottom.call(this)) {
                var stage = this.getStage();
                if(stage) {
                    var children = stage.getChildren();
                    stage.content.removeChild(this.getCanvas()._canvas);
                    stage.content.insertBefore(this.getCanvas()._canvas, children[1].getCanvas()._canvas);
                }
            }
            return this;
        },
        getLayer: function() {
            return this;
        },
        remove: function() {
            var _canvas = this.getCanvas()._canvas;

            Konva.Node.prototype.remove.call(this);

            if(_canvas && _canvas.parentNode && Konva.Util._isInDocument(_canvas)) {
                _canvas.parentNode.removeChild(_canvas);
            }
            return this;
        },
        getStage: function() {
            return this.parent;
        },
        setSize: function(width, height) {
            this.canvas.setSize(width, height);
            return this;
        },
        /**
         * get/set width of layer.getter return width of stage. setter doing nothing.
         * if you want change width use `stage.width(value);`
         * @name width
         * @method
         * @memberof Konva.BaseLayer.prototype
         * @returns {Number}
         * @example
         * var width = layer.width();
         */
        getWidth: function() {
            if (this.parent) {
                return this.parent.getWidth();
            }
        },
        setWidth: function() {
            Konva.Util.warn('Can not change width of layer. Use "stage.width(value)" function instead.');
        },
        /**
         * get/set height of layer.getter return height of stage. setter doing nothing.
         * if you want change height use `stage.height(value);`
         * @name height
         * @method
         * @memberof Konva.BaseLayer.prototype
         * @returns {Number}
         * @example
         * var height = layer.height();
         */
        getHeight: function() {
            if (this.parent) {
                return this.parent.getHeight();
            }
        },
        setHeight: function() {
            Konva.Util.warn('Can not change height of layer. Use "stage.height(value)" function instead.');
        },
        // the apply transform method is handled by the Layer and FastLayer class
        // because it is up to the layer to decide if an absolute or relative transform
        // should be used
        _applyTransform: function(shape, context, top) {
            var m = shape.getAbsoluteTransform(top).getMatrix();
            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
        }
    });
    Konva.Util.extend(Konva.BaseLayer, Konva.Container);

    // add getters and setters
    Konva.Factory.addGetterSetter(Konva.BaseLayer, 'clearBeforeDraw', true);
    /**
     * get/set clearBeforeDraw flag which determines if the layer is cleared or not
     *  before drawing
     * @name clearBeforeDraw
     * @method
     * @memberof Konva.BaseLayer.prototype
     * @param {Boolean} clearBeforeDraw
     * @returns {Boolean}
     * @example
     * // get clearBeforeDraw flag
     * var clearBeforeDraw = layer.clearBeforeDraw();
     *
     * // disable clear before draw
     * layer.clearBeforeDraw(false);
     *
     * // enable clear before draw
     * layer.clearBeforeDraw(true);
     */

    Konva.Collection.mapMethods(Konva.BaseLayer);
})();

(function() {
    'use strict';
    // constants
    var HASH = '#',
        BEFORE_DRAW = 'beforeDraw',
        DRAW = 'draw',

        /*
         * 2 - 3 - 4
         * |       |
         * 1 - 0   5
         *         |
         * 8 - 7 - 6
         */
        INTERSECTION_OFFSETS = [
            {x: 0, y: 0},  // 0
            {x: -1, y: 0}, // 1
            {x: -1, y: -1}, // 2
            {x: 0, y: -1}, // 3
            {x: 1, y: -1}, // 4
            {x: 1, y: 0}, // 5
            {x: 1, y: 1}, // 6
            {x: 0, y: 1}, // 7
            {x: -1, y: 1}  // 8
        ],
        INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;

    /**
     * Layer constructor.  Layers are tied to their own canvas element and are used
     * to contain groups or shapes.
     * @constructor
     * @memberof Konva
     * @augments Konva.BaseLayer
     * @param {Object} config
     * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
     * to clear the canvas before each layer draw.  The default value is true.
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height

     * @example
     * var layer = new Konva.Layer();
     */
    Konva.Layer = function(config) {
        this.____init(config);
    };

    Konva.Util.addMethods(Konva.Layer, {
        ____init: function(config) {
            this.nodeType = 'Layer';
            this.canvas = new Konva.SceneCanvas();
            this.hitCanvas = new Konva.HitCanvas({
                pixelRatio: 1
            });
            // call super constructor
            Konva.BaseLayer.call(this, config);
        },
        _setCanvasSize: function(width, height) {
            this.canvas.setSize(width, height);
            this.hitCanvas.setSize(width, height);
        },
        _validateAdd: function(child) {
            var type = child.getType();
            if (type !== 'Group' && type !== 'Shape') {
                Konva.Util.throw('You may only add groups and shapes to a layer.');
            }
        },
        /**
         * get visible intersection shape. This is the preferred
         * method for determining if a point intersects a shape or not
         * also you may pass optional selector parametr to return ancestor of intersected shape
         * @method
         * @memberof Konva.Layer.prototype
         * @param {Object} pos
         * @param {Number} pos.x
         * @param {Number} pos.y
         * @param {String} [selector]
         * @returns {Konva.Node}
         * @example
         * var shape = layer.getIntersection({x: 50, y: 50});
         * // or if you interested in shape parent:
         * var group = layer.getIntersection({x: 50, y: 50}, 'Group');
         */
        getIntersection: function(pos, selector) {
            var obj, i, intersectionOffset, shape;

            if(!this.hitGraphEnabled() || !this.isVisible()) {
                return null;
            }
            // in some cases antialiased area may be bigger than 1px
            // it is possible if we will cache node, then scale it a lot
            // TODO: check { 0; 0 } point before loop, and remove it from INTERSECTION_OFFSETS.
            var spiralSearchDistance = 1;
            var continueSearch = false;
            while (true) {
                for (i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {
                    intersectionOffset = INTERSECTION_OFFSETS[i];
                    obj = this._getIntersection({
                        x: pos.x + intersectionOffset.x * spiralSearchDistance,
                        y: pos.y + intersectionOffset.y * spiralSearchDistance
                    });
                    shape = obj.shape;
                    if (shape && selector) {
                        return shape.findAncestor(selector, true);
                    } else if (shape) {
                        return shape;
                    }
                    // we should continue search if we found antialiased pixel
                    // that means our node somewhere very close
                    continueSearch = !!obj.antialiased;
                    // stop search if found empty pixel
                    if (!obj.antialiased) {
                        break;
                    }
                }
                // if no shape, and no antialiased pixel, we should end searching
                if (continueSearch) {
                    spiralSearchDistance += 1;
                } else {
                    return null;
                }
            }
        },
        _getImageData: function(x, y) {
            var width = this.hitCanvas.width || 1,
                height = this.hitCanvas.height || 1,
                index = (Math.round(y) * width ) + Math.round(x);

            if (!this._hitImageData) {
                this._hitImageData = this.hitCanvas.context.getImageData(0, 0, width, height);
            }

            return [
                this._hitImageData.data[4 * index + 0], // Red
                this._hitImageData.data[4 * index + 1], // Green
                this._hitImageData.data[4 * index + 2], // Blue
                this._hitImageData.data[4 * index + 3] // Alpha
            ];
        },
        _getIntersection: function(pos) {
            var ratio = this.hitCanvas.pixelRatio;
            var p = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio), Math.round(pos.y * ratio), 1, 1).data,
                p3 = p[3],
                colorKey, shape;
            // fully opaque pixel
            if(p3 === 255) {
                colorKey = Konva.Util._rgbToHex(p[0], p[1], p[2]);
                shape = Konva.shapes[HASH + colorKey];
                if (shape) {
                    return {
                        shape: shape
                    };
                }
                return {
                    antialiased: true
                };
            }
            // antialiased pixel
            else if(p3 > 0) {
                return {
                    antialiased: true
                };
            }
            // empty pixel
            return {};
        },
        drawScene: function(can, top) {
            var layer = this.getLayer(),
                canvas = can || (layer && layer.getCanvas());

            this._fire(BEFORE_DRAW, {
                node: this
            });

            if(this.getClearBeforeDraw()) {
                canvas.getContext().clear();
            }

            Konva.Container.prototype.drawScene.call(this, canvas, top);

            this._fire(DRAW, {
                node: this
            });

            return this;
        },
        drawHit: function(can, top) {
            var layer = this.getLayer(),
                canvas = can || (layer && layer.hitCanvas);

            if(layer && layer.getClearBeforeDraw()) {
                layer.getHitCanvas().getContext().clear();
            }

            Konva.Container.prototype.drawHit.call(this, canvas, top);
            this.imageData = null; // Clear imageData cache
            return this;
        },
        clear: function(bounds) {
            Konva.BaseLayer.prototype.clear.call(this, bounds);
            this.getHitCanvas().getContext().clear(bounds);
            this.imageData = null; // Clear getImageData cache
            return this;
        },
        // extend Node.prototype.setVisible
        setVisible: function(visible) {
            Konva.Node.prototype.setVisible.call(this, visible);
            if(visible) {
                this.getCanvas()._canvas.style.display = 'block';
                this.hitCanvas._canvas.style.display = 'block';
            }
            else {
                this.getCanvas()._canvas.style.display = 'none';
                this.hitCanvas._canvas.style.display = 'none';
            }
            return this;
        },
        /**
         * enable hit graph
         * @name enableHitGraph
         * @method
         * @memberof Konva.Layer.prototype
         * @returns {Layer}
         */
        enableHitGraph: function() {
            this.setHitGraphEnabled(true);
            return this;
        },
        /**
         * disable hit graph
         * @name disableHitGraph
         * @method
         * @memberof Konva.Layer.prototype
         * @returns {Layer}
         */
        disableHitGraph: function() {
            this.setHitGraphEnabled(false);
            return this;
        },
        setSize: function(width, height) {
            Konva.BaseLayer.prototype.setSize.call(this, width, height);
            this.hitCanvas.setSize(width, height);
            return this;
        }
    });
    Konva.Util.extend(Konva.Layer, Konva.BaseLayer);

    Konva.Factory.addGetterSetter(Konva.Layer, 'hitGraphEnabled', true);
    /**
     * get/set hitGraphEnabled flag.  Disabling the hit graph will greatly increase
     *  draw performance because the hit graph will not be redrawn each time the layer is
     *  drawn.  This, however, also disables mouse/touch event detection
     * @name hitGraphEnabled
     * @method
     * @memberof Konva.Layer.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get hitGraphEnabled flag
     * var hitGraphEnabled = layer.hitGraphEnabled();
     *
     * // disable hit graph
     * layer.hitGraphEnabled(false);
     *
     * // enable hit graph
     * layer.hitGraphEnabled(true);
     */
    Konva.Collection.mapMethods(Konva.Layer);
})();

(function() {
    'use strict';
    /**
     * FastLayer constructor. Layers are tied to their own canvas element and are used
     * to contain shapes only.  If you don't need node nesting, mouse and touch interactions,
     * or event pub/sub, you should use FastLayer instead of Layer to create your layers.
     * It renders about 2x faster than normal layers.
     * @constructor
     * @memberof Konva
     * @augments Konva.BaseLayer
     * @param {Object} config
     * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
     * to clear the canvas before each layer draw.  The default value is true.
     * @param {Boolean} [config.visible]
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height

     * @example
     * var layer = new Konva.FastLayer();
     */
    Konva.FastLayer = function(config) {
        this.____init(config);
    };

    Konva.Util.addMethods(Konva.FastLayer, {
        ____init: function(config) {
            this.nodeType = 'Layer';
            this.canvas = new Konva.SceneCanvas();
            // call super constructor
            Konva.BaseLayer.call(this, config);
        },
        _validateAdd: function(child) {
            var type = child.getType();
            if (type !== 'Shape') {
                Konva.Util.throw('You may only add shapes to a fast layer.');
            }
        },
        _setCanvasSize: function(width, height) {
            this.canvas.setSize(width, height);
        },
        hitGraphEnabled: function() {
            return false;
        },
        getIntersection: function() {
            return null;
        },
        drawScene: function(can) {
            var layer = this.getLayer(),
                canvas = can || (layer && layer.getCanvas());

            if(this.getClearBeforeDraw()) {
                canvas.getContext().clear();
            }

            Konva.Container.prototype.drawScene.call(this, canvas);

            return this;
        },
        draw: function() {
            this.drawScene();
            return this;
        },
        // extend Node.prototype.setVisible
        setVisible: function(visible) {
            Konva.Node.prototype.setVisible.call(this, visible);
            if(visible) {
                this.getCanvas()._canvas.style.display = 'block';
            }
            else {
                this.getCanvas()._canvas.style.display = 'none';
            }
            return this;
        }
    });
    Konva.Util.extend(Konva.FastLayer, Konva.BaseLayer);

    Konva.Collection.mapMethods(Konva.FastLayer);
})();

(function() {
    'use strict';
    /**
     * Group constructor.  Groups are used to contain shapes or other groups.
     * @constructor
     * @memberof Konva
     * @augments Konva.Container
     * @param {Object} config
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height

     * @example
     * var group = new Konva.Group();
     */
    Konva.Group = function(config) {
        this.___init(config);
    };

    Konva.Util.addMethods(Konva.Group, {
        ___init: function(config) {
            this.nodeType = 'Group';
            // call super constructor
            Konva.Container.call(this, config);
        },
        _validateAdd: function(child) {
            var type = child.getType();
            if (type !== 'Group' && type !== 'Shape') {
                Konva.Util.throw('You may only add groups and shapes to groups.');
            }
        }
    });
    Konva.Util.extend(Konva.Group, Konva.Container);

    Konva.Collection.mapMethods(Konva.Group);
})();

(function(Konva) {
    'use strict';
    var BATCH_DRAW_STOP_TIME_DIFF = 500;

    var now = (function() {
        if (Konva.global.performance && Konva.global.performance.now) {
            return function() {
                return Konva.global.performance.now();
            };
        }

        return function() {
            return new Date().getTime();
        };
    })();

    function FRAF(callback) {
        setTimeout(callback, 1000 / 60);
    }

    var RAF = (function(){
        return Konva.global.requestAnimationFrame
            || Konva.global.webkitRequestAnimationFrame
            || Konva.global.mozRequestAnimationFrame
            || Konva.global.oRequestAnimationFrame
            || Konva.global.msRequestAnimationFrame
            || FRAF;
    })();



    function requestAnimFrame() {
        return RAF.apply(Konva.global, arguments);
    }

    /**
     * Animation constructor.  A stage is used to contain multiple layers and handle
     * @constructor
     * @memberof Konva
     * @param {Function} func function executed on each animation frame.  The function is passed a frame object, which contains
     *  timeDiff, lastTime, time, and frameRate properties.  The timeDiff property is the number of milliseconds that have passed
     *  since the last animation frame.  The lastTime property is time in milliseconds that elapsed from the moment the animation started
     *  to the last animation frame.  The time property is the time in milliseconds that ellapsed from the moment the animation started
     *  to the current animation frame.  The frameRate property is the current frame rate in frames / second. Return false from function,
     *  if you don't need to redraw layer/layers on some frames.
     * @param {Konva.Layer|Array} [layers] layer(s) to be redrawn on each animation frame. Can be a layer, an array of layers, or null.
     *  Not specifying a node will result in no redraw.
     * @example
     * // move a node to the right at 50 pixels / second
     * var velocity = 50;
     *
     * var anim = new Konva.Animation(function(frame) {
     *   var dist = velocity * (frame.timeDiff / 1000);
     *   node.move(dist, 0);
     * }, layer);
     *
     * anim.start();
     */
    Konva.Animation = function(func, layers) {
        var Anim = Konva.Animation;
        this.func = func;
        this.setLayers(layers);
        this.id = Anim.animIdCounter++;
        this.frame = {
            time: 0,
            timeDiff: 0,
            lastTime: now()
        };
    };
    /*
     * Animation methods
     */
    Konva.Animation.prototype = {
        /**
         * set layers to be redrawn on each animation frame
         * @method
         * @memberof Konva.Animation.prototype
         * @param {Konva.Layer|Array} [layers] layer(s) to be redrawn.&nbsp; Can be a layer, an array of layers, or null.  Not specifying a node will result in no redraw.
         * @return {Konva.Animation} this
         */
        setLayers: function(layers) {
            var lays = [];
            // if passing in no layers
            if (!layers) {
                lays = [];
            }
            // if passing in an array of Layers
            // NOTE: layers could be an array or Konva.Collection.  for simplicity, I'm just inspecting
            // the length property to check for both cases
            else if (layers.length > 0) {
                lays = layers;
            }
            // if passing in a Layer
            else {
                lays = [layers];
            }

            this.layers = lays;
            return this;
        },
        /**
         * get layers
         * @method
         * @memberof Konva.Animation.prototype
         * @return {Array} Array of Konva.Layer
         */
        getLayers: function() {
            return this.layers;
        },
        /**
         * add layer.  Returns true if the layer was added, and false if it was not
         * @method
         * @memberof Konva.Animation.prototype
         * @param {Konva.Layer} layer to add
         * @return {Bool} true if layer is added to animation, otherwise false
         */
        addLayer: function(layer) {
            var layers = this.layers,
                len = layers.length, n;

            // don't add the layer if it already exists
            for (n = 0; n < len; n++) {
                if (layers[n]._id === layer._id){
                    return false;
                }
            }

            this.layers.push(layer);
            return true;
        },
        /**
         * determine if animation is running or not.  returns true or false
         * @method
         * @memberof Konva.Animation.prototype
         * @return {Bool} is animation running?
         */
        isRunning: function() {
            var a = Konva.Animation,
                animations = a.animations,
                len = animations.length,
                n;

            for(n = 0; n < len; n++) {
                if(animations[n].id === this.id) {
                    return true;
                }
            }
            return false;
        },
        /**
         * start animation
         * @method
         * @memberof Konva.Animation.prototype
         * @return {Konva.Animation} this
         */
        start: function() {
            var Anim = Konva.Animation;
            this.stop();
            this.frame.timeDiff = 0;
            this.frame.lastTime = now();
            Anim._addAnimation(this);
            return this;
        },
        /**
         * stop animation
         * @method
         * @memberof Konva.Animation.prototype
         * @return {Konva.Animation} this
         */
        stop: function() {
            Konva.Animation._removeAnimation(this);
            return this;
        },
        _updateFrameObject: function(time) {
            this.frame.timeDiff = time - this.frame.lastTime;
            this.frame.lastTime = time;
            this.frame.time += this.frame.timeDiff;
            this.frame.frameRate = 1000 / this.frame.timeDiff;
        }
    };
    Konva.Animation.animations = [];
    Konva.Animation.animIdCounter = 0;
    Konva.Animation.animRunning = false;

    Konva.Animation._addAnimation = function(anim) {
        this.animations.push(anim);
        this._handleAnimation();
    };
    Konva.Animation._removeAnimation = function(anim) {
        var id = anim.id,
            animations = this.animations,
            len = animations.length,
            n;

        for(n = 0; n < len; n++) {
            if(animations[n].id === id) {
                this.animations.splice(n, 1);
                break;
            }
        }
    };

    Konva.Animation._runFrames = function() {
        var layerHash = {},
            animations = this.animations,
            anim, layers, func, n, i, layersLen, layer, key, needRedraw;
        /*
         * loop through all animations and execute animation
         *  function.  if the animation object has specified node,
         *  we can add the node to the nodes hash to eliminate
         *  drawing the same node multiple times.  The node property
         *  can be the stage itself or a layer
         */
        /*
         * WARNING: don't cache animations.length because it could change while
         * the for loop is running, causing a JS error
         */

        for(n = 0; n < animations.length; n++) {
            anim = animations[n];
            layers = anim.layers;
            func = anim.func;


            anim._updateFrameObject(now());
            layersLen = layers.length;

            // if animation object has a function, execute it
            if (func) {
                // allow anim bypassing drawing
                needRedraw = (func.call(anim, anim.frame) !== false);
            } else {
                needRedraw = true;
            }
            if (!needRedraw) {
                continue;
            }
            for (i = 0; i < layersLen; i++) {
                layer = layers[i];

                if (layer._id !== undefined) {
                    layerHash[layer._id] = layer;
                }
            }
        }

        for (key in layerHash) {
            if (!layerHash.hasOwnProperty(key)) {
                continue;
            }
            layerHash[key].draw();
        }
    };
    Konva.Animation._animationLoop = function() {
        var Anim = Konva.Animation;
        if(Anim.animations.length) {
            requestAnimFrame(Anim._animationLoop);
            Anim._runFrames();
        }
        else {
            Anim.animRunning = false;
        }
    };
    Konva.Animation._handleAnimation = function() {
        if(!this.animRunning) {
            this.animRunning = true;
            this._animationLoop();
        }
    };

    /**
     * batch draw
     * @method
     * @return {Konva.Layer} this
     * @memberof Konva.Base.prototype
     */
    Konva.BaseLayer.prototype.batchDraw = function() {
        var that = this,
            Anim = Konva.Animation;

        if (!this.batchAnim) {
            this.batchAnim = new Anim(function() {
                if (that.lastBatchDrawTime && now() - that.lastBatchDrawTime > BATCH_DRAW_STOP_TIME_DIFF) {
                    that.batchAnim.stop();
                }
            }, this);
        }

        this.lastBatchDrawTime = now();

        if (!this.batchAnim.isRunning()) {
            this.draw();
            this.batchAnim.start();
        }
        return this;
    };

    /**
     * batch draw
     * @method
     * @return {Konva.Stage} this
     * @memberof Konva.Stage.prototype
     */
    Konva.Stage.prototype.batchDraw = function() {
        this.getChildren().each(function(layer) {
            layer.batchDraw();
        });
        return this;
    };
})(Konva);

(function() {
    'use strict';
    var blacklist = {
        node: 1,
        duration: 1,
        easing: 1,
        onFinish: 1,
        yoyo: 1
    },

    PAUSED = 1,
    PLAYING = 2,
    REVERSING = 3,

    idCounter = 0,
    colorAttrs = ['fill', 'stroke', 'shadowColor'];

    var Tween = function(prop, propFunc, func, begin, finish, duration, yoyo) {
        this.prop = prop;
        this.propFunc = propFunc;
        this.begin = begin;
        this._pos = begin;
        this.duration = duration;
        this._change = 0;
        this.prevPos = 0;
        this.yoyo = yoyo;
        this._time = 0;
        this._position = 0;
        this._startTime = 0;
        this._finish = 0;
        this.func = func;
        this._change = finish - this.begin;
        this.pause();
    };
    /*
     * Tween methods
     */
    Tween.prototype = {
        fire: function(str) {
            var handler = this[str];
            if (handler) {
                handler();
            }
        },
        setTime: function(t) {
            if(t > this.duration) {
                if(this.yoyo) {
                    this._time = this.duration;
                    this.reverse();
                }
                else {
                    this.finish();
                }
            }
            else if(t < 0) {
                if(this.yoyo) {
                    this._time = 0;
                    this.play();
                }
                else {
                    this.reset();
                }
            }
            else {
                this._time = t;
                this.update();
            }
        },
        getTime: function() {
            return this._time;
        },
        setPosition: function(p) {
            this.prevPos = this._pos;
            this.propFunc(p);
            this._pos = p;
        },
        getPosition: function(t) {
            if(t === undefined) {
                t = this._time;
            }
            return this.func(t, this.begin, this._change, this.duration);
        },
        play: function() {
            this.state = PLAYING;
            this._startTime = this.getTimer() - this._time;
            this.onEnterFrame();
            this.fire('onPlay');
        },
        reverse: function() {
            this.state = REVERSING;
            this._time = this.duration - this._time;
            this._startTime = this.getTimer() - this._time;
            this.onEnterFrame();
            this.fire('onReverse');
        },
        seek: function(t) {
            this.pause();
            this._time = t;
            this.update();
            this.fire('onSeek');
        },
        reset: function() {
            this.pause();
            this._time = 0;
            this.update();
            this.fire('onReset');
        },
        finish: function() {
            this.pause();
            this._time = this.duration;
            this.update();
            this.fire('onFinish');
        },
        update: function() {
            this.setPosition(this.getPosition(this._time));
        },
        onEnterFrame: function() {
            var t = this.getTimer() - this._startTime;
            if(this.state === PLAYING) {
                this.setTime(t);
            }
            else if (this.state === REVERSING) {
                this.setTime(this.duration - t);
            }
        },
        pause: function() {
            this.state = PAUSED;
            this.fire('onPause');
        },
        getTimer: function() {
            return new Date().getTime();
        }
    };

    /**
     * Tween constructor.  Tweens enable you to animate a node between the current state and a new state.
     *  You can play, pause, reverse, seek, reset, and finish tweens.  By default, tweens are animated using
     *  a linear easing.  For more tweening options, check out {@link Konva.Easings}
     * @constructor
     * @memberof Konva
     * @example
     * // instantiate new tween which fully rotates a node in 1 second
     * var tween = new Konva.Tween({
     *   node: node,
     *   rotationDeg: 360,
     *   duration: 1,
     *   easing: Konva.Easings.EaseInOut
     * });
     *
     * // play tween
     * tween.play();
     *
     * // pause tween
     * tween.pause();
     */
    Konva.Tween = function(config) {
        var that = this,
            node = config.node,
            nodeId = node._id,
            duration,
            easing = config.easing || Konva.Easings.Linear,
            yoyo = !!config.yoyo,
            key;

        if (typeof config.duration === 'undefined') {
            duration = 1;
        } else if (config.duration === 0) {  // zero is bad value for duration
            duration = 0.001;
        } else {
            duration = config.duration;
        }
        this.node = node;
        this._id = idCounter++;

        this.anim = new Konva.Animation(function() {
            that.tween.onEnterFrame();
        }, node.getLayer() || ((node instanceof Konva.Stage) ? node.getLayers() : null));

        this.tween = new Tween(key, function(i) {
            that._tweenFunc(i);
        }, easing, 0, 1, duration * 1000, yoyo);

        this._addListeners();

        // init attrs map
        if (!Konva.Tween.attrs[nodeId]) {
            Konva.Tween.attrs[nodeId] = {};
        }
        if (!Konva.Tween.attrs[nodeId][this._id]) {
            Konva.Tween.attrs[nodeId][this._id] = {};
        }
        // init tweens map
        if (!Konva.Tween.tweens[nodeId]) {
            Konva.Tween.tweens[nodeId] = {};
        }

        for (key in config) {
            if (blacklist[key] === undefined) {
                this._addAttr(key, config[key]);
            }
        }

        this.reset();

        // callbacks
        this.onFinish = config.onFinish;
        this.onReset = config.onReset;
    };

    // start/diff object = attrs.nodeId.tweenId.attr
    Konva.Tween.attrs = {};
    // tweenId = tweens.nodeId.attr
    Konva.Tween.tweens = {};

    Konva.Tween.prototype = {
        _addAttr: function(key, end) {
            var node = this.node,
                nodeId = node._id,
                start, diff, tweenId, n, len, trueEnd, trueStart;

            // remove conflict from tween map if it exists
            tweenId = Konva.Tween.tweens[nodeId][key];

            if (tweenId) {
                delete Konva.Tween.attrs[nodeId][tweenId][key];
            }

            // add to tween map
            start = node.getAttr(key);

            if (Konva.Util._isArray(end)) {
                diff = [];
                len = Math.max(end.length, start.length);

                if (key === 'points' && end.length !== start.length) {
                    // before tweening points we need to make sure that start.length === end.length
                    // Konva.Util._prepareArrayForTween thinking that end.length > start.length

                    if (end.length > start.length) {
                        // so in this case we will increase number of starting points
                        trueStart = start;
                        start = Konva.Util._prepareArrayForTween(start, end, node.closed());
                    } else {
                        // in this case we will increase number of eding points
                        trueEnd = end;
                        end = Konva.Util._prepareArrayForTween(end, start, node.closed());
                    }
                }

                for (n = 0; n < len; n++) {
                    diff.push((end[n]) - (start[n]));
                }

            } else if (colorAttrs.indexOf(key) !== -1) {
                start = Konva.Util.colorToRGBA(start);
                var endRGBA = Konva.Util.colorToRGBA(end);
                diff = {
                    r: endRGBA.r - start.r,
                    g: endRGBA.g - start.g,
                    b: endRGBA.b - start.b,
                    a: endRGBA.a - start.a
                };
            } else {
                diff = end - start;
            }

            Konva.Tween.attrs[nodeId][this._id][key] = {
                start: start,
                diff: diff,
                end: end,
                trueEnd: trueEnd,
                trueStart: trueStart
            };
            Konva.Tween.tweens[nodeId][key] = this._id;
        },
        _tweenFunc: function(i) {
            var node = this.node,
                attrs = Konva.Tween.attrs[node._id][this._id],
                key, attr, start, diff, newVal, n, len, end;

            for (key in attrs) {
                attr = attrs[key];
                start = attr.start;
                diff = attr.diff;
                end = attr.end;

                if (Konva.Util._isArray(start)) {
                    newVal = [];
                    len = Math.max(start.length, end.length);
                    for (n = 0; n < len; n++) {
                        newVal.push((start[n] || 0) + (diff[n] * i));
                    }
                } else if (colorAttrs.indexOf(key) !== -1) {
                    newVal = 'rgba(' +
                            Math.round(start.r + diff.r * i) + ',' +
                            Math.round(start.g + diff.g * i) + ',' +
                            Math.round(start.b + diff.b * i) + ',' +
                            (start.a + diff.a * i) + ')';
                } else {
                    newVal = start + (diff * i);
                }

                node.setAttr(key, newVal);
            }
        },
        _addListeners: function() {
            var that = this;

            // start listeners
            this.tween.onPlay = function() {
                that.anim.start();
            };
            this.tween.onReverse = function() {
                that.anim.start();
            };

            // stop listeners
            this.tween.onPause = function() {
                that.anim.stop();
            };
            this.tween.onFinish = function() {
                var node = that.node;

                // after tweening  points of line we need to set original end
                var attrs = Konva.Tween.attrs[node._id][that._id];
                if (attrs.points && attrs.points.trueEnd) {
                    node.points(attrs.points.trueEnd);
                }

                if (that.onFinish) {
                    that.onFinish.call(that);
                }
            };
            this.tween.onReset = function() {
                var node = that.node;
                // after tweening  points of line we need to set original start
                var attrs = Konva.Tween.attrs[node._id][that._id];
                if (attrs.points && attrs.points.trueStart) {
                    node.points(attrs.points.trueStart);
                }

                if (that.onReset) {
                    that.onReset();
                }
            };
        },
        /**
         * play
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
        play: function() {
            this.tween.play();
            return this;
        },
        /**
         * reverse
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
        reverse: function() {
            this.tween.reverse();
            return this;
        },
        /**
         * reset
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
        reset: function() {
            this.tween.reset();
            return this;
        },
        /**
         * seek
         * @method
         * @memberof Konva.Tween.prototype
         * @param {Integer} t time in seconds between 0 and the duration
         * @returns {Tween}
         */
        seek: function(t) {
            this.tween.seek(t * 1000);
            return this;
        },
        /**
         * pause
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
        pause: function() {
            this.tween.pause();
            return this;
        },
        /**
         * finish
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
        finish: function() {
            this.tween.finish();
            return this;
        },
        /**
         * destroy
         * @method
         * @memberof Konva.Tween.prototype
         */
        destroy: function() {
            var nodeId = this.node._id,
                thisId = this._id,
                attrs = Konva.Tween.tweens[nodeId],
                key;

            this.pause();

            for (key in attrs) {
                delete Konva.Tween.tweens[nodeId][key];
            }

            delete Konva.Tween.attrs[nodeId][thisId];
        }
    };

    /**
     * Tween node properties. Shorter usage of {@link Konva.Tween} object.
     *
     * @method Konva.Node#to
     * @memberof Konva.Node
     * @param {Object} [params] tween params
     * @example
     *
     * circle.to({
     *  x : 50,
     *  duration : 0.5
     * });
     */
    Konva.Node.prototype.to = function(params) {
        var onFinish = params.onFinish;
        params.node = this;
        params.onFinish = function() {
            this.destroy();
            if (onFinish) {
                onFinish();
            }
        };
        var tween = new Konva.Tween(params);
        tween.play();
    };

    /*
    * These eases were ported from an Adobe Flash tweening library to JavaScript
    * by Xaric
    */

    /**
     * @namespace Easings
     * @memberof Konva
     */
    Konva.Easings = {
        /**
        * back ease in
        * @function
        * @memberof Konva.Easings
        */
        'BackEaseIn': function(t, b, c, d) {
            var s = 1.70158;
            return c * (t /= d) * t * ((s + 1) * t - s) + b;
        },
        /**
        * back ease out
        * @function
        * @memberof Konva.Easings
        */
        'BackEaseOut': function(t, b, c, d) {
            var s = 1.70158;
            return c * (( t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
        },
        /**
        * back ease in out
        * @function
        * @memberof Konva.Easings
        */
        'BackEaseInOut': function(t, b, c, d) {
            var s = 1.70158;
            if((t /= d / 2) < 1) {
                return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
            }
            return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
        },
        /**
        * elastic ease in
        * @function
        * @memberof Konva.Easings
        */
        'ElasticEaseIn': function(t, b, c, d, a, p) {
            // added s = 0
            var s = 0;
            if(t === 0) {
                return b;
            }
            if((t /= d) === 1) {
                return b + c;
            }
            if(!p) {
                p = d * 0.3;
            }
            if(!a || a < Math.abs(c)) {
                a = c;
                s = p / 4;
            }
            else {
                s = p / (2 * Math.PI) * Math.asin(c / a);
            }
            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
        },
        /**
        * elastic ease out
        * @function
        * @memberof Konva.Easings
        */
        'ElasticEaseOut': function(t, b, c, d, a, p) {
            // added s = 0
            var s = 0;
            if(t === 0) {
                return b;
            }
            if((t /= d) === 1) {
                return b + c;
            }
            if(!p) {
                p = d * 0.3;
            }
            if(!a || a < Math.abs(c)) {
                a = c;
                s = p / 4;
            }
            else {
                s = p / (2 * Math.PI) * Math.asin(c / a);
            }
            return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b);
        },
        /**
        * elastic ease in out
        * @function
        * @memberof Konva.Easings
        */
        'ElasticEaseInOut': function(t, b, c, d, a, p) {
            // added s = 0
            var s = 0;
            if(t === 0) {
                return b;
            }
            if((t /= d / 2) === 2) {
                return b + c;
            }
            if(!p) {
                p = d * (0.3 * 1.5);
            }
            if(!a || a < Math.abs(c)) {
                a = c;
                s = p / 4;
            }
            else {
                s = p / (2 * Math.PI) * Math.asin(c / a);
            }
            if(t < 1) {
                return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
            }
            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
        },
        /**
        * bounce ease out
        * @function
        * @memberof Konva.Easings
        */
        'BounceEaseOut': function(t, b, c, d) {
            if((t /= d) < (1 / 2.75)) {
                return c * (7.5625 * t * t) + b;
            }
            else if(t < (2 / 2.75)) {
                return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
            }
            else if(t < (2.5 / 2.75)) {
                return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
            }
            else {
                return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
            }
        },
        /**
        * bounce ease in
        * @function
        * @memberof Konva.Easings
        */
        'BounceEaseIn': function(t, b, c, d) {
            return c - Konva.Easings.BounceEaseOut(d - t, 0, c, d) + b;
        },
        /**
        * bounce ease in out
        * @function
        * @memberof Konva.Easings
        */
        'BounceEaseInOut': function(t, b, c, d) {
            if(t < d / 2) {
                return Konva.Easings.BounceEaseIn(t * 2, 0, c, d) * 0.5 + b;
            }
            else {
                return Konva.Easings.BounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
            }
        },
        /**
        * ease in
        * @function
        * @memberof Konva.Easings
        */
        'EaseIn': function(t, b, c, d) {
            return c * (t /= d) * t + b;
        },
        /**
        * ease out
        * @function
        * @memberof Konva.Easings
        */
        'EaseOut': function(t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        },
        /**
        * ease in out
        * @function
        * @memberof Konva.Easings
        */
        'EaseInOut': function(t, b, c, d) {
            if((t /= d / 2) < 1) {
                return c / 2 * t * t + b;
            }
            return -c / 2 * ((--t) * (t - 2) - 1) + b;
        },
        /**
        * strong ease in
        * @function
        * @memberof Konva.Easings
        */
        'StrongEaseIn': function(t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
        },
        /**
        * strong ease out
        * @function
        * @memberof Konva.Easings
        */
        'StrongEaseOut': function(t, b, c, d) {
            return c * (( t = t / d - 1) * t * t * t * t + 1) + b;
        },
        /**
        * strong ease in out
        * @function
        * @memberof Konva.Easings
        */
        'StrongEaseInOut': function(t, b, c, d) {
            if((t /= d / 2) < 1) {
                return c / 2 * t * t * t * t * t + b;
            }
            return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
        },
        /**
        * linear
        * @function
        * @memberof Konva.Easings
        */
        'Linear': function(t, b, c, d) {
            return c * t / d + b;
        }
    };
})();

(function() {
    'use strict';
    Konva.DD = {
        // properties
        anim: new Konva.Animation(function() {
            var b = this.dirty;
            this.dirty = false;
            return b;
        }),
        isDragging: false,
        justDragged: false,
        offset: {
            x: 0,
            y: 0
        },
        node: null,

        // methods
        _drag: function(evt) {
            var dd = Konva.DD,
                node = dd.node;

            if(node) {
               if(!dd.isDragging) {
                    var pos = node.getStage().getPointerPosition();
                    var dragDistance = node.dragDistance();
                    var distance = Math.max(
                        Math.abs(pos.x - dd.startPointerPos.x),
                        Math.abs(pos.y - dd.startPointerPos.y)
                    );
                    if (distance < dragDistance) {
                        return;
                    }
                }


                node.getStage()._setPointerPosition(evt);
                node._setDragPosition(evt);
                if(!dd.isDragging) {
                    dd.isDragging = true;
                    node.fire('dragstart', {
                        type: 'dragstart',
                        target: node,
                        evt: evt
                    }, true);
                }

                // execute ondragmove if defined
                node.fire('dragmove', {
                    type: 'dragmove',
                    target: node,
                    evt: evt
                }, true);
            }
        },
        _endDragBefore: function(evt) {
            var dd = Konva.DD,
                node = dd.node,
                layer;

            if(node) {
                layer = node.getLayer();
                dd.anim.stop();

                // only fire dragend event if the drag and drop
                // operation actually started.
                if(dd.isDragging) {
                    dd.isDragging = false;
                    dd.justDragged = true;
                    Konva.listenClickTap = false;

                    if (evt) {
                        evt.dragEndNode = node;
                    }
                }

                delete dd.node;

                (layer || node).draw();
            }
        },
        _endDragAfter: function(evt) {
            evt = evt || {};
            var dragEndNode = evt.dragEndNode;

            if (evt && dragEndNode) {
                dragEndNode.fire('dragend', {
                    type: 'dragend',
                    target: dragEndNode,
                    evt: evt
                }, true);
            }
        }
    };

    // Node extenders

    /**
     * initiate drag and drop
     * @method
     * @memberof Konva.Node.prototype
     */
    Konva.Node.prototype.startDrag = function() {
        var dd = Konva.DD,
            stage = this.getStage(),
            layer = this.getLayer(),
            pos = stage.getPointerPosition(),
            ap = this.getAbsolutePosition();

        if(pos) {
            if (dd.node) {
                dd.node.stopDrag();
            }

            dd.node = this;
            dd.startPointerPos = pos;
            dd.offset.x = pos.x - ap.x;
            dd.offset.y = pos.y - ap.y;
            dd.anim.setLayers(layer || this.getLayers());
            dd.anim.start();

            this._setDragPosition();
        }
    };

    Konva.Node.prototype._setDragPosition = function(evt) {
        var dd = Konva.DD,
            pos = this.getStage().getPointerPosition(),
            dbf = this.getDragBoundFunc();
        if (!pos) {
            return;
        }
        var newNodePos = {
            x: pos.x - dd.offset.x,
            y: pos.y - dd.offset.y
        };

        if(dbf !== undefined) {
            newNodePos = dbf.call(this, newNodePos, evt);
        }
        this.setAbsolutePosition(newNodePos);

        if (!this._lastPos || this._lastPos.x !== newNodePos.x ||
            this._lastPos.y !== newNodePos.y) {
            dd.anim.dirty = true;
        }

        this._lastPos = newNodePos;
    };

    /**
     * stop drag and drop
     * @method
     * @memberof Konva.Node.prototype
     */
    Konva.Node.prototype.stopDrag = function() {
        var dd = Konva.DD,
            evt = {};
        dd._endDragBefore(evt);
        dd._endDragAfter(evt);
    };

    Konva.Node.prototype.setDraggable = function(draggable) {
        this._setAttr('draggable', draggable);
        this._dragChange();
    };

    var origDestroy = Konva.Node.prototype.destroy;

    Konva.Node.prototype.destroy = function() {
        var dd = Konva.DD;

        // stop DD
        if(dd.node && dd.node._id === this._id) {

            this.stopDrag();
        }

        origDestroy.call(this);
    };

    /**
     * determine if node is currently in drag and drop mode
     * @method
     * @memberof Konva.Node.prototype
     */
    Konva.Node.prototype.isDragging = function() {
        var dd = Konva.DD;
        return !!(dd.node && dd.node._id === this._id && dd.isDragging);
    };

    Konva.Node.prototype._listenDrag = function() {
        var that = this;

        this._dragCleanup();

        if (this.getClassName() === 'Stage') {
            this.on('contentMousedown.konva contentTouchstart.konva', function(evt) {
                if(!Konva.DD.node) {
                    that.startDrag(evt);
                }
            });
        }
        else {
            this.on('mousedown.konva touchstart.konva', function(evt) {
                // ignore right and middle buttons
                if (evt.evt.button === 1 || evt.evt.button === 2) {
                    return;
                }
                if(!Konva.DD.node) {
                    that.startDrag(evt);
                }
            });
        }

        // listening is required for drag and drop
        /*
        this._listeningEnabled = true;
        this._clearSelfAndAncestorCache('listeningEnabled');
        */
    };

    Konva.Node.prototype._dragChange = function() {
        if(this.attrs.draggable) {
            this._listenDrag();
        }
        else {
            // remove event listeners
            this._dragCleanup();

            /*
             * force drag and drop to end
             * if this node is currently in
             * drag and drop mode
             */
            var stage = this.getStage();
            var dd = Konva.DD;
            if(stage && dd.node && dd.node._id === this._id) {
                dd.node.stopDrag();
            }
        }
    };

    Konva.Node.prototype._dragCleanup = function() {
        if (this.getClassName() === 'Stage') {
            this.off('contentMousedown.konva');
            this.off('contentTouchstart.konva');
        } else {
            this.off('mousedown.konva');
            this.off('touchstart.konva');
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'dragBoundFunc');

    /**
     * get/set drag bound function.  This is used to override the default
     *  drag and drop position
     * @name dragBoundFunc
     * @method
     * @memberof Konva.Node.prototype
     * @param {Function} dragBoundFunc
     * @returns {Function}
     * @example
     * // get drag bound function
     * var dragBoundFunc = node.dragBoundFunc();
     *
     * // create vertical drag and drop
     * node.dragBoundFunc(function(pos){
     *   return {
     *     x: this.getAbsolutePosition().x,
     *     y: pos.y
     *   };
     * });
     */

    Konva.Factory.addGetter(Konva.Node, 'draggable', false);
    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'draggable');

     /**
     * get/set draggable flag
     * @name draggable
     * @method
     * @memberof Konva.Node.prototype
     * @param {Boolean} draggable
     * @returns {Boolean}
     * @example
     * // get draggable flag
     * var draggable = node.draggable();
     *
     * // enable drag and drop
     * node.draggable(true);
     *
     * // disable drag and drop
     * node.draggable(false);
     */

    var html = Konva.document.documentElement;
    html.addEventListener('mouseup', Konva.DD._endDragBefore, true);
    html.addEventListener('touchend', Konva.DD._endDragBefore, true);

    html.addEventListener('mousemove', Konva.DD._drag);
    html.addEventListener('touchmove', Konva.DD._drag);

    html.addEventListener('mouseup', Konva.DD._endDragAfter, false);
    html.addEventListener('touchend', Konva.DD._endDragAfter, false);

})();

(function() {
    'use strict';
    /**
     * Rect constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} [config.cornerRadius]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var rect = new Konva.Rect({
     *   width: 100,
     *   height: 50,
     *   fill: 'red',
     *   stroke: 'black',
     *   strokeWidth: 5
     * });
     */
    Konva.Rect = function(config) {
        this.___init(config);
    };

    Konva.Rect.prototype = {
        ___init: function(config) {
            Konva.Shape.call(this, config);
            this.className = 'Rect';
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            var cornerRadius = this.getCornerRadius(),
                width = this.getWidth(),
                height = this.getHeight();

            context.beginPath();

            if(!cornerRadius) {
                // simple rect - don't bother doing all that complicated maths stuff.
                context.rect(0, 0, width, height);
            } else {
                // arcTo would be nicer, but browser support is patchy (Opera)
                cornerRadius = Math.min(cornerRadius, width / 2, height / 2);
                context.moveTo(cornerRadius, 0);
                context.lineTo(width - cornerRadius, 0);
                context.arc(width - cornerRadius, cornerRadius, cornerRadius, Math.PI * 3 / 2, 0, false);
                context.lineTo(width, height - cornerRadius);
                context.arc(width - cornerRadius, height - cornerRadius, cornerRadius, 0, Math.PI / 2, false);
                context.lineTo(cornerRadius, height);
                context.arc(cornerRadius, height - cornerRadius, cornerRadius, Math.PI / 2, Math.PI, false);
                context.lineTo(0, cornerRadius);
                context.arc(cornerRadius, cornerRadius, cornerRadius, Math.PI, Math.PI * 3 / 2, false);
            }
            context.closePath();
            context.fillStrokeShape(this);
        }
    };

    Konva.Util.extend(Konva.Rect, Konva.Shape);

    Konva.Factory.addGetterSetter(Konva.Rect, 'cornerRadius', 0);
    /**
     * get/set corner radius
     * @name cornerRadius
     * @method
     * @memberof Konva.Rect.prototype
     * @param {Number} cornerRadius
     * @returns {Number}
     * @example
     * // get corner radius
     * var cornerRadius = rect.cornerRadius();
     *
     * // set corner radius
     * rect.cornerRadius(10);
     */

    Konva.Collection.mapMethods(Konva.Rect);
})();

(function() {
    'use strict';
    // the 0.0001 offset fixes a bug in Chrome 27
    var PIx2 = (Math.PI * 2) - 0.0001,
        CIRCLE = 'Circle';

    /**
     * Circle constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.radius
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * // create circle
     * var circle = new Konva.Circle({
     *   radius: 40,
     *   fill: 'red',
     *   stroke: 'black'
     *   strokeWidth: 5
     * });
     */
    Konva.Circle = function(config) {
        this.___init(config);
    };

    Konva.Circle.prototype = {
        _centroid: true,
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = CIRCLE;
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            context.beginPath();
            context.arc(0, 0, this.getRadius(), 0, PIx2, false);
            context.closePath();
            context.fillStrokeShape(this);
        },
        // implements Shape.prototype.getWidth()
        getWidth: function() {
            return this.getRadius() * 2;
        },
        // implements Shape.prototype.getHeight()
        getHeight: function() {
            return this.getRadius() * 2;
        },
        // implements Shape.prototype.setWidth()
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            if (this.radius() !== width / 2) {
                this.setRadius(width / 2);
            }
        },
        // implements Shape.prototype.setHeight()
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            if (this.radius() !== height / 2) {
                this.setRadius(height / 2);
            }
        }
    };
    Konva.Util.extend(Konva.Circle, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Circle, 'radius', 0);
    Konva.Factory.addOverloadedGetterSetter(Konva.Circle, 'radius');

    /**
     * get/set radius
     * @name radius
     * @method
     * @memberof Konva.Circle.prototype
     * @param {Number} radius
     * @returns {Number}
     * @example
     * // get radius
     * var radius = circle.radius();
     *
     * // set radius
     * circle.radius(10);
     */

    Konva.Collection.mapMethods(Konva.Circle);
})();

(function() {
    'use strict';
    // the 0.0001 offset fixes a bug in Chrome 27
    var PIx2 = (Math.PI * 2) - 0.0001,
        ELLIPSE = 'Ellipse';

    /**
     * Ellipse constructor
     * @constructor
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Object} config.radius defines x and y radius
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var ellipse = new Konva.Ellipse({
     *   radius : {
     *     x : 50,
     *     y : 50
     *   },
     *   fill: 'red'
     * });
     */
    Konva.Ellipse = function(config) {
        this.___init(config);
    };

    Konva.Ellipse.prototype = {
        _centroid: true,
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = ELLIPSE;
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            var rx = this.getRadiusX(),
                ry = this.getRadiusY();

            context.beginPath();
            context.save();
            if(rx !== ry) {
                context.scale(1, ry / rx);
            }
            context.arc(0, 0, rx, 0, PIx2, false);
            context.restore();
            context.closePath();
            context.fillStrokeShape(this);
        },
        // implements Shape.prototype.getWidth()
        getWidth: function() {
            return this.getRadiusX() * 2;
        },
        // implements Shape.prototype.getHeight()
        getHeight: function() {
            return this.getRadiusY() * 2;
        },
        // implements Shape.prototype.setWidth()
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            this.setRadius({
                x: width / 2
            });
        },
        // implements Shape.prototype.setHeight()
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            this.setRadius({
                y: height / 2
            });
        }
    };
    Konva.Util.extend(Konva.Ellipse, Konva.Shape);

    // add getters setters
    Konva.Factory.addComponentsGetterSetter(Konva.Ellipse, 'radius', ['x', 'y']);

    /**
     * get/set radius
     * @name radius
     * @method
     * @memberof Konva.Ellipse.prototype
     * @param {Object} radius
     * @param {Number} radius.x
     * @param {Number} radius.y
     * @returns {Object}
     * @example
     * // get radius
     * var radius = ellipse.radius();
     *
     * // set radius
     * ellipse.radius({
     *   x: 200,
     *   y: 100
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Ellipse, 'radiusX', 0);
    /**
     * get/set radius x
     * @name radiusX
     * @method
     * @memberof Konva.Ellipse.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get radius x
     * var radiusX = ellipse.radiusX();
     *
     * // set radius x
     * ellipse.radiusX(200);
     */

    Konva.Factory.addGetterSetter(Konva.Ellipse, 'radiusY', 0);
    /**
     * get/set radius y
     * @name radiusY
     * @method
     * @memberof Konva.Ellipse.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get radius y
     * var radiusY = ellipse.radiusY();
     *
     * // set radius y
     * ellipse.radiusY(200);
     */

    Konva.Collection.mapMethods(Konva.Ellipse);

})();

(function() {
    'use strict';
    // the 0.0001 offset fixes a bug in Chrome 27
    var PIx2 = (Math.PI * 2) - 0.0001;
    /**
     * Ring constructor
     * @constructor
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.innerRadius
     * @param {Number} config.outerRadius
     * @param {Boolean} [config.clockwise]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var ring = new Konva.Ring({
     *   innerRadius: 40,
     *   outerRadius: 80,
     *   fill: 'red',
     *   stroke: 'black',
     *   strokeWidth: 5
     * });
     */
    Konva.Ring = function(config) {
        this.___init(config);
    };

    Konva.Ring.prototype = {
        _centroid: true,
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'Ring';
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            context.beginPath();
            context.arc(0, 0, this.getInnerRadius(), 0, PIx2, false);
            context.moveTo(this.getOuterRadius(), 0);
            context.arc(0, 0, this.getOuterRadius(), PIx2, 0, true);
            context.closePath();
            context.fillStrokeShape(this);
        },
        // implements Shape.prototype.getWidth()
        getWidth: function() {
            return this.getOuterRadius() * 2;
        },
        // implements Shape.prototype.getHeight()
        getHeight: function() {
            return this.getOuterRadius() * 2;
        },
        // implements Shape.prototype.setWidth()
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            if (this.outerRadius() !== width / 2) {
                this.setOuterRadius(width / 2);
            }
        },
        // implements Shape.prototype.setHeight()
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            if (this.outerRadius() !== height / 2) {
                this.setOuterRadius(height / 2);
            }
        },
        setOuterRadius: function(val) {
            this._setAttr('outerRadius', val);
            this.setWidth(val * 2);
            this.setHeight(val * 2);
        }
    };
    Konva.Util.extend(Konva.Ring, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Ring, 'innerRadius', 0);

    /**
     * get/set innerRadius
     * @name innerRadius
     * @method
     * @memberof Konva.Ring.prototype
     * @param {Number} innerRadius
     * @returns {Number}
     * @example
     * // get inner radius
     * var innerRadius = ring.innerRadius();
     *
     * // set inner radius
     * ring.innerRadius(20);
     */
    Konva.Factory.addGetter(Konva.Ring, 'outerRadius', 0);
    Konva.Factory.addOverloadedGetterSetter(Konva.Ring, 'outerRadius');

    /**
     * get/set outerRadius
     * @name outerRadius
     * @method
     * @memberof Konva.Ring.prototype
     * @param {Number} outerRadius
     * @returns {Number}
     * @example
     * // get outer radius
     * var outerRadius = ring.outerRadius();
     *
     * // set outer radius
     * ring.outerRadius(20);
     */

    Konva.Collection.mapMethods(Konva.Ring);
})();

(function() {
    'use strict';
    /**
     * Wedge constructor
     * @constructor
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.angle in degrees
     * @param {Number} config.radius
     * @param {Boolean} [config.clockwise]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * // draw a wedge that's pointing downwards
     * var wedge = new Konva.Wedge({
     *   radius: 40,
     *   fill: 'red',
     *   stroke: 'black'
     *   strokeWidth: 5,
     *   angleDeg: 60,
     *   rotationDeg: -120
     * });
     */
    Konva.Wedge = function(config) {
        this.___init(config);
    };

    Konva.Wedge.prototype = {
        _centroid: true,
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'Wedge';
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            context.beginPath();
            context.arc(0, 0, this.getRadius(), 0, Konva.getAngle(this.getAngle()), this.getClockwise());
            context.lineTo(0, 0);
            context.closePath();
            context.fillStrokeShape(this);
        },
        // implements Shape.prototype.getWidth()
        getWidth: function() {
            return this.getRadius() * 2;
        },
        // implements Shape.prototype.getHeight()
        getHeight: function() {
            return this.getRadius() * 2;
        },
        // implements Shape.prototype.setWidth()
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            if (this.radius() !== width / 2) {
                this.setRadius(width / 2);
            }
        },
        // implements Shape.prototype.setHeight()
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            if (this.radius() !== height / 2) {
                this.setRadius(height / 2);
            }
        }
    };
    Konva.Util.extend(Konva.Wedge, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Wedge, 'radius', 0);

    /**
     * get/set radius
     * @name radius
     * @method
     * @memberof Konva.Wedge.prototype
     * @param {Number} radius
     * @returns {Number}
     * @example
     * // get radius
     * var radius = wedge.radius();
     *
     * // set radius
     * wedge.radius(10);
     */

    Konva.Factory.addGetterSetter(Konva.Wedge, 'angle', 0);

    /**
     * get/set angle in degrees
     * @name angle
     * @method
     * @memberof Konva.Wedge.prototype
     * @param {Number} angle
     * @returns {Number}
     * @example
     * // get angle
     * var angle = wedge.angle();
     *
     * // set angle
     * wedge.angle(20);
     */

    Konva.Factory.addGetterSetter(Konva.Wedge, 'clockwise', false);

    /**
     * get/set clockwise flag
     * @name clockwise
     * @method
     * @memberof Konva.Wedge.prototype
     * @param {Number} clockwise
     * @returns {Number}
     * @example
     * // get clockwise flag
     * var clockwise = wedge.clockwise();
     *
     * // draw wedge counter-clockwise
     * wedge.clockwise(false);
     *
     * // draw wedge clockwise
     * wedge.clockwise(true);
     */

    Konva.Factory.backCompat(Konva.Wedge, {
        angleDeg: 'angle',
        getAngleDeg: 'getAngle',
        setAngleDeg: 'setAngle'
    });

    Konva.Collection.mapMethods(Konva.Wedge);
})();

(function() {
    'use strict';
    /**
     * Arc constructor
     * @constructor
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.angle in degrees
     * @param {Number} config.innerRadius
     * @param {Number} config.outerRadius
     * @param {Boolean} [config.clockwise]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * // draw a Arc that's pointing downwards
     * var arc = new Konva.Arc({
     *   innerRadius: 40,
     *   outerRadius: 80,
     *   fill: 'red',
     *   stroke: 'black'
     *   strokeWidth: 5,
     *   angle: 60,
     *   rotationDeg: -120
     * });
     */
    Konva.Arc = function(config) {
        this.___init(config);
    };

    Konva.Arc.prototype = {
        _centroid: true,
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'Arc';
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            var angle = Konva.getAngle(this.angle()),
                clockwise = this.clockwise();

            context.beginPath();
            context.arc(0, 0, this.getOuterRadius(), 0, angle, clockwise);
            context.arc(0, 0, this.getInnerRadius(), angle, 0, !clockwise);
            context.closePath();
            context.fillStrokeShape(this);
        },
        // implements Shape.prototype.getWidth()
        getWidth: function() {
            return this.getOuterRadius() * 2;
        },
        // implements Shape.prototype.getHeight()
        getHeight: function() {
            return this.getOuterRadius() * 2;
        },
        // implements Shape.prototype.setWidth()
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            if (this.getOuterRadius() !== width / 2) {
                this.setOuterRadius(width / 2);
            }
        },
        // implements Shape.prototype.setHeight()
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            if (this.getOuterRadius() !== height / 2) {
                this.setOuterRadius(height / 2);
            }
        }
    };
    Konva.Util.extend(Konva.Arc, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Arc, 'innerRadius', 0);

    /**
     * get/set innerRadius
     * @name innerRadius
     * @method
     * @memberof Konva.Arc.prototype
     * @param {Number} innerRadius
     * @returns {Number}
     * @example
     * // get inner radius
     * var innerRadius = arc.innerRadius();
     *
     * // set inner radius
     * arc.innerRadius(20);
     */

    Konva.Factory.addGetterSetter(Konva.Arc, 'outerRadius', 0);

    /**
     * get/set outerRadius
     * @name outerRadius
     * @method
     * @memberof Konva.Arc.prototype
     * @param {Number} outerRadius
     * @returns {Number}
     * @example
     * // get outer radius
     * var outerRadius = arc.outerRadius();
     *
     * // set outer radius
     * arc.outerRadius(20);
     */

    Konva.Factory.addGetterSetter(Konva.Arc, 'angle', 0);

    /**
     * get/set angle in degrees
     * @name angle
     * @method
     * @memberof Konva.Arc.prototype
     * @param {Number} angle
     * @returns {Number}
     * @example
     * // get angle
     * var angle = arc.angle();
     *
     * // set angle
     * arc.angle(20);
     */

    Konva.Factory.addGetterSetter(Konva.Arc, 'clockwise', false);

    /**
     * get/set clockwise flag
     * @name clockwise
     * @method
     * @memberof Konva.Arc.prototype
     * @param {Boolean} clockwise
     * @returns {Boolean}
     * @example
     * // get clockwise flag
     * var clockwise = arc.clockwise();
     *
     * // draw arc counter-clockwise
     * arc.clockwise(false);
     *
     * // draw arc clockwise
     * arc.clockwise(true);
     */

    Konva.Collection.mapMethods(Konva.Arc);
})();

(function() {
    'use strict';
    // CONSTANTS
    var IMAGE = 'Image';

    /**
     * Image constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Image} config.image
     * @param {Object} [config.crop]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var imageObj = new Image();
     * imageObj.onload = function() {
     *   var image = new Konva.Image({
     *     x: 200,
     *     y: 50,
     *     image: imageObj,
     *     width: 100,
     *     height: 100
     *   });
     * };
     * imageObj.src = '/path/to/image.jpg'
     */
    Konva.Image = function(config) {
        this.___init(config);
    };

    Konva.Image.prototype = {
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = IMAGE;
            this.sceneFunc(this._sceneFunc);
            this.hitFunc(this._hitFunc);
        },
        _useBufferCanvas: function() {
            return (this.hasShadow() || this.getAbsoluteOpacity() !== 1) && this.hasStroke() && this.getStage();
        },
        _sceneFunc: function(context) {
            var width = this.getWidth(),
                height = this.getHeight(),
                image = this.getImage(),
                cropWidth, cropHeight, params;

            if (image) {
                cropWidth = this.getCropWidth();
                cropHeight = this.getCropHeight();
                if (cropWidth && cropHeight) {
                    params = [image, this.getCropX(), this.getCropY(), cropWidth, cropHeight, 0, 0, width, height];
                } else {
                    params = [image, 0, 0, width, height];
                }
            }

            if (this.hasFill() || this.hasStroke()) {
                context.beginPath();
                context.rect(0, 0, width, height);
                context.closePath();
                context.fillStrokeShape(this);
            }

            if (image) {
                context.drawImage.apply(context, params);
            }
        },
        _hitFunc: function(context) {
            var width = this.getWidth(),
                height = this.getHeight();

            context.beginPath();
            context.rect(0, 0, width, height);
            context.closePath();
            context.fillStrokeShape(this);
        },
        getWidth: function() {
            var image = this.getImage();
            return this.attrs.width || (image ? image.width : 0);
        },
        getHeight: function() {
            var image = this.getImage();
            return this.attrs.height || (image ? image.height : 0);
        }
    };
    Konva.Util.extend(Konva.Image, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Image, 'image');

    /**
     * set image
     * @name setImage
     * @method
     * @memberof Konva.Image.prototype
     * @param {Image} image
     */

    /**
     * get image
     * @name getImage
     * @method
     * @memberof Konva.Image.prototype
     * @returns {Image}
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Image, 'crop', ['x', 'y', 'width', 'height']);
    /**
     * get/set crop
     * @method
     * @name crop
     * @memberof Konva.Image.prototype
     * @param {Object} crop
     * @param {Number} crop.x
     * @param {Number} crop.y
     * @param {Number} crop.width
     * @param {Number} crop.height
     * @returns {Object}
     * @example
     * // get crop
     * var crop = image.crop();
     *
     * // set crop
     * image.crop({
     *   x: 20,
     *   y: 20,
     *   width: 20,
     *   height: 20
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Image, 'cropX', 0);
    /**
     * get/set crop x
     * @method
     * @name cropX
     * @memberof Konva.Image.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get crop x
     * var cropX = image.cropX();
     *
     * // set crop x
     * image.cropX(20);
     */

    Konva.Factory.addGetterSetter(Konva.Image, 'cropY', 0);
    /**
     * get/set crop y
     * @name cropY
     * @method
     * @memberof Konva.Image.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get crop y
     * var cropY = image.cropY();
     *
     * // set crop y
     * image.cropY(20);
     */

    Konva.Factory.addGetterSetter(Konva.Image, 'cropWidth', 0);
    /**
     * get/set crop width
     * @name cropWidth
     * @method
     * @memberof Konva.Image.prototype
     * @param {Number} width
     * @returns {Number}
     * @example
     * // get crop width
     * var cropWidth = image.cropWidth();
     *
     * // set crop width
     * image.cropWidth(20);
     */

    Konva.Factory.addGetterSetter(Konva.Image, 'cropHeight', 0);
    /**
     * get/set crop height
     * @name cropHeight
     * @method
     * @memberof Konva.Image.prototype
     * @param {Number} height
     * @returns {Number}
     * @example
     * // get crop height
     * var cropHeight = image.cropHeight();
     *
     * // set crop height
     * image.cropHeight(20);
     */

    Konva.Collection.mapMethods(Konva.Image);

    /**
     * load image from given url and create `Konva.Image` instance
     * @method
     * @memberof Konva.Image
     * @param {String} url image source
     * @param {Function} callback with Konva.Image instance as first argument
     * @example
     *  Konva.Image.fromURL(imageURL, function(image){
     *    // image is Konva.Image instance
     *    layer.add(image);
     *    layer.draw();
     *  });
     */
    Konva.Image.fromURL = function(url, callback) {
        var img = new Image();
        img.onload = function() {
          var image = new Konva.Image({
            image: img
          });
          callback(image);
        };
        img.src = url;
    };
})();

/*eslint-disable max-depth */
(function() {
    'use strict';
    // constants
    var AUTO = 'auto',
        //CANVAS = 'canvas',
        CENTER = 'center',
        CHANGE_KONVA = 'Change.konva',
        CONTEXT_2D = '2d',
        DASH = '-',
        EMPTY_STRING = '',
        LEFT = 'left',
        TEXT = 'text',
        TEXT_UPPER = 'Text',
        MIDDLE = 'middle',
        NORMAL = 'normal',
        PX_SPACE = 'px ',
        SPACE = ' ',
        RIGHT = 'right',
        WORD = 'word',
        CHAR = 'char',
        NONE = 'none',
        ATTR_CHANGE_LIST = ['fontFamily', 'fontSize', 'fontStyle', 'fontVariant', 'padding', 'align', 'lineHeight', 'text', 'width', 'height', 'wrap'],

        // cached variables
        attrChangeListLen = ATTR_CHANGE_LIST.length,
        dummyContext = Konva.Util.createCanvasElement().getContext(CONTEXT_2D);

    /**
     * Text constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {String} [config.fontFamily] default is Arial
     * @param {Number} [config.fontSize] in pixels.  Default is 12
     * @param {String} [config.fontStyle] can be normal, bold, or italic.  Default is normal
     * @param {String} [config.fontVariant] can be normal or small-caps.  Default is normal
     * @param {String} config.text
     * @param {String} [config.align] can be left, center, or right
     * @param {Number} [config.padding]
     * @param {Number} [config.width] default is auto
     * @param {Number} [config.height] default is auto
     * @param {Number} [config.lineHeight] default is 1
     * @param {String} [config.wrap] can be word, char, or none. Default is word
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var text = new Konva.Text({
     *   x: 10,
     *   y: 15,
     *   text: 'Simple Text',
     *   fontSize: 30,
     *   fontFamily: 'Calibri',
     *   fill: 'green'
     * });
     */
    Konva.Text = function(config) {
        this.___init(config);
    };
    function _fillFunc(context) {
        context.fillText(this.partialText, 0, 0);
    }
    function _strokeFunc(context) {
        context.strokeText(this.partialText, 0, 0);
    }

    Konva.Text.prototype = {
        ___init: function(config) {
            config = config || {};

            // set default color to black
            if (!config.fillLinearGradientColorStops && !config.fillRadialGradientColorStops) {
                config.fill = config.fill || 'black';
            }

            if (config.width === undefined) {
                config.width = AUTO;
            }
            if (config.height === undefined) {
                config.height = AUTO;
            }

            // call super constructor
            Konva.Shape.call(this, config);

            this._fillFunc = _fillFunc;
            this._strokeFunc = _strokeFunc;
            this.className = TEXT_UPPER;

            // update text data for certain attr changes
            for(var n = 0; n < attrChangeListLen; n++) {
                this.on(ATTR_CHANGE_LIST[n] + CHANGE_KONVA, this._setTextData);
            }

            this._setTextData();
            this.sceneFunc(this._sceneFunc);
            this.hitFunc(this._hitFunc);
        },
        _sceneFunc: function(context) {
            var p = this.getPadding(),
                textHeight = this.getTextHeight(),
                lineHeightPx = this.getLineHeight() * textHeight,
                textArr = this.textArr,
                textArrLen = textArr.length,
                totalWidth = this.getWidth(),
                n;

            context.setAttr('font', this._getContextFont());

            context.setAttr('textBaseline', MIDDLE);
            context.setAttr('textAlign', LEFT);
            context.save();
            if (p) {
                context.translate(p, 0);
                context.translate(0, p + textHeight / 2);
            } else {
                context.translate(0, textHeight / 2);
            }


            // draw text lines
            for(n = 0; n < textArrLen; n++) {
                var obj = textArr[n],
                    text = obj.text,
                    width = obj.width;

                // horizontal alignment
                context.save();
                if(this.getAlign() === RIGHT) {
                    context.translate(totalWidth - width - p * 2, 0);
                }
                else if(this.getAlign() === CENTER) {
                    context.translate((totalWidth - width - p * 2) / 2, 0);
                }

                this.partialText = text;

                context.fillStrokeShape(this);
                context.restore();
                context.translate(0, lineHeightPx);
            }
            context.restore();
        },
        _hitFunc: function(context) {
            var width = this.getWidth(),
                height = this.getHeight();

            context.beginPath();
            context.rect(0, 0, width, height);
            context.closePath();
            context.fillStrokeShape(this);
        },
        setText: function(text) {
            var str = Konva.Util._isString(text) ? text : text.toString();
            this._setAttr(TEXT, str);
            return this;
        },
        /**
         * get width of text area, which includes padding
         * @method
         * @memberof Konva.Text.prototype
         * @returns {Number}
         */
        getWidth: function() {
            return this.attrs.width === AUTO ? this.getTextWidth() + this.getPadding() * 2 : this.attrs.width;
        },
        /**
         * get the height of the text area, which takes into account multi-line text, line heights, and padding
         * @method
         * @memberof Konva.Text.prototype
         * @returns {Number}
         */
        getHeight: function() {
            return this.attrs.height === AUTO ? (this.getTextHeight() * this.textArr.length * this.getLineHeight()) + this.getPadding() * 2 : this.attrs.height;
        },
        /**
         * get text width
         * @method
         * @memberof Konva.Text.prototype
         * @returns {Number}
         */
        getTextWidth: function() {
            return this.textWidth;
        },
        /**
         * get text height
         * @method
         * @memberof Konva.Text.prototype
         * @returns {Number}
         */
        getTextHeight: function() {
            return this.textHeight;
        },
        _getTextSize: function(text) {
            var _context = dummyContext,
                fontSize = this.getFontSize(),
                metrics;

            _context.save();
            _context.font = this._getContextFont();

            metrics = _context.measureText(text);
            _context.restore();
            return {
                width: metrics.width,
                height: parseInt(fontSize, 10)
            };
        },
        _getContextFont: function() {
            return this.getFontStyle() + SPACE + this.getFontVariant() + SPACE + this.getFontSize() + PX_SPACE + this.getFontFamily();
        },
        _addTextLine: function (line, width) {
            return this.textArr.push({text: line, width: width});
        },
        _getTextWidth: function (text) {
            return dummyContext.measureText(text).width;
        },
        _setTextData: function () {
            var lines = this.getText().split('\n'),
                fontSize = +this.getFontSize(),
                textWidth = 0,
                lineHeightPx = this.getLineHeight() * fontSize,
                width = this.attrs.width,
                height = this.attrs.height,
                fixedWidth = width !== AUTO,
                fixedHeight = height !== AUTO,
                padding = this.getPadding(),
                maxWidth = width - padding * 2,
                maxHeightPx = height - padding * 2,
                currentHeightPx = 0,
                wrap = this.getWrap(),
                shouldWrap = wrap !== NONE,
                wrapAtWord = wrap !== CHAR && shouldWrap;

            this.textArr = [];
            dummyContext.save();
            dummyContext.font = this._getContextFont();
            for (var i = 0, max = lines.length; i < max; ++i) {
                var line = lines[i],
                    lineWidth = this._getTextWidth(line);
                if (fixedWidth && lineWidth > maxWidth) {
                    /*
                     * if width is fixed and line does not fit entirely
                     * break the line into multiple fitting lines
                     */
                    while (line.length > 0) {
                        /*
                         * use binary search to find the longest substring that
                         * that would fit in the specified width
                         */
                        var low = 0, high = line.length,
                            match = '', matchWidth = 0;
                        while (low < high) {
                            var mid = (low + high) >>> 1,
                                substr = line.slice(0, mid + 1),
                                substrWidth = this._getTextWidth(substr);
                            if (substrWidth <= maxWidth) {
                                low = mid + 1;
                                match = substr;
                                matchWidth = substrWidth;
                            } else {
                                high = mid;
                            }
                        }
                        /*
                         * 'low' is now the index of the substring end
                         * 'match' is the substring
                         * 'matchWidth' is the substring width in px
                         */
                        if (match) {
                            // a fitting substring was found
                            if (wrapAtWord) {
                                // try to find a space or dash where wrapping could be done
                                var wrapIndex = Math.max(match.lastIndexOf(SPACE),
                                                          match.lastIndexOf(DASH)) + 1;
                                if (wrapIndex > 0) {
                                    // re-cut the substring found at the space/dash position
                                    low = wrapIndex;
                                    match = match.slice(0, low);
                                    matchWidth = this._getTextWidth(match);
                                }
                            }
                            this._addTextLine(match, matchWidth);
                            textWidth = Math.max(textWidth, matchWidth);
                            currentHeightPx += lineHeightPx;
                            if (!shouldWrap ||
                                (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx)) {
                                /*
                                 * stop wrapping if wrapping is disabled or if adding
                                 * one more line would overflow the fixed height
                                 */
                                break;
                            }
                            line = line.slice(low);
                            if (line.length > 0) {
                                // Check if the remaining text would fit on one line
                                lineWidth = this._getTextWidth(line);
                                if (lineWidth <= maxWidth) {
                                    // if it does, add the line and break out of the loop
                                    this._addTextLine(line, lineWidth);
                                    currentHeightPx += lineHeightPx;
                                    textWidth = Math.max(textWidth, lineWidth);
                                    break;
                                }
                            }
                        } else {
                            // not even one character could fit in the element, abort
                            break;
                        }
                    }
                } else {
                    // element width is automatically adjusted to max line width
                    this._addTextLine(line, lineWidth);
                    currentHeightPx += lineHeightPx;
                    textWidth = Math.max(textWidth, lineWidth);
                }
                // if element height is fixed, abort if adding one more line would overflow
                if (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx) {
                    break;
                }
            }
            dummyContext.restore();
            this.textHeight = fontSize;
            this.textWidth = textWidth;
        }
    };
    Konva.Util.extend(Konva.Text, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Text, 'fontFamily', 'Arial');

    /**
     * get/set font family
     * @name fontFamily
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} fontFamily
     * @returns {String}
     * @example
     * // get font family
     * var fontFamily = text.fontFamily();
     *
     * // set font family
     * text.fontFamily('Arial');
     */

    Konva.Factory.addGetterSetter(Konva.Text, 'fontSize', 12);

    /**
     * get/set font size in pixels
     * @name fontSize
     * @method
     * @memberof Konva.Text.prototype
     * @param {Number} fontSize
     * @returns {Number}
     * @example
     * // get font size
     * var fontSize = text.fontSize();
     *
     * // set font size to 22px
     * text.fontSize(22);
     */

    Konva.Factory.addGetterSetter(Konva.Text, 'fontStyle', NORMAL);

    /**
     * set font style.  Can be 'normal', 'italic', or 'bold'.  'normal' is the default.
     * @name fontStyle
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} fontStyle
     * @returns {String}
     * @example
     * // get font style
     * var fontStyle = text.fontStyle();
     *
     * // set font style
     * text.fontStyle('bold');
     */

    Konva.Factory.addGetterSetter(Konva.Text, 'fontVariant', NORMAL);

    /**
     * set font variant.  Can be 'normal' or 'small-caps'.  'normal' is the default.
     * @name fontVariant
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} fontVariant
     * @returns {String}
     * @example
     * // get font variant
     * var fontVariant = text.fontVariant();
     *
     * // set font variant
     * text.fontVariant('small-caps');
     */

    Konva.Factory.addGetterSetter(Konva.Text, 'padding', 0);

    /**
     * set padding
     * @name padding
     * @method
     * @memberof Konva.Text.prototype
     * @param {Number} padding
     * @returns {Number}
     * @example
     * // get padding
     * var padding = text.padding();
     *
     * // set padding to 10 pixels
     * text.padding(10);
     */

    Konva.Factory.addGetterSetter(Konva.Text, 'align', LEFT);

    /**
     * get/set horizontal align of text.  Can be 'left', 'center', or 'right'
     * @name align
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} align
     * @returns {String}
     * @example
     * // get text align
     * var align = text.align();
     *
     * // center text
     * text.align('center');
     *
     * // align text to right
     * text.align('right');
     */

    Konva.Factory.addGetterSetter(Konva.Text, 'lineHeight', 1);

    /**
     * get/set line height.  The default is 1.
     * @name lineHeight
     * @method
     * @memberof Konva.Text.prototype
     * @param {Number} lineHeight
     * @returns {Number}
     * @example
     * // get line height
     * var lineHeight = text.lineHeight();
     *
     * // set the line height
     * text.lineHeight(2);
     */

    Konva.Factory.addGetterSetter(Konva.Text, 'wrap', WORD);

    /**
     * get/set wrap.  Can be word, char, or none. Default is word.
     * @name wrap
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} wrap
     * @returns {String}
     * @example
     * // get wrap
     * var wrap = text.wrap();
     *
     * // set wrap
     * text.wrap('word');
     */

    Konva.Factory.addGetter(Konva.Text, 'text', EMPTY_STRING);
    Konva.Factory.addOverloadedGetterSetter(Konva.Text, 'text');

    /**
     * get/set text
     * @name getText
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} text
     * @returns {String}
     * @example
     * // get text
     * var text = text.text();
     *
     * // set text
     * text.text('Hello world!');
     */

    Konva.Collection.mapMethods(Konva.Text);
})();

(function () {
    'use strict';
    /**
     * Line constructor.&nbsp; Lines are defined by an array of points and
     *  a tension
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Array} config.points
     * @param {Number} [config.tension] Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
     *   The default is 0
     * @param {Boolean} [config.closed] defines whether or not the line shape is closed, creating a polygon or blob
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var line = new Konva.Line({
     *   x: 100,
     *   y: 50,
     *   points: [73, 70, 340, 23, 450, 60, 500, 20],
     *   stroke: 'red',
     *   tension: 1
     * });
     */
    Konva.Line = function (config) {
        this.___init(config);
    };

    Konva.Line.prototype = {
        ___init: function (config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'Line';

            this.on('pointsChange.konva tensionChange.konva closedChange.konva', function () {
                this._clearCache('tensionPoints');
            });

            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function (context) {
            var points = this.getPoints(),
                length = points.length,
                tension = this.getTension(),
                closed = this.getClosed(),
                tp, len, n;

            if (!length) {
                return;
            }

            context.beginPath();
            context.moveTo(points[0], points[1]);

            // tension
            if (tension !== 0 && length > 4) {
                tp = this.getTensionPoints();
                len = tp.length;
                n = closed ? 0 : 4;

                if (!closed) {
                    context.quadraticCurveTo(tp[0], tp[1], tp[2], tp[3]);
                }

                while (n < len - 2) {
                    context.bezierCurveTo(tp[n++], tp[n++], tp[n++], tp[n++], tp[n++], tp[n++]);
                }

                if (!closed) {
                    context.quadraticCurveTo(tp[len - 2], tp[len - 1], points[length - 2], points[length - 1]);
                }
            }
            // no tension
            else {
                for (n = 2; n < length; n += 2) {
                    context.lineTo(points[n], points[n + 1]);
                }
            }

            // closed e.g. polygons and blobs
            if (closed) {
                context.closePath();
                context.fillStrokeShape(this);
            }
            // open e.g. lines and splines
            else {
                context.strokeShape(this);
            }
        },
        getTensionPoints: function () {
            return this._getCache('tensionPoints', this._getTensionPoints);
        },
        _getTensionPoints: function () {
            if (this.getClosed()) {
                return this._getTensionPointsClosed();
            } else {
                return Konva.Util._expandPoints(this.getPoints(), this.getTension());
            }
        },
        _getTensionPointsClosed: function () {
            var p = this.getPoints(),
                len = p.length,
                tension = this.getTension(),
                util = Konva.Util,
                firstControlPoints = util._getControlPoints(
                    p[len - 2],
                    p[len - 1],
                    p[0],
                    p[1],
                    p[2],
                    p[3],
                    tension
                ),
                lastControlPoints = util._getControlPoints(
                    p[len - 4],
                    p[len - 3],
                    p[len - 2],
                    p[len - 1],
                    p[0],
                    p[1],
                    tension
                ),
                middle = Konva.Util._expandPoints(p, tension),
                tp = [
                    firstControlPoints[2],
                    firstControlPoints[3]
                ]
                .concat(middle)
                .concat([
                    lastControlPoints[0],
                    lastControlPoints[1],
                    p[len - 2],
                    p[len - 1],
                    lastControlPoints[2],
                    lastControlPoints[3],
                    firstControlPoints[0],
                    firstControlPoints[1],
                    p[0],
                    p[1]
                ]);

            return tp;
        },
        getWidth: function () {
            return this.getSelfRect().width;
        },
        getHeight: function () {
            return this.getSelfRect().height;
        },
        // overload size detection
        getSelfRect: function () {
            var points;
            if (this.getTension() !== 0) {
                points = this._getTensionPoints();
            } else {
                points = this.getPoints();
            }
            var minX = points[0];
            var maxX = points[0];
            var minY = points[1];
            var maxY = points[1];
            var x, y;
            for (var i = 0; i < points.length / 2; i++) {
                x = points[i * 2];
                y = points[i * 2 + 1];
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }
            return {
                x: Math.round(minX),
                y: Math.round(minY),
                width: Math.round(maxX - minX),
                height: Math.round(maxY - minY)
            };
        }
    };
    Konva.Util.extend(Konva.Line, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Line, 'closed', false);

    /**
     * get/set closed flag.  The default is false
     * @name closed
     * @method
     * @memberof Konva.Line.prototype
     * @param {Boolean} closed
     * @returns {Boolean}
     * @example
     * // get closed flag
     * var closed = line.closed();
     *
     * // close the shape
     * line.closed(true);
     *
     * // open the shape
     * line.closed(false);
     */

    Konva.Factory.addGetterSetter(Konva.Line, 'tension', 0);

    /**
     * get/set tension
     * @name tension
     * @method
     * @memberof Konva.Line.prototype
     * @param {Number} Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
     *   The default is 0
     * @returns {Number}
     * @example
     * // get tension
     * var tension = line.tension();
     *
     * // set tension
     * line.tension(3);
     */

    Konva.Factory.addGetterSetter(Konva.Line, 'points', []);
    /**
     * get/set points array
     * @name points
     * @method
     * @memberof Konva.Line.prototype
     * @param {Array} points
     * @returns {Array}
     * @example
     * // get points
     * var points = line.points();
     *
     * // set points
     * line.points([10, 20, 30, 40, 50, 60]);
     *
     * // push a new point
     * line.points(line.points().concat([70, 80]));
     */

    Konva.Collection.mapMethods(Konva.Line);
})();

(function() {
    'use strict';
    /**
     * Sprite constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {String} config.animation animation key
     * @param {Object} config.animations animation map
     * @param {Integer} [config.frameIndex] animation frame index
     * @param {Image} config.image image object
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var imageObj = new Image();
     * imageObj.onload = function() {
     *   var sprite = new Konva.Sprite({
     *     x: 200,
     *     y: 100,
     *     image: imageObj,
     *     animation: 'standing',
     *     animations: {
     *       standing: [
     *         // x, y, width, height (6 frames)
     *         0, 0, 49, 109,
     *         52, 0, 49, 109,
     *         105, 0, 49, 109,
     *         158, 0, 49, 109,
     *         210, 0, 49, 109,
     *         262, 0, 49, 109
     *       ],
     *       kicking: [
     *         // x, y, width, height (6 frames)
     *         0, 109, 45, 98,
     *         45, 109, 45, 98,
     *         95, 109, 63, 98,
     *         156, 109, 70, 98,
     *         229, 109, 60, 98,
     *         287, 109, 41, 98
     *       ]
     *     },
     *     frameRate: 7,
     *     frameIndex: 0
     *   });
     * };
     * imageObj.src = '/path/to/image.jpg'
     */
    Konva.Sprite = function(config) {
        this.___init(config);
    };

    Konva.Sprite.prototype = {
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'Sprite';

            this._updated = true;
            var that = this;
            this.anim = new Konva.Animation(function() {
                // if we don't need to redraw layer we should return false
                var updated = that._updated;
                that._updated = false;
                return updated;
            });
            this.on('animationChange.konva', function() {
                // reset index when animation changes
                this.frameIndex(0);
            });
            this.on('frameIndexChange.konva', function() {
                this._updated = true;
            });
            // smooth change for frameRate
            this.on('frameRateChange.konva', function() {
                if (!this.anim.isRunning()) {
                    return;
                }
                clearInterval(this.interval);
                this._setInterval();
            });

            this.sceneFunc(this._sceneFunc);
            this.hitFunc(this._hitFunc);
        },
        _sceneFunc: function(context) {
            var anim = this.getAnimation(),
                index = this.frameIndex(),
                ix4 = index * 4,
                set = this.getAnimations()[anim],
                offsets = this.frameOffsets(),
                x = set[ix4 + 0],
                y = set[ix4 + 1],
                width = set[ix4 + 2],
                height = set[ix4 + 3],
                image = this.getImage();

            if (this.hasFill() || this.hasStroke()) {
                context.beginPath();
                context.rect(0, 0, width, height);
                context.closePath();
                context.fillStrokeShape(this);
            }

            if(image) {
                if (offsets) {
                    var offset = offsets[anim],
                    ix2 = index * 2;
                    context.drawImage(image, x, y, width, height, offset[ix2 + 0], offset[ix2 + 1], width, height);
                } else {
                    context.drawImage(image, x, y, width, height, 0, 0, width, height);
                }
            }
        },
        _hitFunc: function(context) {
            var anim = this.getAnimation(),
                index = this.frameIndex(),
                ix4 = index * 4,
                set = this.getAnimations()[anim],
                offsets = this.frameOffsets(),
                width = set[ix4 + 2],
                height = set[ix4 + 3];

            context.beginPath();
            if (offsets) {
                var offset = offsets[anim];
                var ix2 = index * 2;
                context.rect(offset[ix2 + 0], offset[ix2 + 1], width, height);
            } else {
                context.rect(0, 0, width, height);
            }
            context.closePath();
            context.fillShape(this);
        },
        _useBufferCanvas: function() {
            return (this.hasShadow() || this.getAbsoluteOpacity() !== 1) && this.hasStroke();
        },
        _setInterval: function() {
            var that = this;
            this.interval = setInterval(function() {
                that._updateIndex();
            }, 1000 / this.getFrameRate());
        },
        /**
         * start sprite animation
         * @method
         * @memberof Konva.Sprite.prototype
         */
        start: function() {
            var layer = this.getLayer();

            /*
             * animation object has no executable function because
             *  the updates are done with a fixed FPS with the setInterval
             *  below.  The anim object only needs the layer reference for
             *  redraw
             */
            this.anim.setLayers(layer);
            this._setInterval();
            this.anim.start();
        },
        /**
         * stop sprite animation
         * @method
         * @memberof Konva.Sprite.prototype
         */
        stop: function() {
            this.anim.stop();
            clearInterval(this.interval);
        },
        /**
         * determine if animation of sprite is running or not.  returns true or false
         * @method
         * @memberof Konva.Animation.prototype
         * @returns {Boolean}
         */
        isRunning: function() {
            return this.anim.isRunning();
        },
        _updateIndex: function() {
            var index = this.frameIndex(),
                animation = this.getAnimation(),
                animations = this.getAnimations(),
                anim = animations[animation],
                len = anim.length / 4;

            if(index < len - 1) {
                this.frameIndex(index + 1);
            }
            else {
                this.frameIndex(0);
            }
        }
    };
    Konva.Util.extend(Konva.Sprite, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Sprite, 'animation');

    /**
     * get/set animation key
     * @name animation
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {String} anim animation key
     * @returns {String}
     * @example
     * // get animation key
     * var animation = sprite.animation();
     *
     * // set animation key
     * sprite.animation('kicking');
     */

    Konva.Factory.addGetterSetter(Konva.Sprite, 'animations');

    /**
     * get/set animations map
     * @name animations
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {Object} animations
     * @returns {Object}
     * @example
     * // get animations map
     * var animations = sprite.animations();
     *
     * // set animations map
     * sprite.animations({
     *   standing: [
     *     // x, y, width, height (6 frames)
     *     0, 0, 49, 109,
     *     52, 0, 49, 109,
     *     105, 0, 49, 109,
     *     158, 0, 49, 109,
     *     210, 0, 49, 109,
     *     262, 0, 49, 109
     *   ],
     *   kicking: [
     *     // x, y, width, height (6 frames)
     *     0, 109, 45, 98,
     *     45, 109, 45, 98,
     *     95, 109, 63, 98,
     *     156, 109, 70, 98,
     *     229, 109, 60, 98,
     *     287, 109, 41, 98
     *   ]
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Sprite, 'frameOffsets');

    /**
    * get/set offsets map
    * @name offsets
    * @method
    * @memberof Konva.Sprite.prototype
    * @param {Object} offsets
    * @returns {Object}
    * @example
    * // get offsets map
    * var offsets = sprite.offsets();
    *
    * // set offsets map
    * sprite.offsets({
    *   standing: [
    *     // x, y (6 frames)
    *     0, 0,
    *     0, 0,
    *     5, 0,
    *     0, 0,
    *     0, 3,
    *     2, 0
    *   ],
    *   kicking: [
    *     // x, y (6 frames)
    *     0, 5,
    *     5, 0,
    *     10, 0,
    *     0, 0,
    *     2, 1,
    *     0, 0
    *   ]
    * });
    */

    Konva.Factory.addGetterSetter(Konva.Sprite, 'image');

    /**
     * get/set image
     * @name image
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {Image} image
     * @returns {Image}
     * @example
     * // get image
     * var image = sprite.image();
     *
     * // set image
     * sprite.image(imageObj);
     */

    Konva.Factory.addGetterSetter(Konva.Sprite, 'frameIndex', 0);

    /**
     * set/set animation frame index
     * @name frameIndex
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {Integer} frameIndex
     * @returns {Integer}
     * @example
     * // get animation frame index
     * var frameIndex = sprite.frameIndex();
     *
     * // set animation frame index
     * sprite.frameIndex(3);
     */

    Konva.Factory.addGetterSetter(Konva.Sprite, 'frameRate', 17);

    /**
     * get/set frame rate in frames per second.  Increase this number to make the sprite
     *  animation run faster, and decrease the number to make the sprite animation run slower
     *  The default is 17 frames per second
     * @name frameRate
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {Integer} frameRate
     * @returns {Integer}
     * @example
     * // get frame rate
     * var frameRate = sprite.frameRate();
     *
     * // set frame rate to 2 frames per second
     * sprite.frameRate(2);
     */

    Konva.Factory.backCompat(Konva.Sprite, {
        index: 'frameIndex',
        getIndex: 'getFrameIndex',
        setIndex: 'setFrameIndex'
    });

    Konva.Collection.mapMethods(Konva.Sprite);
})();

/*eslint-disable  no-shadow, max-len, max-depth */
(function () {
    'use strict';
    /**
     * Path constructor.
     * @author Jason Follas
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {String} config.data SVG data string
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var path = new Konva.Path({
     *   x: 240,
     *   y: 40,
     *   data: 'M12.582,9.551C3.251,16.237,0.921,29.021,7.08,38.564l-2.36,1.689l4.893,2.262l4.893,2.262l-0.568-5.36l-0.567-5.359l-2.365,1.694c-4.657-7.375-2.83-17.185,4.352-22.33c7.451-5.338,17.817-3.625,23.156,3.824c5.337,7.449,3.625,17.813-3.821,23.152l2.857,3.988c9.617-6.893,11.827-20.277,4.935-29.896C35.591,4.87,22.204,2.658,12.582,9.551z',
     *   fill: 'green',
     *   scale: 2
     * });
     */
    Konva.Path = function (config) {
        this.___init(config);
    };

    Konva.Path.prototype = {
        ___init: function (config) {
            this.dataArray = [];
            var that = this;

            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'Path';

            this.dataArray = Konva.Path.parsePathData(this.getData());
            this.on('dataChange.konva', function () {
                that.dataArray = Konva.Path.parsePathData(this.getData());
            });

            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            var ca = this.dataArray,
                closedPath = false;

            // context position
            context.beginPath();
            for (var n = 0; n < ca.length; n++) {
                var c = ca[n].command;
                var p = ca[n].points;
                switch (c) {
                    case 'L':
                        context.lineTo(p[0], p[1]);
                        break;
                    case 'M':
                        context.moveTo(p[0], p[1]);
                        break;
                    case 'C':
                        context.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
                        break;
                    case 'Q':
                        context.quadraticCurveTo(p[0], p[1], p[2], p[3]);
                        break;
                    case 'A':
                        var cx = p[0], cy = p[1], rx = p[2], ry = p[3], theta = p[4], dTheta = p[5], psi = p[6], fs = p[7];

                        var r = (rx > ry) ? rx : ry;
                        var scaleX = (rx > ry) ? 1 : rx / ry;
                        var scaleY = (rx > ry) ? ry / rx : 1;

                        context.translate(cx, cy);
                        context.rotate(psi);
                        context.scale(scaleX, scaleY);
                        context.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
                        context.scale(1 / scaleX, 1 / scaleY);
                        context.rotate(-psi);
                        context.translate(-cx, -cy);

                        break;
                    case 'z':
                        context.closePath();
                        closedPath = true;
                        break;
                }
            }

            if (closedPath) {
                context.fillStrokeShape(this);
            }
            else {
                context.strokeShape(this);
            }
        },
        getSelfRect: function() {
            var points = [];
            this.dataArray.forEach(function(data) {
                points = points.concat(data.points);
            });
            var minX = points[0];
            var maxX = points[0];
            var minY = points[0];
            var maxY = points[0];
            var x, y;
            for (var i = 0; i < points.length / 2; i++) {
                x = points[i * 2]; y = points[i * 2 + 1];
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }
            return {
                x: Math.round(minX),
                y: Math.round(minY),
                width: Math.round(maxX - minX),
                height: Math.round(maxY - minY)
            };
        }
    };
    Konva.Util.extend(Konva.Path, Konva.Shape);

    Konva.Path.getLineLength = function(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    };
    Konva.Path.getPointOnLine = function(dist, P1x, P1y, P2x, P2y, fromX, fromY) {
        if(fromX === undefined) {
            fromX = P1x;
        }
        if(fromY === undefined) {
            fromY = P1y;
        }

        var m = (P2y - P1y) / ((P2x - P1x) + 0.00000001);
        var run = Math.sqrt(dist * dist / (1 + m * m));
        if(P2x < P1x) {
            run *= -1;
        }
        var rise = m * run;
        var pt;

        if (P2x === P1x) { // vertical line
            pt = {
                x: fromX,
                y: fromY + rise
            };
        } else if((fromY - P1y) / ((fromX - P1x) + 0.00000001) === m) {
            pt = {
                x: fromX + run,
                y: fromY + rise
            };
        }
        else {
            var ix, iy;

            var len = this.getLineLength(P1x, P1y, P2x, P2y);
            if(len < 0.00000001) {
                return undefined;
            }
            var u = (((fromX - P1x) * (P2x - P1x)) + ((fromY - P1y) * (P2y - P1y)));
            u = u / (len * len);
            ix = P1x + u * (P2x - P1x);
            iy = P1y + u * (P2y - P1y);

            var pRise = this.getLineLength(fromX, fromY, ix, iy);
            var pRun = Math.sqrt(dist * dist - pRise * pRise);
            run = Math.sqrt(pRun * pRun / (1 + m * m));
            if(P2x < P1x) {
                run *= -1;
            }
            rise = m * run;
            pt = {
                x: ix + run,
                y: iy + rise
            };
        }

        return pt;
    };

    Konva.Path.getPointOnCubicBezier = function(pct, P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y) {
        function CB1(t) {
            return t * t * t;
        }
        function CB2(t) {
            return 3 * t * t * (1 - t);
        }
        function CB3(t) {
            return 3 * t * (1 - t) * (1 - t);
        }
        function CB4(t) {
            return (1 - t) * (1 - t) * (1 - t);
        }
        var x = P4x * CB1(pct) + P3x * CB2(pct) + P2x * CB3(pct) + P1x * CB4(pct);
        var y = P4y * CB1(pct) + P3y * CB2(pct) + P2y * CB3(pct) + P1y * CB4(pct);

        return {
            x: x,
            y: y
        };
    };
    Konva.Path.getPointOnQuadraticBezier = function(pct, P1x, P1y, P2x, P2y, P3x, P3y) {
        function QB1(t) {
            return t * t;
        }
        function QB2(t) {
            return 2 * t * (1 - t);
        }
        function QB3(t) {
            return (1 - t) * (1 - t);
        }
        var x = P3x * QB1(pct) + P2x * QB2(pct) + P1x * QB3(pct);
        var y = P3y * QB1(pct) + P2y * QB2(pct) + P1y * QB3(pct);

        return {
            x: x,
            y: y
        };
    };
    Konva.Path.getPointOnEllipticalArc = function(cx, cy, rx, ry, theta, psi) {
        var cosPsi = Math.cos(psi), sinPsi = Math.sin(psi);
        var pt = {
            x: rx * Math.cos(theta),
            y: ry * Math.sin(theta)
        };
        return {
            x: cx + (pt.x * cosPsi - pt.y * sinPsi),
            y: cy + (pt.x * sinPsi + pt.y * cosPsi)
        };
    };
    /*
     * get parsed data array from the data
     *  string.  V, v, H, h, and l data are converted to
     *  L data for the purpose of high performance Path
     *  rendering
     */
    Konva.Path.parsePathData = function(data) {
        // Path Data Segment must begin with a moveTo
        //m (x y)+  Relative moveTo (subsequent points are treated as lineTo)
        //M (x y)+  Absolute moveTo (subsequent points are treated as lineTo)
        //l (x y)+  Relative lineTo
        //L (x y)+  Absolute LineTo
        //h (x)+    Relative horizontal lineTo
        //H (x)+    Absolute horizontal lineTo
        //v (y)+    Relative vertical lineTo
        //V (y)+    Absolute vertical lineTo
        //z (closepath)
        //Z (closepath)
        //c (x1 y1 x2 y2 x y)+ Relative Bezier curve
        //C (x1 y1 x2 y2 x y)+ Absolute Bezier curve
        //q (x1 y1 x y)+       Relative Quadratic Bezier
        //Q (x1 y1 x y)+       Absolute Quadratic Bezier
        //t (x y)+    Shorthand/Smooth Relative Quadratic Bezier
        //T (x y)+    Shorthand/Smooth Absolute Quadratic Bezier
        //s (x2 y2 x y)+       Shorthand/Smooth Relative Bezier curve
        //S (x2 y2 x y)+       Shorthand/Smooth Absolute Bezier curve
        //a (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+     Relative Elliptical Arc
        //A (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+  Absolute Elliptical Arc

        // return early if data is not defined
        if(!data) {
            return [];
        }

        // command string
        var cs = data;

        // command chars
        var cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];
        // convert white spaces to commas
        cs = cs.replace(new RegExp(' ', 'g'), ',');
        // create pipes so that we can split the data
        for(var n = 0; n < cc.length; n++) {
            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
        }
        // create array
        var arr = cs.split('|');
        var ca = [];
        // init context point
        var cpx = 0;
        var cpy = 0;
        for( n = 1; n < arr.length; n++) {
            var str = arr[n];
            var c = str.charAt(0);
            str = str.slice(1);
            // remove ,- for consistency
            str = str.replace(new RegExp(',-', 'g'), '-');
            // add commas so that it's easy to split
            str = str.replace(new RegExp('-', 'g'), ',-');
            str = str.replace(new RegExp('e,-', 'g'), 'e-');
            var p = str.split(',');
            if(p.length > 0 && p[0] === '') {
                p.shift();
            }
            // convert strings to floats
            for(var i = 0; i < p.length; i++) {
                p[i] = parseFloat(p[i]);
            }
            while(p.length > 0) {
                if(isNaN(p[0])) {// case for a trailing comma before next command
                    break;
                }

                var cmd = null;
                var points = [];
                var startX = cpx, startY = cpy;
                // Move var from within the switch to up here (jshint)
                var prevCmd, ctlPtx, ctlPty;     // Ss, Tt
                var rx, ry, psi, fa, fs, x1, y1; // Aa


                // convert l, H, h, V, and v to L
                switch (c) {

                    // Note: Keep the lineTo's above the moveTo's in this switch
                    case 'l':
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'L':
                        cpx = p.shift();
                        cpy = p.shift();
                        points.push(cpx, cpy);
                        break;

                    // Note: lineTo handlers need to be above this point
                    case 'm':
                        var dx = p.shift();
                        var dy = p.shift();
                        cpx += dx;
                        cpy += dy;
                        cmd = 'M';
                        // After closing the path move the current position
                        // to the the first point of the path (if any).
                        if(ca.length > 2 && ca[ca.length - 1].command === 'z'){
                            for(var idx = ca.length - 2; idx >= 0; idx--){
                                if(ca[idx].command === 'M'){
                                    cpx = ca[idx].points[0] + dx;
                                    cpy = ca[idx].points[1] + dy;
                                    break;
                                }
                            }
                        }
                        points.push(cpx, cpy);
                        c = 'l';
                        // subsequent points are treated as relative lineTo
                        break;
                    case 'M':
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'M';
                        points.push(cpx, cpy);
                        c = 'L';
                        // subsequent points are treated as absolute lineTo
                        break;

                    case 'h':
                        cpx += p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'H':
                        cpx = p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'v':
                        cpy += p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'V':
                        cpy = p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'C':
                        points.push(p.shift(), p.shift(), p.shift(), p.shift());
                        cpx = p.shift();
                        cpy = p.shift();
                        points.push(cpx, cpy);
                        break;
                    case 'c':
                        points.push(cpx + p.shift(), cpy + p.shift(), cpx + p.shift(), cpy + p.shift());
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'C';
                        points.push(cpx, cpy);
                        break;
                    case 'S':
                        ctlPtx = cpx;
                        ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if(prevCmd.command === 'C') {
                            ctlPtx = cpx + (cpx - prevCmd.points[2]);
                            ctlPty = cpy + (cpy - prevCmd.points[3]);
                        }
                        points.push(ctlPtx, ctlPty, p.shift(), p.shift());
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'C';
                        points.push(cpx, cpy);
                        break;
                    case 's':
                        ctlPtx = cpx;
                        ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if(prevCmd.command === 'C') {
                            ctlPtx = cpx + (cpx - prevCmd.points[2]);
                            ctlPty = cpy + (cpy - prevCmd.points[3]);
                        }
                        points.push(ctlPtx, ctlPty, cpx + p.shift(), cpy + p.shift());
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'C';
                        points.push(cpx, cpy);
                        break;
                    case 'Q':
                        points.push(p.shift(), p.shift());
                        cpx = p.shift();
                        cpy = p.shift();
                        points.push(cpx, cpy);
                        break;
                    case 'q':
                        points.push(cpx + p.shift(), cpy + p.shift());
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'Q';
                        points.push(cpx, cpy);
                        break;
                    case 'T':
                        ctlPtx = cpx;
                        ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if(prevCmd.command === 'Q') {
                            ctlPtx = cpx + (cpx - prevCmd.points[0]);
                            ctlPty = cpy + (cpy - prevCmd.points[1]);
                        }
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'Q';
                        points.push(ctlPtx, ctlPty, cpx, cpy);
                        break;
                    case 't':
                        ctlPtx = cpx;
                        ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if(prevCmd.command === 'Q') {
                            ctlPtx = cpx + (cpx - prevCmd.points[0]);
                            ctlPty = cpy + (cpy - prevCmd.points[1]);
                        }
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'Q';
                        points.push(ctlPtx, ctlPty, cpx, cpy);
                        break;
                    case 'A':
                        rx = p.shift();
                        ry = p.shift();
                        psi = p.shift();
                        fa = p.shift();
                        fs = p.shift();
                        x1 = cpx;
                        y1 = cpy;
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'A';
                        points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
                        break;
                    case 'a':
                        rx = p.shift();
                        ry = p.shift();
                        psi = p.shift();
                        fa = p.shift();
                        fs = p.shift();
                        x1 = cpx;
                        y1 = cpy; cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'A';
                        points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
                        break;
                }

                ca.push({
                    command: cmd || c,
                    points: points,
                    start: {
                        x: startX,
                        y: startY
                    },
                    pathLength: this.calcLength(startX, startY, cmd || c, points)
                });
            }

            if(c === 'z' || c === 'Z') {
                ca.push({
                    command: 'z',
                    points: [],
                    start: undefined,
                    pathLength: 0
                });
            }
        }

        return ca;
    };
    Konva.Path.calcLength = function(x, y, cmd, points) {
        var len, p1, p2, t;
        var path = Konva.Path;

        switch (cmd) {
            case 'L':
                return path.getLineLength(x, y, points[0], points[1]);
            case 'C':
                // Approximates by breaking curve into 100 line segments
                len = 0.0;
                p1 = path.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
                for( t = 0.01; t <= 1; t += 0.01) {
                    p2 = path.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
                    len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                    p1 = p2;
                }
                return len;
            case 'Q':
                // Approximates by breaking curve into 100 line segments
                len = 0.0;
                p1 = path.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);
                for( t = 0.01; t <= 1; t += 0.01) {
                    p2 = path.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);
                    len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                    p1 = p2;
                }
                return len;
            case 'A':
                // Approximates by breaking curve into line segments
                len = 0.0;
                var start = points[4];
                // 4 = theta
                var dTheta = points[5];
                // 5 = dTheta
                var end = points[4] + dTheta;
                var inc = Math.PI / 180.0;
                // 1 degree resolution
                if(Math.abs(start - end) < inc) {
                    inc = Math.abs(start - end);
                }
                // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi
                p1 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);
                if(dTheta < 0) {// clockwise
                    for( t = start - inc; t > end; t -= inc) {
                        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                        p1 = p2;
                    }
                }
                else {// counter-clockwise
                    for( t = start + inc; t < end; t += inc) {
                        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                        p1 = p2;
                    }
                }
                p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
                len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);

                return len;
        }

        return 0;
    };
    Konva.Path.convertEndpointToCenterParameterization = function(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg) {
        // Derived from: http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
        var psi = psiDeg * (Math.PI / 180.0);
        var xp = Math.cos(psi) * (x1 - x2) / 2.0 + Math.sin(psi) * (y1 - y2) / 2.0;
        var yp = -1 * Math.sin(psi) * (x1 - x2) / 2.0 + Math.cos(psi) * (y1 - y2) / 2.0;

        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);

        if(lambda > 1) {
            rx *= Math.sqrt(lambda);
            ry *= Math.sqrt(lambda);
        }

        var f = Math.sqrt((((rx * rx) * (ry * ry)) - ((rx * rx) * (yp * yp)) - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp) + (ry * ry) * (xp * xp)));

        if(fa === fs) {
            f *= -1;
        }
        if(isNaN(f)) {
            f = 0;
        }

        var cxp = f * rx * yp / ry;
        var cyp = f * -ry * xp / rx;

        var cx = (x1 + x2) / 2.0 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;
        var cy = (y1 + y2) / 2.0 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;

        var vMag = function(v) {
            return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
        };
        var vRatio = function(u, v) {
            return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
        };
        var vAngle = function(u, v) {
            return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
        };
        var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
        var u = [(xp - cxp) / rx, (yp - cyp) / ry];
        var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
        var dTheta = vAngle(u, v);

        if(vRatio(u, v) <= -1) {
            dTheta = Math.PI;
        }
        if(vRatio(u, v) >= 1) {
            dTheta = 0;
        }
        if(fs === 0 && dTheta > 0) {
            dTheta = dTheta - 2 * Math.PI;
        }
        if(fs === 1 && dTheta < 0) {
            dTheta = dTheta + 2 * Math.PI;
        }
        return [cx, cy, rx, ry, theta, dTheta, psi, fs];
    };
    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Path, 'data');

    /**
     * set SVG path data string.  This method
     *  also automatically parses the data string
     *  into a data array.  Currently supported SVG data:
     *  M, m, L, l, H, h, V, v, Q, q, T, t, C, c, S, s, A, a, Z, z
     * @name setData
     * @method
     * @memberof Konva.Path.prototype
     * @param {String} SVG path command string
     */

    /**
     * get SVG path data string
     * @name getData
     * @method
     * @memberof Konva.Path.prototype
     */

    Konva.Collection.mapMethods(Konva.Path);
})();

(function() {
    'use strict';
    var EMPTY_STRING = '',
        //CALIBRI = 'Calibri',
        NORMAL = 'normal';

    /**
     * Path constructor.
     * @author Jason Follas
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {String} [config.fontFamily] default is Calibri
     * @param {Number} [config.fontSize] default is 12
     * @param {String} [config.fontStyle] can be normal, bold, or italic.  Default is normal
     * @param {String} [config.fontVariant] can be normal or small-caps.  Default is normal
     * @param {String} config.text
     * @param {String} config.data SVG data string
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var textpath = new Konva.TextPath({
     *   x: 100,
     *   y: 50,
     *   fill: '#333',
     *   fontSize: '24',
     *   fontFamily: 'Arial',
     *   text: 'All the world\'s a stage, and all the men and women merely players.',
     *   data: 'M10,10 C0,0 10,150 100,100 S300,150 400,50'
     * });
     */
    Konva.TextPath = function(config) {
        this.___init(config);
    };

    function _fillFunc(context) {
        context.fillText(this.partialText, 0, 0);
    }
    function _strokeFunc(context) {
        context.strokeText(this.partialText, 0, 0);
    }

    Konva.TextPath.prototype = {
        ___init: function(config) {
            var that = this;
            this.dummyCanvas = Konva.Util.createCanvasElement();
            this.dataArray = [];

            // call super constructor
            Konva.Shape.call(this, config);

            // overrides
            // TODO: shouldn't this be on the prototype?
            this._fillFunc = _fillFunc;
            this._strokeFunc = _strokeFunc;
            this._fillFuncHit = _fillFunc;
            this._strokeFuncHit = _strokeFunc;

            this.className = 'TextPath';

            this.dataArray = Konva.Path.parsePathData(this.attrs.data);
            this.on('dataChange.konva', function() {
                that.dataArray = Konva.Path.parsePathData(this.attrs.data);
            });

            // update text data for certain attr changes
            this.on('textChange.konva textStroke.konva textStrokeWidth.konva', that._setTextData);
            that._setTextData();
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            context.setAttr('font', this._getContextFont());
            context.setAttr('textBaseline', 'middle');
            context.setAttr('textAlign', 'left');
            context.save();

            var glyphInfo = this.glyphInfo;
            for(var i = 0; i < glyphInfo.length; i++) {
                context.save();

                var p0 = glyphInfo[i].p0;

                context.translate(p0.x, p0.y);
                context.rotate(glyphInfo[i].rotation);
                this.partialText = glyphInfo[i].text;

                context.fillStrokeShape(this);
                context.restore();

                //// To assist with debugging visually, uncomment following
                // context.beginPath();
                // if (i % 2)
                // context.strokeStyle = 'cyan';
                // else
                // context.strokeStyle = 'green';
                // var p1 = glyphInfo[i].p1;
                // context.moveTo(p0.x, p0.y);
                // context.lineTo(p1.x, p1.y);
                // context.stroke();
            }
            context.restore();
        },
        /**
         * get text width in pixels
         * @method
         * @memberof Konva.TextPath.prototype
         */
        getTextWidth: function() {
            return this.textWidth;
        },
        /**
         * get text height in pixels
         * @method
         * @memberof Konva.TextPath.prototype
         */
        getTextHeight: function() {
            return this.textHeight;
        },
        /**
         * set text
         * @method
         * @memberof Konva.TextPath.prototype
         * @param {String} text
         */
        setText: function(text) {
            Konva.Text.prototype.setText.call(this, text);
        },
        _getTextSize: function(text) {
            var dummyCanvas = this.dummyCanvas;
            var _context = dummyCanvas.getContext('2d');

            _context.save();

            _context.font = this._getContextFont();
            var metrics = _context.measureText(text);

            _context.restore();

            return {
                width: metrics.width,
                height: parseInt(this.attrs.fontSize, 10)
            };
        },
        _setTextData: function() {

            var that = this;
            var size = this._getTextSize(this.attrs.text);
            this.textWidth = size.width;
            this.textHeight = size.height;

            this.glyphInfo = [];

            var charArr = this.attrs.text.split('');

            var p0, p1, pathCmd;

            var pIndex = -1;
            var currentT = 0;

            var getNextPathSegment = function() {
                currentT = 0;
                var pathData = that.dataArray;

                for(var j = pIndex + 1; j < pathData.length; j++) {
                    if(pathData[j].pathLength > 0) {
                        pIndex = j;

                        return pathData[j];
                    }
                    else if(pathData[j].command === 'M') {
                        p0 = {
                            x: pathData[j].points[0],
                            y: pathData[j].points[1]
                        };
                    }
                }

                return {};
            };
            var findSegmentToFitCharacter = function(c) {

                var glyphWidth = that._getTextSize(c).width;

                var currLen = 0;
                var attempts = 0;

                p1 = undefined;
                while(Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 && attempts < 25) {
                    attempts++;
                    var cumulativePathLength = currLen;
                    while(pathCmd === undefined) {
                        pathCmd = getNextPathSegment();

                        if(pathCmd && cumulativePathLength + pathCmd.pathLength < glyphWidth) {
                            cumulativePathLength += pathCmd.pathLength;
                            pathCmd = undefined;
                        }
                    }

                    if(pathCmd === {} || p0 === undefined) {
                        return undefined;
                    }

                    var needNewSegment = false;

                    switch (pathCmd.command) {
                        case 'L':
                            if(Konva.Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {
                                p1 = Konva.Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);
                            }
                            else {
                                pathCmd = undefined;
                            }
                            break;
                        case 'A':

                            var start = pathCmd.points[4];
                            // 4 = theta
                            var dTheta = pathCmd.points[5];
                            // 5 = dTheta
                            var end = pathCmd.points[4] + dTheta;

                            if(currentT === 0){
                                currentT = start + 0.00000001;
                            }
                            // Just in case start is 0
                            else if(glyphWidth > currLen) {
                                currentT += (Math.PI / 180.0) * dTheta / Math.abs(dTheta);
                            }
                            else {
                                currentT -= Math.PI / 360.0 * dTheta / Math.abs(dTheta);
                            }

                            // Credit for bug fix: @therth https://github.com/ericdrowell/KonvaJS/issues/249
                            // Old code failed to render text along arc of this path: "M 50 50 a 150 50 0 0 1 250 50 l 50 0"
                            if(dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {
                                currentT = end;
                                needNewSegment = true;
                            }
                            p1 = Konva.Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);
                            break;
                        case 'C':
                            if(currentT === 0) {
                                if(glyphWidth > pathCmd.pathLength) {
                                    currentT = 0.00000001;
                                }
                                else {
                                    currentT = glyphWidth / pathCmd.pathLength;
                                }
                            }
                            else if(glyphWidth > currLen) {
                                currentT += (glyphWidth - currLen) / pathCmd.pathLength;
                            }
                            else {
                                currentT -= (currLen - glyphWidth) / pathCmd.pathLength;
                            }

                            if(currentT > 1.0) {
                                currentT = 1.0;
                                needNewSegment = true;
                            }
                            p1 = Konva.Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);
                            break;
                        case 'Q':
                            if(currentT === 0) {
                                currentT = glyphWidth / pathCmd.pathLength;
                            }
                            else if(glyphWidth > currLen) {
                                currentT += (glyphWidth - currLen) / pathCmd.pathLength;
                            }
                            else {
                                currentT -= (currLen - glyphWidth) / pathCmd.pathLength;
                            }

                            if(currentT > 1.0) {
                                currentT = 1.0;
                                needNewSegment = true;
                            }
                            p1 = Konva.Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);
                            break;

                    }

                    if(p1 !== undefined) {
                        currLen = Konva.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);
                    }

                    if(needNewSegment) {
                        needNewSegment = false;
                        pathCmd = undefined;
                    }
                }
            };
            for(var i = 0; i < charArr.length; i++) {

                // Find p1 such that line segment between p0 and p1 is approx. width of glyph
                findSegmentToFitCharacter(charArr[i]);

                if(p0 === undefined || p1 === undefined) {
                    break;
                }

                var width = Konva.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);

                // Note: Since glyphs are rendered one at a time, any kerning pair data built into the font will not be used.
                // Can foresee having a rough pair table built in that the developer can override as needed.

                var kern = 0;
                // placeholder for future implementation

                var midpoint = Konva.Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);

                var rotation = Math.atan2((p1.y - p0.y), (p1.x - p0.x));
                this.glyphInfo.push({
                    transposeX: midpoint.x,
                    transposeY: midpoint.y,
                    text: charArr[i],
                    rotation: rotation,
                    p0: p0,
                    p1: p1
                });
                p0 = p1;
            }
        },
        getSelfRect: function() {
            var points = [];
            var fontSize = this.fontSize();

            this.glyphInfo.forEach(function(info) {
                points.push(info.p0.x);
                points.push(info.p0.y);
                points.push(info.p1.x);
                points.push(info.p1.y);
            });
            var minX = points[0];
            var maxX = points[0];
            var minY = points[0];
            var maxY = points[0];
            var x, y;
            for (var i = 0; i < points.length / 2; i++) {
                x = points[i * 2]; y = points[i * 2 + 1];
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }
            return {
                x: Math.round(minX) - fontSize,
                y: Math.round(minY) - fontSize,
                width: Math.round(maxX - minX) + fontSize * 2,
                height: Math.round(maxY - minY) + fontSize * 2
            };
        }
    };

    // map TextPath methods to Text
    Konva.TextPath.prototype._getContextFont = Konva.Text.prototype._getContextFont;

    Konva.Util.extend(Konva.TextPath, Konva.Shape);

    // add setters and getters
    Konva.Factory.addGetterSetter(Konva.TextPath, 'fontFamily', 'Arial');

    /**
     * set font family
     * @name setFontFamily
     * @method
     * @memberof Konva.TextPath.prototype
     * @param {String} fontFamily
     */

     /**
     * get font family
     * @name getFontFamily
     * @method
     * @memberof Konva.TextPath.prototype
     */

    Konva.Factory.addGetterSetter(Konva.TextPath, 'fontSize', 12);

    /**
     * set font size
     * @name setFontSize
     * @method
     * @memberof Konva.TextPath.prototype
     * @param {int} fontSize
     */

     /**
     * get font size
     * @name getFontSize
     * @method
     * @memberof Konva.TextPath.prototype
     */

    Konva.Factory.addGetterSetter(Konva.TextPath, 'fontStyle', NORMAL);

    /**
     * set font style.  Can be 'normal', 'italic', or 'bold'.  'normal' is the default.
     * @name setFontStyle
     * @method
     * @memberof Konva.TextPath.prototype
     * @param {String} fontStyle
     */

     /**
     * get font style
     * @name getFontStyle
     * @method
     * @memberof Konva.TextPath.prototype
     */

    Konva.Factory.addGetterSetter(Konva.TextPath, 'fontVariant', NORMAL);

    /**
     * set font variant.  Can be 'normal' or 'small-caps'.  'normal' is the default.
     * @name setFontVariant
     * @method
     * @memberof Konva.TextPath.prototype
     * @param {String} fontVariant
     */

    /**
     * @get font variant
     * @name getFontVariant
     * @method
     * @memberof Konva.TextPath.prototype
     */

    Konva.Factory.addGetter(Konva.TextPath, 'text', EMPTY_STRING);

    /**
     * get text
     * @name getText
     * @method
     * @memberof Konva.TextPath.prototype
     */

    Konva.Collection.mapMethods(Konva.TextPath);
})();

(function() {
    'use strict';
    /**
     * RegularPolygon constructor.&nbsp; Examples include triangles, squares, pentagons, hexagons, etc.
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.sides
     * @param {Number} config.radius
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var hexagon = new Konva.RegularPolygon({
     *   x: 100,
     *   y: 200,
     *   sides: 6,
     *   radius: 70,
     *   fill: 'red',
     *   stroke: 'black',
     *   strokeWidth: 4
     * });
     */
    Konva.RegularPolygon = function(config) {
        this.___init(config);
    };

    Konva.RegularPolygon.prototype = {
        _centroid: true,
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'RegularPolygon';
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            var sides = this.attrs.sides,
                radius = this.attrs.radius,
                n, x, y;

            context.beginPath();
            context.moveTo(0, 0 - radius);

            for(n = 1; n < sides; n++) {
                x = radius * Math.sin(n * 2 * Math.PI / sides);
                y = -1 * radius * Math.cos(n * 2 * Math.PI / sides);
                context.lineTo(x, y);
            }
            context.closePath();
            context.fillStrokeShape(this);
        },
        getWidth: function() {
            return this.getRadius() * 2;
        },
        // implements Shape.prototype.getHeight()
        getHeight: function() {
            return this.getRadius() * 2;
        },
        // implements Shape.prototype.setWidth()
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            if (this.radius() !== width / 2) {
                this.setRadius(width / 2);
            }
        },
        // implements Shape.prototype.setHeight()
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            if (this.radius() !== height / 2) {
                this.setRadius(height / 2);
            }
        }
    };
    Konva.Util.extend(Konva.RegularPolygon, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.RegularPolygon, 'radius', 0);

    /**
     * set radius
     * @name setRadius
     * @method
     * @memberof Konva.RegularPolygon.prototype
     * @param {Number} radius
     */

     /**
     * get radius
     * @name getRadius
     * @method
     * @memberof Konva.RegularPolygon.prototype
     */

    Konva.Factory.addGetterSetter(Konva.RegularPolygon, 'sides', 0);

    /**
     * set number of sides
     * @name setSides
     * @method
     * @memberof Konva.RegularPolygon.prototype
     * @param {int} sides
     */

    /**
     * get number of sides
     * @name getSides
     * @method
     * @memberof Konva.RegularPolygon.prototype
     */

    Konva.Collection.mapMethods(Konva.RegularPolygon);
})();

(function() {
    'use strict';
    /**
     * Star constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Integer} config.numPoints
     * @param {Number} config.innerRadius
     * @param {Number} config.outerRadius
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var star = new Konva.Star({
     *   x: 100,
     *   y: 200,
     *   numPoints: 5,
     *   innerRadius: 70,
     *   outerRadius: 70,
     *   fill: 'red',
     *   stroke: 'black',
     *   strokeWidth: 4
     * });
     */
    Konva.Star = function(config) {
        this.___init(config);
    };

    Konva.Star.prototype = {
        _centroid: true,
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'Star';
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            var innerRadius = this.innerRadius(),
                outerRadius = this.outerRadius(),
                numPoints = this.numPoints();

            context.beginPath();
            context.moveTo(0, 0 - outerRadius);

            for(var n = 1; n < numPoints * 2; n++) {
                var radius = n % 2 === 0 ? outerRadius : innerRadius;
                var x = radius * Math.sin(n * Math.PI / numPoints);
                var y = -1 * radius * Math.cos(n * Math.PI / numPoints);
                context.lineTo(x, y);
            }
            context.closePath();

            context.fillStrokeShape(this);
        },
        // implements Shape.prototype.getWidth()
        getWidth: function() {
            return this.getOuterRadius() * 2;
        },
        // implements Shape.prototype.getHeight()
        getHeight: function() {
            return this.getOuterRadius() * 2;
        },
        // implements Shape.prototype.setWidth()
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            if (this.outerRadius() !== width / 2) {
                this.setOuterRadius(width / 2);
            }
        },
        // implements Shape.prototype.setHeight()
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            if (this.outerRadius() !== height / 2) {
                this.setOuterRadius(height / 2);
            }
        }
    };
    Konva.Util.extend(Konva.Star, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Star, 'numPoints', 5);

    /**
     * set number of points
     * @name setNumPoints
     * @method
     * @memberof Konva.Star.prototype
     * @param {Integer} points
     */

     /**
     * get number of points
     * @name getNumPoints
     * @method
     * @memberof Konva.Star.prototype
     */

    Konva.Factory.addGetterSetter(Konva.Star, 'innerRadius', 0);

    /**
     * set inner radius
     * @name setInnerRadius
     * @method
     * @memberof Konva.Star.prototype
     * @param {Number} radius
     */

     /**
     * get inner radius
     * @name getInnerRadius
     * @method
     * @memberof Konva.Star.prototype
     */

    Konva.Factory.addGetterSetter(Konva.Star, 'outerRadius', 0);

    /**
     * set outer radius
     * @name setOuterRadius
     * @method
     * @memberof Konva.Star.prototype
     * @param {Number} radius
     */

     /**
     * get outer radius
     * @name getOuterRadius
     * @method
     * @memberof Konva.Star.prototype
     */

    Konva.Collection.mapMethods(Konva.Star);
})();

(function() {
    'use strict';
    // constants
    var ATTR_CHANGE_LIST = ['fontFamily', 'fontSize', 'fontStyle', 'padding', 'lineHeight', 'text'],
        CHANGE_KONVA = 'Change.konva',
        NONE = 'none',
        UP = 'up',
        RIGHT = 'right',
        DOWN = 'down',
        LEFT = 'left',
        LABEL = 'Label',

     // cached variables
     attrChangeListLen = ATTR_CHANGE_LIST.length;

    /**
     * Label constructor.&nbsp; Labels are groups that contain a Text and Tag shape
     * @constructor
     * @memberof Konva
     * @param {Object} config
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * // create label
     * var label = new Konva.Label({
     *   x: 100,
     *   y: 100,
     *   draggable: true
     * });
     *
     * // add a tag to the label
     * label.add(new Konva.Tag({
     *   fill: '#bbb',
     *   stroke: '#333',
     *   shadowColor: 'black',
     *   shadowBlur: 10,
     *   shadowOffset: [10, 10],
     *   shadowOpacity: 0.2,
     *   lineJoin: 'round',
     *   pointerDirection: 'up',
     *   pointerWidth: 20,
     *   pointerHeight: 20,
     *   cornerRadius: 5
     * }));
     *
     * // add text to the label
     * label.add(new Konva.Text({
     *   text: 'Hello World!',
     *   fontSize: 50,
     *   lineHeight: 1.2,
     *   padding: 10,
     *   fill: 'green'
     *  }));
     */
    Konva.Label = function(config) {
        this.____init(config);
    };

    Konva.Label.prototype = {
        ____init: function(config) {
            var that = this;

            Konva.Group.call(this, config);
            this.className = LABEL;

            this.on('add.konva', function(evt) {
                that._addListeners(evt.child);
                that._sync();
            });
        },
        /**
         * get Text shape for the label.  You need to access the Text shape in order to update
         * the text properties
         * @name getText
         * @method
         * @memberof Konva.Label.prototype
         */
        getText: function() {
            return this.find('Text')[0];
        },
        /**
         * get Tag shape for the label.  You need to access the Tag shape in order to update
         * the pointer properties and the corner radius
         * @name getTag
         * @method
         * @memberof Konva.Label.prototype
         */
        getTag: function() {
            return this.find('Tag')[0];
        },
        _addListeners: function(text) {
            var that = this,
                n;
            var func = function(){
                    that._sync();
                };

            // update text data for certain attr changes
            for(n = 0; n < attrChangeListLen; n++) {
                text.on(ATTR_CHANGE_LIST[n] + CHANGE_KONVA, func);
            }
        },
        getWidth: function() {
            return this.getText().getWidth();
        },
        getHeight: function() {
            return this.getText().getHeight();
        },
        _sync: function() {
            var text = this.getText(),
                tag = this.getTag(),
                width, height, pointerDirection, pointerWidth, x, y, pointerHeight;

            if (text && tag) {
                width = text.getWidth();
                height = text.getHeight();
                pointerDirection = tag.getPointerDirection();
                pointerWidth = tag.getPointerWidth();
                pointerHeight = tag.getPointerHeight();
                x = 0;
                y = 0;

                switch(pointerDirection) {
                    case UP:
                        x = width / 2;
                        y = -1 * pointerHeight;
                        break;
                    case RIGHT:
                        x = width + pointerWidth;
                        y = height / 2;
                        break;
                    case DOWN:
                        x = width / 2;
                        y = height + pointerHeight;
                        break;
                    case LEFT:
                        x = -1 * pointerWidth;
                        y = height / 2;
                        break;
                }

                tag.setAttrs({
                    x: -1 * x,
                    y: -1 * y,
                    width: width,
                    height: height
                });

                text.setAttrs({
                    x: -1 * x,
                    y: -1 * y
                });
            }
        }
    };

    Konva.Util.extend(Konva.Label, Konva.Group);

    Konva.Collection.mapMethods(Konva.Label);

    /**
     * Tag constructor.&nbsp; A Tag can be configured
     *  to have a pointer element that points up, right, down, or left
     * @constructor
     * @memberof Konva
     * @param {Object} config
     * @param {String} [config.pointerDirection] can be up, right, down, left, or none; the default
     *  is none.  When a pointer is present, the positioning of the label is relative to the tip of the pointer.
     * @param {Number} [config.pointerWidth]
     * @param {Number} [config.pointerHeight]
     * @param {Number} [config.cornerRadius]
     */
    Konva.Tag = function(config) {
        this.___init(config);
    };

    Konva.Tag.prototype = {
        ___init: function(config) {
            Konva.Shape.call(this, config);
            this.className = 'Tag';
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            var width = this.getWidth(),
                height = this.getHeight(),
                pointerDirection = this.getPointerDirection(),
                pointerWidth = this.getPointerWidth(),
                pointerHeight = this.getPointerHeight(),
                cornerRadius = Math.min(this.getCornerRadius(), width / 2, height / 2);

            context.beginPath();
            if (!cornerRadius) {
                context.moveTo(0, 0);
            } else {
                context.moveTo(cornerRadius, 0);
            }

            if (pointerDirection === UP) {
                context.lineTo((width - pointerWidth) / 2, 0);
                context.lineTo(width / 2, -1 * pointerHeight);
                context.lineTo((width + pointerWidth) / 2, 0);
            }

            if(!cornerRadius) {
                context.lineTo(width, 0);
            } else {
                context.lineTo(width - cornerRadius, 0);
                context.arc(width - cornerRadius, cornerRadius, cornerRadius, Math.PI * 3 / 2, 0, false);
            }

            if (pointerDirection === RIGHT) {
                context.lineTo(width, (height - pointerHeight) / 2);
                context.lineTo(width + pointerWidth, height / 2);
                context.lineTo(width, (height + pointerHeight) / 2);
            }

            if(!cornerRadius) {
                context.lineTo(width, height);
            } else {
                context.lineTo(width, height - cornerRadius);
                context.arc(width - cornerRadius, height - cornerRadius, cornerRadius, 0, Math.PI / 2, false);
            }

            if (pointerDirection === DOWN) {
                context.lineTo((width + pointerWidth) / 2, height);
                context.lineTo(width / 2, height + pointerHeight);
                context.lineTo((width - pointerWidth) / 2, height);
            }

            if(!cornerRadius) {
                context.lineTo(0, height);
            } else {
                context.lineTo(cornerRadius, height);
                context.arc(cornerRadius, height - cornerRadius, cornerRadius, Math.PI / 2, Math.PI, false);
            }

            if (pointerDirection === LEFT) {
                context.lineTo(0, (height + pointerHeight) / 2);
                context.lineTo(-1 * pointerWidth, height / 2);
                context.lineTo(0, (height - pointerHeight) / 2);
            }

            if(cornerRadius) {
                context.lineTo(0, cornerRadius);
                context.arc(cornerRadius, cornerRadius, cornerRadius, Math.PI, Math.PI * 3 / 2, false);
            }

            context.closePath();
            context.fillStrokeShape(this);
        },
        getSelfRect: function() {
            var x = 0,
                y = 0,
                pointerWidth = this.getPointerWidth(),
                pointerHeight = this.getPointerHeight(),
                direction = this.pointerDirection(),
                width = this.getWidth(),
                height = this.getHeight();

            if (direction === UP) {
                y -= pointerHeight;
                height += pointerHeight;
            } else if (direction === DOWN) {
                height += pointerHeight;
            } else if (direction === LEFT) {
                // ARGH!!! I have no idea why should I used magic 1.5!!!!!!!!!
                x -= pointerWidth * 1.5;
                width += pointerWidth;
            } else if (direction === RIGHT) {
                width += pointerWidth * 1.5;
            }
            return {
                x: x,
                y: y,
                width: width,
                height: height
            };
        }
    };

    Konva.Util.extend(Konva.Tag, Konva.Shape);
    Konva.Factory.addGetterSetter(Konva.Tag, 'pointerDirection', NONE);

    /**
     * set pointer Direction
     * @name setPointerDirection
     * @method
     * @memberof Konva.Tag.prototype
     * @param {String} pointerDirection can be up, right, down, left, or none.  The
     *  default is none
     */

     /**
     * get pointer Direction
     * @name getPointerDirection
     * @method
     * @memberof Konva.Tag.prototype
     */

    Konva.Factory.addGetterSetter(Konva.Tag, 'pointerWidth', 0);

    /**
     * set pointer width
     * @name setPointerWidth
     * @method
     * @memberof Konva.Tag.prototype
     * @param {Number} pointerWidth
     */

     /**
     * get pointer width
     * @name getPointerWidth
     * @method
     * @memberof Konva.Tag.prototype
     */

    Konva.Factory.addGetterSetter(Konva.Tag, 'pointerHeight', 0);

    /**
     * set pointer height
     * @name setPointerHeight
     * @method
     * @memberof Konva.Tag.prototype
     * @param {Number} pointerHeight
     */

     /**
     * get pointer height
     * @name getPointerHeight
     * @method
     * @memberof Konva.Tag.prototype
     */

    Konva.Factory.addGetterSetter(Konva.Tag, 'cornerRadius', 0);

    /**
     * set corner radius
     * @name setCornerRadius
     * @method
     * @memberof Konva.Tag.prototype
     * @param {Number} corner radius
     */

    /**
     * get corner radius
     * @name getCornerRadius
     * @method
     * @memberof Konva.Tag.prototype
     */

    Konva.Collection.mapMethods(Konva.Tag);
})();

(function() {
    'use strict';
    /**
     * Arrow constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Array} config.points
     * @param {Number} [config.tension] Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
     *   The default is 0
     * @param {Number} config.pointerLength
     * @param {Number} config.pointerWidth
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var line = new Konva.Line({
     *   points: [73, 70, 340, 23, 450, 60, 500, 20],
     *   stroke: 'red',
     *   tension: 1,
     *   pointerLength : 10,
     *   pointerWidth : 12
     * });
     */
    Konva.Arrow = function(config) {
        this.____init(config);
    };

    Konva.Arrow.prototype = {
        ____init: function(config) {
            // call super constructor
            Konva.Line.call(this, config);
            this.className = 'Arrow';
        },
        _sceneFunc: function(ctx) {
            Konva.Line.prototype._sceneFunc.apply(this, arguments);
            var PI2 = Math.PI * 2;
            var points = this.points();
            var n = points.length;
            var dx = points[n - 2] - points[n - 4];
            var dy = points[n - 1] - points[n - 3];
            var radians = (Math.atan2(dy, dx) + PI2) % PI2;
            var length = this.pointerLength();
            var width = this.pointerWidth();

            ctx.save();
            ctx.beginPath();
            ctx.translate(points[n - 2], points[n - 1]);
            ctx.rotate(radians);
            ctx.moveTo(0, 0);
            ctx.lineTo(-length, width / 2);
            ctx.lineTo(-length, -width / 2);
            ctx.closePath();
            ctx.restore();

            if (this.pointerAtBeginning()) {
                ctx.save();
                ctx.translate(points[0], points[1]);
                dx = points[2] - points[0];
                dy = points[3] - points[1];
                ctx.rotate((Math.atan2(-dy, -dx) + PI2) % PI2);
                ctx.moveTo(0, 0);
                ctx.lineTo(-length, width / 2);
                ctx.lineTo(-length, -width / 2);
                ctx.closePath();
                ctx.restore();
            }
            ctx.fillStrokeShape(this);
        }
    };

    Konva.Util.extend(Konva.Arrow, Konva.Line);
    /**
     * get/set pointerLength
     * @name pointerLength
     * @method
     * @memberof Konva.Arrow.prototype
     * @param {Number} Length of pointer of arrow.
     *   The default is 10.
     * @returns {Number}
     * @example
     * // get tension
     * var pointerLength = line.pointerLength();
     *
     * // set tension
     * line.pointerLength(15);
     */

    Konva.Factory.addGetterSetter(Konva.Arrow, 'pointerLength', 10);
    /**
     * get/set pointerWidth
     * @name pointerWidth
     * @method
     * @memberof Konva.Arrow.prototype
     * @param {Number} Width of pointer of arrow.
     *   The default is 10.
     * @returns {Number}
     * @example
     * // get tension
     * var pointerWidth = line.pointerWidth();
     *
     * // set tension
     * line.pointerWidth(15);
     */

    Konva.Factory.addGetterSetter(Konva.Arrow, 'pointerWidth', 10);
    /**
     * get/set pointerAtBeginning
     * @name pointerAtBeginning
     * @method
     * @memberof Konva.Arrow.prototype
     * @param {Number} Should pointer displayed at beginning of arrow.
     *   The default is false.
     * @returns {Boolean}
     * @example
     * // get tension
     * var pointerAtBeginning = line.pointerAtBeginning();
     *
     * // set tension
     * line.pointerAtBeginning(true);
     */

    Konva.Factory.addGetterSetter(Konva.Arrow, 'pointerAtBeginning', false);
    Konva.Collection.mapMethods(Konva.Arrow);

})();


},{"canvas":181,"jsdom":181}],181:[function(require,module,exports){
arguments[4][170][0].apply(exports,arguments)
},{"dup":170}],182:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],183:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}]},{},[75])(75)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2F4aXMvc3JjL2F4aXMvYXhpcy1sYXllci5qcyIsImRpc3QvYXhpcy9zcmMvYXhpcy9iZWF0LWdyaWQtYXhpcy1nZW5lcmF0b3IuanMiLCJkaXN0L2F4aXMvc3JjL2F4aXMvZ3JpZC1heGlzLWdlbmVyYXRvci5qcyIsImRpc3QvYXhpcy9zcmMvYXhpcy90aW1lLWF4aXMtZ2VuZXJhdG9yLmpzIiwiZGlzdC9iZWhhdmlvcnMvc3JjL2JlaGF2aW9ycy9iYXNlLWJlaGF2aW9yLmpzIiwiZGlzdC9iZWhhdmlvcnMvc3JjL2JlaGF2aW9ycy9iZWF0LWdyaWQtc25hcC1zZWdtZW50LWJlaGF2aW9yLmpzIiwiZGlzdC9iZWhhdmlvcnMvc3JjL2JlaGF2aW9ycy9icmVha3BvaW50LWJlaGF2aW9yLmpzIiwiZGlzdC9iZWhhdmlvcnMvc3JjL2JlaGF2aW9ycy9tYXJrZXItYmVoYXZpb3IuanMiLCJkaXN0L2JlaGF2aW9ycy9zcmMvYmVoYXZpb3JzL25vLWJlaGF2aW9yLmpzIiwiZGlzdC9iZWhhdmlvcnMvc3JjL2JlaGF2aW9ycy9uby1ob3Jpem9udGFsLW92ZXJsYXBwaW5nLXNlZ21lbnRzLWJlaGF2aW9yLmpzIiwiZGlzdC9iZWhhdmlvcnMvc3JjL2JlaGF2aW9ycy9zY3JvbGwtc2VnbWVudC1iZWhhdmlvci5qcyIsImRpc3QvYmVoYXZpb3JzL3NyYy9iZWhhdmlvcnMvc2VnbWVudC1iZWhhdmlvci5qcyIsImRpc3QvYmVoYXZpb3JzL3NyYy9iZWhhdmlvcnMvc2libGluZy1sb2NrZWQtc2VnbWVudC1iZWhhdmlvci5qcyIsImRpc3QvYmVoYXZpb3JzL3NyYy9iZWhhdmlvcnMvc2ltcGxlLXNuYXAtc2VnbWVudC1iZWhhdmlvci5qcyIsImRpc3QvYmVoYXZpb3JzL3NyYy9iZWhhdmlvcnMvc25hcC1iYXNlLWJlaGF2aW9yLmpzIiwiZGlzdC9iZWhhdmlvcnMvc3JjL2JlaGF2aW9ycy90aW1lLWNvbnRleHQtYmVoYXZpb3IuanMiLCJkaXN0L2JlaGF2aW9ycy9zcmMvYmVoYXZpb3JzL3RyYWNlLWJlaGF2aW9yLmpzIiwiZGlzdC9iZWhhdmlvcnMvc3JjL2JlaGF2aW9ycy93YXZlZm9ybS1iZWhhdmlvci5qcyIsImRpc3QvY29yZS9zcmMvY29yZS9sYXllci10aW1lLWNvbnRleHQuanMiLCJkaXN0L2NvcmUvc3JjL2NvcmUvbGF5ZXIuanMiLCJkaXN0L2NvcmUvc3JjL2NvcmUvdGltZWxpbmUtdGltZS1jb250ZXh0LmpzIiwiZGlzdC9jb3JlL3NyYy9jb3JlL3RpbWVsaW5lLmpzIiwiZGlzdC9jb3JlL3NyYy9jb3JlL3RyYWNrLWNvbGxlY3Rpb24uanMiLCJkaXN0L2NvcmUvc3JjL2NvcmUvdHJhY2suanMiLCJkaXN0L2hlbHBlcnMvc3JjL2hlbHBlcnMvYW5ub3RhdGVkLW1hcmtlci1sYXllci5qcyIsImRpc3QvaGVscGVycy9zcmMvaGVscGVycy9hbm5vdGF0ZWQtc2VnbWVudC1sYXllci5qcyIsImRpc3QvaGVscGVycy9zcmMvaGVscGVycy9iZWF0LWdyaWQtYXhpcy1sYXllci5qcyIsImRpc3QvaGVscGVycy9zcmMvaGVscGVycy9iZWF0LWdyaWQtbGF5ZXIuanMiLCJkaXN0L2hlbHBlcnMvc3JjL2hlbHBlcnMvYnJlYWtwb2ludC1sYXllci5qcyIsImRpc3QvaGVscGVycy9zcmMvaGVscGVycy9icnVzaC1jb250cm9sbGVyLmpzIiwiZGlzdC9oZWxwZXJzL3NyYy9oZWxwZXJzL2N1cnNvci1sYXllci5qcyIsImRpc3QvaGVscGVycy9zcmMvaGVscGVycy9ncmlkLWF4aXMtbGF5ZXIuanMiLCJkaXN0L2hlbHBlcnMvc3JjL2hlbHBlcnMvbWFya2VyLWxheWVyLmpzIiwiZGlzdC9oZWxwZXJzL3NyYy9oZWxwZXJzL3Njcm9sbGVyLmpzIiwiZGlzdC9oZWxwZXJzL3NyYy9oZWxwZXJzL3NlZ21lbnQtbGF5ZXIuanMiLCJkaXN0L2hlbHBlcnMvc3JjL2hlbHBlcnMvdGljay1sYXllci5qcyIsImRpc3QvaGVscGVycy9zcmMvaGVscGVycy90aW1lLWF4aXMtbGF5ZXIuanMiLCJkaXN0L2hlbHBlcnMvc3JjL2hlbHBlcnMvdHJhY2UtbGF5ZXIuanMiLCJkaXN0L2hlbHBlcnMvc3JjL2hlbHBlcnMvd2F2ZWZvcm0tbGF5ZXIuanMiLCJkaXN0L2ludGVyYWN0aW9ucy9zcmMvaW50ZXJhY3Rpb25zL2V2ZW50LXNvdXJjZS5qcyIsImRpc3QvaW50ZXJhY3Rpb25zL3NyYy9pbnRlcmFjdGlvbnMva2V5Ym9hcmQuanMiLCJkaXN0L2ludGVyYWN0aW9ucy9zcmMvaW50ZXJhY3Rpb25zL2tvbnZhLXN1cmZhY2UuanMiLCJkaXN0L2ludGVyYWN0aW9ucy9zcmMvaW50ZXJhY3Rpb25zL2tvbnZhLXdhdmUtZXZlbnQuanMiLCJkaXN0L2ludGVyYWN0aW9ucy9zcmMvaW50ZXJhY3Rpb25zL3dhdmUtZXZlbnQuanMiLCJkaXN0L3NoYXBlcy9zcmMvc2hhcGVzL2Fubm90YXRlZC1kb3QuanMiLCJkaXN0L3NoYXBlcy9zcmMvc2hhcGVzL2Fubm90YXRlZC1tYXJrZXIuanMiLCJkaXN0L3NoYXBlcy9zcmMvc2hhcGVzL2Fubm90YXRlZC1zZWdtZW50LmpzIiwiZGlzdC9zaGFwZXMvc3JjL3NoYXBlcy9iYXNlLXNoYXBlLmpzIiwiZGlzdC9zaGFwZXMvc3JjL3NoYXBlcy9jdXJzb3IuanMiLCJkaXN0L3NoYXBlcy9zcmMvc2hhcGVzL2RvdC5qcyIsImRpc3Qvc2hhcGVzL3NyYy9zaGFwZXMvbGluZS5qcyIsImRpc3Qvc2hhcGVzL3NyYy9zaGFwZXMvbWFya2VyLmpzIiwiZGlzdC9zaGFwZXMvc3JjL3NoYXBlcy9zZWdtZW50LmpzIiwiZGlzdC9zaGFwZXMvc3JjL3NoYXBlcy90aWNrcy5qcyIsImRpc3Qvc2hhcGVzL3NyYy9zaGFwZXMvdHJhY2UtZG90cy5qcyIsImRpc3Qvc2hhcGVzL3NyYy9zaGFwZXMvdHJhY2UtcGF0aC5qcyIsImRpc3Qvc2hhcGVzL3NyYy9zaGFwZXMvd2F2ZWZvcm0uanMiLCJkaXN0L3N0YXRlcy9zcmMvc3RhdGVzL2Jhc2Utc3RhdGUuanMiLCJkaXN0L3N0YXRlcy9zcmMvc3RhdGVzL2JyZWFrcG9pbnQtc3RhdGUuanMiLCJkaXN0L3N0YXRlcy9zcmMvc3RhdGVzL2JydXNoLXpvb20tc3RhdGUuanMiLCJkaXN0L3N0YXRlcy9zcmMvc3RhdGVzL2NlbnRlcmVkLXNjcm9sbC1zdGF0ZS5qcyIsImRpc3Qvc3RhdGVzL3NyYy9zdGF0ZXMvY2VudGVyZWQtem9vbS1zdGF0ZS5qcyIsImRpc3Qvc3RhdGVzL3NyYy9zdGF0ZXMvY29udGV4dC1lZGl0aW9uLXN0YXRlLmpzIiwiZGlzdC9zdGF0ZXMvc3JjL3N0YXRlcy9kcmFnLWFuZC1kcm9wLXN0YXRlLmpzIiwiZGlzdC9zdGF0ZXMvc3JjL3N0YXRlcy9kcmFnLXRvLWNyZWF0ZS1pbnRlcnZhbC1zdGF0ZS5qcyIsImRpc3Qvc3RhdGVzL3NyYy9zdGF0ZXMvZHJvcC1hbmQtYWRkLXN0YXRlLmpzIiwiZGlzdC9zdGF0ZXMvc3JjL3N0YXRlcy9lZGl0aW9uLXN0YXRlLmpzIiwiZGlzdC9zdGF0ZXMvc3JjL3N0YXRlcy9ob3Jpem9udGFsLXNlbGVjdGlvbi1zdGF0ZS5qcyIsImRpc3Qvc3RhdGVzL3NyYy9zdGF0ZXMvc2VsZWN0aW9uLXN0YXRlLmpzIiwiZGlzdC9zdGF0ZXMvc3JjL3N0YXRlcy9zaGFwZS1pbnNlcnRpb24tc3RhdGUuanMiLCJkaXN0L3N0YXRlcy9zcmMvc3RhdGVzL3NpbXBsZS1lZGl0aW9uLXN0YXRlLmpzIiwiZGlzdC91dGlscy9zcmMvdXRpbHMvZm9ybWF0LmpzIiwiZGlzdC91dGlscy9zcmMvdXRpbHMvb3J0aG9nb25hbC1kYXRhLmpzIiwiZGlzdC91dGlscy9zcmMvdXRpbHMvc2NhbGVzLmpzIiwiZGlzdC9zcmMvd2F2ZXMtdWkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvbWFwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2UuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3NldC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzLWNhbGwtY2hlY2suanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZS1jbGFzcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZ2V0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvaW50ZXJvcC1yZXF1aXJlLWRlZmF1bHQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vbWFwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2UuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3NldC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5hLWZ1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuYW4tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY2xhc3NvZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmNvZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmNvbGxlY3Rpb24tc3Ryb25nLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY29sbGVjdGlvbi10by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmNvcmUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jdHguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5kb20tY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZW51bS1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZXhwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZmFpbHMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5mb3Itb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5nZXQtbmFtZXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5oYXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5oaWRlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmludm9rZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmlvYmplY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pcy1hcnJheS1pdGVyLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXMtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pdGVyLWNhbGwuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pdGVyLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLml0ZXItZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlci1kZXRlY3QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pdGVyLXN0ZXAuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pdGVyYXRvcnMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmtleW9mLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQubGlicmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLm1pY3JvdGFzay5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLm9iamVjdC1hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5vYmplY3Qtc2FwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQucHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnJlZGVmaW5lLWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnJlZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc2FtZS12YWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnNldC1wcm90by5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnNldC1zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc2V0LXRvLXN0cmluZy10YWcuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zaGFyZWQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc3RyaWN0LW5ldy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnN0cmluZy1hdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnRhc2suanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC50by1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQudG8taW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnRvLWxlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnRvLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnVpZC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLndrcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5tYXAuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc2V0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcubWFwLnRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL3J1bnRpbWUuanMiLCJub2RlX21vZHVsZXMva29udmEva29udmEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQSxZQUFZLENBQUM7Ozs7Ozs7Ozs7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QUE7O0FDQUE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7O0FDRkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7O0FDRkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xPQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdG9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzd5ZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IExheWVyIGZyb20gJy4uL2NvcmUvbGF5ZXInO1xuaW1wb3J0IFNlZ21lbnQgZnJvbSAnLi4vc2hhcGVzL3NlZ21lbnQnO1xuaW1wb3J0IEJhc2VCZWhhdmlvciBmcm9tICcuLi9iZWhhdmlvcnMvYmFzZS1iZWhhdmlvcic7XG5cblxuLyoqXG4gKiBTaW1wbGlmaWVkIExheWVyIGZvciBBeGlzLiBUaGUgbWFpbiBkaWZmZXJlbmNlIHdpdGggYSByZWd1bGFyIGxheWVyIGlzIHRoYXRcbiAqIGFuIGF4aXMgbGF5ZXIgdXNlIHRoZSBgVGltZWxpbmV+dGltZUNvbnRleHRgIGF0dHJpYnV0ZXMgdG8gcmVuZGVyIGl0J3MgbGF5b3V0XG4gKiBhbmQgc3RheSBzeW5jaHJvbml6ZWQgd2l0aCB0aGUgdHJhY2tzIHZpc2libGUgYXJlYS4gQWxsIGdldHRlcnMgYW5kIHNldHRlcnNcbiAqIHRvIHRoZSBgVGltZWxpbmVUaW1lQ29udGV4dGAgYXR0cmlidXRlcyBhcmUgYnlwYXNzZWQuXG4gKlxuICogSXQgYWxzbyBoYW5kbGUgaXQncyBvd24gZGF0YSBhbmQgaXRzIHVwZGF0ZXMuIFRoZSBgX2dlbmVyYXRlRGF0YWAgbWV0aG9kIGlzXG4gKiByZXNwb25zaWJsZSB0byBjcmVhdGUgc29tZSB1c2VmdWxsIGRhdGEgdG8gdmlzdWFsaXplXG4gKlxuICogW2V4YW1wbGUgdXNhZ2Ugb2YgdGhlIGxheWVyLWF4aXNdKC4vZXhhbXBsZXMvbGF5ZXItYXhpcy5odG1sKVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBeGlzTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZW5lcmF0b3IgLSBBIGZ1bmN0aW9uIHRvIGNyZWF0ZSBkYXRhIGFjY29yZGluZyB0b1xuICAgKiAgICB0aGUgYFRpbWVsaW5lfnRpbWVDb250ZXh0YC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBMYXllciBvcHRpb25zLCBjZi4gTGF5ZXIgZm9yIGF2YWlsYWJsZSBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZ2VuZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoJ2VudGl0eScsIFtdLCBvcHRpb25zKTtcbiAgICB0aGlzLl9nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG5cbiAgICB0aGlzLl9jb250ZXh0U2hhcGUgPSBuZXcgU2VnbWVudCh7fSk7XG4gICAgdGhpcy5fY29udGV4dFNoYXBlLmluc3RhbGwoe1xuICAgICAgb3BhY2l0eSA6ICgpID0+IDEsIFxuICAgICAgY29sb3IgOiAoKSA9PiB0aGlzLnBhcmFtcy5jb250ZXh0LmNvbG9yLCBcbiAgICAgIHdpZHRoIDogKCkgPT4gdGhpcy50aW1lQ29udGV4dC52aXNpYmxlRHVyYXRpb24sXG4gICAgICBoZWlnaHQgIDogKCkgPT4gdGhpcy5fcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwuZG9tYWluKClbMV0sXG4gICAgICB5ICAgOiAoKSA9PiB0aGlzLl9yZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbC5kb21haW4oKVswXSxcbiAgICAgIHggICA6ICgpID0+IC10aGlzLnRpbWVDb250ZXh0Lm9mZnNldFxuICAgIH0pOyBcbiAgICB0aGlzLl9jb250ZXh0U2hhcGUucGFyYW1zLmhhbmRsZXJXaWR0aCA9IHRoaXMucGFyYW1zLmNvbnRleHQuaGFuZGxlcldpZHRoO1xuICAgIHRoaXMuX2NvbnRleHRTaGFwZS5yZW5kZXIodGhpcy5fcmVuZGVyaW5nQ29udGV4dCk7XG4gICAgdGhpcy5fY29udGV4dFNoYXBlLmxheWVyID0gdGhpcztcbiAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5fY29udGV4dFNoYXBlLiRlbC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fY29udGV4dExheWVyLmFkZCh0aGlzLl9jb250ZXh0U2hhcGUuJGVsW2ldKTtcbiAgICB9XG4gICAgdGhpcy5fY29udGV4dFNoYXBlLiRlbC5mb3JFYWNoKChrcykgPT4geyBrcy5zaGFwZSA9IHRoaXMuX2NvbnRleHRTaGFwZTsgfSk7XG5cbiAgICB0aGlzLnNldEJlaGF2aW9yKG5ldyBCYXNlQmVoYXZpb3IoKSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgc2V0IHN0cmV0Y2hSYXRpbyh2YWx1ZSkgeyByZXR1cm47IH1cbiAgLyoqIEBwcml2YXRlICovXG4gIHNldCBvZmZzZXQodmFsdWUpIHsgcmV0dXJuOyB9XG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBzZXQgc3RhcnQodmFsdWUpIHsgcmV0dXJuOyB9XG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBzZXQgZHVyYXRpb24odmFsdWUpIHsgcmV0dXJuOyB9XG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBnZXQgc3RyZXRjaFJhdGlvKCkgeyByZXR1cm47IH1cbiAgLyoqIEBwcml2YXRlICovXG4gIGdldCBvZmZzZXQoKSB7IHJldHVybjsgfVxuICAvKiogQHByaXZhdGUgKi9cbiAgZ2V0IHN0YXJ0KCkgeyByZXR1cm47IH1cbiAgLyoqIEBwcml2YXRlICovXG4gIGdldCBkdXJhdGlvbigpIHsgcmV0dXJuOyB9XG5cblxuICAvKipcbiAgICogVGhlIGdlbmVyYXRvciB0aGF0IGNyZWF0ZXMgdGhlIGRhdGEgdG8gYmUgcmVuZGVyZWQgdG8gZGlzcGxheSB0aGUgYXhpcy5cbiAgICpcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgc2V0IGdlbmVyYXRvcihmdW5jKSB7XG4gICAgdGhpcy5fZ2VuZXJhdG9yID0gZnVuYztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZ2VuZXJhdG9yIHRoYXQgY3JlYXRlcyB0aGUgZGF0YSB0byBiZSByZW5kZXJlZCB0byBkaXNwbGF5IHRoZSBheGlzLlxuICAgKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICBnZXQgZ2VuZXJhdG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9nZW5lcmF0b3I7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgdGhlIG1haW4gZGlmZmVyZW5jZSB3aXRoIGEgY2xhc3NpY2FsIGxheWVyLiBBbiBgQXhpc0xheWVyYFxuICAgKiBpbnN0YW5jZSBnZW5lcmF0ZXMgYW5kIG1haW50YWlucyBpdCdzIG93biBkYXRhLlxuICAgKi9cbiAgX2dlbmVyYXRlRGF0YSgpIHtcbiAgICBjb25zdCB0aGF0ID0gdGhpcztcbiAgICB0aGlzLmNvbnRlbnRMYXllcnMuZm9yRWFjaCgobCkgPT4geyAvLyBIYWNrZWQgdGhpcyB0byBtYWtlIGl0IHdvcmsuXG4gICAgICBsLmRlc3Ryb3koKTtcbiAgICAgIHRoYXQuY29udGVudExheWVycy5kZWxldGUobCk7XG4gICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2dlbmVyYXRvcih0aGlzLnRpbWVDb250ZXh0KTtcbiAgICAvLyB0aGlzLnJlbW92ZSh0aGlzLmRhdGEpO1xuICAgIHRoaXMuc2V0KFtkYXRhXSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSBkYXRhIGFuZCB1cGRhdGUgdGhlIGxheWVyLlxuICAgKi9cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuX2dlbmVyYXRlRGF0YSgpO1xuICAgIHN1cGVyLnVwZGF0ZSgpO1xuICB9XG5cbiAgdXBkYXRlQ29udGFpbmVyKCkge1xuICAgIHRoaXMuX3VwZGF0ZVJlbmRlcmluZ0NvbnRleHQoKTtcbiAgfVxuXG4gIHVwZGF0ZVNoYXBlcygpIHtcbiAgICBjb25zdCBjaGFuZ2VkQ29udGVudExheWVycyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB0aGF0ID0gdGhpcztcblxuICAgIHRoaXMuYWxsb2NhdGVTaGFwZXNUb0NvbnRlbnRMYXllcnModGhpcy5fc3RhZ2UsIHRoaXMuZGF0YSwgJ2RhdHVtcycsIHRydWUpLmZvckVhY2goKGNoYW5nZWRDb250ZW50TGF5ZXIpID0+IHtcbiAgICAgIGNoYW5nZWRDb250ZW50TGF5ZXJzLmFkZChjaGFuZ2VkQ29udGVudExheWVyKTtcbiAgICB9KTtcblxuICAgIGNoYW5nZWRDb250ZW50TGF5ZXJzLmZvckVhY2goKGNoYW5nZWRDb250ZW50TGF5ZXIpID0+IHtcbiAgICAgIGNoYW5nZWRDb250ZW50TGF5ZXJcbiAgICAgICAgLnkodGhhdC5wYXJhbXMudG9wKVxuICAgICAgICAub2Zmc2V0WCgwKTtcbiAgICAgIGNoYW5nZWRDb250ZW50TGF5ZXIuY2xlYXIoKTtcbiAgICAgIGNoYW5nZWRDb250ZW50TGF5ZXIuYmF0Y2hEcmF3KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9jb250ZXh0U2hhcGUudXBkYXRlKHRoaXMuX3JlbmRlcmluZ0NvbnRleHQsIHRoaXMudGltZUNvbnRleHQpO1xuXG4gICAgdGhpcy5fY29udGV4dExheWVyXG4gICAgICAgIC55KHRoYXQucGFyYW1zLnRvcClcbiAgICAgICAgLmJhdGNoRHJhdygpXG4gICAgICAgIC5tb3ZlVG9Cb3R0b20oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSByZW5kZXJpbmcgY29udGV4dCBmb3IgdGhlIHNoYXBlcy5cbiAgICovXG4gIF91cGRhdGVSZW5kZXJpbmdDb250ZXh0KCkge1xuICAgIHRoaXMuX3JlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwgPSB0aGlzLnRpbWVDb250ZXh0LnRpbWVUb1BpeGVsO1xuICAgIHRoaXMuX3JlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsID0gdGhpcy5fdmFsdWVUb1BpeGVsO1xuXG4gICAgdGhpcy5fcmVuZGVyaW5nQ29udGV4dC5oZWlnaHQgPSB0aGlzLnBhcmFtcy5oZWlnaHQ7XG4gICAgdGhpcy5fcmVuZGVyaW5nQ29udGV4dC53aWR0aCAgPSB0aGlzLnRpbWVDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMudGltZUNvbnRleHQudmlzaWJsZUR1cmF0aW9uKTtcblxuICAgIC8vIGZvciBmb3JlaWduIG9iamVjdCBpc3N1ZSBpbiBjaHJvbWVcbiAgICB0aGlzLl9yZW5kZXJpbmdDb250ZXh0Lm9mZnNldFggPSB0aGlzLnRpbWVDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMudGltZUNvbnRleHQub2Zmc2V0KTtcblxuICAgIC8vIGV4cG9zZSBzb21lIHRpbWVsaW5lIGF0dHJpYnV0ZXMgLSBhbGxvdyB0byBpbXByb3ZlIHBlcmYgaW4gc29tZSBjYXNlcyAtIGNmLiBXYXZlZm9ybVxuICAgIHRoaXMuX3JlbmRlcmluZ0NvbnRleHQudHJhY2tPZmZzZXRYID0gdGhpcy50aW1lQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLnRpbWVDb250ZXh0Lm9mZnNldCk7XG4gICAgdGhpcy5fcmVuZGVyaW5nQ29udGV4dC52aXNpYmxlV2lkdGggPSB0aGlzLnRpbWVDb250ZXh0LnZpc2libGVXaWR0aDtcbiAgfVxuXG4gIHZpc2libGVfZGF0YSh0aW1lQ29udGV4dCwgZGF0YSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBzb3J0X2RhdGEoZGF0YSkgeyB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpc0xheWVyOyIsIid1c2Ugc3RyaWN0JztcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiZWF0R3JpZEF4aXNHZW5lcmF0b3IoYmVhdEdyaWQsIHNpZ25hdHVyZSkge1xuICBjb25zdCBfYmVhdEdyaWQgPSAgYmVhdEdyaWQ7XG4gIHNpZ25hdHVyZSA9IHNpZ25hdHVyZSB8fCAnNC80JztcbiAgY29uc3QgX3VuaXQgPSAxIC8gcGFyc2VJbnQoc2lnbmF0dXJlLnNwbGl0KCcvJylbMV0sIDEwKTtcbiAgY29uc3QgX25iclVuaXRzUGVyTWVzdXJlID0gcGFyc2VJbnQoc2lnbmF0dXJlLnNwbGl0KCcvJylbMF0sIDEwKTtcblxuICByZXR1cm4gZnVuY3Rpb24odGltZUNvbnRleHQpIHtcbiAgICBcbiAgICBsZXQgc3RhcnQgPSBNYXRoLnJvdW5kKE1hdGgubWF4KDAsIF9iZWF0R3JpZC5iZWF0cygtdGltZUNvbnRleHQub2Zmc2V0KSkpO1xuICAgIGxldCBlbmQgPSBNYXRoLnJvdW5kKF9iZWF0R3JpZC5iZWF0cygtdGltZUNvbnRleHQub2Zmc2V0ICsgdGltZUNvbnRleHQudmlzaWJsZUR1cmF0aW9uKSk7XG4gICAgbGV0IGZvY3VzZWQgPSBmYWxzZTtcbiAgICBsZXQgZGF0YSA9IFtdO1xuXG4gICAgZm9yIChsZXQgYmVhdCA9IHN0YXJ0OyBiZWF0IDwgZW5kOyBiZWF0KyspIHtcbiAgICAgIGxldCB0aW1lID0gX2JlYXRHcmlkLnNlY29uZHMoYmVhdCk7XG4gICAgICBsZXQgbGFiZWwgPSBcIlwiICsgYmVhdDtcbiAgICAgIC8vIGxldCBmb2N1c2VkID0gKGJlYXQgJSA0ID09PSAwKT8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgZGF0YS5wdXNoKHsgdGltZSwgZm9jdXNlZCwgbGFiZWwgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmVhdEdyaWRBeGlzR2VuZXJhdG9yOyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGdlbmVyYXRvciB0byBjcmVhdGUgZGF0YSBmb3IgZ3JpZCBheGlzIGFjY29yZGluZyB0byBhIGBicG1gIGFuZCBhIGBtZXRlcmAuXG4gKlxuICogW2V4YW1wbGUgdXNhZ2VdKC4vZXhhbXBsZXMvbGF5ZXItYXhpcy5odG1sKVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBicG0gLSBUaGUgbnVtYmVyIG9mIGJlYXRzIHBlciBtaW51dGVzLlxuICogQHBhcmFtIHtTdHJpbmd9IHNpZ25hdHVyZSAtIFRoZSBtZXRlciBvZiB0aGUgbWVzdXJlIChgJzQvNCdgLCBgJzMvOCdgLCAuLi4pLlxuICogQHJldHVybiB7RnVuY3Rpb259IC0gVGhlIGNvbmZpZ3VyZWQgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBkYXRhIHdoZW4gY2FsbGVkLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBncmlkQXhpc0dlbmVyYXRvcihicG0sIHNpZ25hdHVyZSkge1xuICBjb25zdCBfYnBzID0gIGJwbSAvIDYwOyAvLyBzZWNcbiAgY29uc3QgX3VuaXQgPSAxIC8gcGFyc2VJbnQoc2lnbmF0dXJlLnNwbGl0KCcvJylbMV0sIDEwKTtcbiAgY29uc3QgX25iclVuaXRzUGVyTWVzdXJlID0gcGFyc2VJbnQoc2lnbmF0dXJlLnNwbGl0KCcvJylbMF0sIDEwKTtcblxuICByZXR1cm4gZnVuY3Rpb24odGltZUNvbnRleHQpIHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRpbWVDb250ZXh0LnZpc2libGVEdXJhdGlvbjtcbiAgICBjb25zdCBvZmZzZXQgPSB0aW1lQ29udGV4dC5vZmZzZXQ7XG4gICAgY29uc3QgZGF0YSA9IFtdO1xuXG4gICAgLy8gY29uc3QgbWluID0gTWF0aC5taW4oLW9mZnNldCwgMCk7XG4gICAgY29uc3QgbWluID0gLSBvZmZzZXQ7XG4gICAgLy8gcmVtb3ZlIHRoZSB0aW1lbGluZSdzIG9mZnNldCB0byBrZWVwIHRoZSBsYXllciBjZW50ZXJlZFxuICAgIGNvbnN0IG1heCA9IGR1cmF0aW9uIC0gb2Zmc2V0O1xuXG4gICAgLy8gZGVmaW5lIHBpeGVscyBmb3IgMSBzZWNvbmRcbiAgICBjb25zdCBwaXhlbHNQZXJTZWNvbmQgPSB0aW1lQ29udGV4dC5jb21wdXRlZFBpeGVsc1BlclNlY29uZDtcbiAgICAvLyB0aW1lIGZvciBvbmUgX3VuaXRcbiAgICBjb25zdCB1bml0VGltZSA9IDEgLyBfYnBzO1xuICAgIC8vIGRlZmluZSB0aGUgZmlyc3QgdGljayA+IG1pblxuICAgIGNvbnN0IG1vZHVsbyA9IG1pbiAlIHVuaXRUaW1lO1xuICAgIGNvbnN0IG11bHQgPSAobWluIC0gbW9kdWxvKSAvIHVuaXRUaW1lO1xuICAgIGNvbnN0IGZpcnN0VGlja1RpbWUgPSB1bml0VGltZSAqIG11bHQ7XG4gICAgLy8gdHJhY2sgd2hpY2ggcG9zaXRpb24gb2YgY3VycmVudCBiZWF0IGluIHRoZSBtZXN1cmVcbiAgICBsZXQgcG9zaXRpb25Jbk1lc3VyZSA9IG11bHQgJSBfbmJyVW5pdHNQZXJNZXN1cmU7XG5cbiAgICAvLyByZW1vdmUgbm90IGZvY3VzZWQgYmVhdHMsIGlmIHpvb21lZCBvdXRcbiAgICBjb25zdCBwaXhlbHNQZXJUaWNrID0gcGl4ZWxzUGVyU2Vjb25kIC8gX2JwcztcbiAgICBjb25zdCBtaW5TdGVwID0gNTtcblxuICAgIC8vIHRpbWUgc2hvdWxkIGJlXG4gICAgZm9yIChsZXQgdGltZSA9IGZpcnN0VGlja1RpbWU7IHRpbWUgPCBtYXg7IHRpbWUgKz0gdW5pdFRpbWUpIHtcbiAgICAgIC8vIGZpbmQgZmlyc3QgYmVhdFxuICAgICAgY29uc3QgZm9jdXNlZCA9IChwb3NpdGlvbkluTWVzdXJlKysgJSBfbmJyVW5pdHNQZXJNZXN1cmUgPT09IDApO1xuICAgICAgLy8gaWdub3JlIGlmIHBpeGVscyBwZXIgdGlja3MgaXMgdG9vIHNtYWxsXG4gICAgICBpZiAoKHBpeGVsc1BlclRpY2sgPD0gbWluU3RlcCkgJiYgIWZvY3VzZWQpIHsgY29udGludWU7IH1cblxuICAgICAgZGF0YS5wdXNoKHsgdGltZSwgZm9jdXNlZCB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBncmlkQXhpc0dlbmVyYXRvcjsiLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBwYWRMZWZ0IH0gZnJvbSAnLi4vdXRpbHMvZm9ybWF0JztcblxuLyoqXG4gKiBBIGdlbmVyYXRvciB0byBjcmVhdGUgZGF0YSBmb3IgdGltZSBheGlzLlxuICpcbiAqIFtleGFtcGxlIHVzYWdlXSguL2V4YW1wbGVzL2xheWVyLWF4aXMuaHRtbClcbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gLSBUaGUgY29uZmlndXJlZCBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGRhdGEgd2hlbiBjYWxsZWQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRpbWVBeGlzR2VuZXJhdG9yKCkge1xuICAvLyBhZGQgZmFjdG9yeSB0byBzaGFyZSBBUEkgd2l0aCBicG1HZW5lcmF0b3JcbiAgcmV0dXJuIGZ1bmN0aW9uKHRpbWVDb250ZXh0KSB7XG4gICAgY29uc3QgZHVyYXRpb24gPSB0aW1lQ29udGV4dC52aXNpYmxlRHVyYXRpb247XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGltZUNvbnRleHQub2Zmc2V0O1xuICAgIGNvbnN0IGRhdGEgPSBbXTtcblxuICAgIC8vIGNvbnN0IG1pbiA9IE1hdGgubWluKC1vZmZzZXQsIDApO1xuICAgIGNvbnN0IG1pbiA9IC0gb2Zmc2V0O1xuICAgIC8vIHJlbW92ZSB0aGUgdGltZWxpbmUncyBvZmZzZXQgdG8ga2VlcCB0aGUgbGF5ZXIgY2VudGVyZWRcbiAgICBjb25zdCBtYXggPSBkdXJhdGlvbiAtIG9mZnNldDtcblxuICAgIC8vIGRlZmluZSBwaXhlbHMgZm9yIDEgc2Vjb25kXG4gICAgY29uc3QgcGl4ZWxzUGVyU2Vjb25kID0gdGltZUNvbnRleHQuY29tcHV0ZWRQaXhlbHNQZXJTZWNvbmQ7XG4gICAgY29uc3QgbWluU3RlcCA9IDc7XG5cbiAgICAvLyBkZWZpbmUgYWxsIGRpc3BsYXkgaW5mb3JtYXRpb24gYWNjb3JkaW5nIHRvIHRoZSBwaXhlbHNQZXJTZWNvbmQgcmF0aW9cbiAgICBsZXQgc3RlcCwgdHlwZSwgdG9GaXhlZCwgbWFya2VyTW9kdWxvLCBpbmNsdWRlTW9kdWxvO1xuXG4gICAgaWYgKHBpeGVsc1BlclNlY29uZCAqIDQgPiBtaW5TdGVwKSB7XG4gICAgICBzdGVwID0gMTsgLy8gdGhlIHN0ZXAgdG8gdXNlIHRvIGNvbXB1dGUgdGltZVxuICAgICAgdG9GaXhlZCA9IDA7XG4gICAgICBtYXJrZXJNb2R1bG8gPSA2MDsgLy8gYSB0aW1lc3RhbXAgZXZlcnkgNSBzdGVwaXhlbHNQZXJTZWNvbmRcbiAgICAgIGluY2x1ZGVNb2R1bG8gPSA1OyAvLyBhIHRpY2sgZXZlcnkgNSBzdGVwaXhlbHNQZXJTZWNvbmRcbiAgICAgIHR5cGUgPSAnNjBzZWMnO1xuICAgIH1cblxuICAgIGlmIChwaXhlbHNQZXJTZWNvbmQgKiAyID4gbWluU3RlcCkge1xuICAgICAgc3RlcCA9IDE7XG4gICAgICB0b0ZpeGVkID0gMDtcbiAgICAgIG1hcmtlck1vZHVsbyA9IDMwO1xuICAgICAgaW5jbHVkZU1vZHVsbyA9IDE7XG4gICAgICB0eXBlID0gJzMwc2VjJztcbiAgICB9XG5cbiAgICBpZiAocGl4ZWxzUGVyU2Vjb25kID4gbWluU3RlcCkge1xuICAgICAgc3RlcCA9IDE7XG4gICAgICB0b0ZpeGVkID0gMDtcbiAgICAgIG1hcmtlck1vZHVsbyA9IDEwO1xuICAgICAgaW5jbHVkZU1vZHVsbyA9IDE7XG4gICAgICB0eXBlID0gJ3NlYyc7XG4gICAgfVxuXG4gICAgaWYgKHBpeGVsc1BlclNlY29uZCAvIDEwID4gbWluU3RlcCkge1xuICAgICAgc3RlcCA9IDEgLyAxMDtcbiAgICAgIHRvRml4ZWQgPSAxO1xuICAgICAgbWFya2VyTW9kdWxvID0gMTA7XG4gICAgICBpbmNsdWRlTW9kdWxvID0gMTtcbiAgICAgIHR5cGUgPSAnZHMnO1xuICAgIH1cblxuICAgIGlmIChwaXhlbHNQZXJTZWNvbmQgLyAxMDAgPiBtaW5TdGVwKSB7XG4gICAgICBzdGVwID0gMSAvIDEwMDtcbiAgICAgIHRvRml4ZWQgPSAyO1xuICAgICAgbWFya2VyTW9kdWxvID0gMTA7XG4gICAgICBpbmNsdWRlTW9kdWxvID0gMTtcbiAgICAgIHR5cGUgPSAnY3MnO1xuICAgIH1cblxuICAgIGlmIChwaXhlbHNQZXJTZWNvbmQgLyAxMDAwID4gbWluU3RlcCkge1xuICAgICAgc3RlcCA9IDEgLyAxMDAwO1xuICAgICAgdG9GaXhlZCA9IDM7XG4gICAgICBtYXJrZXJNb2R1bG8gPSAxMDtcbiAgICAgIGluY2x1ZGVNb2R1bG8gPSAxO1xuICAgICAgdHlwZSA9ICdtcyc7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgdGltZSA9IG1pbjsgdGltZSA8IG1heDsgdGltZSArPSBzdGVwKSB7XG4gICAgICBjb25zdCBmb3JtYXR0ZWRUaW1lID0gdGltZS50b0ZpeGVkKHRvRml4ZWQpO1xuXG4gICAgICBpZiAoTWF0aC5yb3VuZChmb3JtYXR0ZWRUaW1lIC8gc3RlcCkgJSBpbmNsdWRlTW9kdWxvICE9PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBhdm9pZCBmbG9hdGluZyBwb2ludCBlcnJvcnNcbiAgICAgIGNvbnN0IGZvY3VzZWQgPSBNYXRoLnJvdW5kKGZvcm1hdHRlZFRpbWUgLyBzdGVwKSAlIG1hcmtlck1vZHVsbyA9PT0gMCA/IHRydWUgOiBmYWxzZTtcblxuICAgICAgY29uc3QgZGF0dW0gPSB7IHRpbWU6IGZvcm1hdHRlZFRpbWUsIGZvY3VzZWQgfTtcblxuICAgICAgaWYgKGZvY3VzZWQgPT09IHRydWUpIHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKDEwMDAgKiBmb3JtYXR0ZWRUaW1lKTtcbiAgICAgICAgY29uc3QgbWluID0gcGFkTGVmdChkYXRlLmdldE1pbnV0ZXMoKSwgMCwgMik7XG4gICAgICAgIGNvbnN0IHNlYyA9IHBhZExlZnQoZGF0ZS5nZXRTZWNvbmRzKCksIDAsIDIpO1xuICAgICAgICBjb25zdCBtaWxsaSA9IHBhZExlZnQoZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSwgMCwgMyk7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gYCR7bWlufToke3NlY306JHttaWxsaX1gO1xuXG4gICAgICAgIGRhdHVtLmxhYmVsID0gbGFiZWw7XG4gICAgICB9XG5cbiAgICAgIGRhdGEucHVzaChkYXR1bSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGltZUF4aXNHZW5lcmF0b3I7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIElzIGFuIGFic3RyYWN0IGNsYXNzIG9yIGludGVyZmFjZSB0byBiZSBvdmVycmlkZW4gaW4gb3JkZXIgdG8gZGVmaW5lIHRoZSB3YXlcbiAqIGEgZ2l2ZW4gc2hhcGUgc2hvdWxkIGJlaGF2ZSB3aGVuIHNlbGVjdGVkIG9yIGVkaXRlZCBieSBhIHVzZXIuIEluc3RhbmNlcyBvZlxuICogYEJhc2VCZWhhdmlvcmAgYXJlIGludGVybmFsbHkgdXNlZCBieSBgTGF5ZXJgIGluc3RhbmNlcyB0byBtb2RpZnkgdGhlIGRhdGFcbiAqIGFjY29yZGluZyB0byBhIHVzZXIgaW50ZXJhY3Rpb24gYW5kIGEgZ2l2ZW4gc2hhcGUuIEEgc2luZ2xlIGluc3RhbmNlIG9mXG4gKiBgQmVoYXZpb3JgIGlzIGNyZWF0ZWQgaW4gb25lIGdpdmVuIHNoYXBlLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHRoZSBvbmx5IG1ldGhvZCB0byBvdmVycmlkZSB0byBkZWZpbmUgYSBuZXcgYmVoYXZpb3IgZm9yIGFcbiAqIHNoYXBlIGlzIHRoZSBgZWRpdGAgbWV0aG9kLiBIb3dldmVyLCBpZiBuZWVkZWQgaW4gc3BlY2lhbCBjYXNlcywgYWxsIHRoZVxuICogc2VsZWN0aW9uIGhhbmRsaW5nIGNhbiBiZSBvdmVycmlkZW4gdG9vLlxuICpcbiAqIFRoZSBmbG93IGlzIHRoZSBmb2xsb3dpbmc6XG4gKiBgRXZlbnRgICAtIChmb3J3YXJkZWQgdG8pIC0+IGBMYXllcmAgLSAoY29tbWFuZCkgLT4gYEJlaGF2aW9yYCAtIChtb2RpZnkpIC0+IGBkYXRhYCAtICh1cGF0ZXMpIC0+IGBTaGFwZWBcbiAqXG4gKiBUaGUgYmVoYXZpb3IgcmVzcG9uc2FiaWxpdHkgaXMgdGhlbiB0byBtb2RpZnkgdGhlIGRhdGEgYWNjb3JkaW5nIHRvIHRoZVxuICogdXNlciBpbnRlcmFjdGlvbnMsIHdoaWxlIHNoYXBlcyBhcmUgYWx3YXlzIGEgdmlldyBvZiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGVcbiAqIGRhdGEuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VCZWhhdmlvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3NlbGVjdGVkRGF0dW1zID0gbmV3IFNldCgpOyAvLyBubyBkdXBsaWNhdGUgaW4gU2V0XG4gICAgdGhpcy5fc2VsZWN0ZWRDbGFzcyA9IG51bGw7XG4gICAgdGhpcy5fbGF5ZXIgPSBudWxsO1xuICB9XG5cbiAgaW5pdGlhbGl6ZShsYXllcikge1xuICAgIHRoaXMuX2xheWVyID0gbGF5ZXI7XG4gICAgdGhpcy5fc2VsZWN0ZWRDbGFzcyA9IGxheWVyLnBhcmFtcy5zZWxlY3RlZENsYXNzTmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSByZWZlcmVuY2VzIHRvIHRoZSBzZWxlY3RlZCBkYXR1bXMuXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEB0b2RvIC0gcmVuYW1lIHRvIGBjbGVhclNlbGVjdGlvbmAgKHJlbW92aW5nIHRoZSBjbGFzcykgP1xuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9zZWxlY3RlZERhdHVtcy5jbGVhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjbGFzcyB0byBhZGQgdG8gdGhlIHNoYXBlcyB3aGVuIHNlbGVjdGVkLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc2V0IHNlbGVjdGVkQ2xhc3ModmFsdWUpIHtcbiAgICB0aGlzLl9zZWxlY3RlZENsYXNzID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNsYXNzIHRvIGFkZCB0byB0aGUgc2hhcGVzIHdoZW4gc2VsZWN0ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgc2VsZWN0ZWRDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRDbGFzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBjb250YWluaW5nIGFsbCB0aGUgc2VsZWN0ZWQgZGF0dW1zIG9mIHRoZSBsYXllci5cbiAgICpcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cbiAgZ2V0IHNlbGVjdGVkRGF0dW1zKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZERhdHVtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0dW0gLSBUaGUgZGF0dW0gdG8gc2VsZWN0LlxuICAgKiBAdG9kbyAtIFBhc3MgdGhlIHNoYXBlIG9iamVjdCB0byBnZXQgdGhlIGFjY2Vzc29ycyA/XG4gICAqL1xuICBzZWxlY3QoZGF0dW0pIHtcbiAgICAvLyAkaXRlbS5jbGFzc0xpc3QuYWRkKHRoaXMuc2VsZWN0ZWRDbGFzcyk7XG4gICAgdGhpcy5fc2VsZWN0ZWREYXR1bXMuYWRkKGRhdHVtKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0dW0gLSBUaGUgZGF0dW0gdG8gdW5zZWxlY3QuXG4gICAqIEB0b2RvIC0gUGFzcyB0aGUgc2hhcGUgb2JqZWN0IHRvIGdldCB0aGUgYWNjZXNzb3JzID9cbiAgICovXG4gIHVuc2VsZWN0KGRhdHVtKSB7XG4gICAgLy8gJGl0ZW0uY2xhc3NMaXN0LnJlbW92ZSh0aGlzLnNlbGVjdGVkQ2xhc3MpO1xuICAgIHRoaXMuX3NlbGVjdGVkRGF0dW1zLmRlbGV0ZShkYXR1bSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdHVtIC0gVGhlIGRhdHVtIHRvIHRvZ2dsZSBzZWxlY3Rpb24uXG4gICAqIEB0b2RvIC0gUGFzcyB0aGUgc2hhcGUgb2JqZWN0IHRvIGdldCB0aGUgYWNjZXNzb3JzID9cbiAgICovXG4gIHRvZ2dsZVNlbGVjdGlvbihkYXR1bSkge1xuICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMuX3NlbGVjdGVkRGF0dW1zLmhhcyhkYXR1bSkgPyAndW5zZWxlY3QnIDogJ3NlbGVjdCc7XG4gICAgcmV0dXJuIHRoaXNbbWV0aG9kXShkYXR1bSk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJmYWNlIG1ldGhvZCB0byBvdmVycmlkZSBpbiBvcmRlciB0byBkZWZpbmUgaXRzIHBhcnRpY3VsYXIgYmVoYXZpb3Igd2hlblxuICAgKiBpbnRlcmFjdGVkIHdpdGguXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZW5kZXJpbmdDb250ZXh0IC0gVGhlIGxheWVyIHJlbmRlcmluZyBjb250ZXh0LlxuICAgKiBAcGFyYW0ge0Jhc2VTaGFwZX0gc2hhcGUgLSBUaGUgc2hhcGUgb2JqZWN0IHRvIGJlIGVkaXRlZC5cbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGRhdHVtIC0gVGhlIHJlbGF0ZWQgZGF0dW0gdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZHggLSBUaGUgdmFsdWUgb2YgdGhlIGludGVyYWN0aW9uIGluIHRoZSB4IGF4aXMgKGluIHBpeGVscykuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkeSAtIFRoZSB2YWx1ZSBvZiB0aGUgaW50ZXJhY3Rpb24gaW4gdGhlIHkgYXhpcyAoaW4gcGl4ZWxzKS5cbiAgICogQHBhcmFtIHtFbGVtZW50fSAkdGFyZ2V0IC0gVGhlIHRhcmdldCBET00gZWxlbWVudCBvZiB0aGUgaW50ZXJhY3Rpb24uXG4gICAqL1xuICBlZGl0KHJlbmRlcmluZ0NvbnRleHQsIHNoYXBlLCBkYXR1bSwgZHgsIGR5LCAkdGFyZ2V0KSB7XG4gICAgLy8gbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBjaGlsZHJlblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUT0RPOiBwb3NzaWJsZSBhY3Rpb25zIGFyZSAnYWRkJywgJ3JlbW92ZScsICdlZGl0JywgJ21pbmltaXplJywgJ2hpZ2hsaWdodCcsICdzZWxlY3QnLCAndW5zZWxlY3QnLlxuICAgKi9cbiAgY2FuKGFjdGlvbiwgZGF0dW1zKSB7IFxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRPRE9cbiAgICovXG4gIG1pbmltaXplKCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvKipcbiAgICogVE9ET1xuICAgKi9cbiAgaGlnaGxpZ2h0KGRhdHVtLCBpc0hpZ2hsaWdodGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgQmFzZUJlaGF2aW9yIGZyb20gJy4vYmFzZS1iZWhhdmlvcic7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmVhdEdyaWRTbmFwU2VnbWVudEJlaGF2aW9yIGV4dGVuZHMgQmFzZUJlaGF2aW9yIHtcblxuICBjb25zdHJ1Y3RvcihiZWF0R3JpZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fYmVhdEdyaWQgPSBiZWF0R3JpZDtcbiAgICB0aGlzLl9zbmFwVG9HcmlkID0gdHJ1ZTtcbiAgfVxuXG4gIHNldCBiZWF0R3JpZCh2YWx1ZSkge1xuICAgIHRoaXMuX2JlYXRHcmlkID0gdmFsdWU7XG4gIH1cblxuICBnZXQgYmVhdEdyaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JlYXRHcmlkO1xuICB9XG5cbiAgc2V0IHNuYXBUb0dyaWQodmFsdWUpIHtcbiAgICB0aGlzLl9zbmFwVG9HcmlkID0gdmFsdWU7XG4gIH1cblxuICBnZXQgc25hcFRvR3JpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc25hcFRvR3JpZDtcbiAgfVxuXG4gIGVkaXQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIGxldCBhY3Rpb24gPSAnbW92ZSc7XG5cbiAgICBpZiAodGFyZ2V0Lmhhc05hbWUoJ2hhbmRsZXInKSkge1xuICAgICAgaWYgKHRhcmdldC5oYXNOYW1lKCdsZWZ0JykpIFxuICAgICAgICBhY3Rpb24gPSAncmVzaXplTGVmdCc7XG4gICAgICBlbHNlIGlmICh0YXJnZXQuaGFzTmFtZSgncmlnaHQnKSkgXG4gICAgICAgIGFjdGlvbiA9ICdyZXNpemVSaWdodCc7XG4gICAgICBlbHNlIFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQga29udmEgc2hhcGUgbmFtZScpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0Lmhhc05hbWUoJ3NlZ21lbnQnKSkgXG4gICAgICBhY3Rpb24gPSAnbW92ZSc7XG4gICAgZWxzZSBcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBrb252YSBzaGFwZSBuYW1lJyk7XG5cbiAgICB0aGlzW2BfJHthY3Rpb259YF0ocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCk7XG4gIH1cblxuICBfbW92ZShyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgY29uc3QgdGltZVRvUGl4ZWwgPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsO1xuICAgIGNvbnN0IGxheWVySGVpZ2h0ID0gcmVuZGVyaW5nQ29udGV4dC5oZWlnaHQ7XG4gICAgLy8gY3VycmVudCB2YWx1ZXNcbiAgICBjb25zdCB4ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChNYXRoLm1heCgwLCBzaGFwZS54KGRhdHVtKSkpO1xuICAgIGNvbnN0IHkgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbChzaGFwZS55KGRhdHVtKSk7XG4gICAgY29uc3Qgd2lkdGggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHNoYXBlLndpZHRoKGRhdHVtKSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwoc2hhcGUuaGVpZ2h0KGRhdHVtKSk7XG4gICAgLy8gdGFyZ2V0IHZhbHVlc1xuICAgIGxldCB0YXJnZXRYID0gTWF0aC5tYXgoeCArIGR4LCAwKTtcbiAgICBsZXQgdGFyZ2V0WSA9IHkgKyBkeTtcblxuICAgIC8vIGxvY2sgaW4gbGF5ZXIncyB5IGF4aXNcbiAgICBpZiAodGFyZ2V0WSA+IGxheWVySGVpZ2h0KSB7XG4gICAgICB0YXJnZXRZID0gbGF5ZXJIZWlnaHQ7XG4gICAgfSBlbHNlIGlmICh0YXJnZXRZIC0gKGxheWVySGVpZ2h0IC0gaGVpZ2h0KSA8IDApIHtcbiAgICAgIHRhcmdldFkgPSAobGF5ZXJIZWlnaHQgLSBoZWlnaHQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNuYXBUb0dyaWQpIHtcbiAgICAgIGNvbnN0IGJlYXQwID0gdGhpcy5fYmVhdEdyaWQuYmVhdHModGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFgpKTtcbiAgICAgIGNvbnN0IHNuYXBwZWQwID0gdGhpcy5fYmVhdEdyaWQuc2Vjb25kcygoZHggPiAwKT8gTWF0aC5jZWlsKGJlYXQwKTogTWF0aC5mbG9vcihiZWF0MCkpO1xuICAgICAgY29uc3QgYmVhdDEgPSB0aGlzLl9iZWF0R3JpZC5iZWF0cyh0aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0WCkgKyBzaGFwZS53aWR0aChkYXR1bSkpO1xuICAgICAgY29uc3Qgc25hcHBlZDEgPSB0aGlzLl9iZWF0R3JpZC5zZWNvbmRzKChkeCA+IDApPyBNYXRoLmNlaWwoYmVhdDEpOiBNYXRoLmZsb29yKGJlYXQxKSk7XG5cbiAgICAgIGlmIChzbmFwcGVkMCAhPT0gc25hcHBlZDEpIHtcbiAgICAgICAgc2hhcGUueChkYXR1bSwgc25hcHBlZDApO1xuICAgICAgICBzaGFwZS53aWR0aChkYXR1bSwgc25hcHBlZDEgLSBzbmFwcGVkMCk7XG4gICAgICAgIC8vIHNoYXBlLnkoZGF0dW0sIHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsLmludmVydCh0YXJnZXRZKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoYXBlLngoZGF0dW0sIHRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRYKSk7XG4gICAgfVxuICAgIFxuICB9XG5cbiAgX3Jlc2l6ZUxlZnQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIGNvbnN0IHRpbWVUb1BpeGVsID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbDtcbiAgICAvLyBjdXJyZW50IHZhbHVlc1xuICAgIGNvbnN0IHggICAgID0gdGltZVRvUGl4ZWwoTWF0aC5tYXgoMCwgc2hhcGUueChkYXR1bSkpKTtcbiAgICBjb25zdCB3aWR0aCA9IHRpbWVUb1BpeGVsKHNoYXBlLndpZHRoKGRhdHVtKSk7XG4gICAgLy8gdGFyZ2V0IHZhbHVlc1xuICAgIGxldCBtYXhUYXJnZXRYICA9IHggKyB3aWR0aDtcbiAgICBsZXQgdGFyZ2V0WCAgICAgPSB4ICsgZHggPCBtYXhUYXJnZXRYID8gTWF0aC5tYXgoeCArIGR4LCAwKSA6IHg7XG4gICAgbGV0IHRhcmdldFdpZHRoID0gdGFyZ2V0WCAhPT0gMCA/IE1hdGgubWF4KHdpZHRoIC0gZHgsIDEpIDogd2lkdGg7XG5cbiAgICBpZiAodGhpcy5zbmFwVG9HcmlkKSB7XG4gICAgICBjb25zdCBiZWF0MCA9IHRoaXMuX2JlYXRHcmlkLmJlYXRzKHRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRYKSk7XG4gICAgICBjb25zdCBzbmFwcGVkMCA9IHRoaXMuX2JlYXRHcmlkLnNlY29uZHMoKGR4ID4gMCk/IE1hdGguY2VpbChiZWF0MCk6IE1hdGguZmxvb3IoYmVhdDApKTtcbiAgICAgIGNvbnN0IGJlYXQxID0gdGhpcy5fYmVhdEdyaWQuYmVhdHModGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFgpICsgdGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFdpZHRoKSk7XG4gICAgICBjb25zdCBzbmFwcGVkMSA9IHRoaXMuX2JlYXRHcmlkLnNlY29uZHMoKGR4ID4gMCk/IE1hdGguY2VpbChiZWF0MSk6IE1hdGguZmxvb3IoYmVhdDEpKTtcblxuXG4gICAgICBpZiAoc25hcHBlZDAgIT09IHNuYXBwZWQxKSB7XG4gICAgICAgIHNoYXBlLngoZGF0dW0sIHNuYXBwZWQwKTtcbiAgICAgICAgc2hhcGUud2lkdGgoZGF0dW0sIHNuYXBwZWQxIC0gc25hcHBlZDApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzaGFwZS54KGRhdHVtLCByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRYKSk7XG4gICAgICBzaGFwZS53aWR0aChkYXR1bSwgcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0V2lkdGgpKTtcbiAgICB9XG5cbiAgICAgIFxuICAgIFxuICB9XG5cbiAgX3Jlc2l6ZVJpZ2h0KHJlbmRlcmluZ0NvbnRleHQsIHNoYXBlLCBkYXR1bSwgZHgsIGR5LCB0YXJnZXQpIHtcbiAgICAvLyBjdXJyZW50IHZhbHVlc1xuICAgIGNvbnN0IHdpZHRoID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS53aWR0aChkYXR1bSkpO1xuICAgIC8vIHRhcmdldCB2YWx1ZXNcbiAgICBsZXQgdGFyZ2V0V2lkdGggPSBNYXRoLm1heCh3aWR0aCArIGR4LCAxKTtcblxuICAgIGlmICh0aGlzLnNuYXBUb0dyaWQpIHtcbiAgICAgIGNvbnN0IGJlYXQxID0gdGhpcy5fYmVhdEdyaWQuYmVhdHMoc2hhcGUueChkYXR1bSkgKyByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRXaWR0aCkpO1xuICAgICAgY29uc3Qgc25hcHBlZDEgPSB0aGlzLl9iZWF0R3JpZC5zZWNvbmRzKChkeCA+IDApPyBNYXRoLmNlaWwoYmVhdDEpOiBNYXRoLmZsb29yKGJlYXQxKSk7XG5cbiAgICAgIGlmIChzbmFwcGVkMSAtIHNoYXBlLngoZGF0dW0pKSB7XG4gICAgICAgIHNoYXBlLndpZHRoKGRhdHVtLCBzbmFwcGVkMSAtIHNoYXBlLngoZGF0dW0pKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2hhcGUud2lkdGgoZGF0dW0sIHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFdpZHRoKSk7XG4gICAgfVxuICB9XG5cbiAgc2VsZWN0KGRhdHVtKSB7XG4gICAgc3VwZXIuc2VsZWN0KGRhdHVtKTtcbiAgICB0aGlzLmhpZ2hsaWdodChkYXR1bSwgdHJ1ZSk7XG4gIH1cblxuICB1bnNlbGVjdChkYXR1bSkge1xuICAgIHN1cGVyLnVuc2VsZWN0KGRhdHVtKTtcbiAgICB0aGlzLmhpZ2hsaWdodChkYXR1bSwgZmFsc2UpO1xuICB9XG5cbiAgaGlnaGxpZ2h0KGRhdHVtLCBpc0hpZ2hsaWdodGVkKSB7XG4gICAgY29uc3Qgc2hhcGUgPSB0aGlzLl9sYXllci5nZXRTaGFwZUZyb21EYXR1bShkYXR1bSk7XG4gICAgaWYgKHNoYXBlKSB7XG4gICAgICBpZiAoaXNIaWdobGlnaHRlZCkge1xuICAgICAgICBzaGFwZS5wYXJhbXMuY29sb3IgPSAncmVkJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNoYXBlLnBhcmFtcy5jb2xvciA9ICdibGFjayc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2hhcGUgZm9yIHRoaXMgZGF0dW0gaW4gdGhpcyBsYXllcicsIHsgZGF0dW06IGRhdHVtLCBsYXllcjogdGhpcy5fbGF5ZXIgfSk7XG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgQmFzZUJlaGF2aW9yIGZyb20gJy4vYmFzZS1iZWhhdmlvcic7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJlYWtwb2ludEJlaGF2aW9yIGV4dGVuZHMgQmFzZUJlaGF2aW9yIHtcbiAgY29uc3RydWN0b3Ioc25hcEZuKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNuYXBGbiA9IHNuYXBGbiB8fCBmdW5jdGlvbihkYXR1bSwgYWNjZXNzb3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGVkaXQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIGNvbnN0IGRhdGEgID0gdGhpcy5fbGF5ZXIuZGF0YTtcbiAgICBjb25zdCBsYXllckhlaWdodCA9IHJlbmRlcmluZ0NvbnRleHQuaGVpZ2h0O1xuICAgIC8vIGN1cnJlbnQgcG9zaXRpb25cbiAgICBjb25zdCB4ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS54KGRhdHVtKSk7XG4gICAgY29uc3QgeSA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHNoYXBlLnkoZGF0dW0pKTtcbiAgICAvLyB0YXJnZXQgcG9zaXRpb25cbiAgICBsZXQgdGFyZ2V0WCA9IHggKyBkeDtcbiAgICBsZXQgdGFyZ2V0WSA9IHkgKyBkeTtcblxuICAgIC8vIGlmIChkYXRhLmxlbmd0aCA+IDIpIHtcbiAgICAvLyAgIC8vIGNyZWF0ZSBhIHNvcnRlZCBtYXAgb2YgYWxsIGB4YCBwb3NpdGlvbnNcbiAgICAvLyAgIGNvbnN0IHhNYXAgPSBkYXRhLm1hcCgoZCkgPT4gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS54KGQpKSk7XG4gICAgLy8gICB4TWFwLnNvcnQoKGEsIGIpID0+IGEgPCBiID8gLTEgOiAxKTtcbiAgICAvLyAgIC8vIGZpbmQgaW5kZXggb2Ygb3VyIHNoYXBlIHggcG9zaXRpb25cbiAgICAvLyAgIGNvbnN0IGluZGV4ID0geE1hcC5pbmRleE9mKHgpO1xuICAgIC8vICAgLy8gbG9jayB0byBuZXh0IHNpYmxpbmdzXG4gICAgLy8gICBpZiAodGFyZ2V0WCA8IHhNYXBbaW5kZXggLSAxXSB8fCB0YXJnZXRYID4geE1hcFtpbmRleCArIDFdKSB7XG4gICAgLy8gICAgIHRhcmdldFggPSB4O1xuICAgIC8vICAgfVxuICAgIC8vIH1cblxuICAgIC8vIEFTU1VNRSBUSEFUIFRIRSAnZGF0YScgQVJSQVkgSVMgT1JERVJFRCBBQ0NPUkRJTkcgVE8geC5cblxuICAgIGlmICh0YXJnZXRYIDwgMClcbiAgICAgIHRhcmdldFggPSAwO1xuXG4gICAgLy8gbG9jayBpbiB5IGF4aXNcbiAgICBpZiAodGFyZ2V0WSA8IDApIHtcbiAgICAgIHRhcmdldFkgPSAwO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0WSA+IGxheWVySGVpZ2h0KSB7XG4gICAgICB0YXJnZXRZID0gbGF5ZXJIZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGRhdHVtIHdpdGggbmV3IHZhbHVlc1xuICAgIHNoYXBlLngoZGF0dW0sIHRoaXMuc25hcEZuKGRhdHVtLCAneCcsIHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFgpKSk7XG4gICAgc2hhcGUueShkYXR1bSwgdGhpcy5zbmFwRm4oZGF0dW0sICd5JywgcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFkpKSk7XG4gIH1cblxuICBzZWxlY3QoZGF0dW0pIHtcbiAgICBzdXBlci5zZWxlY3QoZGF0dW0pO1xuICAgIHRoaXMuaGlnaGxpZ2h0KGRhdHVtLCB0cnVlKTtcbiAgfVxuXG4gIHVuc2VsZWN0KGRhdHVtKSB7XG4gICAgc3VwZXIudW5zZWxlY3QoZGF0dW0pO1xuICAgIHRoaXMuaGlnaGxpZ2h0KGRhdHVtLCBmYWxzZSk7XG4gIH1cblxuICBoaWdobGlnaHQoZGF0dW0sIGlzSGlnaGxpZ2h0ZWQpIHtcbiAgICBjb25zdCBzaGFwZSA9IHRoaXMuX2xheWVyLmdldFNoYXBlRnJvbURhdHVtKGRhdHVtKTtcbiAgICBpZiAoc2hhcGUpIHtcbiAgICAgIGlmIChpc0hpZ2hsaWdodGVkKSB7XG4gICAgICAgIHNoYXBlLnBhcmFtcy5jb2xvciA9ICdyZWQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2hhcGUucGFyYW1zLmNvbG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNoYXBlIGZvciB0aGlzIGRhdHVtIGluIHRoaXMgbGF5ZXInLCB7IGRhdHVtOiBkYXR1bSwgbGF5ZXI6IHRoaXMuX2xheWVyIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEJhc2VCZWhhdmlvciBmcm9tICcuL2Jhc2UtYmVoYXZpb3InO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcmtlckJlaGF2aW9yIGV4dGVuZHMgQmFzZUJlaGF2aW9yIHtcblxuXHRjb25zdHJ1Y3RvcihzbmFwRm4pIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuc25hcEZuID0gc25hcEZuIHx8IGZ1bmN0aW9uKGRhdHVtLCBhY2Nlc3NvciwgdmFsdWUpIHtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9O1xuXHR9XG5cblx0ZWRpdChyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG5cdFx0Y29uc3QgeCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoc2hhcGUueChkYXR1bSkpO1xuXHRcdGxldCB0YXJnZXRYID0gKHggKyBkeCkgPiAwID8geCArIGR4IDogMDtcblxuXHRcdHNoYXBlLngoZGF0dW0sIHRoaXMuc25hcEZuKGRhdHVtLCAneCcsIHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFgpKSk7XG5cdH1cblxuXHRzZWxlY3QoZGF0dW0pIHtcblx0XHRzdXBlci5zZWxlY3QoZGF0dW0pO1xuXHRcdHRoaXMuaGlnaGxpZ2h0KGRhdHVtLCB0cnVlKTtcblx0fVxuXG5cdHVuc2VsZWN0KGRhdHVtKSB7XG5cdFx0c3VwZXIudW5zZWxlY3QoZGF0dW0pO1xuXHRcdHRoaXMuaGlnaGxpZ2h0KGRhdHVtLCBmYWxzZSk7XG5cdH1cblxuXHRoaWdobGlnaHQoZGF0dW0sIGlzSGlnaGxpZ2h0ZWQpIHtcblx0XHRjb25zdCBzaGFwZSA9IHRoaXMuX2xheWVyLmdldFNoYXBlRnJvbURhdHVtKGRhdHVtKTtcblx0XHRpZiAoc2hhcGUpIHtcblx0XHRcdGlmIChpc0hpZ2hsaWdodGVkKSB7XG5cdFx0XHRcdHNoYXBlLnBhcmFtcy5jb2xvciA9IHNoYXBlLnBhcmFtcy5oYW5kbGVyQ29sb3IgPSAncmVkJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNoYXBlLnBhcmFtcy5jb2xvciA9IHNoYXBlLnBhcmFtcy5oYW5kbGVyQ29sb3IgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTm8gc2hhcGUgZm9yIHRoaXMgZGF0dW0gaW4gdGhpcyBsYXllcicsIHsgZGF0dW06IGRhdHVtLCBsYXllcjogdGhpcy5fbGF5ZXIgfSk7XG5cdFx0fVxuXHR9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgQmFzZUJlaGF2aW9yIGZyb20gJy4vYmFzZS1iZWhhdmlvcic7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9CZWhhdmlvciBleHRlbmRzIEJhc2VCZWhhdmlvciB7XG5cbiAgc2V0IHNlbGVjdGVkQ2xhc3ModmFsdWUpIHsgfVxuXG4gIGdldCBzZWxlY3RlZENsYXNzKCkgeyB9XG5cbiAgZ2V0IHNlbGVjdGVkRGF0dW1zKCkgeyB9XG5cbiAgc2VsZWN0KGRhdHVtKSB7IH1cblxuICB1bnNlbGVjdChkYXR1bSkgeyB9XG5cbiAgdG9nZ2xlU2VsZWN0aW9uKGRhdHVtKSB7IH1cblxuICBlZGl0KHJlbmRlcmluZ0NvbnRleHQsIHNoYXBlLCBkYXR1bSwgZHgsIGR5LCAkdGFyZ2V0KSB7IH1cblxuICBjYW4oYWN0aW9uLCBkYXR1bXMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgY3JlYXRlKGRhdHVtKSB7IH1cblxuICByZW1vdmUoZGF0dW0pIHsgfVxuXG4gIG1pbmltaXplKCkgeyB9XG5cbiAgaGlnaGxpZ2h0KGRhdHVtLCBpc0hpZ2hsaWdodGVkKSB7IH1cblxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEJhc2VCZWhhdmlvciBmcm9tICcuL2Jhc2UtYmVoYXZpb3InO1xuXG4vKlxuICogIEFsbG93IHRvIGNyZWF0ZSBhIG5ldyBkYXR1bSBvbmx5IGluIGVtcHR5IHNwYWNlcy5cbiAqICBXaGVuIHRoZSBsYXllciByZXF1ZXN0cyBhbiBlZGl0LCByZWZ1c2UgaXQgaWYgdGhlIG5ldyBkYXR1bSB2ZXJzaW9uIG92ZXJsYXBzIGFuIGV4aXN0aW5nIHNlZ21lbnQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vSG9yaXpvbnRhbGxPdmVybGFwcGluZ1NlZ21lbnRzQmVoYXZpb3IgZXh0ZW5kcyBCYXNlQmVoYXZpb3Ige1xuICAvKiBUaGlzIGNsYXNzIG5hbWUgY2xlYXJseSBzaG93cyB0aGUgYXV0aG9yIHN1ZmZlcnMgZnJvbSBzb21lIEphdmEvQ09CT0wgcmVsYXRlZCBjb2duaXRpdmUgZGlzZWFzZS4gKi9cblxuICBjb25zdHJ1Y3RvcihhY2Nlc3NvcnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZHVtbXkgPSB7XG4gICAgICB4OiAoZCwgdikgPT4ge1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB2ID0gbnVsbDtcbiAgICAgICAgaWYgKHYgPT09IG51bGwpIHsgcmV0dXJuIGQueDsgfVxuICAgICAgICBkLnggPSB2O1xuICAgICAgfSwgXG4gICAgICB3aWR0aDogKGQsIHYpID0+IHtcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkgdiA9IG51bGw7XG4gICAgICAgIGlmICh2ID09PSBudWxsKSB7IHJldHVybiBkLndpZHRoOyB9XG4gICAgICAgIGQud2lkdGggPSB2O1xuICAgICAgfVxuICAgIH07XG4gICAgZm9yIChsZXQga2V5IGluIGFjY2Vzc29ycykgeyB0aGlzLmR1bW15W2tleV0gPSBhY2Nlc3NvcnNba2V5XTsgfVxuICB9XG5cbiAgaW5pdGlhbGl6ZShsYXllcikge1xuICAgIHN1cGVyLmluaXRpYWxpemUobGF5ZXIpO1xuICAgIGxldCBhY2Nlc3NvcnMgPSAodGhpcy5fbGF5ZXIuX3NoYXBlQ29uZmlndXJhdGlvbik/IHRoaXMuX2xheWVyLl9zaGFwZUNvbmZpZ3VyYXRpb24uYWNjZXNzb3JzIDoge307XG4gICAgZm9yIChsZXQga2V5IGluIGFjY2Vzc29ycykgeyB0aGlzLmR1bW15W2tleV0gPSBhY2Nlc3NvcnNba2V5XTsgfVxuICB9XG5cbiAgaW50ZXJzZWN0cyhkYXR1bTEsIGRhdHVtMikge1xuICAgIGlmICh0aGlzLmR1bW15LngoZGF0dW0xKSA+PSB0aGlzLmR1bW15LngoZGF0dW0yKSArIHRoaXMuZHVtbXkud2lkdGgoZGF0dW0yKSB8fCBcbiAgICAgICAgdGhpcy5kdW1teS54KGRhdHVtMSkgKyB0aGlzLmR1bW15LndpZHRoKGRhdHVtMSkgPD0gdGhpcy5kdW1teS54KGRhdHVtMikpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZWxzZSBcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgdGhpcy5pbnRlcnNlY3RzID0gbnVsbDtcbiAgfVxuXG4gIGVkaXQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIGxldCBhY3Rpb24gPSAnbW92ZSc7XG5cbiAgICBpZiAodGFyZ2V0Lmhhc05hbWUoJ2hhbmRsZXInKSkge1xuICAgICAgaWYgKHRhcmdldC5oYXNOYW1lKCdsZWZ0JykpIFxuICAgICAgICBhY3Rpb24gPSAncmVzaXplTGVmdCc7XG4gICAgICBlbHNlIGlmICh0YXJnZXQuaGFzTmFtZSgncmlnaHQnKSkgXG4gICAgICAgIGFjdGlvbiA9ICdyZXNpemVSaWdodCc7XG4gICAgICBlbHNlIFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQga29udmEgc2hhcGUgbmFtZScpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0Lmhhc05hbWUoJ3NlZ21lbnQnKSkgXG4gICAgICBhY3Rpb24gPSAnbW92ZSc7XG4gICAgZWxzZSBcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBrb252YSBzaGFwZSBuYW1lJyk7XG5cbiAgICB0aGlzW2BfJHthY3Rpb259YF0ocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCk7XG4gIH1cblxuICBfbW92ZShyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgY29uc3QgbGF5ZXJIZWlnaHQgPSByZW5kZXJpbmdDb250ZXh0LmhlaWdodDtcbiAgICAvLyBjdXJyZW50IHZhbHVlc1xuICAgIGxldCB4ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS54KGRhdHVtKSk7XG4gICAgY29uc3QgeSA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHNoYXBlLnkoZGF0dW0pKTtcbiAgICBjb25zdCB3aWR0aCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoc2hhcGUud2lkdGgoZGF0dW0pKTtcbiAgICBjb25zdCBoZWlnaHQgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbChzaGFwZS5oZWlnaHQoZGF0dW0pKTtcbiAgICAvLyB0YXJnZXQgdmFsdWVzXG4gICAgbGV0IHRhcmdldFggPSBNYXRoLm1heCh4ICsgZHgsIDApO1xuXG4gICAgdGFyZ2V0WCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFgpO1xuICAgIHggPSBzaGFwZS54KGRhdHVtKTtcblxuICAgIHNoYXBlLngoZGF0dW0sIHRhcmdldFgpO1xuXG4gICAgZm9yIChsZXQgaT0wOyBpIDwgdGhpcy5fbGF5ZXIuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuX2xheWVyLmRhdGFbaV0gIT09IGRhdHVtICYmIHRoaXMuaW50ZXJzZWN0cyh0aGlzLl9sYXllci5kYXRhW2ldLCBkYXR1bSkpIHtcbiAgICAgICAgaWYgKHggPCBzaGFwZS54KHRoaXMuX2xheWVyLmRhdGFbaV0pKSBcbiAgICAgICAgICBzaGFwZS54KGRhdHVtLCBzaGFwZS54KHRoaXMuX2xheWVyLmRhdGFbaV0pIC0gc2hhcGUud2lkdGgoZGF0dW0pKTtcbiAgICAgICAgZWxzZSBcbiAgICAgICAgICBzaGFwZS54KGRhdHVtLCBzaGFwZS54KHRoaXMuX2xheWVyLmRhdGFbaV0pICsgc2hhcGUud2lkdGgodGhpcy5fbGF5ZXIuZGF0YVtpXSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3Jlc2l6ZUxlZnQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIC8vIGN1cnJlbnQgdmFsdWVzXG4gICAgbGV0IHggICAgID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS54KGRhdHVtKSk7XG4gICAgbGV0IHdpZHRoID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS53aWR0aChkYXR1bSkpO1xuICAgIC8vIHRhcmdldCB2YWx1ZXNcbiAgICBsZXQgbWF4VGFyZ2V0WCAgPSB4ICsgd2lkdGg7XG4gICAgbGV0IHRhcmdldFggICAgID0geCArIGR4IDwgbWF4VGFyZ2V0WCA/IE1hdGgubWF4KHggKyBkeCwgMCkgOiB4O1xuICAgIGxldCB0YXJnZXRXaWR0aCA9IHRhcmdldFggIT09IDAgPyBNYXRoLm1heCh3aWR0aCAtIGR4LCAxKSA6IHdpZHRoO1xuXG4gICAgdGFyZ2V0WCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFgpO1xuICAgIHRhcmdldFdpZHRoID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0V2lkdGgpO1xuICAgIHggPSBzaGFwZS54KGRhdHVtKTtcbiAgICB3aWR0aCA9IHNoYXBlLndpZHRoKGRhdHVtKTtcblxuICAgIHNoYXBlLngoZGF0dW0sIHRhcmdldFgpO1xuICAgIHNoYXBlLndpZHRoKGRhdHVtLCB0YXJnZXRXaWR0aCk7XG5cbiAgICBmb3IgKGxldCBpPTA7IGkgPCB0aGlzLl9sYXllci5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5fbGF5ZXIuZGF0YVtpXSAhPT0gZGF0dW0gJiYgdGhpcy5pbnRlcnNlY3RzKHRoaXMuX2xheWVyLmRhdGFbaV0sIGRhdHVtKSkge1xuICAgICAgICBzaGFwZS53aWR0aChkYXR1bSwgKHggKyB3aWR0aCkgLSAoc2hhcGUueCh0aGlzLl9sYXllci5kYXRhW2ldKSArIHNoYXBlLndpZHRoKHRoaXMuX2xheWVyLmRhdGFbaV0pKSk7XG4gICAgICAgIHNoYXBlLngoZGF0dW0sIHNoYXBlLngodGhpcy5fbGF5ZXIuZGF0YVtpXSkgKyBzaGFwZS53aWR0aCh0aGlzLl9sYXllci5kYXRhW2ldKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIF9yZXNpemVSaWdodChyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgLy8gY3VycmVudCB2YWx1ZXNcbiAgICBsZXQgd2lkdGggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHNoYXBlLndpZHRoKGRhdHVtKSk7XG4gICAgLy8gdGFyZ2V0IHZhbHVlc1xuICAgIGxldCB0YXJnZXRXaWR0aCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KE1hdGgubWF4KHdpZHRoICsgZHgsIDEpKTtcbiAgICBsZXQgeCA9IHNoYXBlLngoZGF0dW0pO1xuICAgIHdpZHRoID0gc2hhcGUud2lkdGgoZGF0dW0pO1xuXG4gICAgc2hhcGUud2lkdGgoZGF0dW0sIHRhcmdldFdpZHRoKTtcblxuICAgIGZvciAobGV0IGk9MDsgaSA8IHRoaXMuX2xheWVyLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLl9sYXllci5kYXRhW2ldICE9PSBkYXR1bSAmJiB0aGlzLmludGVyc2VjdHModGhpcy5fbGF5ZXIuZGF0YVtpXSwgZGF0dW0pKSB7XG4gICAgICAgIHNoYXBlLndpZHRoKGRhdHVtLCBzaGFwZS54KHRoaXMuX2xheWVyLmRhdGFbaV0pIC0gc2hhcGUueChkYXR1bSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2FuKGFjdGlvbiwgZGF0dW1zKSB7IFxuICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICBjYXNlICdhZGQnOiBcbiAgICAgICAgbGV0IGk9MCwgaj0wO1xuICAgICAgICBmb3IgKGk9MDsgaSA8IGRhdHVtcy5sZW5ndGg7IGkrKykgXG4gICAgICAgICAgZm9yIChqPWkrMTsgaiA8IGRhdHVtcy5sZW5ndGg7IGorKykgXG4gICAgICAgICAgICBpZiAoZGF0dW1zW2ldICE9PSBkYXR1bXNbal0gJiYgdGhpcy5pbnRlcnNlY3RzKGRhdHVtc1tpXSwgZGF0dW1zW2pdKSlcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGZvciAoaT0wOyBpIDwgdGhpcy5fbGF5ZXIuZGF0YS5sZW5ndGg7IGkrKykgXG4gICAgICAgICAgZm9yIChqPTA7IGogPCBkYXR1bXMubGVuZ3RoOyBqKyspIFxuICAgICAgICAgICAgaWYgKHRoaXMuX2xheWVyLmRhdGFbaV0gIT09IGRhdHVtc1tqXSAmJiB0aGlzLmludGVyc2VjdHModGhpcy5fbGF5ZXIuZGF0YVtpXSwgZGF0dW1zW2pdKSlcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlQmVoYXZpb3IgZnJvbSAnLi9iYXNlLWJlaGF2aW9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Nyb2xsU2VnbWVudEJlaGF2aW9yIGV4dGVuZHMgQmFzZUJlaGF2aW9yIHtcbiAgY29uc3RydWN0b3IodGFyZ2V0VGltZWxpbmVzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnRhcmdldFRpbWVsaW5lcyA9IHRhcmdldFRpbWVsaW5lcztcbiAgfVxuXG4gIGVkaXQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIGxldCBhY3Rpb24gPSAnbW92ZSc7XG5cbiAgICBpZiAodGFyZ2V0Lmhhc05hbWUoJ2hhbmRsZXInKSkge1xuICAgICAgaWYgKHRhcmdldC5oYXNOYW1lKCdsZWZ0JykpIFxuICAgICAgICBhY3Rpb24gPSAncmVzaXplTGVmdCc7XG4gICAgICBlbHNlIGlmICh0YXJnZXQuaGFzTmFtZSgncmlnaHQnKSkgXG4gICAgICAgIGFjdGlvbiA9ICdyZXNpemVSaWdodCc7XG4gICAgICBlbHNlIFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQga29udmEgc2hhcGUgbmFtZScpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0Lmhhc05hbWUoJ3NlZ21lbnQnKSkgXG4gICAgICBhY3Rpb24gPSAnbW92ZSc7XG4gICAgZWxzZSBcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBrb252YSBzaGFwZSBuYW1lJyk7XG5cbiAgICB0aGlzW2BfJHthY3Rpb259YF0ocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCk7XG4gIH1cblxuICBfbW92ZShyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgY29uc3QgbGF5ZXJIZWlnaHQgPSByZW5kZXJpbmdDb250ZXh0LmhlaWdodDtcbiAgICAvLyBjdXJyZW50IHZhbHVlc1xuICAgIGNvbnN0IHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHNoYXBlLngoZGF0dW0pKTtcbiAgICBjb25zdCB5ID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwoc2hhcGUueShkYXR1bSkpO1xuICAgIGNvbnN0IHdpZHRoID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS53aWR0aChkYXR1bSkpO1xuICAgIGNvbnN0IGhlaWdodCA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHNoYXBlLmhlaWdodChkYXR1bSkpO1xuICAgIC8vIHRhcmdldCB2YWx1ZXNcbiAgICBsZXQgdGFyZ2V0WCA9IE1hdGgubWF4KHggKyBkeCwgMCk7XG4gICAgbGV0IHRhcmdldFkgPSB5ICsgZHk7XG5cbiAgICAvLyBsb2NrIGluIGxheWVyJ3MgeSBheGlzXG4gICAgaWYgKHRhcmdldFkgPiBsYXllckhlaWdodCkge1xuICAgICAgdGFyZ2V0WSA9IGxheWVySGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0WSAtIChsYXllckhlaWdodCAtIGhlaWdodCkgPCAwKSB7XG4gICAgICB0YXJnZXRZID0gKGxheWVySGVpZ2h0IC0gaGVpZ2h0KTtcbiAgICB9XG5cbiAgICBzaGFwZS54KGRhdHVtLCByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRYKSk7XG4gICAgc2hhcGUueShkYXR1bSwgcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFkpKTtcblxuICAgIHRoaXMuX3JlZnJlc2goc2hhcGUueChkYXR1bSksIHNoYXBlLndpZHRoKGRhdHVtKSk7XG4gIH1cblxuICBfcmVzaXplTGVmdChyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgLy8gY3VycmVudCB2YWx1ZXNcbiAgICBjb25zdCB4ICAgICA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoc2hhcGUueChkYXR1bSkpO1xuICAgIGNvbnN0IHdpZHRoID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS53aWR0aChkYXR1bSkpO1xuICAgIC8vIHRhcmdldCB2YWx1ZXNcbiAgICBsZXQgbWF4VGFyZ2V0WCAgPSB4ICsgd2lkdGg7XG4gICAgbGV0IHRhcmdldFggICAgID0geCArIGR4IDwgbWF4VGFyZ2V0WCA/IE1hdGgubWF4KHggKyBkeCwgMCkgOiB4O1xuICAgIGxldCB0YXJnZXRXaWR0aCA9IHRhcmdldFggIT09IDAgPyBNYXRoLm1heCh3aWR0aCAtIGR4LCAxKSA6IHdpZHRoO1xuXG4gICAgc2hhcGUueChkYXR1bSwgcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0WCkpO1xuICAgIHNoYXBlLndpZHRoKGRhdHVtLCByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRXaWR0aCkpO1xuXG4gICAgdGhpcy5fcmVmcmVzaChzaGFwZS54KGRhdHVtKSwgc2hhcGUud2lkdGgoZGF0dW0pKTtcblxuICB9XG5cbiAgX3Jlc2l6ZVJpZ2h0KHJlbmRlcmluZ0NvbnRleHQsIHNoYXBlLCBkYXR1bSwgZHgsIGR5LCB0YXJnZXQpIHtcbiAgICAvLyBjdXJyZW50IHZhbHVlc1xuICAgIGNvbnN0IHdpZHRoID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS53aWR0aChkYXR1bSkpO1xuICAgIC8vIHRhcmdldCB2YWx1ZXNcbiAgICBsZXQgdGFyZ2V0V2lkdGggPSBNYXRoLm1heCh3aWR0aCArIGR4LCAxKTtcblxuICAgIHNoYXBlLndpZHRoKGRhdHVtLCByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRXaWR0aCkpO1xuXG4gICAgdGhpcy5fcmVmcmVzaChzaGFwZS54KGRhdHVtKSwgc2hhcGUud2lkdGgoZGF0dW0pKTtcbiAgfVxuXG4gIF9yZWZyZXNoKHgsIHdpZHRoKSB7XG4gICAgeCA9ICh4ID09PSB1bmRlZmluZWQpPyB0aGlzLmxheWVyLmRhdGFbMF0ueCA6IHg7IFxuICAgIHdpZHRoID0gKHdpZHRoID09PSB1bmRlZmluZWQpPyB0aGlzLmxheWVyLmRhdGFbMF0ud2lkdGggOiB3aWR0aDsgXG4gICAgdGhpcy50YXJnZXRUaW1lbGluZXMuZm9yRWFjaCgodGltZWxpbmUpID0+IHtcbiAgICAgIHRpbWVsaW5lLnZpc2libGVJbnRlcnZhbCA9IHtzdGFydDogeCwgZHVyYXRpb246IHdpZHRofTtcbiAgICAgIHRpbWVsaW5lLnRyYWNrcy51cGRhdGUoKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEJhc2VCZWhhdmlvciBmcm9tICcuL2Jhc2UtYmVoYXZpb3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWdtZW50QmVoYXZpb3IgZXh0ZW5kcyBCYXNlQmVoYXZpb3Ige1xuICBjb25zdHJ1Y3RvcihzbmFwRm4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc25hcEZuID0gc25hcEZuIHx8IGZ1bmN0aW9uKGRhdHVtLCBhY2Nlc3NvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZWRpdChyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgbGV0IGFjdGlvbiA9ICdtb3ZlJztcblxuICAgIGlmICh0YXJnZXQuaGFzTmFtZSgnaGFuZGxlcicpKSB7XG4gICAgICBpZiAodGFyZ2V0Lmhhc05hbWUoJ2xlZnQnKSkgXG4gICAgICAgIGFjdGlvbiA9ICdyZXNpemVMZWZ0JztcbiAgICAgIGVsc2UgaWYgKHRhcmdldC5oYXNOYW1lKCdyaWdodCcpKSBcbiAgICAgICAgYWN0aW9uID0gJ3Jlc2l6ZVJpZ2h0JztcbiAgICAgIGVsc2UgaWYgKHRhcmdldC5oYXNOYW1lKCd0b3AnKSlcbiAgICAgIFx0YWN0aW9uID0gJ3Jlc2l6ZVRvcCc7XG4gICAgICBlbHNlIGlmICh0YXJnZXQuaGFzTmFtZSgnYm90dG9tJykpXG4gICAgICBcdGFjdGlvbiA9ICdyZXNpemVCb3R0b20nO1xuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQga29udmEgc2hhcGUgbmFtZScpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0Lmhhc05hbWUoJ3NlZ21lbnQnKSkgXG4gICAgICBhY3Rpb24gPSAnbW92ZSc7XG4gICAgZWxzZSBcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBrb252YSBzaGFwZSBuYW1lJyk7XG5cbiAgICB0aGlzW2BfJHthY3Rpb259YF0ocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCk7XG4gIH1cblxuICBfbW92ZShyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgY29uc3QgbGF5ZXJIZWlnaHQgPSByZW5kZXJpbmdDb250ZXh0LmhlaWdodDtcbiAgICAvLyBjdXJyZW50IHZhbHVlc1xuICAgIGNvbnN0IHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHNoYXBlLngoZGF0dW0pKTtcbiAgICBjb25zdCB5ID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwoc2hhcGUueShkYXR1bSkpO1xuICAgIGNvbnN0IHdpZHRoID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS53aWR0aChkYXR1bSkpO1xuICAgIC8vIGNvbnN0IGhlaWdodCA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHNoYXBlLmhlaWdodChkYXR1bSkpO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGguYWJzKHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHNoYXBlLnkoZGF0dW0pICsgc2hhcGUuaGVpZ2h0KGRhdHVtKSkgLSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbChzaGFwZS55KGRhdHVtKSkpO1xuICAgIFxuICAgIC8vIHRhcmdldCB2YWx1ZXNcbiAgICBsZXQgdGFyZ2V0WCA9IE1hdGgubWF4KHggKyBkeCwgMCk7XG4gICAgbGV0IHRhcmdldFkgPSBNYXRoLm1pbihNYXRoLm1heCgwLCB5ICsgZHkpLCBsYXllckhlaWdodCk7XG5cbiAgICAvLyBjb25zb2xlLmxvZyhbdGFyZ2V0WSwgeSwgaGVpZ2h0LCBsYXllckhlaWdodF0pO1xuXG4gICAgLy8gbG9jayBpbiBsYXllcidzIHkgYXhpc1xuICAgIGlmICh0YXJnZXRZID4gbGF5ZXJIZWlnaHQpIHtcbiAgICAgIHRhcmdldFkgPSBsYXllckhlaWdodDtcbiAgICB9IGVsc2UgaWYgKHRhcmdldFkgLSBoZWlnaHQgPCAwKSB7XG4gICAgICB0YXJnZXRZID0gaGVpZ2h0O1xuICAgIH1cblxuICAgIHNoYXBlLngoZGF0dW0sIHRoaXMuc25hcEZuKGRhdHVtLCAneCcsIHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFgpKSk7XG4gICAgc2hhcGUueShkYXR1bSwgdGhpcy5zbmFwRm4oZGF0dW0sICd5JywgcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFkpKSk7XG4gIH1cblxuICBfcmVzaXplTGVmdChyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgLy8gY3VycmVudCB2YWx1ZXNcbiAgICBjb25zdCB4ICAgICA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoc2hhcGUueChkYXR1bSkpO1xuICAgIGNvbnN0IHdpZHRoID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS53aWR0aChkYXR1bSkpO1xuICAgIC8vIHRhcmdldCB2YWx1ZXNcbiAgICBsZXQgbWF4VGFyZ2V0WCAgPSB4ICsgd2lkdGg7XG4gICAgbGV0IHRhcmdldFggICAgID0geCArIGR4IDwgbWF4VGFyZ2V0WCA/IE1hdGgubWF4KHggKyBkeCwgMCkgOiB4O1xuICAgIGxldCB0YXJnZXRXaWR0aCA9IHRhcmdldFggIT09IDAgPyBNYXRoLm1heCh3aWR0aCAtIGR4LCAxKSA6IHdpZHRoO1xuXG4gICAgc2hhcGUueChkYXR1bSwgdGhpcy5zbmFwRm4oZGF0dW0sICd4JywgcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0WCkpKTtcbiAgICBzaGFwZS53aWR0aChkYXR1bSwgdGhpcy5zbmFwRm4oZGF0dW0sICd3aWR0aCcsIHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFdpZHRoKSkpO1xuICB9XG5cbiAgX3Jlc2l6ZVJpZ2h0KHJlbmRlcmluZ0NvbnRleHQsIHNoYXBlLCBkYXR1bSwgZHgsIGR5LCB0YXJnZXQpIHtcbiAgICAvLyBjdXJyZW50IHZhbHVlc1xuICAgIGNvbnN0IHdpZHRoID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS53aWR0aChkYXR1bSkpO1xuICAgIC8vIHRhcmdldCB2YWx1ZXNcbiAgICBsZXQgdGFyZ2V0V2lkdGggPSBNYXRoLm1heCh3aWR0aCArIGR4LCAxKTtcblxuICAgIHNoYXBlLndpZHRoKGRhdHVtLCB0aGlzLnNuYXBGbihkYXR1bSwgJ3dpZHRoJywgcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0V2lkdGgpKSk7XG4gIH1cblxuICBfcmVzaXplVG9wKHJlbmRlcmluZ0NvbnRleHQsIHNoYXBlLCBkYXR1bSwgZHgsIGR5LCB0YXJnZXQpIHtcbiAgXHQvLyBjb25zb2xlLmxvZygndG9wICcgKyBkeSk7XG5cblx0Y29uc3QgaGVpZ2h0ID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwoc2hhcGUuaGVpZ2h0KGRhdHVtKSk7XG5cbiAgXHRsZXQgdGFyZ2V0SGVpZ2h0ID0gaGVpZ2h0ICsgZHk7XG5cbiAgXHRzaGFwZS5oZWlnaHQoZGF0dW0sIHRoaXMuc25hcEZuKGRhdHVtLCAnaGVpZ2h0JywgcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldEhlaWdodCkpKTtcblxuICB9XG5cbiAgX3Jlc2l6ZUJvdHRvbShyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gIFx0Ly8gY29uc29sZS5sb2coJ2JvdHRvbSAnICsgZHkpO1xuXG4gICAgY29uc3QgbGF5ZXJIZWlnaHQgPSByZW5kZXJpbmdDb250ZXh0LmhlaWdodDtcbiAgICBjb25zdCB5ID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwoc2hhcGUueShkYXR1bSkpO1xuICAgIGNvbnN0IGhlaWdodCA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHNoYXBlLmhlaWdodChkYXR1bSkpO1xuXG4gIFx0bGV0IHRhcmdldFkgPSBNYXRoLm1pbihNYXRoLm1heCgwLCB5ICsgZHkpLCBsYXllckhlaWdodCk7XG4gIFx0bGV0IHRhcmdldEhlaWdodCA9IGhlaWdodCAtIGR5O1xuXG4gIFx0c2hhcGUueShkYXR1bSwgdGhpcy5zbmFwRm4oZGF0dW0sICd5JywgcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFkpKSk7XG4gIFx0c2hhcGUuaGVpZ2h0KGRhdHVtLCB0aGlzLnNuYXBGbihkYXR1bSwgJ2hlaWdodCcsIHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsLmludmVydCh0YXJnZXRIZWlnaHQpKSk7XG5cbiAgfVxuXG4gIHNlbGVjdChkYXR1bSkge1xuICAgIHN1cGVyLnNlbGVjdChkYXR1bSk7XG4gICAgdGhpcy5oaWdobGlnaHQoZGF0dW0sIHRydWUpO1xuICB9XG5cbiAgdW5zZWxlY3QoZGF0dW0pIHtcbiAgICBzdXBlci51bnNlbGVjdChkYXR1bSk7XG4gICAgdGhpcy5oaWdobGlnaHQoZGF0dW0sIGZhbHNlKTtcbiAgfVxuXG4gIGhpZ2hsaWdodChkYXR1bSwgaXNIaWdobGlnaHRlZCkge1xuICAgIGNvbnN0IHNoYXBlID0gdGhpcy5fbGF5ZXIuZ2V0U2hhcGVGcm9tRGF0dW0oZGF0dW0pO1xuICAgIGlmIChzaGFwZSkge1xuICAgICAgaWYgKGlzSGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgc2hhcGUucGFyYW1zLmNvbG9yID0gJ3JlZCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaGFwZS5wYXJhbXMuY29sb3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2hhcGUgZm9yIHRoaXMgZGF0dW0gaW4gdGhpcyBsYXllcicsIHsgZGF0dW06IGRhdHVtLCBsYXllcjogdGhpcy5fbGF5ZXIgfSk7XG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgQmFzZUJlaGF2aW9yIGZyb20gJy4vYmFzZS1iZWhhdmlvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpYmxpbmdMb2NrZWRTZWdtZW50QmVoYXZpb3IgZXh0ZW5kcyBCYXNlQmVoYXZpb3Ige1xuICBlZGl0KHJlbmRlcmluZ0NvbnRleHQsIHNoYXBlLCBkYXR1bSwgZHgsIGR5LCB0YXJnZXQpIHtcbiAgICBjb25zdCBkYXRhICA9IHRoaXMuX2xheWVyLmRhdGE7XG4gICAgY29uc3QgbGF5ZXJIZWlnaHQgPSByZW5kZXJpbmdDb250ZXh0LmhlaWdodDtcbiAgICAvLyBjdXJyZW50IHBvc2l0aW9uXG4gICAgY29uc3QgeCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoc2hhcGUueChkYXR1bSkpO1xuICAgIGNvbnN0IHkgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbChzaGFwZS55KGRhdHVtKSk7XG4gICAgLy8gdGFyZ2V0IHBvc2l0aW9uXG4gICAgbGV0IHRhcmdldFggPSB4ICsgZHg7XG4gICAgbGV0IHRhcmdldFkgPSB5ICsgZHk7XG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPiAyKSB7XG4gICAgICAvLyBjcmVhdGUgYSBzb3J0ZWQgbWFwIG9mIGFsbCBgeGAgcG9zaXRpb25zXG4gICAgICBjb25zdCB4TWFwID0gZGF0YS5tYXAoKGQpID0+IHtcbiAgICAgICAgbGV0IHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHNoYXBlLngoZCkpOyBcbiAgICAgICAgbGV0IHdpZHRoID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS54KGQpICsgc2hhcGUud2lkdGgoZCkpO1xuICAgICAgICByZXR1cm4geyBzdGFydDogeCwgZW5kOiB4ICsgd2lkdGggfTtcbiAgICAgIH0pO1xuICAgICAgeE1hcC5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0IDwgYi5zdGFydCA/IC0xIDogMSk7XG4gICAgICAvLyBmaW5kIGluZGV4IG9mIG91ciBzaGFwZSB4IHBvc2l0aW9uXG4gICAgICBjb25zdCBpbmRleCA9IHhNYXAuaW5kZXhPZih4KTtcbiAgICAgIC8vIGxvY2sgdG8gbmV4dCBzaWJsaW5nc1xuICAgICAgaWYgKHRhcmdldFggPCB4TWFwW2luZGV4IC0gMV0uZW5kIHx8IHRhcmdldFggKyBzaGFwZS53aWR0aChkYXR1bSkgPiB4TWFwW2luZGV4ICsgMV0uc3RhcnQpIHtcbiAgICAgICAgdGFyZ2V0WCA9IHg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldFggPCAwKVxuICAgICAgdGFyZ2V0WCA9IDA7XG5cbiAgICAvLyBsb2NrIGluIHkgYXhpc1xuICAgIGlmICh0YXJnZXRZIDwgMCkge1xuICAgICAgdGFyZ2V0WSA9IDA7XG4gICAgfSBlbHNlIGlmICh0YXJnZXRZID4gbGF5ZXJIZWlnaHQpIHtcbiAgICAgIHRhcmdldFkgPSBsYXllckhlaWdodDtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgZGF0dW0gd2l0aCBuZXcgdmFsdWVzXG4gICAgc2hhcGUueChkYXR1bSwgcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0WCkpO1xuICAgIHNoYXBlLnkoZGF0dW0sIHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsLmludmVydCh0YXJnZXRZKSk7XG4gIH1cblxuICBzZWxlY3QoZGF0dW0pIHtcbiAgICBzdXBlci5zZWxlY3QoZGF0dW0pO1xuICAgIHRoaXMuaGlnaGxpZ2h0KGRhdHVtLCB0cnVlKTtcbiAgfVxuXG4gIHVuc2VsZWN0KGRhdHVtKSB7XG4gICAgc3VwZXIudW5zZWxlY3QoZGF0dW0pO1xuICAgIHRoaXMuaGlnaGxpZ2h0KGRhdHVtLCBmYWxzZSk7XG4gIH1cblxuICBoaWdobGlnaHQoZGF0dW0sIGlzSGlnaGxpZ2h0ZWQpIHtcbiAgICBjb25zdCBzaGFwZSA9IHRoaXMuX2xheWVyLmdldFNoYXBlRnJvbURhdHVtKGRhdHVtKTtcbiAgICBpZiAoc2hhcGUpIHtcbiAgICAgIGlmIChpc0hpZ2hsaWdodGVkKSB7XG4gICAgICAgIHNoYXBlLnBhcmFtcy5jb2xvciA9ICdyZWQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2hhcGUucGFyYW1zLmNvbG9yID0gJ2JsYWNrJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzaGFwZSBmb3IgdGhpcyBkYXR1bSBpbiB0aGlzIGxheWVyJywgeyBkYXR1bTogZGF0dW0sIGxheWVyOiB0aGlzLl9sYXllciB9KTtcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlQmVoYXZpb3IgZnJvbSAnLi9iYXNlLWJlaGF2aW9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2ltcGxlU25hcFNlZ21lbnRCZWhhdmlvciBleHRlbmRzIEJhc2VCZWhhdmlvciB7XG4gIGVkaXQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIGxldCBhY3Rpb24gPSAnbW92ZSc7XG5cbiAgICBpZiAodGFyZ2V0Lmhhc05hbWUoJ2hhbmRsZXInKSkge1xuICAgICAgaWYgKHRhcmdldC5oYXNOYW1lKCdsZWZ0JykpIFxuICAgICAgICBhY3Rpb24gPSAncmVzaXplTGVmdCc7XG4gICAgICBlbHNlIGlmICh0YXJnZXQuaGFzTmFtZSgncmlnaHQnKSkgXG4gICAgICAgIGFjdGlvbiA9ICdyZXNpemVSaWdodCc7XG4gICAgICBlbHNlIFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQga29udmEgc2hhcGUgbmFtZScpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0Lmhhc05hbWUoJ3NlZ21lbnQnKSkgXG4gICAgICBhY3Rpb24gPSAnbW92ZSc7XG4gICAgZWxzZSBcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBrb252YSBzaGFwZSBuYW1lJyk7XG5cbiAgICB0aGlzW2BfJHthY3Rpb259YF0ocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCk7XG4gIH1cblxuICBfbW92ZShyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgY29uc3QgbGF5ZXJIZWlnaHQgPSByZW5kZXJpbmdDb250ZXh0LmhlaWdodDtcbiAgICAvLyBjdXJyZW50IHZhbHVlc1xuICAgIGNvbnN0IHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHNoYXBlLngoZGF0dW0pKTtcbiAgICBjb25zdCB5ID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwoc2hhcGUueShkYXR1bSkpO1xuICAgIGNvbnN0IHdpZHRoID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS53aWR0aChkYXR1bSkpO1xuICAgIGNvbnN0IGhlaWdodCA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHNoYXBlLmhlaWdodChkYXR1bSkpO1xuICAgIC8vIHRhcmdldCB2YWx1ZXNcbiAgICBsZXQgdGFyZ2V0WCA9IE1hdGgubWF4KHggKyBkeCwgMCk7XG4gICAgbGV0IHRhcmdldFkgPSB5ICsgZHk7XG5cbiAgICAvLyBsb2NrIGluIGxheWVyJ3MgeSBheGlzXG4gICAgaWYgKHRhcmdldFkgPiBsYXllckhlaWdodCkge1xuICAgICAgdGFyZ2V0WSA9IGxheWVySGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0WSAtIChsYXllckhlaWdodCAtIGhlaWdodCkgPCAwKSB7XG4gICAgICB0YXJnZXRZID0gKGxheWVySGVpZ2h0IC0gaGVpZ2h0KTtcbiAgICB9XG5cbiAgICBzaGFwZS54KGRhdHVtLCByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRYKSk7XG4gICAgc2hhcGUueShkYXR1bSwgcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFkpKTtcblxuICAgIGNvbnN0IHNuYXBwZWRYID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChNYXRoLnJvdW5kKHNoYXBlLngoZGF0dW0pKSk7XG5cbiAgICBzaGFwZS54KGRhdHVtLCByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydChzbmFwcGVkWCkpO1xuICB9XG5cbiAgX3Jlc2l6ZUxlZnQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIC8vIGN1cnJlbnQgdmFsdWVzXG4gICAgY29uc3QgeCAgICAgPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHNoYXBlLngoZGF0dW0pKTtcbiAgICBjb25zdCB3aWR0aCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoc2hhcGUud2lkdGgoZGF0dW0pKTtcbiAgICAvLyB0YXJnZXQgdmFsdWVzXG4gICAgbGV0IG1heFRhcmdldFggID0geCArIHdpZHRoO1xuICAgIGxldCB0YXJnZXRYICAgICA9IHggKyBkeCA8IG1heFRhcmdldFggPyBNYXRoLm1heCh4ICsgZHgsIDApIDogeDtcbiAgICBsZXQgdGFyZ2V0V2lkdGggPSB0YXJnZXRYICE9PSAwID8gTWF0aC5tYXgod2lkdGggLSBkeCwgMSkgOiB3aWR0aDtcblxuICAgIHNoYXBlLngoZGF0dW0sIHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFgpKTtcbiAgICBzaGFwZS53aWR0aChkYXR1bSwgcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0V2lkdGgpKTtcbiAgfVxuXG4gIF9yZXNpemVSaWdodChyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgLy8gY3VycmVudCB2YWx1ZXNcbiAgICBjb25zdCB3aWR0aCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoc2hhcGUud2lkdGgoZGF0dW0pKTtcbiAgICAvLyB0YXJnZXQgdmFsdWVzXG4gICAgbGV0IHRhcmdldFdpZHRoID0gTWF0aC5tYXgod2lkdGggKyBkeCwgMSk7XG5cbiAgICBzaGFwZS53aWR0aChkYXR1bSwgcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0V2lkdGgpKTtcbiAgfVxuXG4gIHNlbGVjdChkYXR1bSkge1xuICAgIHN1cGVyLnNlbGVjdChkYXR1bSk7XG4gICAgdGhpcy5oaWdobGlnaHQoZGF0dW0sIHRydWUpO1xuICB9XG5cbiAgdW5zZWxlY3QoZGF0dW0pIHtcbiAgICBzdXBlci51bnNlbGVjdChkYXR1bSk7XG4gICAgdGhpcy5oaWdobGlnaHQoZGF0dW0sIGZhbHNlKTtcbiAgfVxuXG4gIGhpZ2hsaWdodChkYXR1bSwgaXNIaWdobGlnaHRlZCkge1xuICAgIGNvbnN0IHNoYXBlID0gdGhpcy5fbGF5ZXIuZ2V0U2hhcGVGcm9tRGF0dW0oZGF0dW0pO1xuICAgIGlmIChzaGFwZSkge1xuICAgICAgaWYgKGlzSGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgc2hhcGUucGFyYW1zLmNvbG9yID0gJ3JlZCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaGFwZS5wYXJhbXMuY29sb3IgPSAnYmxhY2snO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNoYXBlIGZvciB0aGlzIGRhdHVtIGluIHRoaXMgbGF5ZXInLCB7IGRhdHVtOiBkYXR1bSwgbGF5ZXI6IHRoaXMuX2xheWVyIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEJhc2VCZWhhdmlvciBmcm9tICcuL2Jhc2UtYmVoYXZpb3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTbmFwQmFzZUJlaGF2aW9yIGV4dGVuZHMgQmFzZUJlaGF2aW9yIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXHRcdFxuXHRcdHRoaXMuc25hcEZuID0gZnVuY3Rpb24oZGF0dW0sIGFjY2Vzc29yLCB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH07XG5cdH1cblx0XG59IiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEJhc2VCZWhhdmlvciBmcm9tICcuL2Jhc2UtYmVoYXZpb3InO1xuXG4vKipcbiogVGltZUNvbnRleHRCZWhhdmlvciBpcyB1c2VkIGludGVybmFsbHkgaW4gTGF5ZXJzIHRvIG1vZGlmeSB0aGVpciBUaW1lQ29udGV4dC5cbiogVGhpcyBvYmplY3QgaXMgZGlmZmVyZW50IGZyb20gb3RoZXIgU2hhcGVzIEJlaGF2aW9ycyBhbmQgZXhpc3RzIG1vc3RseSB0byBkZWNyZWFzZSB0aGUgc2l6ZSBvZiB0aGUgTGF5ZXIuXG4qIEFsbCB0aGUgY29kZSBoZXJlIGNvdWxkIGJlIGNvbnNpZGVyZWQgYXMgcGFydCBvZiB0aGUgbGF5ZXIuXG4qL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZUNvbnRleHRCZWhhdmlvciBleHRlbmRzIEJhc2VCZWhhdmlvciB7XG5cdGVkaXQobGF5ZXIsIGR4LCBkeSwgdGFyZ2V0KSB7XG5cdFx0Y29uc3QgdGltZUNvbnRleHQgPSBsYXllci50aW1lQ29udGV4dDtcblxuXHRcdGlmICh0YXJnZXQuaGFzTmFtZSgnaGFuZGxlcicpKSB7XG5cdFx0XHRpZiAodGFyZ2V0Lmhhc05hbWUoJ2xlZnQnKSkgXG5cdFx0XHRcdHRoaXMuX2VkaXRMZWZ0KHRpbWVDb250ZXh0LCBkeCk7XG5cdFx0XHRlbHNlIGlmICh0YXJnZXQuaGFzTmFtZSgncmlnaHQnKSkgXG5cdFx0XHRcdHRoaXMuX2VkaXRSaWdodCh0aW1lQ29udGV4dCwgZHgpO1xuXHRcdFx0ZWxzZSBcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGtvbnZhIHNoYXBlIG5hbWUnKTtcblx0XHR9IGVsc2UgaWYgKHRhcmdldC5oYXNOYW1lKCdzZWdtZW50JykpIFxuXHRcdFx0dGhpcy5fbW92ZSh0aW1lQ29udGV4dCwgZHgpO1xuXHRcdGVsc2UgXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQga29udmEgc2hhcGUgbmFtZScpO1xuXHR9XG5cblx0X2VkaXRMZWZ0KHRpbWVDb250ZXh0LCBkeCkge1xuXHRcdC8vIGVkaXQgYHN0YXJ0YCwgYG9mZnNldGAgYW5kIGBkdXJhdGlvbmBcblx0XHRjb25zdCB4ID0gdGltZUNvbnRleHQucGFyZW50LnRpbWVUb1BpeGVsKHRpbWVDb250ZXh0LnN0YXJ0KTtcblx0XHRjb25zdCBvZmZzZXQgPSB0aW1lQ29udGV4dC50aW1lVG9QaXhlbCh0aW1lQ29udGV4dC5vZmZzZXQpO1xuXHRcdGNvbnN0IHdpZHRoID0gdGltZUNvbnRleHQudGltZVRvUGl4ZWwodGltZUNvbnRleHQuZHVyYXRpb24pO1xuXG5cdFx0Y29uc3QgdGFyZ2V0WCA9IHggKyBkeDtcblx0XHRjb25zdCB0YXJnZXRPZmZzZXQgPSBvZmZzZXQgLSBkeDtcblx0XHRjb25zdCB0YXJnZXRXaWR0aCA9IE1hdGgubWF4KHdpZHRoIC0gZHgsIDEpO1xuXG5cdFx0dGltZUNvbnRleHQuc3RhcnQgPSB0aW1lQ29udGV4dC5wYXJlbnQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFgpO1xuXHRcdHRpbWVDb250ZXh0Lm9mZnNldCA9IHRpbWVDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRPZmZzZXQpO1xuXHRcdHRpbWVDb250ZXh0LmR1cmF0aW9uID0gdGltZUNvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFdpZHRoKTtcblx0fVxuXG5cdF9lZGl0UmlnaHQodGltZUNvbnRleHQsIGR4KSB7XG5cdFx0Y29uc3Qgd2lkdGggPSB0aW1lQ29udGV4dC50aW1lVG9QaXhlbCh0aW1lQ29udGV4dC5kdXJhdGlvbik7XG5cdFx0Y29uc3QgdGFyZ2V0V2lkdGggPSBNYXRoLm1heCh3aWR0aCArIGR4LCAxKTtcblxuXHRcdHRpbWVDb250ZXh0LmR1cmF0aW9uID0gdGltZUNvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFdpZHRoKTtcblx0fVxuXG5cdF9tb3ZlKHRpbWVDb250ZXh0LCBkeCkge1xuXHRcdGNvbnN0IHggPSB0aW1lQ29udGV4dC5wYXJlbnQudGltZVRvUGl4ZWwodGltZUNvbnRleHQuc3RhcnQpO1xuXHRcdGNvbnN0IHRhcmdldFggPSBNYXRoLm1heCh4ICsgZHgsIDApO1xuXG5cdFx0dGltZUNvbnRleHQuc3RhcnQgPSB0aW1lQ29udGV4dC5wYXJlbnQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFgpO1xuXHR9XG5cblx0c3RyZXRjaChsYXllciwgZHgsIGR5LCB0YXJnZXQpIHtcblx0XHRjb25zdCB0aW1lQ29udGV4dCA9IGxheWVyLnRpbWVDb250ZXh0O1xuXHRcdGNvbnN0IGxhc3REdXJhdGlvbiA9IHRpbWVDb250ZXh0LmR1cmF0aW9uO1xuXHRcdGNvbnN0IGxhc3RPZmZzZXQgPSB0aW1lQ29udGV4dC5vZmZzZXQ7XG5cblx0XHR0aGlzLmVkaXQobGF5ZXIsIGR4LCBkeSwgdGFyZ2V0KTtcblxuXHRcdGNvbnN0IG5ld0R1cmF0aW9uID0gdGltZUNvbnRleHQuZHVyYXRpb247XG5cdFx0Y29uc3QgcmF0aW8gPSAobmV3RHVyYXRpb24gLyBsYXN0RHVyYXRpb24pO1xuXG5cdFx0dGltZUNvbnRleHQuc3RyZXRjaFJhdGlvICo9IHJhdGlvO1xuXHRcdHRpbWVDb250ZXh0Lm9mZnNldCA9IGxhc3RPZmZzZXQ7XG5cdFx0dGltZUNvbnRleHQuZHVyYXRpb24gPSBsYXN0RHVyYXRpb247XG5cdH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlQmVoYXZpb3IgZnJvbSAnLi9iYXNlLWJlaGF2aW9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhY2VCZWhhdmlvciBleHRlbmRzIEJhc2VCZWhhdmlvciB7XG4gIGVkaXQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQuaGFzTmFtZSgnbWluJykpIHtcbiAgICAgIHRoaXMuX2VkaXRSYW5nZShyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCAtZHksICdtaW4nKTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5oYXNOYW1lKCdtYXgnKSkge1xuICAgICAgdGhpcy5fZWRpdFJhbmdlKHJlbmRlcmluZ0NvbnRleHQsIHNoYXBlLCBkYXR1bSwgZHgsIC1keSwgJ21heCcpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0Lmhhc05hbWUoJ21lYW4nKSkge1xuICAgICAgdGhpcy5fZWRpdE1lYW4ocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgLWR5KTtcbiAgICB9IGVsc2UgXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQga29udmEgc2hhcGUgbmFtZScpO1xuICB9XG5cbiAgX2VkaXRNZWFuKHJlbmRlcmluZ0NvbnRleHQsIHNoYXBlLCBkYXR1bSwgZHgsIGR5KSB7XG4gICAgLy8gd29yayBpbiBwaXhlbCBkb21haW5cbiAgICBjb25zdCB4ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS54KGRhdHVtKSk7XG4gICAgY29uc3QgeSA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHNoYXBlLm1lYW4oZGF0dW0pKTtcblxuICAgIGxldCB0YXJnZXRYID0geCArIGR4O1xuICAgIGxldCB0YXJnZXRZID0geSAtIGR5O1xuXG4gICAgc2hhcGUueChkYXR1bSwgcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0WCkpO1xuICAgIHNoYXBlLm1lYW4oZGF0dW0sIHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsLmludmVydCh0YXJnZXRZKSk7XG4gIH1cblxuICBfZWRpdFJhbmdlKHJlbmRlcmluZ0NvbnRleHQsIHNoYXBlLCBkYXR1bSwgZHgsIGR5LCByYW5nZVNpZGUpIHtcbiAgICBjb25zdCByYW5nZSA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHNoYXBlLnJhbmdlKGRhdHVtKSk7XG5cbiAgICBsZXQgdGFyZ2V0UmFuZ2UgPSByYW5nZVNpZGUgPT09ICdtaW4nID8gcmFuZ2UgKyAyICogZHkgOiByYW5nZSAtIDIgKiBkeTtcbiAgICB0YXJnZXRSYW5nZSA9IE1hdGgubWF4KHRhcmdldFJhbmdlLCAwKTtcblxuICAgIHNoYXBlLnJhbmdlKGRhdHVtLCBNYXRoLm1heCgwLCByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbC5pbnZlcnQodGFyZ2V0UmFuZ2UpKSk7XG4gIH1cblxuICBzZWxlY3QoZGF0dW0pIHtcbiAgICBzdXBlci5zZWxlY3QoZGF0dW0pO1xuICAgIHRoaXMuaGlnaGxpZ2h0KGRhdHVtLCB0cnVlKTtcbiAgfVxuXG4gIHVuc2VsZWN0KGRhdHVtKSB7XG4gICAgc3VwZXIudW5zZWxlY3QoZGF0dW0pO1xuICAgIHRoaXMuaGlnaGxpZ2h0KGRhdHVtLCBmYWxzZSk7XG4gIH1cblxuICBoaWdobGlnaHQoZGF0dW0sIGlzSGlnaGxpZ2h0ZWQpIHtcbiAgICBjb25zdCBzaGFwZSA9IHRoaXMuX2xheWVyLmdldFNoYXBlRnJvbURhdHVtKGRhdHVtKTtcbiAgICBpZiAoc2hhcGUpIHtcbiAgICAgIGlmIChpc0hpZ2hsaWdodGVkKSB7XG4gICAgICAgIHNoYXBlLnBhcmFtcy5tZWFuQ29sb3IgPSAncmVkJztcbiAgICAgICAgc2hhcGUucGFyYW1zLnJhbmdlQ29sb3IgPSAncmVkJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRzID0gc2hhcGUuX2dldERlZmF1bHRzKCk7XG4gICAgICAgIHNoYXBlLnBhcmFtcy5tZWFuQ29sb3IgPSBkZWZhdWx0cy5tZWFuQ29sb3I7XG4gICAgICAgIHNoYXBlLnBhcmFtcy5yYW5nZUNvbG9yID0gZGVmYXVsdHMucmFuZ2VDb2xvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzaGFwZSBmb3IgdGhpcyBkYXR1bSBpbiB0aGlzIGxheWVyJywgeyBkYXR1bTogZGF0dW0sIGxheWVyOiB0aGlzLl9sYXllciB9KTtcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlQmVoYXZpb3IgZnJvbSAnLi9iYXNlLWJlaGF2aW9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2F2ZWZvcm1CZWhhdmlvciBleHRlbmRzIEJhc2VCZWhhdmlvciB7XG4gIGVkaXQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIGxldCBhY3Rpb24gPSAnbW92ZSc7XG5cbiAgICBpZiAodGFyZ2V0Lmhhc05hbWUoJ2hhbmRsZXInKSkge1xuICAgICAgaWYgKHRhcmdldC5oYXNOYW1lKCdsZWZ0JykpIFxuICAgICAgICBhY3Rpb24gPSAncmVzaXplTGVmdCc7XG4gICAgICBlbHNlIGlmICh0YXJnZXQuaGFzTmFtZSgncmlnaHQnKSkgXG4gICAgICAgIGFjdGlvbiA9ICdyZXNpemVSaWdodCc7XG4gICAgICBlbHNlIFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQga29udmEgc2hhcGUgbmFtZScpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0Lmhhc05hbWUoJ2JvZHknKSkge1xuICAgICAgYWN0aW9uID0gJ21vdmUnO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0Lmhhc05hbWUoJ2hlYWRlcicpKSB7XG4gICAgICAvLyBUT0RPXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGtvbnZhIHNoYXBlIG5hbWUnKTtcblxuICAgIHRoaXNbYF8ke2FjdGlvbn1gXShyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KTtcbiAgfVxuXG4gIF9tb3ZlKHJlbmRlcmluZ0NvbnRleHQsIHNoYXBlLCBkYXR1bSwgZHgsIGR5LCB0YXJnZXQpIHtcbiAgICBjb25zdCBsYXllckhlaWdodCA9IHJlbmRlcmluZ0NvbnRleHQuaGVpZ2h0O1xuICAgIC8vIGN1cnJlbnQgdmFsdWVzXG4gICAgY29uc3QgeCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoc2hhcGUueChkYXR1bSkpO1xuICAgIC8vIGNvbnN0IHkgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbChzaGFwZS55KGRhdHVtKSk7XG4gICAgY29uc3QgeSA9IDA7XG4gICAgY29uc3Qgd2lkdGggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHNoYXBlLndpZHRoKGRhdHVtKSk7XG4gICAgLy8gY29uc3QgaGVpZ2h0ID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwoc2hhcGUuaGVpZ2h0KGRhdHVtKSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gcmVuZGVyaW5nQ29udGV4dC5oZWlnaHQ7XG4gICAgLy8gdGFyZ2V0IHZhbHVlc1xuICAgIGxldCB0YXJnZXRYID0gTWF0aC5tYXgoeCArIGR4LCAwKTtcbiAgICBsZXQgdGFyZ2V0WSA9IHkgKyBkeTtcblxuICAgIC8vIGxvY2sgaW4gbGF5ZXIncyB5IGF4aXNcbiAgICBpZiAodGFyZ2V0WSA+IGxheWVySGVpZ2h0KSB7XG4gICAgICB0YXJnZXRZID0gbGF5ZXJIZWlnaHQ7XG4gICAgfSBlbHNlIGlmICh0YXJnZXRZIC0gKGxheWVySGVpZ2h0IC0gaGVpZ2h0KSA8IDApIHtcbiAgICAgIHRhcmdldFkgPSAobGF5ZXJIZWlnaHQgLSBoZWlnaHQpO1xuICAgIH1cblxuICAgIHNoYXBlLngoZGF0dW0sIHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFgpKTtcbiAgICAvLyBzaGFwZS55KGRhdHVtLCByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbC5pbnZlcnQodGFyZ2V0WSkpO1xuICB9XG5cbiAgX3Jlc2l6ZUxlZnQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIC8vIHJldHVybjsgLy8gVE9ETzogdXBkYXRlIHRoaXMgZm9yIHRoZSB3YXZlZm9ybSBzaGFwZVxuICAgIC8vIGN1cnJlbnQgdmFsdWVzXG4gICAgY29uc3QgeCAgICAgPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHNoYXBlLngoZGF0dW0pKTtcbiAgICBjb25zdCB3aWR0aCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoc2hhcGUud2lkdGgoZGF0dW0pKTtcbiAgICAvLyB0YXJnZXQgdmFsdWVzXG4gICAgbGV0IG1heFRhcmdldFggID0geCArIHdpZHRoO1xuICAgIGxldCB0YXJnZXRYICAgICA9IHggKyBkeCA8IG1heFRhcmdldFggPyBNYXRoLm1heCh4ICsgZHgsIDApIDogeDtcbiAgICBsZXQgdGFyZ2V0V2lkdGggPSB0YXJnZXRYICE9PSAwID8gTWF0aC5tYXgod2lkdGggLSBkeCwgMSkgOiB3aWR0aDtcblxuICAgIHNoYXBlLngoZGF0dW0sIHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFgpKTtcbiAgICBzaGFwZS53aWR0aChkYXR1bSwgcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0V2lkdGgpKTtcbiAgfVxuXG4gIF9yZXNpemVSaWdodChyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgLy8gcmV0dXJuOyAvLyBUT0RPOiB1cGRhdGUgdGhpcyBmb3IgdGhlIHdhdmVmb3JtIHNoYXBlXG4gICAgLy8gY3VycmVudCB2YWx1ZXNcbiAgICBjb25zdCB3aWR0aCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoc2hhcGUud2lkdGgoZGF0dW0pKTtcbiAgICAvLyB0YXJnZXQgdmFsdWVzXG4gICAgbGV0IHRhcmdldFdpZHRoID0gTWF0aC5tYXgod2lkdGggKyBkeCwgMSk7XG5cbiAgICBzaGFwZS53aWR0aChkYXR1bSwgcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0V2lkdGgpKTtcbiAgfVxuXG4gIHNlbGVjdChkYXR1bSkge1xuICAgIHN1cGVyLnNlbGVjdChkYXR1bSk7XG4gICAgdGhpcy5oaWdobGlnaHQoZGF0dW0sIHRydWUpO1xuICB9XG5cbiAgdW5zZWxlY3QoZGF0dW0pIHtcbiAgICBzdXBlci51bnNlbGVjdChkYXR1bSk7XG4gICAgdGhpcy5oaWdobGlnaHQoZGF0dW0sIGZhbHNlKTtcbiAgfVxuXG4gIGhpZ2hsaWdodChkYXR1bSwgaXNIaWdobGlnaHRlZCkge1xuICAgIGNvbnN0IHNoYXBlID0gdGhpcy5fbGF5ZXIuZ2V0U2hhcGVGcm9tRGF0dW0oZGF0dW0pO1xuICAgIGlmIChzaGFwZSkge1xuICAgICAgLy8gaWYgKGlzSGlnaGxpZ2h0ZWQpIHtcbiAgICAgIC8vICAgc2hhcGUucGFyYW1zLmNvbG9yID0gJ3JlZCc7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICBzaGFwZS5wYXJhbXMuY29sb3IgPSAnYmxhY2snO1xuICAgICAgLy8gfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNoYXBlIGZvciB0aGlzIGRhdHVtIGluIHRoaXMgbGF5ZXInLCB7IGRhdHVtOiBkYXR1bSwgbGF5ZXI6IHRoaXMuX2xheWVyIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHNjYWxlcyBmcm9tICcuLi91dGlscy9zY2FsZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYXllclRpbWVDb250ZXh0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VGltZWxpbmVUaW1lQ29udGV4dH0gcGFyZW50IC0gVGhlIGBUaW1lbGluZVRpbWVDb250ZXh0YCBpbnN0YW5jZSBvZiB0aGUgdGltZWxpbmUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBpZiAoIXBhcmVudCkgeyB0aHJvdyBuZXcgRXJyb3IoJ0xheWVyVGltZUNvbnRleHQgbXVzdCBoYXZlIGEgcGFyZW50Jyk7IH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBgVGltZWxpbmVUaW1lQ29udGV4dGAgaW5zdGFuY2Ugb2YgdGhlIHRpbWVsaW5lLlxuICAgICAqXG4gICAgICogQHR5cGUge1RpbWVsaW5lVGltZUNvbnRleHR9XG4gICAgICovXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5fbG9ja2VkVG9QYXJlbnRJbnRlcnZhbCA9IGZhbHNlO1xuXG4gICAgdGhpcy5fdGltZVRvUGl4ZWwgPSBudWxsO1xuICAgIHRoaXMuX3N0YXJ0ID0gMDtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IHBhcmVudC52aXNpYmxlRHVyYXRpb247XG4gICAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgICB0aGlzLl9zdHJldGNoUmF0aW8gPSAxO1xuICAgIC8vIHJlZ2lzdGVyIGludG8gdGhlIHRpbWVsaW5lJ3MgVGltZUNvbnRleHRcbiAgICB0aGlzLnBhcmVudC5fY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgdGltZSBjb250ZXh0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtMYXllclRpbWVDb250ZXh0fVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY3R4ID0gbmV3IHRoaXMoKTtcblxuICAgIGN0eC5wYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICBjdHguc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgIGN0eC5kdXJhdGlvbiA9IHRoaXMuZHVyYXRpb247XG4gICAgY3R4Lm9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgIGN0eC5zdHJldGNoUmF0aW8gPSB0aGlzLnN0cmV0Y2hSYXRpbzsgLy8gY3JlYXRlcyB0aGUgbG9jYWwgc2NhbGUgaWYgbmVlZGVkXG5cbiAgICByZXR1cm4gY3R4O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSB0aW1lIGNvbnRleHQgKGluIHNlY29uZHMpLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHN0YXJ0KCkge1xuICAgIHJldHVybiAoIXRoaXMuX2xvY2tlZFRvUGFyZW50SW50ZXJ2YWwpPyB0aGlzLl9zdGFydCA6IC10aGlzLnBhcmVudC5vZmZzZXQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHRpbWUgY29udGV4dCAoaW4gc2Vjb25kcykuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBzZXQgc3RhcnQodmFsdWUpIHtcbiAgICB0aGlzLl9zdGFydCA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGR1cmF0aW9uIG9mIHRoZSB0aW1lIGNvbnRleHQgKGluIHNlY29uZHMpLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGR1cmF0aW9uKCkge1xuICAgIHJldHVybiAoIXRoaXMuX2xvY2tlZFRvUGFyZW50SW50ZXJ2YWwpPyB0aGlzLl9kdXJhdGlvbiA6IHRoaXMucGFyZW50LnZpc2libGVEdXJhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkdXJhdGlvbiBvZiB0aGUgdGltZSBjb250ZXh0IChpbiBzZWNvbmRzKS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHNldCBkdXJhdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX2R1cmF0aW9uID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0IG9mIHRoZSB0aW1lIGNvbnRleHQgKGluIHNlY29uZHMpLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IG9mZnNldCgpIHtcbiAgICByZXR1cm4gKCF0aGlzLl9sb2NrZWRUb1BhcmVudEludGVydmFsKT8gdGhpcy5fb2Zmc2V0IDogdGhpcy5wYXJlbnQub2Zmc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG9mZnNldCBvZiB0aGUgdGltZSBjb250ZXh0IChpbiBzZWNvbmRzKS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHNldCBvZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLl9vZmZzZXQgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHJldGNoIHJhdGlvIG9mIHRoZSB0aW1lIGNvbnRleHQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc3RyZXRjaFJhdGlvKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJldGNoUmF0aW87XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3RyZXRjaCByYXRpbyBvZiB0aGUgdGltZSBjb250ZXh0LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgc2V0IHN0cmV0Y2hSYXRpbyh2YWx1ZSkge1xuICAgIC8vIHJlbW92ZSBsb2NhbCBzY2FsZSBpZiByYXRpbyA9IDFcbiAgICBpZiAodmFsdWUgPT09ICAxKSB7XG4gICAgICB0aGlzLl90aW1lVG9QaXhlbCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHJldXNlIHByZXZpc291c2x5IGNyZWF0ZWQgbG9jYWwgc2NhbGUgaWYgZXhpc3RzXG4gICAgY29uc3QgdGltZVRvUGl4ZWwgPSB0aGlzLl90aW1lVG9QaXhlbCA/XG4gICAgICB0aGlzLl90aW1lVG9QaXhlbCA6IHNjYWxlcy5saW5lYXIoKS5kb21haW4oWzAsIDFdKTtcblxuICAgIHRpbWVUb1BpeGVsLnJhbmdlKFswLCB0aGlzLnBhcmVudC5jb21wdXRlZFBpeGVsc1BlclNlY29uZCAqIHZhbHVlXSk7XG5cbiAgICB0aGlzLl90aW1lVG9QaXhlbCA9IHRpbWVUb1BpeGVsO1xuICAgIHRoaXMuX3N0cmV0Y2hSYXRpbyA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRpbWUgdG8gcGl4ZWwgdHJhbnNmZXJ0IGZ1bmN0aW9uIG9mIHRoZSB0aW1lIGNvbnRleHQuIElmXG4gICAqIHRoZSBgc3RyZXRjaFJhdGlvYCBhdHRyaWJ1dGUgaXMgZXF1YWwgdG8gMSwgdGhpcyBmdW5jdGlvbiBpcyB0aGUgZ2xvYmFsXG4gICAqIG9uZSBmcm9tIHRoZSBgVGltZWxpbmVUaW1lQ29udGV4dGAgaW5zdGFuY2UuXG4gICAqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIGdldCB0aW1lVG9QaXhlbCgpIHtcbiAgICBpZiAoIXRoaXMuX3RpbWVUb1BpeGVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQudGltZVRvUGl4ZWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3RpbWVUb1BpeGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IHBpeGVsIHRvIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBweFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBwaXhlbFRvVGltZShweCkge1xuICAgIGlmICghdGhpcy5fdGltZVRvUGl4ZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC50aW1lVG9QaXhlbC5pbnZlcnQocHgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl90aW1lVG9QaXhlbC5pbnZlcnQocHgpO1xuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGltZSBpbnRlcnZhbCBvZiB0aGUgdmlzaWJsZSBhcmVhIGluIHRoZSB0aW1lbGluZS5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH0gXG4gICAqL1xuICBnZXQgdmlzaWJsZUludGVydmFsKCkge1xuICAgIHZhciBpbnRlcnZhbCA9IHt9O1xuICAgIGludGVydmFsLnN0YXJ0ID0gLXRoaXMub2Zmc2V0O1xuICAgIGludGVydmFsLmR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbjtcbiAgICByZXR1cm4gaW50ZXJ2YWw7XG4gIH1cblxuICAvKipcbiAgICogRm9jdXMgdGhlIHRpbWVsaW5lIHZpc2libGUgYXJlYSBpbiB0aGUgcHJvdmlkZWQgdGltZSBpbnRlcnZhbC5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH0gXG4gICAqL1xuICBzZXQgdmlzaWJsZUludGVydmFsKHZhbHVlKSB7XG4gICAgdGhpcy5vZmZzZXQgPSAtdmFsdWUuc3RhcnQ7XG4gICAgdGhpcy5kdXJhdGlvbiA9IHZhbHVlLmR1cmF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqICBUT0RPXG4gICAqL1xuICBnZXQgbG9ja2VkVG9QYXJlbnRJbnRlcnZhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9ja2VkVG9QYXJlbnRJbnRlcnZhbDtcbiAgfVxuXG4gIHNldCBsb2NrZWRUb1BhcmVudEludGVydmFsKHZhbHVlKSB7XG4gICAgdGhpcy5fbG9ja2VkVG9QYXJlbnRJbnRlcnZhbCA9IHZhbHVlO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgc2NhbGVzIGZyb20gJy4uL3V0aWxzL3NjYWxlcyc7XG5pbXBvcnQgZXZlbnRzIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgU2VnbWVudCBmcm9tICcuLi9zaGFwZXMvc2VnbWVudCc7XG5pbXBvcnQgVGltZUNvbnRleHRCZWhhdmlvciBmcm9tICcuLi9iZWhhdmlvcnMvdGltZS1jb250ZXh0LWJlaGF2aW9yJztcbmltcG9ydCBLb252YSBmcm9tICdrb252YSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExheWVyIGV4dGVuZHMgZXZlbnRzLkV2ZW50RW1pdHRlciB7XG5cblx0Y29uc3RydWN0b3IoZGF0YVR5cGUsIGRhdGEsIG9wdGlvbnMpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5kYXRhVHlwZSA9IGRhdGFUeXBlO1xuXG5cdFx0aWYgKCFvcHRpb25zKSBcblx0XHRcdG9wdGlvbnMgPSB7fTtcblxuXHRcdGNvbnN0IGRlZmF1bHRzID0ge1xuXHRcdFx0aGVpZ2h0OiAxMDAsXG5cdFx0XHR0b3A6IDAsXG5cdFx0XHRvcGFjaXR5OiAxLFxuXHRcdFx0eURvbWFpbjogWzAsIDFdLFxuXHRcdFx0Y2xhc3NOYW1lOiBudWxsLCAvLyBUT0RPXG5cdFx0XHRzZWxlY3RlZENsYXNzTmFtZTogJ3NlbGVjdGVkJyxcblx0XHRcdGNvbnRleHQ6IHtcblx0XHRcdFx0aGFuZGxlcldpZHRoOiAxMCxcblx0XHRcdFx0aGFuZGxlck9wYWNpdHk6IDAuMixcblx0XHRcdFx0b3BhY2l0eTogMC41LCBcblx0XHRcdFx0Y29sb3I6ICcjNzg3ODc4Jyxcblx0XHRcdH0sIFxuXHRcdFx0aGl0dGFibGU6IHRydWUsIC8vIHdoZW4gZmFsc2UgdGhlIGxheWVyIGlzIG5vdCByZXR1cm5lZCBieSBgQmFzZVN0YXRlLmdldEhpdExheWVyc2Bcblx0XHR9O1xuXG5cdFx0dGhpcy5fYmVoYXZpb3IgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0KiBQYXJhbWV0ZXJzIG9mIHRoZSBsYXllcnMsIGBkZWZhdWx0c2Agb3ZlcnJpZGVkIHdpdGggb3B0aW9ucy5cblx0XHQqIEB0eXBlIHtPYmplY3R9XG5cdFx0Ki9cblx0XHR0aGlzLnBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcblx0XHR0aGlzLnRpbWVDb250ZXh0QmVoYXZpb3IgPSBuZXcgVGltZUNvbnRleHRCZWhhdmlvcigpO1xuXG5cdFx0dGhpcy5fc2hhcGVDb25maWd1cmF0aW9uID0gbnVsbDtcdFx0XHQgLy8geyBjdG9yLCBhY2Nlc3NvcnMsIG9wdGlvbnMgfVxuXHRcdHRoaXMuX2NvbW1vblNoYXBlQ29uZmlndXJhdGlvbiA9IG51bGw7IC8vIHsgY3RvciwgYWNjZXNzb3JzLCBvcHRpb25zIH1cblx0XHR0aGlzLl8kZGF0dW1Ub1NoYXBlID0gbmV3IE1hcCgpO1xuXHRcdHRoaXMuXyRzaGFwZVRvRGF0dW0gPSBuZXcgTWFwKCk7XG5cdFx0dGhpcy5fY29tbW9uU2hhcGUgPSBudWxsO1xuXHRcdHRoaXMuX3JlbmRlcmluZ0NvbnRleHQgPSB7fTtcblx0XHR0aGlzLmRhdGEgPSBbXTtcblxuXHRcdHRoaXMuX2lzQ29udGV4dEVkaXRhYmxlID0gZmFsc2U7XG5cblx0XHR0aGlzLl92YWx1ZVRvUGl4ZWwgPSBzY2FsZXMubGluZWFyKClcblx0XHRcdC5kb21haW4odGhpcy5wYXJhbXMueURvbWFpbilcblx0XHRcdC5yYW5nZShbdGhpcy5wYXJhbXMuaGVpZ2h0LCAwXSk7XG5cblx0XHR0aGlzLmNvbnRlbnRMYXllcnMgPSBuZXcgU2V0KCk7XG5cblx0XHR0aGlzLl9kcmFnTGF5ZXIgPSBuZXcgS29udmEuTGF5ZXIoe30pO1xuXG5cdFx0dGhpcy5fY29tbW9uU2hhcGVMYXllciA9IG5ldyBLb252YS5GYXN0TGF5ZXIoe30pO1xuXHRcdHRoaXMuX2NvbW1vblNoYXBlTGF5ZXIuYWRkTmFtZSgnY29tbW9uLXNoYXBlLWxheWVyJyk7XG5cdFx0dGhpcy5fY29tbW9uU2hhcGVMYXllci5sYXllciA9IHRoaXM7XG5cblx0XHR0aGlzLl9jb250ZXh0TGF5ZXIgPSBuZXcgS29udmEuTGF5ZXIoe30pO1xuXHRcdHRoaXMuX2NvbnRleHRMYXllci5sYXllciA9IHRoaXM7XG5cdFx0dGhpcy5fY29udGV4dExheWVyLmFkZE5hbWUoJ2NvbnRleHQtbGF5ZXInKTtcblxuXHRcdHRoaXMuc2V0Q29udGV4dEVkaXRhYmxlKHRoaXMuX2lzQ29udGV4dEVkaXRhYmxlKTtcblx0XHRcblx0XHR0aGlzLl9jb250ZXh0U2hhcGUgPSBuZXcgU2VnbWVudCh7fSk7XG5cdFx0dGhpcy5fY29udGV4dFNoYXBlLmluc3RhbGwoe1xuXHRcdFx0b3BhY2l0eVx0OiAoKSA9PiAxLCBcblx0XHRcdGNvbG9yXHQ6ICgpID0+IHRoaXMucGFyYW1zLmNvbnRleHQuY29sb3IsIFxuXHRcdFx0d2lkdGhcdDogKCkgPT4gdGhpcy50aW1lQ29udGV4dC5kdXJhdGlvbixcblx0XHRcdGhlaWdodFx0OiAoKSA9PiB0aGlzLl9yZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbC5kb21haW4oKVsxXSxcblx0XHRcdHlcdFx0OiAoKSA9PiB0aGlzLl9yZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbC5kb21haW4oKVswXSxcblx0XHRcdHhcdFx0OiAoKSA9PiB0aGlzLnRpbWVDb250ZXh0LnN0YXJ0IC8gdGhpcy50aW1lQ29udGV4dC5zdHJldGNoUmF0aW9cblx0XHR9KTsgXG5cdFx0dGhpcy5fY29udGV4dFNoYXBlLnBhcmFtcy5oYW5kbGVyV2lkdGggPSB0aGlzLnBhcmFtcy5jb250ZXh0LmhhbmRsZXJXaWR0aDtcblx0XHR0aGlzLl9jb250ZXh0U2hhcGUucmVuZGVyKHRoaXMuX3JlbmRlcmluZ0NvbnRleHQpO1xuXHRcdHRoaXMuX2NvbnRleHRTaGFwZS5sYXllciA9IHRoaXM7XG5cdFx0dGhpcy5fY29udGV4dFNoYXBlLmlzQ29udGV4dFNoYXBlID0gdHJ1ZTtcblx0XHRmb3IgKHZhciBpPTA7IGk8dGhpcy5fY29udGV4dFNoYXBlLiRlbC5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5fY29udGV4dExheWVyLmFkZCh0aGlzLl9jb250ZXh0U2hhcGUuJGVsW2ldKTtcblx0XHR9XG5cdFx0dGhpcy5fY29udGV4dFNoYXBlLiRlbC5mb3JFYWNoKChrcykgPT4geyBrcy5zaGFwZSA9IHRoaXMuX2NvbnRleHRTaGFwZTsgfSk7XG5cblx0XHR0aGlzLl9zdGFnZSA9IG51bGw7XG5cdH1cblxuXHRnZXQgdmlzaWJsZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ0xheWVyLnZpc2libGUoKTtcblx0fVxuXG5cdHNldCB2aXNpYmxlKHZpc2libGUpIHtcblx0XHR0aGlzLl9jb250ZXh0TGF5ZXIudmlzaWJsZSh2aXNpYmxlKTtcblx0XHR0aGlzLl9jb21tb25TaGFwZUxheWVyLnZpc2libGUodmlzaWJsZSk7XG5cdFx0dGhpcy5fZHJhZ0xheWVyLnZpc2libGUodmlzaWJsZSk7XG5cdFx0dGhpcy5jb250ZW50TGF5ZXJzLmZvckVhY2goKGwpID0+IGwudmlzaWJsZSh2aXNpYmxlKSk7XG5cdFx0aWYgKCF0aGlzLl92aXNpYmxlICYmIHZpc2libGUpIHtcblx0XHRcdHRoaXMuX3Zpc2libGUgPSB2aXNpYmxlO1xuXHRcdFx0dGhpcy51cGRhdGVTaGFwZXMoKTtcblx0XHR9XG5cdH1cblxuXHRnZXQgekluZGV4KCkge1xuXHRcdHJldHVybiB0aGlzLl9jb250ZXh0TGF5ZXIuZ2V0WkluZGV4KCk7XG5cdH1cblxuXHRjcmVhdGVDb250YWluZXIoc3RhZ2UpIHtcblx0XHR0aGlzLl9zdGFnZSA9IHN0YWdlO1xuXG5cdFx0dGhpcy5fc3RhZ2UuYWRkKHRoaXMuX2NvbnRleHRMYXllcik7XG5cdFx0dGhpcy5fc3RhZ2UuYWRkKHRoaXMuX2NvbW1vblNoYXBlTGF5ZXIpO1xuXHRcdHRoaXMuX3N0YWdlLmFkZCh0aGlzLl9kcmFnTGF5ZXIpO1xuXHR9XG5cblxuXHRfZGVzdHJveShpdCkge1xuXHRcdHZhciBlbnRyeSA9IGl0Lm5leHQoKTtcblx0XHR3aGlsZSAoIWVudHJ5LmRvbmUpIHtcblx0XHRcdHZhciBsYXllciA9IGVudHJ5LnZhbHVlO1xuXHRcdFx0bGF5ZXIuZGVzdHJveSgpO1xuXHRcdFx0ZW50cnkgPSBpdC5uZXh0KCk7XG5cdFx0fVxuXHR9XG5cblx0ZGVzdHJveSgpIHtcblx0XHR0aGlzLl9jb250ZXh0U2hhcGUuZGVzdHJveSgpO1xuXHRcdHRoaXMuX2Rlc3Ryb3kodGhpcy5fJGRhdHVtVG9TaGFwZS52YWx1ZXMoKSk7XG5cdFx0dGhpcy5fZGVzdHJveSh0aGlzLmNvbnRlbnRMYXllcnMudmFsdWVzKCkpO1xuXHRcdHRoaXMuY29udGVudExheWVycy5jbGVhcigpO1xuXG5cdFx0dGhpcy5fY29tbW9uU2hhcGVMYXllciA9IG51bGw7XG5cdFx0dGhpcy5fY29udGV4dExheWVyID0gbnVsbDtcblx0XHR0aGlzLl9jb250ZXh0U2hhcGUgPSBudWxsO1xuXHRcdHRoaXMuX3N0YWdlID0gbnVsbDtcblx0XHR0aGlzLnBhcmFtcyA9IG51bGw7XG5cdFx0dGhpcy50aW1lQ29udGV4dEJlaGF2aW9yID0gbnVsbDtcblx0XHR0aGlzLl9zaGFwZUNvbmZpZ3VyYXRpb24gPSBudWxsO1xuXHRcdHRoaXMuX2NvbW1vblNoYXBlQ29uZmlndXJhdGlvbiA9IG51bGw7XG5cdFx0dGhpcy5fJGRhdHVtVG9TaGFwZSA9IG51bGw7XG5cdFx0dGhpcy5fJHNoYXBlVG9EYXR1bSA9IG51bGw7XG5cdFx0dGhpcy5fY29tbW9uU2hhcGUgPSBudWxsO1xuXHRcdHRoaXMuX3JlbmRlcmluZ0NvbnRleHQgPSBudWxsO1xuXHRcdHRoaXMuX2lzQ29udGV4dEVkaXRhYmxlID0gbnVsbDtcblx0XHR0aGlzLl9iZWhhdmlvciA9IG51bGw7XG5cdH1cblxuXG5cblx0LyoqXG5cdCAqIEFsbG93cyB0byBvdmVycmlkZSBkZWZhdWx0IHRoZSBgVGltZUNvbnRleHRCZWhhdmlvcmAgdXNlZCB0byBlZGl0IHRoZSBsYXllci5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGN0b3Jcblx0ICovXG5cdHN0YXRpYyBjb25maWd1cmVUaW1lQ29udGV4dEJlaGF2aW9yKGN0b3IpIHtcblx0XHR0aGlzLnRpbWVDb250ZXh0QmVoYXZpb3JDdG9yID0gY3Rvcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGBMYXllclRpbWVDb250ZXh0YCdzIGBzdGFydGAgdGltZSBkb21haW4gdmFsdWUuXG5cdCAqXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqL1xuXHRnZXQgc3RhcnQoKSB7XG5cdFx0cmV0dXJuIHRoaXMudGltZUNvbnRleHQuc3RhcnQ7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBgTGF5ZXJUaW1lQ29udGV4dGAncyBgc3RhcnRgIHRpbWUgZG9tYWluIHZhbHVlLlxuXHQgKlxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKi9cblx0c2V0IHN0YXJ0KHZhbHVlKSB7XG5cdFx0dGhpcy50aW1lQ29udGV4dC5zdGFydCA9IHZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYExheWVyVGltZUNvbnRleHRgJ3MgYG9mZnNldGAgdGltZSBkb21haW4gdmFsdWUuXG5cdCAqXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqL1xuXHRnZXQgb2Zmc2V0KCkge1xuXHRcdHJldHVybiB0aGlzLnRpbWVDb250ZXh0Lm9mZnNldDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIGBMYXllclRpbWVDb250ZXh0YCdzIGBvZmZzZXRgIHRpbWUgZG9tYWluIHZhbHVlLlxuXHQgKlxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKi9cblx0c2V0IG9mZnNldCh2YWx1ZSkge1xuXHRcdHRoaXMudGltZUNvbnRleHQub2Zmc2V0ID0gdmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgTGF5ZXJUaW1lQ29udGV4dGAncyBgZHVyYXRpb25gIHRpbWUgZG9tYWluIHZhbHVlLlxuXHQgKlxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKi9cblx0Z2V0IGR1cmF0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnRpbWVDb250ZXh0LmR1cmF0aW9uO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgYExheWVyVGltZUNvbnRleHRgJ3MgYGR1cmF0aW9uYCB0aW1lIGRvbWFpbiB2YWx1ZS5cblx0ICpcblx0ICogQHR5cGUge051bWJlcn1cblx0ICovXG5cdHNldCBkdXJhdGlvbih2YWx1ZSkge1xuXHRcdHRoaXMudGltZUNvbnRleHQuZHVyYXRpb24gPSB2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGBMYXllclRpbWVDb250ZXh0YCdzIGBzdHJldGNoUmF0aW9gIHRpbWUgZG9tYWluIHZhbHVlLlxuXHQgKlxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKi9cblx0Z2V0IHN0cmV0Y2hSYXRpbygpIHtcblx0XHRyZXR1cm4gdGhpcy50aW1lQ29udGV4dC5zdHJldGNoUmF0aW87XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBgTGF5ZXJUaW1lQ29udGV4dGAncyBgc3RyZXRjaFJhdGlvYCB0aW1lIGRvbWFpbiB2YWx1ZS5cblx0ICpcblx0ICogQHR5cGUge051bWJlcn1cblx0ICovXG5cdHNldCBzdHJldGNoUmF0aW8odmFsdWUpIHtcblx0XHR0aGlzLnRpbWVDb250ZXh0LnN0cmV0Y2hSYXRpbyA9IHZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgZG9tYWluIGJvdW5kYXJpZXMgb2YgdGhlIGRhdGEgZm9yIHRoZSB5IGF4aXMuXG5cdCAqXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICovXG5cdHNldCB5RG9tYWluKGRvbWFpbikge1xuXHRcdHRoaXMucGFyYW1zLnlEb21haW4gPSBkb21haW47XG5cdFx0dGhpcy5fdmFsdWVUb1BpeGVsLmRvbWFpbihkb21haW4pO1xuXHRcdHRoaXMuX3VwZGF0ZVJlbmRlcmluZ0NvbnRleHQoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkb21haW4gYm91bmRhcmllcyBvZiB0aGUgZGF0YSBmb3IgdGhlIHkgYXhpcy5cblx0ICpcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKi9cblx0Z2V0IHlEb21haW4oKSB7XG5cdFx0cmV0dXJuIHRoaXMucGFyYW1zLnlEb21haW47XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgd2hvbGUgbGF5ZXIuXG5cdCAqXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqL1xuXHRzZXQgb3BhY2l0eSh2YWx1ZSkge1xuXHRcdHRoaXMucGFyYW1zLm9wYWNpdHkgPSB2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBvcGFjaXR5IG9mIHRoZSB3aG9sZSBsYXllci5cblx0ICpcblx0ICogQHR5cGUge051bWJlcn1cblx0ICovXG5cdGdldCBvcGFjaXR5KCkge1xuXHRcdHJldHVybiB0aGlzLnBhcmFtcy5vcGFjaXR5O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHRyYW5zZmVydCBmdW5jdGlvbiB1c2VkIHRvIGRpc3BsYXkgdGhlIGRhdGEgaW4gdGhlIHggYXhpcy5cblx0ICpcblx0ICogQHR5cGUge051bWJlcn1cblx0ICovXG5cdGdldCB0aW1lVG9QaXhlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy50aW1lQ29udGV4dC50aW1lVG9QaXhlbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0cmFuc2ZlcnQgZnVuY3Rpb24gdXNlZCB0byBkaXNwbGF5IHRoZSBkYXRhIGluIHRoZSB5IGF4aXMuXG5cdCAqXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqL1xuXHRnZXQgdmFsdWVUb1BpeGVsKCkge1xuXHRcdHJldHVybiB0aGlzLl92YWx1ZVRvUGl4ZWw7XG5cdH1cblxuXG5cdGdldCBoZWlnaHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMucGFyYW1zLmhlaWdodDtcblx0fVxuXG5cdHNldCBoZWlnaHQodmFsdWUpIHtcblx0XHR0aGlzLnBhcmFtcy5oZWlnaHQgPSB2YWx1ZTtcblx0XHR0aGlzLl92YWx1ZVRvUGl4ZWwucmFuZ2UoW3RoaXMucGFyYW1zLmhlaWdodCwgMF0pO1xuXHRcdHRoaXMuX3VwZGF0ZVJlbmRlcmluZ0NvbnRleHQoKTtcblx0fVxuXG5cblxuXG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVyIHRoZSBiZWhhdmlvciB0byB1c2Ugd2hlbiBpbnRlcmFjdGluZyB3aXRoIGEgc2hhcGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QmFzZUJlaGF2aW9yfSBiZWhhdmlvclxuXHQgKi9cblx0c2V0QmVoYXZpb3IoYmVoYXZpb3IpIHtcblx0XHRiZWhhdmlvci5pbml0aWFsaXplKHRoaXMpO1xuXHRcdHRoaXMuX2JlaGF2aW9yID0gYmVoYXZpb3I7XG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKiogU0VMRUNUSU9OICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFxuXHRnZXQgc2VsZWN0ZWREYXR1bXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2JlaGF2aW9yID8gdGhpcy5fYmVoYXZpb3Iuc2VsZWN0ZWREYXR1bXMgOiBuZXcgU2V0KCk7XG5cdH1cblxuXHRpc1NlbGVjdGVkKGRhdHVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2JlaGF2aW9yLl9zZWxlY3RlZERhdHVtcy5oYXMoZGF0dW0pO1xuXHR9XG5cblx0c2VsZWN0KCRkYXR1bXMpIHtcblx0XHRpZiAoJGRhdHVtcyA9PT0gdW5kZWZpbmVkIHx8ICgkZGF0dW1zLmxlbmd0aCA9PT0gdW5kZWZpbmVkICYmICRkYXR1bXMuc2l6ZSA9PT0gdW5kZWZpbmVkKSlcblx0XHRcdCRkYXR1bXMgPSB0aGlzLmRhdGE7XG5cblx0XHRpZiAoIXRoaXMuX2JlaGF2aW9yIHx8ICF0aGlzLl9iZWhhdmlvci5jYW4oJ3NlbGVjdCcsICRkYXR1bXMpKSByZXR1cm4gZmFsc2U7XG5cblx0XHRjb25zdCB0aGF0ID0gdGhpcztcblx0XHQkZGF0dW1zLmZvckVhY2goKGRhdHVtKSA9PiB7XG5cdFx0XHRjb25zdCBzaGFwZSA9IHRoYXQuXyRkYXR1bVRvU2hhcGUuZ2V0KGRhdHVtKTtcblx0XHRcdGlmIChzaGFwZSkge1xuXHRcdFx0XHR0aGlzLl9iZWhhdmlvci5zZWxlY3QoZGF0dW0pO1xuXHRcdFx0XHR0aGlzLl90b0Zyb250KGRhdHVtKTtcblx0XHRcdFx0dGhhdC5lbWl0KCdzZWxlY3QnLCBkYXR1bSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGF0Ll9hZGQoZGF0dW0pO1xuXHRcdFx0XHR0aGlzLl9iZWhhdmlvci5zZWxlY3QoZGF0dW0pO1xuXHRcdFx0XHQvLyB0aHJvdyBuZXcgRXJyb3IoJ05vIHNoYXBlIGZvciB0aGlzIGRhdHVtIGluIHRoaXMgbGF5ZXInLCB7IGRhdHVtOiBkYXR1bSwgbGF5ZXI6IHRoYXQgfSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHVuc2VsZWN0KCRkYXR1bXMpIHtcblx0XHRpZiAoJGRhdHVtcyA9PT0gdW5kZWZpbmVkIHx8ICgkZGF0dW1zLmxlbmd0aCA9PT0gdW5kZWZpbmVkICYmICRkYXR1bXMuc2l6ZSA9PT0gdW5kZWZpbmVkKSlcblx0XHRcdCRkYXR1bXMgPSB0aGlzLmRhdGE7XG5cblx0XHRpZiAoIXRoaXMuX2JlaGF2aW9yIHx8ICF0aGlzLl9iZWhhdmlvci5jYW4oJ3Vuc2VsZWN0JywgJGRhdHVtcykpIHJldHVybiBmYWxzZTtcblx0XHRcblx0XHRjb25zdCB0aGF0ID0gdGhpcztcblx0XHQkZGF0dW1zLmZvckVhY2goKGRhdHVtKSA9PiB7XG5cdFx0XHRjb25zdCBzaGFwZSA9IHRoYXQuXyRkYXR1bVRvU2hhcGUuZ2V0KGRhdHVtKTtcblx0XHRcdGlmIChzaGFwZSkge1xuXHRcdFx0XHR0aGlzLl9iZWhhdmlvci51bnNlbGVjdChkYXR1bSk7XG5cdFx0XHRcdHRoYXQuZW1pdCgndW5zZWxlY3QnLCBkYXR1bSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGF0Ll9hZGQoZGF0dW0pO1xuXHRcdFx0XHR0aGlzLl9iZWhhdmlvci51bnNlbGVjdChkYXR1bSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdF90b0Zyb250KCRkYXR1bSkge1xuXHRcdGxldCAkc2hhcGUgPSB0aGlzLl8kZGF0dW1Ub1NoYXBlLmdldCgkZGF0dW0pO1xuXHRcdGlmICghJHNoYXBlKSB7XG5cdFx0XHR0aGlzLl9hZGQoJGRhdHVtKTtcblx0XHRcdCRzaGFwZSA9IHRoaXMuXyRkYXR1bVRvU2hhcGUuZ2V0KCRkYXR1bSk7XG5cdFx0fVxuXHRcdGlmICgkc2hhcGUuJGVsIGluc3RhbmNlb2YgQXJyYXkgfHwgJHNoYXBlLiRlbCBpbnN0YW5jZW9mIFNldCkge1xuXHRcdFx0JHNoYXBlLiRlbC5mb3JFYWNoKChlbCkgPT4gZWwubW92ZVRvVG9wKCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQkc2hhcGUuJGVsLm1vdmVUb1RvcCgpO1xuXHRcdH1cblx0fVxuXG5cdHRvRHJhZ0xheWVyKCRkYXR1bXMpIHtcblx0XHRjb25zdCB0aGF0ID0gdGhpcztcblx0XHQkZGF0dW1zLmZvckVhY2goKCRkYXR1bSkgPT4ge1xuXHRcdFx0bGV0ICRzaGFwZSA9IHRoaXMuXyRkYXR1bVRvU2hhcGUuZ2V0KCRkYXR1bSk7XG5cdFx0XHRpZiAoISRzaGFwZSkge1xuXHRcdFx0XHR0aGF0Ll9hZGQoJGRhdHVtKTtcblx0XHRcdFx0JHNoYXBlID0gdGhpcy5fJGRhdHVtVG9TaGFwZS5nZXQoJGRhdHVtKTtcblx0XHRcdH1cblx0XHRcdGlmICgkc2hhcGUuJGVsIGluc3RhbmNlb2YgQXJyYXkgfHwgJHNoYXBlLiRlbCBpbnN0YW5jZW9mIFNldCkge1xuXHRcdFx0XHQkc2hhcGUuJGVsLmZvckVhY2goKGVsKSA9PiB0aGF0Ll9kcmFnTGF5ZXIuYWRkKGVsKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9kcmFnTGF5ZXIuYWRkKCRzaGFwZS4kZWwpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblxuXHRcblx0dG9nZ2xlU2VsZWN0aW9uKCRkYXR1bXMpIHtcblx0XHRjb25zdCB0aGF0ID0gdGhpcztcblxuXHRcdC8vIFRPRE86IHVzZSB0aGUgdGhpcy5fYmVoYXZpb3IuY2FuIG1ldGhvZC5cblx0XHQkZGF0dW1zLmZvckVhY2goKGRhdHVtKSA9PiB7XG5cdFx0XHRsZXQgc2hhcGUgPSB0aGF0Ll8kZGF0dW1Ub1NoYXBlLmdldChkYXR1bSk7XG5cdFx0XHRpZiAoIXNoYXBlKSB7XG5cdFx0XHRcdHRoYXQuX2FkZChkYXR1bSk7XG5cdFx0XHRcdHNoYXBlID0gdGhpcy5fJGRhdHVtVG9TaGFwZS5nZXQoZGF0dW0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fYmVoYXZpb3IudG9nZ2xlU2VsZWN0aW9uKGRhdHVtKTtcblx0XHRcdHRoYXQuZW1pdCgndG9nZ2xlLXNlbGVjdCcsIGRhdHVtKTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjb250ZXh0IG9mIHRoZSBsYXllciwgdGh1cyBkZWZpbmluZyBpdHMgYHN0YXJ0YCwgYGR1cmF0aW9uYCxcblx0ICogYG9mZnNldGAgYW5kIGBzdHJldGNoUmF0aW9gLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1RpbWVDb250ZXh0fSB0aW1lQ29udGV4dCAtIFRoZSB0aW1lQ29udGV4dCBpbiB3aGljaCB0aGUgbGF5ZXIgaXMgZGlzcGxheWVkLlxuXHQgKi9cblx0c2V0VGltZUNvbnRleHQodGltZUNvbnRleHQpIHtcblx0XHR0aGlzLnRpbWVDb250ZXh0ID0gdGltZUNvbnRleHQ7XG5cdFx0Ly8gY3JlYXRlIGEgbWl4aW4gdG8gcGFzcyB0byB0aGUgc2hhcGVzXG5cdFx0dGhpcy5fcmVuZGVyaW5nQ29udGV4dCA9IHt9O1xuXHRcdHRoaXMuX3VwZGF0ZVJlbmRlcmluZ0NvbnRleHQoKTtcblx0fVxuXG5cdC8qKlxuXHQqIFJlZ2lzdGVyIGEgc2hhcGUgYW5kIGl0cyBjb25maWd1cmF0aW9uIHRvIHVzZSBpbiBvcmRlciB0byByZW5kZXIgdGhlIGRhdGEuXG5cdCpcblx0KiBAcGFyYW0ge0Jhc2VTaGFwZX0gY3RvciAtIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgc2hhcGUgdG8gYmUgdXNlZC5cblx0KiBAcGFyYW0ge09iamVjdH0gW2FjY2Vzc29ycz17fV0gLSBEZWZpbmVzIGhvdyB0aGUgc2hhcGUgc2hvdWxkIGFkYXB0IHRvIGEgcGFydGljdWxhciBkYXRhIHN0cnV0dXJlLlxuXHQqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBHbG9iYWwgY29uZmlndXJhdGlvbiBmb3IgdGhlIHNoYXBlcywgaXMgc3BlY2lmaWMgdG8gZWFjaCBgU2hhcGVgLlxuXHQqL1xuXHRjb25maWd1cmVTaGFwZShjdG9yLCBhY2Nlc3NvcnMsIG9wdGlvbnMpIHtcblx0XHRpZiAoIWFjY2Vzc29ycykgXG5cdFx0XHRhY2Nlc3NvcnMgPSB7fTtcblx0XHRpZiAoIW9wdGlvbnMpIFxuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdHRoaXMuX3NoYXBlQ29uZmlndXJhdGlvbiA9IHsgY3RvcjogY3RvciwgYWNjZXNzb3JzOiBhY2Nlc3NvcnMsIG9wdGlvbnM6IG9wdGlvbnMgfTtcblx0fVxuXG5cdC8qKlxuXHQqIE9wdGlvbm5hbHkgcmVnaXN0ZXIgYSBzaGFwZSB0byBiZSB1c2VkIGFjY3JvcyB0aGUgZW50aXJlIGNvbGxlY3Rpb24uXG5cdCpcblx0KiBAcGFyYW0ge0Jhc2VTaGFwZX0gY3RvciAtIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgc2hhcGUgdG8gYmUgdXNlZC5cblx0KiBAcGFyYW0ge09iamVjdH0gW2FjY2Vzc29ycz17fV0gLSBEZWZpbmVzIGhvdyB0aGUgc2hhcGUgc2hvdWxkIGFkYXB0IHRvIGEgcGFydGljdWxhciBkYXRhIHN0cnV0dXJlLlxuXHQqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBHbG9iYWwgY29uZmlndXJhdGlvbiBmb3IgdGhlIHNoYXBlcywgaXMgc3BlY2lmaWMgdG8gZWFjaCBgU2hhcGVgLlxuXHQqL1xuXHRjb25maWd1cmVDb21tb25TaGFwZShDdG9yLCBhY2Nlc3NvcnMsIG9wdGlvbnMpIHtcblx0XHRpZiAoIWFjY2Vzc29ycylcdGFjY2Vzc29ycyA9IHt9O1xuXHRcdGlmICghb3B0aW9ucylcdG9wdGlvbnMgPSB7fTtcblx0XHR0aGlzLl9jb21tb25TaGFwZUNvbmZpZ3VyYXRpb24gPSB7IGN0b3I6IEN0b3IsIGFjY2Vzc29yczogYWNjZXNzb3JzLCBvcHRpb25zOiBvcHRpb25zIH07XG5cdFx0dGhpcy5fY29tbW9uU2hhcGUgPSBuZXcgQ3RvcihvcHRpb25zKTtcblx0XHR0aGlzLl9jb21tb25TaGFwZS5pbnN0YWxsKGFjY2Vzc29ycyk7XG5cdFx0dGhpcy5fY29tbW9uU2hhcGUucmVuZGVyKHRoaXMuX3JlbmRlcmluZ0NvbnRleHQpO1xuXHRcdGlmICh0aGlzLl9jb21tb25TaGFwZS4kZWwgaW5zdGFuY2VvZiBBcnJheSB8fCB0aGlzLl9jb21tb25TaGFwZS4kZWwgaW5zdGFuY2VvZiBTZXQpIHtcblx0XHRcdHRoaXMuX2NvbW1vblNoYXBlLiRlbC5mb3JFYWNoKChlbCkgPT4gdGhpcy5fY29tbW9uU2hhcGVMYXllci5hZGQoZWwpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY29tbW9uU2hhcGVMYXllci5hZGQodGhpcy5fY29tbW9uU2hhcGUuJGVsKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEZWZpbmVzIGlmIHRoZSBgTGF5ZXJgLCBhbmQgdGh1cyB0aGUgYExheWVyVGltZUNvbnRleHRgIGlzIGVkaXRhYmxlIG9yIG5vdC5cblx0KlxuXHQqIEBwYXJhbXMge0Jvb2xlYW59IFtib29sPXRydWVdXG5cdCovXG5cdHNldENvbnRleHRFZGl0YWJsZShlZGl0YWJsZSkge1xuXHRcdGlmIChlZGl0YWJsZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0ZWRpdGFibGUgPSB0cnVlO1xuXHRcdC8vIHRoaXMuX2NvbnRleHRMYXllci52aXNpYmxlKGVkaXRhYmxlKTtcblx0XHR0aGlzLl9jb250ZXh0TGF5ZXIub3BhY2l0eSgoZWRpdGFibGUpPyB0aGlzLnBhcmFtcy5jb250ZXh0Lm9wYWNpdHkgOiAwKTtcblx0XHR0aGlzLl9jb250ZXh0TGF5ZXIubGlzdGVuaW5nKGVkaXRhYmxlKTtcblx0XHR0aGlzLl9jb250ZXh0TGF5ZXIudmlzaWJsZShlZGl0YWJsZSk7XG5cdFx0dGhpcy5faXNDb250ZXh0RWRpdGFibGUgPSBlZGl0YWJsZTtcblx0fVxuXHRcblxuXG5cdC8qKlxuXHQqIFVwZGF0ZXMgdGhlIHZhbHVlcyBzdG9yZWQgaW50IHRoZSBgX3JlbmRlcmluZ0NvbnRleHRgIHBhc3NlZFx0dG8gc2hhcGVzXG5cdCogZm9yIHJlbmRlcmluZyBhbmQgdXBkYXRpbmcuXG5cdCovXG5cdF91cGRhdGVSZW5kZXJpbmdDb250ZXh0KCkge1xuXG5cdFx0dGhpcy5fcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbCA9IHRoaXMudGltZUNvbnRleHQudGltZVRvUGl4ZWw7XG5cdFx0dGhpcy5fcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwgPSB0aGlzLl92YWx1ZVRvUGl4ZWw7XG5cblx0XHR0aGlzLl9yZW5kZXJpbmdDb250ZXh0LmhlaWdodCA9IHRoaXMucGFyYW1zLmhlaWdodDtcblx0XHR0aGlzLl9yZW5kZXJpbmdDb250ZXh0LndpZHRoICA9IHRoaXMudGltZUNvbnRleHQudGltZVRvUGl4ZWwodGhpcy50aW1lQ29udGV4dC5kdXJhdGlvbik7XG5cdFx0Ly8gZm9yIGZvcmVpZ24gb2JqZWN0IGlzc3VlIGluIGNocm9tZVxuXHRcdHRoaXMuX3JlbmRlcmluZ0NvbnRleHQub2Zmc2V0WCA9IHRoaXMudGltZUNvbnRleHQudGltZVRvUGl4ZWwodGhpcy50aW1lQ29udGV4dC5vZmZzZXQpO1xuXHRcdHRoaXMuX3JlbmRlcmluZ0NvbnRleHQuc3RhcnRYID0gdGhpcy50aW1lQ29udGV4dC5wYXJlbnQudGltZVRvUGl4ZWwodGhpcy50aW1lQ29udGV4dC5zdGFydCk7XG5cdFx0dGhpcy5fcmVuZGVyaW5nQ29udGV4dC5waXhlbHNQZXJTZWNvbmQgPSB0aGlzLnRpbWVDb250ZXh0LnBhcmVudC5jb21wdXRlZFBpeGVsc1BlclNlY29uZDtcblxuXHRcdC8vIEB0b2RvIHJlcGxhY2Ugd2l0aCBgbWluWGAgYW5kIGBtYXhYYCByZXByZXNlbnRpbmcgdGhlIHZpc2libGUgcGl4ZWxzIGluIHdoaWNoXG5cdFx0Ly8gdGhlIHNoYXBlcyBzaG91bGQgYmUgcmVuZGVyZWQsIGNvdWxkIGFsbG93IHRvIG5vdCB1cGRhdGUgdGhlIERPTSBvZiBzaGFwZXNcblx0XHQvLyB3aG8gYXJlIG5vdCBpbiB0aGlzIGFyZWEuXG5cdFx0dGhpcy5fcmVuZGVyaW5nQ29udGV4dC50cmFja09mZnNldFggPSB0aGlzLnRpbWVDb250ZXh0LnBhcmVudC50aW1lVG9QaXhlbCh0aGlzLnRpbWVDb250ZXh0LnBhcmVudC5vZmZzZXQpO1xuXHRcdHRoaXMuX3JlbmRlcmluZ0NvbnRleHQudmlzaWJsZVdpZHRoID0gdGhpcy50aW1lQ29udGV4dC5wYXJlbnQudmlzaWJsZVdpZHRoO1xuXHR9XG5cblxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvLyBIZWxwZXJzXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0Z2V0RGF0dW1Gcm9tU2hhcGUoJHNoYXBlKSB7XG5cdFx0cmV0dXJuIHRoaXMuXyRzaGFwZVRvRGF0dW0uZ2V0KCRzaGFwZSk7XG5cdH1cblxuXHRnZXRTaGFwZUZyb21EYXR1bSgkZGF0dW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fJGRhdHVtVG9TaGFwZS5nZXQoJGRhdHVtKTtcblx0fVxuXG5cdC8qKlxuXHQqIFJldHJpZXZlIGFsbCB0aGUgZGF0dW1zIGluIGEgZ2l2ZW4gYXJlYSBhcyBkZWZpbmVkIGluIHRoZSByZWdpc3RlcmVkIGBTaGFwZX5pbkFyZWFgIG1ldGhvZC5cblx0KlxuXHQqIEBwYXJhbSB7T2JqZWN0fSBhcmVhIC0gVGhlIGFyZWEgaW4gd2hpY2ggdG8gZmluZCB0aGUgZWxlbWVudHNcblx0KiBAcGFyYW0ge051bWJlcn0gYXJlYS50b3Bcblx0KiBAcGFyYW0ge051bWJlcn0gYXJlYS5sZWZ0XG5cdCogQHBhcmFtIHtOdW1iZXJ9IGFyZWEud2lkdGhcblx0KiBAcGFyYW0ge051bWJlcn0gYXJlYS5oZWlnaHRcblx0KiBAcmV0dXJuIHtBcnJheX0gLSBsaXN0IG9mIHRoZSBkYXR1bXMgcHJlc2VudHMgaW4gdGhlIGFyZWFcblx0Ki9cblx0Z2V0RGF0dW1zSW5BcmVhKGFyZWEpIHtcblx0XHRcblx0XHRsZXQgeDEgPSBhcmVhLmxlZnQ7XG5cdFx0bGV0IHkxID0gYXJlYS50b3A7XG5cdFx0bGV0IHgyID0gYXJlYS5sZWZ0ICsgYXJlYS53aWR0aDtcblx0XHRsZXQgeTIgPSBhcmVhLnRvcCArIGFyZWEuaGVpZ2h0ICsgdGhpcy5wYXJhbXMudG9wO1xuXG5cdFx0Y29uc3QgJGZpbHRlcmVkRGF0dW1zID0gbmV3IFNldCgpO1xuXG5cdFx0Y29uc3QgJGVudHJpZXMgPSB0aGlzLl8kZGF0dW1Ub1NoYXBlLmVudHJpZXMoKTtcblxuXHRcdGNvbnN0IHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy5jb250ZW50TGF5ZXJzLmZvckVhY2goKGNvbnRlbnRMYXllcikgPT4ge1xuXHRcdFx0Y29udGVudExheWVyLmNoaWxkcmVuLmZvckVhY2goKGtvbnZhU2hhcGUpID0+IHtcblx0XHRcdFx0Y29uc3QgJHNoYXBlID0ga29udmFTaGFwZS5zaGFwZTtcblx0XHRcdFx0aWYgKCRzaGFwZSkge1xuXHRcdFx0XHRcdGNvbnN0ICRkYXR1bSA9IHRoYXQuZ2V0RGF0dW1Gcm9tU2hhcGUoJHNoYXBlKTtcblx0XHRcdFx0XHRjb25zdCBpbkFyZWEgPSAkc2hhcGUuaW5BcmVhKHRoaXMuX3JlbmRlcmluZ0NvbnRleHQsICRkYXR1bSwgeDEsIHkxLCB4MiwgeTIpO1xuXG5cdFx0XHRcdFx0aWYgKGluQXJlYSkgeyBcblx0XHRcdFx0XHRcdCRmaWx0ZXJlZERhdHVtcy5hZGQoJGRhdHVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdFxuXHRcdHJldHVybiAkZmlsdGVyZWREYXR1bXM7XG5cdH1cblxuXHRnZXREYXR1bXNJbkludGVydmFsKHN0YXJ0LCBkdXJhdGlvbikge1xuXHRcdHRocm93IG5ldyBFcnJvcignVGhlIGRldmVsb3BlciBtdXN0IGFzc2lnbiBhIHByb3BlciBmdW5jdGlvbicpO1xuXHR9XG5cblx0dXBkYXRlKCRkYXR1bXMpIHtcblxuXHRcdHRoaXMudXBkYXRlQ29udGFpbmVyKCk7XG5cblx0XHRpZiAodGhpcy52aXNpYmxlKVxuXHRcdFx0dGhpcy51cGRhdGVTaGFwZXMoJGRhdHVtcyk7XG5cdFx0XG5cdH1cblxuXG5cdHNvcnRfZGF0YShkYXRhKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgZGV2ZWxvcGVyIG11c3QgYXNzaWduIGEgcHJvcGVyIGZ1bmN0aW9uJyk7XG5cdH1cblxuXHR2aXNpYmxlX2RhdGEodGltZUNvbnRleHQsIGRhdGEpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkZXZlbG9wZXIgbXVzdCBhc3NpZ24gYSBwcm9wZXIgZnVuY3Rpb24nKTtcblx0fVxuXG5cblx0dXBkYXRlU2hhcGVzKCRkYXR1bXMpIHtcblx0XHRjb25zdCB0aGF0ID0gdGhpcztcblx0XHRjb25zdCBjaGFuZ2VkQ29udGVudExheWVycyA9IG5ldyBTZXQoKTtcblx0XHR2YXIgdGFyZ2V0RGF0YSA9IG51bGw7XG5cdFx0dmFyIGludGVydmFsID0gbnVsbDtcblx0XHR2YXIgZXJhc2VDaGlsZHJlbiA9IHRydWU7XG5cblx0XHRpZiAoJGRhdHVtcyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX2NvbW1vblNoYXBlKSB7XG5cdFx0XHRpbnRlcnZhbCA9IHRoaXMudmlzaWJsZV9kYXRhKHRoaXMudGltZUNvbnRleHQsIHRoaXMuZGF0YSk7XG5cdFx0fVxuXG5cdFx0aWYgKCRkYXR1bXMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGFyZ2V0RGF0YSA9IHRoaXMuZGF0YS5zbGljZShpbnRlcnZhbFswXSwgTWF0aC5taW4oaW50ZXJ2YWxbMV0rMSwgdGhpcy5kYXRhLmxlbmd0aCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXREYXRhID0gJGRhdHVtcztcblx0XHRcdGVyYXNlQ2hpbGRyZW4gPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBjb25zb2xlLmxvZyhbdGhpcy5fJGRhdHVtVG9TaGFwZS5zaXplLCB0aGlzLmRhdGEubGVuZ3RoXSk7XG5cdFx0dGhpcy5hbGxvY2F0ZVNoYXBlc1RvQ29udGVudExheWVycyh0aGlzLl9zdGFnZSwgdGFyZ2V0RGF0YSwgJ2RhdHVtcycsIGVyYXNlQ2hpbGRyZW4pLmZvckVhY2goKGNoYW5nZWRDb250ZW50TGF5ZXIpID0+IHtcblx0XHRcdGNoYW5nZWRDb250ZW50TGF5ZXJzLmFkZChjaGFuZ2VkQ29udGVudExheWVyKTtcblx0XHR9KTtcblxuXHRcdC8vIGNvbnNvbGUubG9nKCdudW1iZXIgb2YgY2hhbmdlZENvbnRlbnRMYXllcnMgOiAnICsgY2hhbmdlZENvbnRlbnRMYXllcnMuc2l6ZSk7XG5cblx0XHRjaGFuZ2VkQ29udGVudExheWVycy5mb3JFYWNoKChjaGFuZ2VkQ29udGVudExheWVyKSA9PiB7XG5cdFx0XHRjaGFuZ2VkQ29udGVudExheWVyXG5cdFx0XHRcdC55KHRoYXQucGFyYW1zLnRvcClcblx0XHRcdFx0Lm9mZnNldFgoLXRoYXQuX3JlbmRlcmluZ0NvbnRleHQuc3RhcnRYKVxuXHRcdFx0XHQueCh0aGF0Ll9yZW5kZXJpbmdDb250ZXh0Lm9mZnNldFgpXG5cdFx0XHRcdC5jbGlwKHsgXG5cdFx0XHRcdFx0eDogLXRoYXQuX3JlbmRlcmluZ0NvbnRleHQub2Zmc2V0WCwgXG5cdFx0XHRcdFx0eTogMCwgXG5cdFx0XHRcdFx0d2lkdGg6IHRoYXQuX3JlbmRlcmluZ0NvbnRleHQud2lkdGgsIFxuXHRcdFx0XHRcdGhlaWdodDogdGhhdC5fcmVuZGVyaW5nQ29udGV4dC5oZWlnaHQgXG5cdFx0XHRcdH0pO1xuXHRcdFx0Y2hhbmdlZENvbnRlbnRMYXllci5jbGVhcigpO1xuXHRcdFx0Y2hhbmdlZENvbnRlbnRMYXllci5iYXRjaERyYXcoKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuX2RyYWdMYXllclxuXHRcdFx0XHQueSh0aGF0LnBhcmFtcy50b3ApXG5cdFx0XHRcdC5vZmZzZXRYKC10aGF0Ll9yZW5kZXJpbmdDb250ZXh0LnN0YXJ0WClcblx0XHRcdFx0LngodGhhdC5fcmVuZGVyaW5nQ29udGV4dC5vZmZzZXRYKVxuXHRcdFx0XHQuY2xpcCh7IFxuXHRcdFx0XHRcdHg6IC10aGF0Ll9yZW5kZXJpbmdDb250ZXh0Lm9mZnNldFgsIFxuXHRcdFx0XHRcdHk6IDAsIFxuXHRcdFx0XHRcdHdpZHRoOiB0aGF0Ll9yZW5kZXJpbmdDb250ZXh0LndpZHRoLCBcblx0XHRcdFx0XHRoZWlnaHQ6IHRoYXQuX3JlbmRlcmluZ0NvbnRleHQuaGVpZ2h0IFxuXHRcdFx0XHR9KS5jbGVhcigpLmJhdGNoRHJhdygpO1xuXG5cblx0XHRpZiAodGhpcy5fY29tbW9uU2hhcGUpIHtcblx0XHRcdHRoaXMuX2NvbW1vblNoYXBlTGF5ZXJcblx0XHRcdFx0LnkodGhhdC5wYXJhbXMudG9wKVxuXHRcdFx0XHQub2Zmc2V0WCgtdGhhdC5fcmVuZGVyaW5nQ29udGV4dC5zdGFydFgpXG5cdFx0XHRcdC54KHRoYXQuX3JlbmRlcmluZ0NvbnRleHQub2Zmc2V0WClcblx0XHRcdFx0LmNsaXAoeyBcblx0XHRcdFx0XHR4OiAtdGhhdC5fcmVuZGVyaW5nQ29udGV4dC5vZmZzZXRYLCBcblx0XHRcdFx0XHR5OiAwLCBcblx0XHRcdFx0XHR3aWR0aDogdGhhdC5fcmVuZGVyaW5nQ29udGV4dC53aWR0aCwgXG5cdFx0XHRcdFx0aGVpZ2h0OiB0aGF0Ll9yZW5kZXJpbmdDb250ZXh0LmhlaWdodFxuXHRcdFx0XHR9KTtcblx0XHRcdHRoaXMuX2NvbW1vblNoYXBlLnVwZGF0ZSh0aGlzLl9yZW5kZXJpbmdDb250ZXh0LCB0aGF0LmRhdGEuc2xpY2UoaW50ZXJ2YWxbMF0sIGludGVydmFsWzFdKzEpKTtcblx0XHRcdHRoaXMuX2NvbW1vblNoYXBlTGF5ZXIuYmF0Y2hEcmF3KCk7XG5cdFx0XHQvLyB0aGlzLl9jb21tb25TaGFwZUxheWVyLm1vdmVUb0JvdHRvbSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NvbnRleHRTaGFwZS51cGRhdGUodGhpcy5fcmVuZGVyaW5nQ29udGV4dCwgdGhpcy50aW1lQ29udGV4dCk7XG5cblx0XHR0aGlzLl9jb250ZXh0TGF5ZXJcblx0XHRcdFx0LnkodGhhdC5wYXJhbXMudG9wKVxuXHRcdFx0XHQuYmF0Y2hEcmF3KCk7XG5cdFx0XHRcdC8vIC5tb3ZlVG9Cb3R0b20oKTtcblx0fVxuXG5cdHVwZGF0ZUNvbnRhaW5lcigpIHtcblx0XHR0aGlzLl91cGRhdGVSZW5kZXJpbmdDb250ZXh0KCk7XG5cdFx0Y29uc3QgdGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLmNvbnRlbnRMYXllcnMuZm9yRWFjaCgoY29udGVudExheWVyKSA9PiB7XG5cdFx0XHRjb250ZW50TGF5ZXJcblx0XHRcdFx0Lm9mZnNldFgoLXRoaXMuX3JlbmRlcmluZ0NvbnRleHQuc3RhcnRYKVxuXHRcdFx0XHQueCh0aGlzLl9yZW5kZXJpbmdDb250ZXh0Lm9mZnNldFgpXG5cdFx0XHRcdC5jbGlwKHt4Oi10aGlzLl9yZW5kZXJpbmdDb250ZXh0Lm9mZnNldFgsIHk6MCwgd2lkdGg6IHRoaXMuX3JlbmRlcmluZ0NvbnRleHQud2lkdGgsIGhlaWdodDogdGhpcy5fcmVuZGVyaW5nQ29udGV4dC5oZWlnaHR9KTtcblx0XHR9KTtcblx0fVxuXG5cblxuXHRhbGxvY2F0ZVNoYXBlc1RvQ29udGVudExheWVycyhzdGFnZSwgb2JqcywgdHlwZSwgZXJhc2VDaGlsZHJlbikge1xuXHRcdGNvbnN0IExJTUlUID0gSW5maW5pdHk7IC8vIFRPRE86IG1ha2UgdGhlIExJTUlUIGEgZHluYW1pYyB2YXJpYWJsZSwgY29udHJvbGxlZCBieSBhIHVzZXIgZGVmaW5lZCBmdW5jdGlvbi5cblxuXHRcdGNvbnN0IGNoYW5nZWRDb250ZW50TGF5ZXJzID0gbmV3IFNldCgpO1xuXG5cdFx0Y29uc3Qga29udmFTaGFwZXMgPSBuZXcgU2V0KCk7XG5cblx0XHQvKlxuXHRcdCAqIE9mIGNvdXJzZSBvbmUgY291bGQgd3JpdGUgbGVzcyBjb2RlIGJ5IGluY2x1ZGluZyB0aGUgdHlwZSBjaGVja2luZyBpbnNpZGUgdGhlIGZvckVhY2guXG5cdFx0ICogQnV0IHRoYXQgd291bGQgbWVhbiBhIGNoZWNrIGZvciBlYWNoIG9iamVjdC4gVGhpcyB3YXksIHRoZSBwcm9ncmFtIGNoZWNrcyBvbmx5IG9uZSB0aW1lLlxuXHRcdCAqIFRoaXMgaXMgbWVhbnQgdG8gYmUgYSBzbWFsbCBvcHRpbWl6YXRpb24uIE5vdCBwcmV0dHksIG9mIGNvdXJzZS5cblx0XHQgKiBBbm90aGVyIHRoaW5nOiBpbiBvcmRlciB0byB1c2UganVzdCBvbmUgZm9yRWFjaCBhdCB1cGRhdGVTaGFwZXMsIEkgaW5jbHVkZWQgdGhlIHNoYXBlIHVwZGF0ZSBpbiBoZXJlXG5cdFx0ICovXG5cdFx0Y29uc3QgdGhhdCA9IHRoaXM7XG5cdFx0aWYgKHR5cGUgPT0gJ2RhdHVtcycpIHtcblx0XHRcdG9ianMuZm9yRWFjaCgoZGF0dW0pID0+IHtcblx0XHRcdFx0bGV0IHNoYXBlID0gdGhhdC5nZXRTaGFwZUZyb21EYXR1bShkYXR1bSk7XG5cdFx0XHRcdGlmIChzaGFwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Ly8gdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGRhdHVtJywgeyBkYXR1bTogZGF0dW0sIGxheWVyOiB0aGF0IH0pO1xuXHRcdFx0XHRcdHRoYXQuX2FkZChkYXR1bSk7XG5cdFx0XHRcdFx0c2hhcGUgPSB0aGF0LmdldFNoYXBlRnJvbURhdHVtKGRhdHVtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzaGFwZS51cGRhdGUodGhhdC5fcmVuZGVyaW5nQ29udGV4dCwgZGF0dW0pOyBcblx0XHRcdFx0aWYgKHNoYXBlLiRlbCBpbnN0YW5jZW9mIEFycmF5IHx8IHNoYXBlLiRlbCBpbnN0YW5jZW9mIFNldCkge1xuXHRcdFx0XHRcdHNoYXBlLiRlbC5mb3JFYWNoKChlbCkgPT4ga29udmFTaGFwZXMuYWRkKGVsKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0a29udmFTaGFwZXMuYWRkKHNoYXBlLiRlbCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PSAnc2hhcGVzJykge1xuXHRcdFx0b2Jqcy5mb3JFYWNoKChzaGFwZSkgPT4ge1xuXHRcdFx0XHRjb25zdCBkYXR1bSA9IHRoYXQuZ2V0RGF0dW1Gcm9tU2hhcGUoc2hhcGUpO1xuXHRcdFx0XHRpZiAoZGF0dW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5rbm93biBzaGFwZScsIHsgc2hhcGU6IHNoYXBlLCBsYXllcjogdGhhdCB9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzaGFwZS51cGRhdGUodGhhdC5fcmVuZGVyaW5nQ29udGV4dCwgZGF0dW0pOyBcblx0XHRcdFx0aWYgKHNoYXBlLiRlbCBpbnN0YW5jZW9mIEFycmF5IHx8IHNoYXBlLiRlbCBpbnN0YW5jZW9mIFNldCkge1xuXHRcdFx0XHRcdHNoYXBlLiRlbC5mb3JFYWNoKChlbCkgPT4ga29udmFTaGFwZXMuYWRkKGVsKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0a29udmFTaGFwZXMuYWRkKHNoYXBlLiRlbCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gb2JqZWN0cyB0eXBlJyk7XG5cdFx0fVxuXG5cdFx0Y29uc3Qga3NJdCA9IGtvbnZhU2hhcGVzLmVudHJpZXMoKTtcblxuXHRcdGNvbnN0IGNsSXQgPSB0aGlzLmNvbnRlbnRMYXllcnMuZW50cmllcygpO1xuXG5cdFx0dmFyIGNsZSA9IGNsSXQubmV4dCgpO1xuXHRcdHZhciBrc2UgPSBrc0l0Lm5leHQoKTtcblxuXHRcdHZhciBwcmV2aW91c1NoYXBlID0gbnVsbDtcblxuXHRcdHdoaWxlICghY2xlLmRvbmUpIHtcblx0XHRcdGNvbnN0IGxheWVyID0gY2xlLnZhbHVlWzFdO1xuXHRcdFx0d2hpbGUgKCFrc2UuZG9uZSkge1xuXHRcdFx0XHRjb25zdCBrb252YVNoYXBlID0ga3NlLnZhbHVlWzFdO1xuXHRcdFx0XHRpZiAobGF5ZXIuY2hpbGRyZW4ubGVuZ3RoID49IExJTUlUICYmIGtvbnZhU2hhcGUuc2hhcGUgIT0gcHJldmlvdXNTaGFwZSkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlcmFzZUNoaWxkcmVuICYmICFjaGFuZ2VkQ29udGVudExheWVycy5oYXMobGF5ZXIpKSB7XG5cdFx0XHRcdFx0bGF5ZXIucmVtb3ZlQ2hpbGRyZW4oKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRrb252YVNoYXBlLnJlbW92ZSgpO1xuXHRcdFx0XHRsYXllci5hZGQoa29udmFTaGFwZSk7XG5cdFx0XHRcdGtzZSA9IGtzSXQubmV4dCgpO1xuXHRcdFx0XHRjaGFuZ2VkQ29udGVudExheWVycy5hZGQobGF5ZXIpO1xuXHRcdFx0fVxuXHRcdFx0Y2xlID0gY2xJdC5uZXh0KCk7XG5cdFx0fVxuXG5cdFx0d2hpbGUgKCFrc2UuZG9uZSkge1xuXHRcdFx0Y29uc3QgbGF5ZXIgPSBuZXcgS29udmEuTGF5ZXIoe30pO1xuXHRcdFx0bGF5ZXIubGF5ZXIgPSB0aGlzO1xuXHRcdFx0bGF5ZXIuYWRkTmFtZSgnY29udGVudC1sYXllcicpO1xuXHRcdFx0bGF5ZXIuY2xlYXJCZWZvcmVEcmF3KHRydWUpO1xuXHRcdFx0dGhpcy5jb250ZW50TGF5ZXJzLmFkZChsYXllcik7XG5cdFx0XHRzdGFnZS5hZGQobGF5ZXIpO1xuXHRcdFx0d2hpbGUgKCFrc2UuZG9uZSAmJiBsYXllci5jaGlsZHJlbi5sZW5ndGggPCBMSU1JVCkge1xuXHRcdFx0XHRjb25zdCBrb252YVNoYXBlID0ga3NlLnZhbHVlWzFdO1xuXHRcdFx0XHRrb252YVNoYXBlLnJlbW92ZSgpO1xuXHRcdFx0XHRsYXllci5hZGQoa29udmFTaGFwZSk7XG5cdFx0XHRcdGtzZSA9IGtzSXQubmV4dCgpO1xuXHRcdFx0fVxuXHRcdFx0Y2hhbmdlZENvbnRlbnRMYXllcnMuYWRkKGxheWVyKTtcblx0XHR9XG5cblx0XHQvLyBrb252YVNoYXBlcy5mb3JFYWNoKChrcykgPT4ga3Muc2hhcGUuc3RhcnREcmFnKCkpO1xuXG5cdFx0cmV0dXJuIGNoYW5nZWRDb250ZW50TGF5ZXJzO1xuXHR9XG5cblx0c2V0KGRhdGEpIHtcblx0XHRpZiAoIXRoaXMuX2JlaGF2aW9yIHx8ICF0aGlzLl9iZWhhdmlvci5jYW4oJ2FkZCcsIGRhdGEpKSByZXR1cm4gZmFsc2U7XG5cblx0XHRjb25zdCB0aGF0ID0gdGhpcztcblxuXHRcdHRoaXMudW5zZWxlY3QoKTtcblxuXHRcdHRoaXMuZGF0YS5mb3JFYWNoKChkYXR1bSkgPT4gdGhhdC5fJGRhdHVtVG9TaGFwZS5nZXQoZGF0dW0pLmRlc3Ryb3koKSk7XG5cdFx0dGhpcy5fJGRhdHVtVG9TaGFwZS5jbGVhcigpO1xuXHRcdHRoaXMuXyRzaGFwZVRvRGF0dW0uY2xlYXIoKTtcblxuXHRcdHRoaXMuY29udGVudExheWVycy5mb3JFYWNoKChsYXllcik9PiBsYXllci5kZXN0cm95KCkpO1xuXG5cdFx0dGhpcy5kYXRhLmxlbmd0aCA9IDA7XG5cblx0XHRkYXRhLmZvckVhY2goKGRhdHVtKSA9PiB7XG5cdFx0XHR0aGF0Ll9hZGQoZGF0dW0pO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5kYXRhID0gZGF0YTtcblxuXHRcdHRoaXMuc29ydF9kYXRhKHRoaXMuZGF0YSk7XG5cblx0XHR0aGlzLmVtaXQoJ3NldCcsIGRhdGEpO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRfYWRkKGRhdHVtKSB7XG5cdFx0Y29uc3QgQ3RvciA9IHRoaXMuX3NoYXBlQ29uZmlndXJhdGlvbi5jdG9yO1xuXHRcdGNvbnN0IGFjY2Vzc29ycyA9IHRoaXMuX3NoYXBlQ29uZmlndXJhdGlvbi5hY2Nlc3NvcnM7XG5cdFx0Y29uc3Qgb3B0aW9ucyA9IHRoaXMuX3NoYXBlQ29uZmlndXJhdGlvbi5vcHRpb25zO1xuXG5cdFx0Y29uc3Qgc2hhcGUgPSBuZXcgQ3RvcihvcHRpb25zKTtcblx0XHRzaGFwZS5pbnN0YWxsKGFjY2Vzc29ycyk7XG5cdFx0c2hhcGUucmVuZGVyKHRoaXMuX3JlbmRlcmluZ0NvbnRleHQpO1xuXHRcdHNoYXBlLmxheWVyID0gdGhpcztcblx0XHRzaGFwZS5kYXR1bSA9IGRhdHVtO1xuXHRcdHRoaXMuXyRkYXR1bVRvU2hhcGUuc2V0KGRhdHVtLCBzaGFwZSk7XG5cdFx0dGhpcy5fJHNoYXBlVG9EYXR1bS5zZXQoc2hhcGUsIGRhdHVtKTtcblx0fVxuXG5cdGFkZChkYXR1bSkge1xuXHRcdGlmICghdGhpcy5fYmVoYXZpb3IgfHwgIXRoaXMuX2JlaGF2aW9yLmNhbignYWRkJywgW2RhdHVtXSkpIHJldHVybiBmYWxzZTtcblxuXHRcdHRoaXMuX2FkZChkYXR1bSk7XG5cdFx0dGhpcy5kYXRhW3RoaXMuZGF0YS5sZW5ndGhdID0gZGF0dW07XG5cdFx0dGhpcy5zb3J0X2RhdGEodGhpcy5kYXRhKTtcblxuXHRcdHRoaXMuZW1pdCgnYWRkJywgZGF0dW0pO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZW1vdmUoZGF0dW0pIHtcblx0XHRpZiAoIXRoaXMuX2JlaGF2aW9yIHx8ICF0aGlzLl9iZWhhdmlvci5jYW4oJ3JlbW92ZScsIFtkYXR1bV0pKSByZXR1cm4gZmFsc2U7XG5cblx0XHR0aGlzLnVuc2VsZWN0KFtkYXR1bV0pO1xuXHRcdGNvbnN0IHNoYXBlID0gdGhpcy5fJGRhdHVtVG9TaGFwZS5nZXQoZGF0dW0pO1xuXHRcdGlmIChzaGFwZSkge1xuXHRcdFx0Y29uc3QgY2hhbmdlZENvbnRlbnRMYXllcnMgPSBuZXcgU2V0KCk7XG5cdFx0XHRpZiAoc2hhcGUuJGVsIGluc3RhbmNlb2YgQXJyYXkgfHwgc2hhcGUuJGVsIGluc3RhbmNlb2YgU2V0KSB7XG5cdFx0XHRcdHNoYXBlLiRlbC5mb3JFYWNoKChlbCkgPT4gY2hhbmdlZENvbnRlbnRMYXllcnMuYWRkKGVsLmdldFBhcmVudCgpKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaGFuZ2VkQ29udGVudExheWVycy5hZGQoc2hhcGUuJGVsLmdldFBhcmVudCgpKTtcblx0XHRcdH1cblx0XHRcdHNoYXBlLmxheWVyID0gbnVsbDtcblx0XHRcdHNoYXBlLmRlc3Ryb3koKTtcblx0XHRcdHRoaXMuXyRkYXR1bVRvU2hhcGUuZGVsZXRlKGRhdHVtKTtcblx0XHRcdHRoaXMuXyRzaGFwZVRvRGF0dW0uZGVsZXRlKHNoYXBlKTtcblxuXHRcdFx0Y2hhbmdlZENvbnRlbnRMYXllcnMuZm9yRWFjaCgobGF5ZXIpID0+IHtcblx0XHRcdFx0aWYgKGxheWVyICE9PSB1bmRlZmluZWQpIFxuXHRcdFx0XHRcdGlmIChsYXllci5jaGlsZHJlbiA9PT0gMCkge1xuXHRcdFx0XHRcdFx0bGF5ZXIuZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0dGhpcy5jb250ZW50TGF5ZXJzLmRlbGV0ZShsYXllcik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGxheWVyLmJhdGNoRHJhdygpOyAvLyBhIGxpdHRsZSBoYWNrLi5cblx0XHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0aGlzLmRhdGEuc3BsaWNlKHRoaXMuZGF0YS5pbmRleE9mKGRhdHVtKSwgMSk7XG5cblx0XHR0aGlzLmVtaXQoJ3JlbW92ZScsIGRhdHVtKTtcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblxuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKiogRURJVElPTiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuXHQvKipcblx0ICogRWRpdCBkYXR1bShzKSBhY2NvcmRpbmcgdG8gdGhlIGBlZGl0YCBkZWZpbmVkIGluIHRoZSByZWdpc3RlcmVkIGBCZWhhdmlvcmAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0W119ICRkYXR1bXMgLSBUaGUgZGF0dW0ocykgdG8gZWRpdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGR4IC0gVGhlIG1vZGlmaWNhdGlvbiB0byBhcHBseSBpbiB0aGUgeCBheGlzIChpbiBwaXhlbHMpLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZHkgLSBUaGUgbW9kaWZpY2F0aW9uIHRvIGFwcGx5IGluIHRoZSB5IGF4aXMgKGluIHBpeGVscykuXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gJHRhcmdldCAtIFRoZSB0YXJnZXQgb2YgdGhlIGludGVyYWN0aW9uIChmb3IgZXhhbXBsZSwgbGVmdFxuXHQgKiAgICBoYW5kbGVyIERPTSBlbGVtZW50IGluIGEgc2VnbWVudCkuXG5cdCAqL1xuXHRlZGl0KCRkYXR1bXMsIGR4LCBkeSwgJHRhcmdldCkge1xuXHRcdGlmICghdGhpcy5fYmVoYXZpb3IgfHwgIXRoaXMuX2JlaGF2aW9yLmNhbignZWRpdCcsICRkYXR1bXMpKSByZXR1cm4gZmFsc2U7XG5cblx0XHRjb25zdCB0aGF0ID0gdGhpcztcblx0XHQkZGF0dW1zLmZvckVhY2goKGRhdHVtKSA9PiB7XG5cdFx0XHRjb25zdCBzaGFwZSA9IHRoYXQuXyRkYXR1bVRvU2hhcGUuZ2V0KGRhdHVtKTtcblx0XHRcdHRoaXMuX2JlaGF2aW9yLmVkaXQodGhpcy5fcmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksICR0YXJnZXQpO1xuXHRcdH0pO1xuXHRcdHRoaXMuZW1pdCgnZWRpdCcsICRkYXR1bXMpO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXG5cdC8qKlxuXHQqIEVkaXQgdGhlIGxheWVyIGFuZCB0aHVzIGl0cyByZWxhdGVkIGBMYXllclRpbWVDb250ZXh0YCBhdHRyaWJ1dGVzLlxuXHQqXG5cdCogQHBhcmFtIHtOdW1iZXJ9IGR4IC0gVGhlIG1vZGlmaWNhdGlvbiB0byBhcHBseSBpbiB0aGUgeCBheGlzIChpbiBwaXhlbHMpLlxuXHQqIEBwYXJhbSB7TnVtYmVyfSBkeSAtIFRoZSBtb2RpZmljYXRpb24gdG8gYXBwbHkgaW4gdGhlIHkgYXhpcyAoaW4gcGl4ZWxzKS5cblx0KiBAcGFyYW0ge0VsZW1lbnR9ICR0YXJnZXQgLSBUaGUgdGFyZ2V0IG9mIHRoZSBldmVudCBvZiB0aGUgaW50ZXJhY3Rpb24uXG5cdCovXG5cdGVkaXRDb250ZXh0KGR4LCBkeSwgJHRhcmdldCkge1xuXHRcdC8vIFRPRE9cblx0XHR0aGlzLnRpbWVDb250ZXh0QmVoYXZpb3IuZWRpdCh0aGlzLCBkeCwgZHksICR0YXJnZXQpO1xuXHRcdHRoaXMuZW1pdCgnZWRpdC1jb250ZXh0Jyk7XG5cdH1cblxuXHQvKipcblx0KiBTdHJldGNoIHRoZSBsYXllciBhbmQgdGh1cyBpdHMgcmVsYXRlZCBgTGF5ZXJUaW1lQ29udGV4dGAgYXR0cmlidXRlcy5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfSBkeCAtIFRoZSBtb2RpZmljYXRpb24gdG8gYXBwbHkgaW4gdGhlIHggYXhpcyAoaW4gcGl4ZWxzKS5cblx0KiBAcGFyYW0ge051bWJlcn0gZHkgLSBUaGUgbW9kaWZpY2F0aW9uIHRvIGFwcGx5IGluIHRoZSB5IGF4aXMgKGluIHBpeGVscykuXG5cdCogQHBhcmFtIHtFbGVtZW50fSAkdGFyZ2V0IC0gVGhlIHRhcmdldCBvZiB0aGUgZXZlbnQgb2YgdGhlIGludGVyYWN0aW9uLlxuXHQqL1xuXHRzdHJldGNoQ29udGV4dChkeCwgZHksICR0YXJnZXQpIHtcblx0XHQvLyBUT0RPXG5cdFx0dGhpcy50aW1lQ29udGV4dEJlaGF2aW9yLnN0cmV0Y2godGhpcywgZHgsIGR5LCAkdGFyZ2V0KTtcblx0XHR0aGlzLmVtaXQoJ3N0cmV0Y2gtY29udGV4dCcpO1xuXHR9XG5cblx0bWluaW1pemUoKSB7XG5cdFx0Ly8gVE9ET1xuXHR9XG5cblxuXG5cdGZpbmRfaW5kZXgodmFsdWVzLCB0YXJnZXQsIGNvbXBhcmVGbikge1xuXHRcdGlmICh2YWx1ZXMubGVuZ3RoID09PSAwIHx8IGNvbXBhcmVGbih0YXJnZXQsIHZhbHVlc1swXSkgPCAwKSB7IFxuXHRcdFx0cmV0dXJuIFt1bmRlZmluZWQsIDBdOyBcblx0XHR9XG5cdFx0aWYgKGNvbXBhcmVGbih0YXJnZXQsIHZhbHVlc1t2YWx1ZXMubGVuZ3RoLTFdKSA+IDAgKSB7XG5cdFx0XHRyZXR1cm4gW3ZhbHVlcy5sZW5ndGgtMSwgdW5kZWZpbmVkXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMubW9kaWZpZWRfYmluYXJ5X3NlYXJjaCh2YWx1ZXMsIDAsIHZhbHVlcy5sZW5ndGggLSAxLCB0YXJnZXQsIGNvbXBhcmVGbik7XG5cdH1cblxuXHRtb2RpZmllZF9iaW5hcnlfc2VhcmNoKHZhbHVlcywgc3RhcnQsIGVuZCwgdGFyZ2V0LCBjb21wYXJlRm4pIHtcblx0XHQvLyBpZiB0aGUgdGFyZ2V0IGlzIGJpZ2dlciB0aGFuIHRoZSBsYXN0IG9mIHRoZSBwcm92aWRlZCB2YWx1ZXMuXG5cdFx0aWYgKHN0YXJ0ID4gZW5kKSB7IHJldHVybiBbZW5kXTsgfSBcblxuXHRcdHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKChzdGFydCArIGVuZCkgLyAyKTtcblx0XHR2YXIgbWlkZGxlVmFsdWUgPSB2YWx1ZXNbbWlkZGxlXTtcblxuXHRcdGlmIChjb21wYXJlRm4obWlkZGxlVmFsdWUsIHRhcmdldCkgPCAwICYmIHZhbHVlc1ttaWRkbGUrMV0gJiYgY29tcGFyZUZuKHZhbHVlc1ttaWRkbGUrMV0sIHRhcmdldCkgPiAwKVxuXHRcdFx0Ly8gaWYgdGhlIHRhcmdldCBpcyBpbiBiZXR3ZWVuIHRoZSB0d28gaGFsZnMuXG5cdFx0XHRyZXR1cm4gW21pZGRsZSwgbWlkZGxlKzFdO1xuXHRcdGVsc2UgaWYgKGNvbXBhcmVGbihtaWRkbGVWYWx1ZSwgdGFyZ2V0KSA+IDApXG5cdFx0XHRyZXR1cm4gdGhpcy5tb2RpZmllZF9iaW5hcnlfc2VhcmNoKHZhbHVlcywgc3RhcnQsIG1pZGRsZS0xLCB0YXJnZXQsIGNvbXBhcmVGbik7IFxuXHRcdGVsc2UgaWYgKGNvbXBhcmVGbihtaWRkbGVWYWx1ZSwgdGFyZ2V0KSA8IDApXG5cdFx0XHRyZXR1cm4gdGhpcy5tb2RpZmllZF9iaW5hcnlfc2VhcmNoKHZhbHVlcywgbWlkZGxlKzEsIGVuZCwgdGFyZ2V0LCBjb21wYXJlRm4pOyBcblx0XHRlbHNlIFxuXHRcdFx0cmV0dXJuIFttaWRkbGVdOyAvL2ZvdW5kIVxuXHR9XG5cbn0iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgc2NhbGVzIGZyb20gJy4uL3V0aWxzL3NjYWxlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVsaW5lVGltZUNvbnRleHQge1xuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBpeGVsc1BlclNlY29uZCAtIFRoZSBudW1iZXIgb2YgcGl4ZWxzIHRoYXQgc2hvdWxkIGJlXG4gICAqICAgIHVzZWQgdG8gZGlzcGxheSBvbmUgc2Vjb25kLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmlzaWJsZVdpZHRoIC0gVGhlIGRlZmF1bHQgd2l0aCBvZiB0aGUgdmlzaWJsZSBhcmVhXG4gICAqICAgIGRpc3BsYXllZCBpbiBgdHJhY2tzYCAoaW4gcGl4ZWxzKS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBpeGVsc1BlclNlY29uZCwgdmlzaWJsZVdpZHRoKSB7XG4gICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcblxuICAgIHRoaXMuX3RpbWVUb1BpeGVsID0gbnVsbDtcbiAgICB0aGlzLl9vZmZzZXQgPSAwO1xuICAgIHRoaXMuX3pvb20gPSAxO1xuICAgIHRoaXMuX2NvbXB1dGVkUGl4ZWxzUGVyU2Vjb25kID0gcGl4ZWxzUGVyU2Vjb25kO1xuICAgIC8vIHBhcmFtc1xuICAgIHRoaXMuX3Zpc2libGVXaWR0aCA9IHZpc2libGVXaWR0aDtcbiAgICB0aGlzLl9tYWludGFpblZpc2libGVEdXJhdGlvbiA9IGZhbHNlO1xuXG4gICAgLy8gY3JlYXRlIHRoZSB0aW1lVG9QaXhlbCBzY2FsZVxuICAgIGNvbnN0IHNjYWxlID0gc2NhbGVzLmxpbmVhcigpXG4gICAgICAuZG9tYWluKFswLCAxXSlcbiAgICAgIC5yYW5nZShbMCwgcGl4ZWxzUGVyU2Vjb25kXSk7XG5cbiAgICB0aGlzLl90aW1lVG9QaXhlbCA9IHNjYWxlO1xuXG4gICAgdGhpcy5fb3JpZ2luYWxQaXhlbHNQZXJTZWNvbmQgPSB0aGlzLl9jb21wdXRlZFBpeGVsc1BlclNlY29uZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgcGl4ZWxzIHBlciBzZWNvbmRzIGlnbm9yaW5nIHRoZSBjdXJyZW50IHpvb20gdmFsdWUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcGl4ZWxzUGVyU2Vjb25kKCkge1xuICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbFBpeGVsc1BlclNlY29uZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGFsbCB0aGUgY2FyYWN0ZXJpc3RpY3Mgb2YgdGhpcyBvYmplY3QgYWNjb3JkaW5nIHRvIHRoZSBuZXdcbiAgICogZ2l2ZW4gdmFsdWUgb2YgcGl4ZWxzIHBlciBzZWNvbmRzLiBQcm9wYWdhdGVzIHRoZSBjaGFuZ2VzIHRvIHRoZVxuICAgKiBgTGF5ZXJUaW1lQ29udGV4dGAgY2hpbGRyZW4uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBzZXQgcGl4ZWxzUGVyU2Vjb25kKHZhbHVlKSB7XG4gICAgdGhpcy5fY29tcHV0ZWRQaXhlbHNQZXJTZWNvbmQgPSB2YWx1ZSAqIHRoaXMuem9vbTtcbiAgICB0aGlzLl9vcmlnaW5hbFBpeGVsc1BlclNlY29uZCA9IHZhbHVlO1xuICAgIHRoaXMuX3VwZGF0ZVRpbWVUb1BpeGVsUmFuZ2UoKTtcblxuICAgIC8vIGZvcmNlIGNoaWxkcmVuIHNjYWxlIHVwZGF0ZVxuICAgIHRoaXMuX2NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5zdHJldGNoUmF0aW8gPT09IDEpIHsgcmV0dXJuOyB9XG4gICAgICBjaGlsZC5zdHJldGNoUmF0aW8gPSBjaGlsZC5zdHJldGNoUmF0aW87XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHBpeGVscyBwZXIgc2Vjb25kcyBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgem9vbSB2YWx1ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBjb21wdXRlZFBpeGVsc1BlclNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcHV0ZWRQaXhlbHNQZXJTZWNvbmQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBvZmZzZXQgYXBwbGllZCB0byB0aGUgcmVnaXN0ZXJlZCBgVHJhY2tgIGluc3RhbmNlc1xuICAgKiBmcm9tIG9yaWdpbiAoaW4gc2Vjb25kcykuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgb2Zmc2V0IHRvIGFwcGx5IHRvIHRoZSByZWdpc3RlcmVkIGBUcmFja2AgaW5zdGFuY2VzIGZyb20gb3JpZ2luXG4gICAqIChpbiBzZWNvbmRzKS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHNldCBvZmZzZXQodmFsdWUpIHtcbiAgICB0aGlzLl9vZmZzZXQgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgYXBwbGllZCB0byB0aGUgd2hvbGUgdmlzdWFsaXphdGlvbi5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB6b29tKCkge1xuICAgIHJldHVybiB0aGlzLl96b29tO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHpvb20gcmF0aW8gZm9yIHRoZSB3aG9sZSB2aXN1YWxpemF0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgc2V0IHpvb20odmFsdWUpIHtcbiAgICAvLyBDb21wdXRlIGNoYW5nZSB0byBwcm9wYWdhdGUgdG8gY2hpbGRyZW4gd2hvIGhhdmUgdGhlaXIgb3duIHRpbWVUb1BpeGVsXG4gICAgY29uc3QgcmF0aW9DaGFuZ2UgPSB2YWx1ZSAvIHRoaXMuX3pvb207XG4gICAgdGhpcy5fem9vbSA9IHZhbHVlO1xuICAgIHRoaXMuX2NvbXB1dGVkUGl4ZWxzUGVyU2Vjb25kID0gdGhpcy5fb3JpZ2luYWxQaXhlbHNQZXJTZWNvbmQgKiB2YWx1ZTtcbiAgICB0aGlzLl91cGRhdGVUaW1lVG9QaXhlbFJhbmdlKCk7XG5cbiAgICB0aGlzLl9jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuc3RyZXRjaFJhdGlvID09PSAxKSB7IHJldHVybjsgfVxuICAgICAgY2hpbGQuc3RyZXRjaFJhdGlvID0gY2hpbGQuc3RyZXRjaFJhdGlvICogcmF0aW9DaGFuZ2U7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmlzaWJsZSB3aWR0aCBvZiB0aGUgYFRyYWNrYCBpbnN0YW5jZXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgdmlzaWJsZVdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlV2lkdGg7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmlzaWJsZSB3aWR0aCBvZiB0aGUgYFRyYWNrYCBpbnN0YW5jZXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBzZXQgdmlzaWJsZVdpZHRoKHZhbHVlKSB7XG4gICAgY29uc3Qgd2lkdGhSYXRpbyA9IHZhbHVlIC8gdGhpcy52aXNpYmxlV2lkdGg7XG4gICAgdGhpcy5fdmlzaWJsZVdpZHRoID0gdmFsdWU7XG5cbiAgICBpZiAodGhpcy5tYWludGFpblZpc2libGVEdXJhdGlvbikge1xuICAgICAgdGhpcy5waXhlbHNQZXJTZWNvbmQgPSB0aGlzLl9jb21wdXRlZFBpeGVsc1BlclNlY29uZCAqIHdpZHRoUmF0aW87XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGR1cmF0aW9uIGRpc3BsYXllZCBieSBgVHJhY2tgIGluc3RhbmNlcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCB2aXNpYmxlRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudmlzaWJsZVdpZHRoIC8gdGhpcy5fY29tcHV0ZWRQaXhlbHNQZXJTZWNvbmQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpZiB0aGUgZHVyYXRpb24gZGlzcGxheWVkIGJ5IHRyYWNrcyBzaG91bGQgYmUgbWFpbnRhaW5lZCB3aGVuXG4gICAqIHRoZWlyIHdpZHRoIGlzIHVwZGF0ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgbWFpbnRhaW5WaXNpYmxlRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21haW50YWluVmlzaWJsZUR1cmF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgaWYgdGhlIGR1cmF0aW9uIGRpc3BsYXllZCBieSB0cmFja3Mgc2hvdWxkIGJlIG1haW50YWluZWQgd2hlblxuICAgKiB0aGVpciB3aWR0aCBpcyB1cGRhdGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHNldCBtYWludGFpblZpc2libGVEdXJhdGlvbihib29sKSB7XG4gICAgdGhpcy5fbWFpbnRhaW5WaXNpYmxlRHVyYXRpb24gPSBib29sO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRpbWUgdG8gcGl4ZWwgdHJhc2ZlcnQgZnVuY3Rpb24uXG4gICAqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIGdldCB0aW1lVG9QaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZVRvUGl4ZWw7XG4gIH1cblxuICBfdXBkYXRlVGltZVRvUGl4ZWxSYW5nZSgpIHtcbiAgICB0aGlzLnRpbWVUb1BpeGVsLnJhbmdlKFswLCB0aGlzLl9jb21wdXRlZFBpeGVsc1BlclNlY29uZF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRpbWUgaW50ZXJ2YWwgb2YgdGhlIHZpc2libGUgYXJlYSBpbiB0aGUgdGltZWxpbmUuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9IFxuICAgKi9cbiAgZ2V0IHZpc2libGVJbnRlcnZhbCgpIHtcbiAgICB2YXIgaW50ZXJ2YWwgPSB7fTtcbiAgICBpbnRlcnZhbC5zdGFydCA9IC10aGlzLm9mZnNldDtcbiAgICBpbnRlcnZhbC5kdXJhdGlvbiA9IHRoaXMudmlzaWJsZUR1cmF0aW9uO1xuICAgIHJldHVybiBpbnRlcnZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb2N1cyB0aGUgdGltZWxpbmUgdmlzaWJsZSBhcmVhIGluIHRoZSBwcm92aWRlZCB0aW1lIGludGVydmFsLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fSBcbiAgICovXG4gIHNldCB2aXNpYmxlSW50ZXJ2YWwodmFsdWUpIHtcbiAgICB0aGlzLm9mZnNldCA9IC12YWx1ZS5zdGFydDtcbiAgICB0aGlzLnBpeGVsc1BlclNlY29uZCA9IHRoaXMudmlzaWJsZVdpZHRoIC8gdmFsdWUuZHVyYXRpb247XG4gIH1cblxuXG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgZXZlbnRzIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgVHJhY2sgZnJvbSAnLi90cmFjayc7XG5pbXBvcnQgVHJhY2tDb2xsZWN0aW9uIGZyb20gJy4vdHJhY2stY29sbGVjdGlvbic7XG5pbXBvcnQgVGltZWxpbmVUaW1lQ29udGV4dCBmcm9tICcuL3RpbWVsaW5lLXRpbWUtY29udGV4dCc7XG5pbXBvcnQgTGF5ZXJUaW1lQ29udGV4dCBmcm9tICcuL2xheWVyLXRpbWUtY29udGV4dCc7XG5pbXBvcnQgU3VyZmFjZSBmcm9tICcuLi9pbnRlcmFjdGlvbnMva29udmEtc3VyZmFjZSc7XG5pbXBvcnQgS2V5Ym9hcmQgZnJvbSAnLi4vaW50ZXJhY3Rpb25zL2tleWJvYXJkJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZWxpbmUgZXh0ZW5kcyBldmVudHMuRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGl4ZWxzUGVyU2Vjb25kPTEwMF0gLSB0aGUgZGVmYXVsdCBzY2FsaW5nIGJldHdlZW4gdGltZSBhbmQgcGl4ZWxzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3Zpc2libGVXaWR0aD0xMDAwXSAtIHRoZSBkZWZhdWx0IHZpc2libGUgYXJlYSBmb3IgYWxsIHJlZ2lzdGVyZWQgdHJhY2tzLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGl4ZWxzUGVyU2Vjb25kLCB2aXNpYmxlV2lkdGgsIG9wdHMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgaWYgKHBpeGVsc1BlclNlY29uZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgcGl4ZWxzUGVyU2Vjb25kID0gMTAwO1xuICAgIGlmICh2aXNpYmxlV2lkdGggPT09IHVuZGVmaW5lZClcbiAgICAgIHZpc2libGVXaWR0aCA9IDEwMDA7XG4gICAgaWYgKG9wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0cyA9IHsgcmVnaXN0ZXJLZXlib2FyZDogdHJ1ZSB9O1xuICAgIH0gZWxzZSBpZiAob3B0cy5yZWdpc3RlcktleWJvYXJkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdHMucmVnaXN0ZXJLZXlib2FyZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5fdHJhY2tzID0gbmV3IFRyYWNrQ29sbGVjdGlvbih0aGlzKTtcbiAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG5cbiAgICAvLyBkZWZhdWx0IGludGVyYWN0aW9uc1xuICAgIHRoaXMuX3N1cmZhY2VDdG9yID0gU3VyZmFjZTtcblxuICAgIGlmIChvcHRzLnJlZ2lzdGVyS2V5Ym9hcmQpIHtcbiAgICAgIHRoaXMuY3JlYXRlSW50ZXJhY3Rpb24oS2V5Ym9hcmQsIGRvY3VtZW50KTtcbiAgICB9XG5cbiAgICAvLyBzdG9yZXNcbiAgICB0aGlzLl90cmFja0J5SWQgPSB7fTtcbiAgICB0aGlzLl9ncm91cGVkTGF5ZXJzID0ge307XG5cbiAgICAvKiogQHR5cGUge1RpbWVsaW5lVGltZUNvbnRleHR9IC0gbWFzdGVyIHRpbWUgY29udGV4dCBmb3IgdGhlIHZpc3VhbGl6YXRpb24uICovXG4gICAgdGhpcy50aW1lQ29udGV4dCA9IG5ldyBUaW1lbGluZVRpbWVDb250ZXh0KHBpeGVsc1BlclNlY29uZCwgdmlzaWJsZVdpZHRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGBUaW1lbGluZVRpbWVDb250ZXh0YCdzIGBvZmZzZXRgIHRpbWUgZG9tYWluIHZhbHVlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfSBbb2Zmc2V0PTBdXG4gICAqL1xuICBnZXQgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLnRpbWVDb250ZXh0Lm9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGBUaW1lbGluZVRpbWVDb250ZXh0YCdzIGBvZmZzZXRgIHRpbWUgZG9tYWluIHZhbHVlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfSBbb2Zmc2V0PTBdXG4gICAqL1xuICBzZXQgb2Zmc2V0KHZhbHVlKSB7XG4gICAgdGhpcy50aW1lQ29udGV4dC5vZmZzZXQgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgVGltZWxpbmVUaW1lQ29udGV4dGAncyBgem9vbWAgdmFsdWUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9IFtvZmZzZXQ9MF1cbiAgICovXG4gIGdldCB6b29tKCkge1xuICAgIHJldHVybiB0aGlzLnRpbWVDb250ZXh0Lnpvb207XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYFRpbWVsaW5lVGltZUNvbnRleHRgJ3MgYHpvb21gIHZhbHVlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfSBbb2Zmc2V0PTBdXG4gICAqL1xuICBzZXQgem9vbSh2YWx1ZSkge1xuICAgIHRoaXMudGltZUNvbnRleHQuem9vbSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGBUaW1lbGluZVRpbWVDb250ZXh0YCdzIGBwaXhlbHNQZXJTZWNvbmRgIHJhdGlvLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfSBbb2Zmc2V0PTBdXG4gICAqL1xuICBnZXQgcGl4ZWxzUGVyU2Vjb25kKCkge1xuICAgIHJldHVybiB0aGlzLnRpbWVDb250ZXh0LnBpeGVsc1BlclNlY29uZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBgVGltZWxpbmVUaW1lQ29udGV4dGAncyBgcGl4ZWxzUGVyU2Vjb25kYCByYXRpby5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn0gW29mZnNldD0wXVxuICAgKi9cbiAgc2V0IHBpeGVsc1BlclNlY29uZCh2YWx1ZSkge1xuICAgIHRoaXMudGltZUNvbnRleHQucGl4ZWxzUGVyU2Vjb25kID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGltZSBpbnRlcnZhbCBvZiB0aGUgdmlzaWJsZSBhcmVhIGluIHRoZSB0aW1lbGluZS5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH0gXG4gICAqL1xuICBnZXQgdmlzaWJsZUludGVydmFsKCkge1xuICAgIHJldHVybiB0aGlzLnRpbWVDb250ZXh0LnZpc2libGVJbnRlcnZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb2N1cyB0aGUgdGltZWxpbmUgdmlzaWJsZSBhcmVhIGluIHRoZSBwcm92aWRlZCB0aW1lIGludGVydmFsLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fSBcbiAgICovXG4gIHNldCB2aXNpYmxlSW50ZXJ2YWwodmFsdWUpIHtcbiAgICB0aGlzLnRpbWVDb250ZXh0LnZpc2libGVJbnRlcnZhbCA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGBUaW1lbGluZVRpbWVDb250ZXh0YCdzIGB2aXNpYmxlV2lkdGhgIHBpeGVsIGRvbWFpbiB2YWx1ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn0gW29mZnNldD0wXVxuICAgKi9cbiAgZ2V0IHZpc2libGVXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lQ29udGV4dC52aXNpYmxlV2lkdGg7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYFRpbWVsaW5lVGltZUNvbnRleHRgJ3MgYHZpc2libGVXaWR0aGAgcGl4ZWwgZG9tYWluIHZhbHVlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfSBbb2Zmc2V0PTBdXG4gICAqL1xuICBzZXQgdmlzaWJsZVdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy50aW1lQ29udGV4dC52aXNpYmxlV2lkdGggPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGBUaW1lbGluZVRpbWVDb250ZXh0YCdzIGB0aW1lVG9QaXhlbGAgdHJhbnNmZXJ0IGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICBnZXQgdGltZVRvUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMudGltZUNvbnRleHQudGltZVRvUGl4ZWw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBgVGltZWxpbmVUaW1lQ29udGV4dGAncyBgdmlzaWJsZUR1cmF0aW9uYCBoZWxwZXIgdmFsdWUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgdmlzaWJsZUR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRpbWVDb250ZXh0LnZpc2libGVEdXJhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBgVGltZWxpbmVUaW1lQ29udGV4dGAncyBgbWFpbnRhaW5WaXNpYmxlRHVyYXRpb25gIHZhbHVlLlxuICAgKiBEZWZpbmVzIGlmIHRoZSBkdXJhdGlvbiBvZiB0aGUgdmlzaWJsZSBhcmVhIHNob3VsZCBiZSBtYWludGFpbiB3aGVuXG4gICAqIHRoZSBgdmlzaWJsZVdpZHRoYCBhdHRyaWJ1dGUgaXMgdXBkYXRlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBzZXQgbWFpbnRhaW5WaXNpYmxlRHVyYXRpb24oYm9vbCkge1xuICAgIHRoaXMudGltZUNvbnRleHQubWFpbnRhaW5WaXNpYmxlRHVyYXRpb24gPSBib29sO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYFRpbWVsaW5lVGltZUNvbnRleHRgJ3MgYG1haW50YWluVmlzaWJsZUR1cmF0aW9uYCBjdXJyZW50IHZhbHVlLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBtYWludGFpblZpc2libGVEdXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lQ29udGV4dC5tYWludGFpblZpc2libGVEdXJhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYmplY3QgbWFpbnRhaW5pbmcgYXJyYXlzIG9mIGBMYXllcmAgaW5zdGFuY2VzIG9yZGVyZWQgYnkgdGhlaXIgYGdyb3VwSWRgLlxuICAgKiBJcyB1c2VkIGludGVybmFsbHkgYnkgdGhlIGBUcmFja0NvbGxlY3Rpb25gIGluc3RhbmNlLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0IGdyb3VwZWRMYXllcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dyb3VwZWRMYXllcnM7XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGBTdXJmYWNlYCB0aGF0IGlzIGluc3RhbmNpYXRlZCBvbiBlYWNoIGBUcmFja2BcbiAgICogaW5zdGFuY2UuIFRoaXMgbWV0aG9zIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIGFkZGluZyBhbnkgYFRyYWNrYCBpbnN0YW5jZVxuICAgKiB0byB0aGUgY3VycmVudCBgdGltZWxpbmVgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50U291cmNlfSBDdG9yIC0gVGhlIGNvbnN0cnVjdG9yIHRvIHVzZSBpbiBvcmRlciB0byBjYXRjaCBtb3VzZVxuICAgKiAgICBldmVudHMgb24gZWFjaCBgVHJhY2tgIGluc3RhbmNlcy5cbiAgICovXG4gIGNvbmZpZ3VyZVN1cmZhY2UoQ3Rvcikge1xuICAgIHRoaXMuX3N1cmZhY2VDdG9yID0gQ3RvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBGYWN0b3J5IG1ldGhvZCB0byBhZGQgaW50ZXJhY3Rpb24gbW9kdWxlcyB0aGUgdGltZWxpbmUgc2hvdWxkIGxpc3RlbiB0by5cbiAgICogQnkgZGVmYXVsdCwgdGhlIHRpbWVsaW5lIGluc3RhbmNpYXRlIGEgZ2xvYmFsIGBLZXlib2FyZGAgaW5zdGFuY2UgYW5kIGFcbiAgICogYFN1cmZhY2VgIGluc3RhbmNlIG9uIGVhY2ggY29udGFpbmVyLlxuICAgKiBTaG91bGQgYmUgdXNlZCB0byBpbnN0YWxsIG5ldyBpbnRlcmFjdGlvbnMgaW1wbGVtZW50aW5nIHRoZSBgRXZlbnRTb3VyY2VgIGludGVyZmFjZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFNvdXJjZX0gQ3RvciAtIFRoZSBjb250cnVjdG9yIG9mIHRoZSBpbnRlcmFjdGlvbiBtb2R1bGUgdG8gaW5zdGFuY2lhdGUuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gJGVsIC0gVGhlIERPTSBlbGVtZW50IHdoaWNoIHdpbGwgYmUgYmluZGVkIHRvIHRoZSBgRXZlbnRTb3VyY2VgIG1vZHVsZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIE9wdGlvbnMgdG8gYmUgYXBwbGllZCB0byB0aGUgYEN0b3JgLlxuICAgKi9cbiAgY3JlYXRlSW50ZXJhY3Rpb24oQ3RvciwgJGVsLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgXG4gICAgICBvcHRpb25zID0ge307XG4gICAgY29uc3QgaW50ZXJhY3Rpb24gPSBuZXcgQ3RvcigkZWwsIG9wdGlvbnMpO1xuICAgIGludGVyYWN0aW9uLm9uKCdldmVudCcsIChlKSA9PiB0aGlzLl9oYW5kbGVFdmVudChlKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgdGhlIGxheWVycyBzaXR1YXRlZCB1bmRlciB0aGUgcG9zaXRpb24gb2YgYSBgV2F2ZUV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtXYXZlc0V2ZW50fSBlIC0gQW4gZXZlbnQgdHJpZ2dlcmVkIGJ5IGEgYFdhdmVFdmVudGBcbiAgICogQHJldHVybiB7QXJyYXl9IC0gTWF0Y2hlZCBsYXllcnNcbiAgICovXG4gIGdldEhpdExheWVycyhlKSB7XG4gICAgY29uc3QgeCA9IGUub3JpZ2luYWxFdmVudC5vZmZzZXRYO1xuICAgIGNvbnN0IHkgPSBlLm9yaWdpbmFsRXZlbnQub2Zmc2V0WTtcblxuICAgIGxldCBsYXllcnMgPSBbXTtcblxuICAgIHRoaXMubGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiB7XG4gICAgICBjb25zdCBjdHhYID0gbGF5ZXIuX2NvbnRleHRTaGFwZS4kc2VnbWVudC5nZXRBYnNvbHV0ZVBvc2l0aW9uKCkueDtcbiAgICAgIGNvbnN0IGN0eFkgPSBsYXllci5fY29udGV4dFNoYXBlLiRzZWdtZW50LmdldEFic29sdXRlUG9zaXRpb24oKS55O1xuICAgICAgY29uc3QgY3R4VyA9IGxheWVyLl9jb250ZXh0U2hhcGUuJHNlZ21lbnQud2lkdGgoKTtcbiAgICAgIGNvbnN0IGN0eEggPSBsYXllci5fY29udGV4dFNoYXBlLiRzZWdtZW50LmhlaWdodCgpO1xuXG4gICAgICBpZiAoeCA+PSBjdHhYICYmIHggPD0gY3R4WCArIGN0eFcgJiYgeSA+PSBjdHhZICYmIHkgPD0gY3R4WSArIGN0eEgpXG4gICAgICAgIGxheWVycy5wdXNoKGxheWVyKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBsYXllcnM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNhbGxiYWNrIHRoYXQgaXMgdXNlZCB0byBsaXN0ZW4gdG8gaW50ZXJhY3Rpb25zIG1vZHVsZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7V2F2ZUV2ZW50fSBlIC0gQW4gZXZlbnQgZ2VuZXJhdGVkIGJ5IGFuIGludGVyYWN0aW9uIG1vZHVsZXMgKGBFdmVudFNvdXJjZWApLlxuICAgKi9cbiAgX2hhbmRsZUV2ZW50KGUpIHtcbiAgICBjb25zdCBoaXRMYXllcnMgPSAoZS5zb3VyY2UgPT09ICdzdXJmYWNlJykgP1xuICAgICAgdGhpcy5nZXRIaXRMYXllcnMoZSkgOiBudWxsO1xuICAgIC8vIGVtaXQgZXZlbnQgYXMgYSBtaWRkbGV3YXJlXG4gICAgdGhpcy5lbWl0KCdldmVudCcsIGUsIGhpdExheWVycyk7XG4gICAgLy8gcHJvcGFnYXRlIHRvIHRoZSBzdGF0ZVxuICAgIGlmICghdGhpcy5fc3RhdGUpIHsgcmV0dXJuOyB9XG4gICAgdGhpcy5fc3RhdGUuaGFuZGxlRXZlbnQoZSwgaGl0TGF5ZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgdGltZWxpbmUuXG4gICAqXG4gICAqIEB0eXBlIHtCYXNlU3RhdGV9XG4gICAqL1xuICBzZXQgc3RhdGUoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUpIHsgdGhpcy5fc3RhdGUuZXhpdCgpOyB9XG4gICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICBpZiAodGhpcy5fc3RhdGUpIHsgdGhpcy5fc3RhdGUuZW50ZXIoKTsgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHRpbWVsaW5lLlxuICAgKlxuICAgKiBAdHlwZSB7QmFzZVN0YXRlfVxuICAgKi9cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgVHJhY2tDb2xsZWN0aW9uYCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHR5cGUge1RyYWNrQ29sbGVjdGlvbn1cbiAgICovXG4gIGdldCB0cmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWNrcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGFsbCByZWdpc3RlcmVkIGxheWVycy5cbiAgICpcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cbiAgZ2V0IGxheWVycygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhY2tzLmxheWVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IHRyYWNrIHRvIHRoZSB0aW1lbGluZS5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFja30gdHJhY2sgLSBUaGUgbmV3IHRyYWNrIHRvIGJlIHJlZ2lzdGVyZWQgaW4gdGhlIHRpbWVsaW5lLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3RyYWNrSWQ9bnVsbF0gLSBPcHRpb25uYWwgdW5pcXVlIGlkIHRvIGFzc29jaWF0ZSB3aXRoXG4gICAqICAgIHRoZSB0cmFjaywgdGhpcyBpZCBvbmx5IGV4aXN0cyBpbiB0aW1lbGluZSdzIGNvbnRleHQgYW5kIHNob3VsZCBiZSB1c2VkXG4gICAqICAgIGluIGNvbmpvbmN0aW9uIHdpdGggYGFkZExheWVyYCBtZXRob2QuXG4gICAqL1xuICBhZGQodHJhY2ssIHRyYWNrSWQpIHtcbiAgICBpZiAodHJhY2tJZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgdHJhY2tJZCA9IG51bGw7XG5cbiAgICBpZiAodGhpcy50cmFja3MuaW5kZXhPZih0cmFjaykgIT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYWNrIGFscmVhZHkgYWRkZWQgdG8gdGhlIHRpbWVsaW5lJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVnaXN0ZXJUcmFja0lkKHRyYWNrLCB0cmFja0lkKTtcbiAgICB0cmFjay5jb25maWd1cmUodGhpcy50aW1lQ29udGV4dCk7XG5cbiAgICB0aGlzLnRyYWNrcy5wdXNoKHRyYWNrKTtcbiAgICB0aGlzLmNyZWF0ZUludGVyYWN0aW9uKHRoaXMuX3N1cmZhY2VDdG9yLCB0cmFjayk7XG5cbiAgICB0aGlzLmVtaXQoJ2FkZCcsIHRyYWNrLCB0cmFja0lkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgdHJhY2sgZnJvbSB0aGUgdGltZWxpbmUgYW5kIGRlc3Ryb3lzIHRoYXQgdHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhY2t9IHRyYWNrIC0gdGhlIHRyYWNrIHRvIHJlbW92ZSBmcm9tIHRoZSB0aW1lbGluZS5cbiAgICogQHRvZG8gbm90IGltcGxlbWVudGVkLlxuICAgKi9cbiAgcmVtb3ZlKHRyYWNrKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnRyYWNrcy5pbmRleE9mKHRyYWNrKTtcbiAgICB2YXIgdHJhY2tJZDtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0cmFjay5kZXN0cm95KCk7XG4gICAgICBkZWxldGUgdGhpcy5fdHJhY2tCeUlkW3RyYWNrLmlkXTtcbiAgICAgIHRyYWNrSWQgPSB0cmFjay5pZDtcbiAgICAgIHRyYWNrLmlkID0gbnVsbDtcbiAgICAgIHRoaXMudHJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZScsIHRyYWNrLCB0cmFja0lkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHRvIGNyZWF0ZSBhIG5ldyBgVHJhY2tgIGluc3RhbmNlLiBUaGUgYHRyYWNrYCBpcyBhZGRlZCxcbiAgICogcmVuZGVyZWQgYW5kIHVwZGF0ZWQgYmVmb3JlIGJlaW5nIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9ICRlbCAtIFRoZSBET00gZWxlbWVudCB3aGVyZSB0aGUgdHJhY2sgc2hvdWxkIGJlIGluc2VydGVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdHJhY2tIZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBuZXdseSBjcmVhdGVkIHRyYWNrLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3RyYWNrSWQ9bnVsbF0gLSBPcHRpb25uYWwgdW5pcXVlIGlkIHRvIGFzc29jaWF0ZSB3aXRoXG4gICAqICAgIHRoZSB0cmFjaywgdGhpcyBpZCBvbmx5IGV4aXN0cyBpbiB0aW1lbGluZSdzIGNvbnRleHQgYW5kIHNob3VsZCBiZSB1c2VkIGluXG4gICAqICAgIGNvbmpvbmN0aW9uIHdpdGggYGFkZExheWVyYCBtZXRob2QuXG4gICAqIEByZXR1cm4ge1RyYWNrfVxuICAgKi9cbiAgY3JlYXRlVHJhY2soJGVsLCB0cmFja0hlaWdodCwgdHJhY2tJZCkge1xuICAgIGlmICh0cmFja0hlaWdodCA9PT0gdW5kZWZpbmVkKVxuICAgICAgdHJhY2tIZWlnaHQgPSAxMDA7XG4gICAgaWYgKHRyYWNrSWQgPT09IHVuZGVmaW5lZClcbiAgICAgIHRyYWNrSWQgPSBudWxsO1xuXG4gICAgY29uc3QgdHJhY2sgPSBuZXcgVHJhY2soJGVsLCB0cmFja0hlaWdodCk7XG4gICAgLy8gQWRkIHRyYWNrIHRvIHRoZSB0aW1lbGluZVxuICAgIHRoaXMuYWRkKHRyYWNrLCB0cmFja0lkKTtcblxuICAgIHRyYWNrLnVwZGF0ZSgpO1xuXG4gICAgcmV0dXJuIHRyYWNrO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRyYWNrIGlkIGlzIGRlZmluZWQsIGFzc29jaWF0ZSBhIHRyYWNrIHdpdGggYSB1bmlxdWUgaWQuXG4gICAqL1xuICBfcmVnaXN0ZXJUcmFja0lkKHRyYWNrLCB0cmFja0lkKSB7XG4gICAgaWYgKHRyYWNrSWQgIT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLl90cmFja0J5SWRbdHJhY2tJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHRyYWNrSWQ6IFwiJHt0cmFja0lkfVwiIGlzIGFscmVhZHkgdXNlZGApO1xuICAgICAgfVxuICAgICAgdHJhY2suaWQgPSB0cmFja0lkO1xuICAgICAgdGhpcy5fdHJhY2tCeUlkW3RyYWNrSWRdID0gdHJhY2s7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byBhZGQgYSBgTGF5ZXJgIGluc3RhbmNlIGludG8gYSBnaXZlbiBgVHJhY2tgLiBJcyBkZXNpZ25lZCB0byBiZVxuICAgKiB1c2VkIGluIGNvbmpvbmN0aW9uIHdpdGggdGhlIGBUaW1lbGluZX5nZXRMYXllcnNCeUdyb3VwYCBtZXRob2QuIFRoZVxuICAgKiBsYXllciBpcyBpbnRlcm5hbGx5IHJlbmRlcmVkIGFuZCB1cGRhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0xheWVyfSBsYXllciAtIFRoZSBgTGF5ZXJgIGluc3RhbmNlIHRvIGFkZCBpbnRvIHRoZSB2aXN1YWxpemF0aW9uLlxuICAgKiBAcGFyYW0geyhUcmFja3xTdHJpbmcpfSB0cmFja09yVHJhY2tJZCAtIFRoZSBgVHJhY2tgIGluc3RhbmNlIChvciBpdHMgYGlkYFxuICAgKiAgICBhcyBkZWZpbmVkIGluIHRoZSBgY3JlYXRlVHJhY2tgIG1ldGhvZCkgd2hlcmUgdGhlIGBMYXllcmAgaW5zdGFuY2Ugc2hvdWxkIGJlIGluc2VydGVkLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2dyb3VwSWQ9J2RlZmF1bHQnXSAtIEFuIG9wdGlvbm5hbCBncm91cCBpZCBpbiB3aGljaCB0aGVcbiAgICogICAgYExheWVyYCBzaG91bGQgYmUgaW5zZXJ0ZWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzQXhpc10gLSBTZXQgdG8gYHRydWVgIGlmIHRoZSBhZGRlZCBgbGF5ZXJgIGlzIGFuXG4gICAqICAgIGluc3RhbmNlIG9mIGBBeGlzTGF5ZXJgICh0aGVzZSBsYXllcnMgc2hhcmVzIHRoZSBgVGltbGluZVRpbWVDb250ZXh0YCBpbnN0YW5jZVxuICAgKiAgICBvZiB0aGUgdGltZWxpbmUpLlxuICAgKi9cbiAgYWRkTGF5ZXIobGF5ZXIsIHRyYWNrT3JUcmFja0lkLCBncm91cElkLCBpc0F4aXMpIHtcblxuICAgIGlmIChncm91cElkID09PSB1bmRlZmluZWQpXG4gICAgICBncm91cElkID0gJ2RlZmF1bHQnO1xuICAgIGlmIChpc0F4aXMgPT09IHVuZGVmaW5lZClcbiAgICAgIGlzQXhpcyA9IGZhbHNlO1xuXG4gICAgbGV0IHRyYWNrID0gdHJhY2tPclRyYWNrSWQ7XG5cbiAgICBpZiAodHlwZW9mIHRyYWNrT3JUcmFja0lkID09PSAnc3RyaW5nJykge1xuICAgICAgdHJhY2sgPSB0aGlzLmdldFRyYWNrQnlJZCh0cmFja09yVHJhY2tJZCk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlcyB0aGUgYExheWVyVGltZUNvbnRleHRgIGlmIG5vdCBwcmVzZW50XG4gICAgaWYgKCFsYXllci50aW1lQ29udGV4dCkge1xuICAgICAgY29uc3QgdGltZUNvbnRleHQgPSBpc0F4aXMgP1xuICAgICAgICB0aGlzLnRpbWVDb250ZXh0IDogbmV3IExheWVyVGltZUNvbnRleHQodGhpcy50aW1lQ29udGV4dCk7XG5cbiAgICAgIGxheWVyLnNldFRpbWVDb250ZXh0KHRpbWVDb250ZXh0KTtcbiAgICB9XG5cbiAgICAvLyB3ZSBzaG91bGQgaGF2ZSBhIFRyYWNrIGluc3RhbmNlIGF0IHRoaXMgcG9pbnRcbiAgICB0cmFjay5hZGQobGF5ZXIpO1xuXG4gICAgaWYgKCF0aGlzLl9ncm91cGVkTGF5ZXJzW2dyb3VwSWRdKSB7XG4gICAgICB0aGlzLl9ncm91cGVkTGF5ZXJzW2dyb3VwSWRdID0gW107XG4gICAgfVxuXG4gICAgdGhpcy5fZ3JvdXBlZExheWVyc1tncm91cElkXS5wdXNoKGxheWVyKTtcblxuICAgIFxuICAgIGxheWVyLnVwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBsYXllciBmcm9tIGl0cyB0cmFjay4gVGhlIGxheWVyIGlzIGRldGF0Y2hlZCBmcm9tIHRoZSBET00gYnV0XG4gICAqIGNhbiBzdGlsbCBiZSByZXVzZWQgbGF0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7TGF5ZXJ9IGxheWVyIC0gVGhlIGxheWVyIHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZUxheWVyKGxheWVyKSB7XG4gICAgdGhpcy50cmFja3MuZm9yRWFjaChmdW5jdGlvbih0cmFjaykge1xuICAgICAgY29uc3QgaW5kZXggPSB0cmFjay5sYXllcnMuaW5kZXhPZihsYXllcik7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7IHRyYWNrLnJlbW92ZShsYXllcik7IH1cbiAgICB9KTtcblxuICAgIC8vIGNsZWFuIHJlZmVyZW5jZXMgaW4gaGVscGVyc1xuICAgIGZvciAobGV0IGdyb3VwSWQgaW4gdGhpcy5fZ3JvdXBlZExheWVycykge1xuICAgICAgY29uc3QgZ3JvdXAgPSB0aGlzLl9ncm91cGVkTGF5ZXJzW2dyb3VwSWRdO1xuICAgICAgY29uc3QgaW5kZXggPSBncm91cC5pbmRleE9mKGxheWVyKTtcblxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkgeyBcbiAgICAgICAgZ3JvdXAuc3BsaWNlKGxheWVyLCAxKTsgXG4gICAgICB9XG5cbiAgICAgIGlmICghZ3JvdXAubGVuZ3RoKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ncm91cGVkTGF5ZXJzW2dyb3VwSWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYFRyYWNrYCBpbnN0YW5jZSBmcm9tIGl0J3MgZ2l2ZW4gaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0cmFja0lkXG4gICAqIEByZXR1cm4ge1RyYWNrfVxuICAgKi9cbiAgZ2V0VHJhY2tCeUlkKHRyYWNrSWQpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhY2tCeUlkW3RyYWNrSWRdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRyYWNrIGNvbnRhaW5pbmcgYSBnaXZlbiBET00gRWxlbWVudCwgcmV0dXJucyBudWxsIGlmIG5vIG1hdGNoIGZvdW5kLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9ICRlbCAtIFRoZSBET00gRWxlbWVudCB0byBiZSB0ZXN0ZWQuXG4gICAqIEByZXR1cm4ge1RyYWNrfVxuICAgKi9cbiAgZ2V0VHJhY2tGcm9tRE9NRWxlbWVudCgkZWwpIHtcbiAgICBcbiAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy50cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBub2RlID0gJGVsO1xuICAgICAgd2hpbGUgKG5vZGUgIT09IGRvY3VtZW50LmJvZHkgJiYgbm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy50cmFja3NbaV0uJHN0YWdlLmNvbnRlbnQgPT09IG5vZGUpIFxuICAgICAgICAgIHJldHVybiB0aGlzLnRyYWNrc1tpXTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbGF5ZXJzIGZyb20gdGhlaXIgZ2l2ZW4gZ3JvdXAgaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBncm91cElkIC0gVGhlIGlkIG9mIHRoZSBncm91cCBhcyBkZWZpbmVkIGluIGBhZGRMYXllcmAuXG4gICAqIEByZXR1cm4geyhBcnJheXx1bmRlZmluZWQpfVxuICAgKi9cbiAgZ2V0TGF5ZXJzQnlHcm91cChncm91cElkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dyb3VwZWRMYXllcnNbZ3JvdXBJZF07XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZXMgdGhyb3VnaCB0aGUgYWRkZWQgdHJhY2tzLlxuICAgKi9cbiAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHlpZWxkKiB0aGlzLnRyYWNrc1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBMYXllciBmcm9tICcuL2xheWVyJztcblxuLyoqXG4gKiBDb2xsZWN0aW9uIGhvc3RpbmcgYWxsIHRoZSBgVHJhY2tgIGluc3RhbmNlcyByZWdpc3RlcmVkIGludG8gdGhlIHRpbWVsaW5lLlxuICogSXQgcHJvdmlkZXMgc2hvcmN1dHMgdG8gdHJpZ2dlciBgcmVuZGVyYCAvIGB1cGRhdGVgIG1ldGhvZHMgb24gdHJhY2tzIG9yXG4gKiBsYXllcnMuIEV4dGVuZCBidWlsdC1pbiBBcnJheVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFja0NvbGxlY3Rpb24gZXh0ZW5kcyBBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHRpbWVsaW5lKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX3RpbWVsaW5lID0gdGltZWxpbmU7XG4gIH1cblxuICAvLyBAbm90ZSAtIHNob3VsZCBiZSBpbiB0aGUgdGltZWxpbmUgP1xuICAvLyBAdG9kbyAtIGFsbG93IHRvIHBhc3MgYW4gYXJyYXkgb2YgbGF5ZXJzXG4gIF9nZXRMYXllcnNPckdyb3VwcyhsYXllck9yR3JvdXApIHtcbiAgICBpZiAobGF5ZXJPckdyb3VwID09PSB1bmRlZmluZWQpIFxuICAgICAgbGF5ZXJPckdyb3VwID0gbnVsbDtcblxuICAgIGxldCBsYXllcnMgPSBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBsYXllck9yR3JvdXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsYXllcnMgPSB0aGlzLl90aW1lbGluZS5ncm91cGVkTGF5ZXJzW2xheWVyT3JHcm91cF07XG4gICAgfSBlbHNlIGlmIChsYXllck9yR3JvdXAgaW5zdGFuY2VvZiBMYXllcikge1xuICAgICAgbGF5ZXJzID0gW2xheWVyT3JHcm91cF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheWVycyA9IHRoaXMubGF5ZXJzO1xuICAgIH1cblxuICAgIHJldHVybiBsYXllcnM7XG4gIH1cblxuICAvLyBATk9URSBrZWVwIHRoaXMgP1xuICAvLyBjb3VsZCBwcmVwYXJlIHNvbWUgdmVydGljYWwgcmVzaXppbmcgYWJpbGl0eVxuICAvLyB0aGlzIHNob3VsZCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgbGF5ZXJzIHlTY2FsZSB0byBiZSByZWFsbHkgdXNlZnVsbFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfSAtIFVwZGF0ZXMgdGhlIGhlaWdodCBvZiBhbGwgdHJhY2tzIGF0IG9uY2UuXG4gICAqIEB0b2RvIC0gUHJvcGFnYXRlIHRvIGxheWVycywgbm90IHVzZWZ1bGwgZm9yIG5vdy5cbiAgICovXG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLmZvckVhY2goKHRyYWNrKSA9PiB0cmFjay5oZWlnaHQgPSB2YWx1ZSk7XG4gIH1cblxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgYWxsIHJlZ2lzdGVyZWQgbGF5ZXJzLlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8TGF5ZXI+fVxuICAgKi9cbiAgZ2V0IGxheWVycygpIHtcbiAgICBsZXQgbGF5ZXJzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuZm9yRWFjaCgodHJhY2spID0+IHRyYWNrLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4gbGF5ZXJzLmFkZChsYXllcikpKTtcblxuICAgIHJldHVybiBsYXllcnM7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIGFsbCB0cmFja3MgYW5kIGxheWVycy4gV2hlbiBkb25lLCB0aGUgdGltZWxpbmUgdHJpZ2dlcnMgYSBgcmVuZGVyYCBldmVudC5cbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmZvckVhY2goKHRyYWNrKSA9PiB0cmFjay5yZW5kZXIoKSk7XG4gICAgdGhpcy5fdGltZWxpbmUuZW1pdCgncmVuZGVyJyk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBhbGwgdHJhY2tzIGFuZCBsYXllcnMuIFdoZW4gZG9uZSwgdGhlIHRpbWVsaW5lIHRyaWdnZXJzIGFcbiAgICogYHVwZGF0ZWAgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7TGF5ZXJ8U3RyaW5nfSBsYXllck9yR3JvdXAgLSBGaWx0ZXIgdGhlIGxheWVycyB0byB1cGRhdGUgYnlcbiAgICogICAgcGFzc2luZyB0aGUgYExheWVyYCBpbnN0YW5jZSB0byB1cGRhdGUgb3IgYSBgZ3JvdXBJZGBcbiAgICovXG4gIHVwZGF0ZShsYXllck9yR3JvdXApIHtcbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLl9nZXRMYXllcnNPckdyb3VwcyhsYXllck9yR3JvdXApO1xuICAgIHRoaXMuZm9yRWFjaCgodHJhY2spID0+IHRyYWNrLnVwZGF0ZShsYXllcnMpKTtcbiAgICB0aGlzLl90aW1lbGluZS5lbWl0KCd1cGRhdGUnLCBsYXllcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYWxsIGBUcmFja2AgY29udGFpbmVycywgbGF5ZXJzIGFyZSBub3QgdXBkYXRlZCB3aXRoIHRoaXMgbWV0aG9kLlxuICAgKiBXaGVuIGRvbmUsIHRoZSB0aW1lbGluZSB0cmlnZ2VycyBhIGB1cGRhdGU6Y29udGFpbmVyc2AgZXZlbnQuXG4gICAqL1xuICB1cGRhdGVDb250YWluZXIoLyogdHJhY2tPclRyYWNrSWRzICovKSB7XG4gICAgdGhpcy5mb3JFYWNoKCh0cmFjaykgPT4gdHJhY2sudXBkYXRlQ29udGFpbmVyKCkpO1xuICAgIHRoaXMuX3RpbWVsaW5lLmVtaXQoJ3VwZGF0ZTpjb250YWluZXJzJyk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBhbGwgbGF5ZXJzLiBXaGVuIGRvbmUsIHRoZSB0aW1lbGluZSB0cmlnZ2VycyBhIGB1cGRhdGU6bGF5ZXJzYCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtMYXllcnxTdHJpbmd9IGxheWVyT3JHcm91cCAtIEZpbHRlciB0aGUgbGF5ZXJzIHRvIHVwZGF0ZSBieVxuICAgKiAgICBwYXNzaW5nIHRoZSBgTGF5ZXJgIGluc3RhbmNlIHRvIHVwZGF0ZSBvciBhIGBncm91cElkYFxuICAgKi9cbiAgdXBkYXRlTGF5ZXJzKGxheWVyT3JHcm91cCkge1xuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuX2dldExheWVyc09yR3JvdXBzKGxheWVyT3JHcm91cCk7XG4gICAgdGhpcy5mb3JFYWNoKCh0cmFjaykgPT4gdHJhY2sudXBkYXRlTGF5ZXJzKGxheWVycykpO1xuICAgIHRoaXMuX3RpbWVsaW5lLmVtaXQoJ3VwZGF0ZTpsYXllcnMnLCBsYXllcnMpO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgZXZlbnRzIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgS29udmEgZnJvbSAna29udmEnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYWNrIGV4dGVuZHMgZXZlbnRzLkV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9ICRlbFxuICAgKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodCA9IDEwMF1cbiAgICovXG4gIGNvbnN0cnVjdG9yKCRlbCwgaGVpZ2h0KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmICghaGVpZ2h0KVxuICAgICAgaGVpZ2h0ID0gMTAwO1xuXG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgLyoqXG4gICAgICogVGhlIERPTSBlbGVtZW50IGluIHdoaWNoIHRoZSB0cmFjayBpcyBjcmVhdGVkLlxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuJGVsID0gJGVsO1xuXG4gICAgdGhpcy4kc3RhZ2UgPSBudWxsO1xuXG4gICAgdGhpcy4kZHJhZ0xheWVyID0gbnVsbDtcbiAgICBcbiAgICB0aGlzLiRpbnRlcmFjdGlvbnNMYXllciA9IG51bGw7XG5cbiAgICB0aGlzLiRiYWNrZ3JvdW5kTGF5ZXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBzZXQgb2YgYWxsIHRoZSBsYXllcnMgYmVsb25naW5nIHRvIHRoZSB0cmFjay5cbiAgICAgKiBAdHlwZSB7U2V0PExheWVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmxheWVycyA9IG5ldyBTZXQoKTtcbiAgICAvKipcbiAgICAgKiBUaGUgY29udGV4dCB1c2VkIHRvIG1haW50YWluIHRoZSBET00gc3RydWN0dXJlIG9mIHRoZSB0cmFjay5cbiAgICAgKiBAdHlwZSB7VGltZWxpbmVUaW1lQ29udGV4dH1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmluZ0NvbnRleHQgPSBudWxsO1xuXG4gICAgdGhpcy5fY3JlYXRlQ29udGFpbmVyKCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIHRyYWNrLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGhlaWdodCBvZiB0aGUgdHJhY2suXG4gICAqXG4gICAqIEB0b2RvIHByb3BhZ2F0ZSB0byBsYXllcnMsIGtlZXBpbmcgcmF0aW8/IGNvdWxkIGJlIGhhbmR5IGZvciB2ZXJ0aWNhbFxuICAgKiAgICByZXNpemUuIFRoaXMgaXMgd2h5IGEgc2V0L2dldCBpcyBpbXBsZW1lbnRlZCBoZXJlLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICAgIHRoaXMuJHN0YWdlLmhlaWdodCh0aGlzLl9oZWlnaHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFjayBpcyBhZGRlZCB0byB0aGUgdGltZWxpbmUuIFRoZVxuICAgKiB0cmFjayBjYW5ub3QgYmUgdXBkYXRlZCB3aXRob3V0IGJlaW5nIGFkZGVkIHRvIGEgdGltZWxpbmUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VGltZWxpbmVUaW1lQ29udGV4dH0gcmVuZGVyaW5nQ29udGV4dFxuICAgKi9cbiAgY29uZmlndXJlKHJlbmRlcmluZ0NvbnRleHQpIHtcbiAgICB0aGlzLnJlbmRlcmluZ0NvbnRleHQgPSByZW5kZXJpbmdDb250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIHRyYWNrIGFuZCBpdHMgbGF5ZXJzLlxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4gbGF5ZXIuZGVzdHJveSgpKTtcbiAgICB0aGlzLmxheWVycy5jbGVhcigpO1xuXG4gICAgdGhpcy4kc3RhZ2UuZGVzdHJveSgpO1xuICAgIHRoaXMuJGludGVyYWN0aW9uc0xheWVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLiRiYWNrZ3JvdW5kTGF5ZXIuZGVzdHJveSgpO1xuXG4gICAgdGhpcy5faGVpZ2h0ID0gbnVsbDtcbiAgICB0aGlzLiRlbCA9IG51bGw7XG4gICAgdGhpcy4kc3RhZ2UgPSBudWxsO1xuICAgIHRoaXMuJGludGVyYWN0aW9uc0xheWVyID0gbnVsbDtcbiAgICB0aGlzLiRiYWNrZ3JvdW5kTGF5ZXIgPSBudWxsO1xuICAgIHRoaXMucmVuZGVyaW5nQ29udGV4dCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgYmFzaWMgS29udmEgc3RydWN0dXJlIG9mIHRoZSB0cmFjay5cbiAgICovXG4gIF9jcmVhdGVDb250YWluZXIoKSB7XG4gICAgdGhpcy4kc3RhZ2UgPSBuZXcgS29udmEuU3RhZ2Uoe1xuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCwgXG4gICAgICBjb250YWluZXI6IHRoaXMuJGVsXG4gICAgfSk7XG4gICAgdGhpcy4kc3RhZ2UuYWRkTmFtZSgndHJhY2stc3RhZ2UnKTtcblxuICAgIHRoaXMuJGludGVyYWN0aW9uc0xheWVyID0gbmV3IEtvbnZhLkxheWVyKHt9KTtcbiAgICB0aGlzLiRpbnRlcmFjdGlvbnNMYXllci5hZGROYW1lKCd0cmFjay1pbnRlcmFjdGlvbnMnKTtcblxuICAgIHRoaXMuJGJhY2tncm91bmRMYXllciA9IG5ldyBLb252YS5MYXllcih7fSk7XG4gICAgdGhpcy4kYmFja2dyb3VuZExheWVyLmFkZE5hbWUoJ3RyYWNrLWJhY2tncm91bmQnKTtcbiAgICBjb25zdCBiZ3JlY3QgPSBuZXcgS29udmEuUmVjdCh7fSk7XG4gICAgYmdyZWN0LmFkZE5hbWUoJ3RyYWNrLWJhY2tncm91bmQtcmVjdCcpO1xuICAgIHRoaXMuJGJhY2tncm91bmRMYXllci5hZGQoYmdyZWN0KTtcbiAgICAvLyB0aGlzLiRiYWNrZ3JvdW5kTGF5ZXIuY2hpbGRyZW5bMF0uc2hhcGUgPSB7IGxheWVyOiB7IHRyYWNrOiB0aGlzIH0gfTsgLy8gU2hhbWUhISEgLi4uLi4gU2hhbWUhISEgLi4uLiBTaGFtZSEhIVxuXG4gICAgdGhpcy4kZHJhZ0xheWVyID0gbmV3IEtvbnZhLkxheWVyKHt9KTtcbiAgICB0aGlzLiRkcmFnTGF5ZXIuYWRkTmFtZSgndHJhY2stZHJhZy1sYXllcicpO1xuXG4gICAgdGhpcy4kc3RhZ2UuYWRkKHRoaXMuJGRyYWdMYXllcik7XG4gICAgdGhpcy4kc3RhZ2UuYWRkKHRoaXMuJGludGVyYWN0aW9uc0xheWVyKTtcbiAgICB0aGlzLiRzdGFnZS5hZGQodGhpcy4kYmFja2dyb3VuZExheWVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbGF5ZXIgdG8gdGhlIHRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge0xheWVyfSBsYXllciAtIHRoZSBsYXllciB0byBhZGQgdG8gdGhlIHRyYWNrLlxuICAgKi9cbiAgYWRkKGxheWVyKSB7XG4gICAgaWYgKCF0aGlzLmxheWVycy5oYXMobGF5ZXIpKSB7XG4gICAgICBsYXllci5jcmVhdGVDb250YWluZXIodGhpcy4kc3RhZ2UpO1xuICAgICAgdGhpcy5sYXllcnMuYWRkKGxheWVyKTtcbiAgICAgIHRoaXMubW92ZVRvVG9wKGxheWVyKTtcbiAgICAgIHRoaXMuZW1pdCgnYWRkJywgbGF5ZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgbGF5ZXIgZnJvbSB0aGUgdHJhY2sgYW5kIGRlc3Ryb3lzIHRoYXQgYWx5ZXJcbiAgICpcbiAgICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSB0aGUgbGF5ZXIgdG8gcmVtb3ZlIGZyb20gdGhlIHRyYWNrLlxuICAgKi9cbiAgcmVtb3ZlKGxheWVyKSB7XG4gICAgLy8gVE9ET1xuICAgIGlmICh0aGlzLmxheWVycy5oYXMobGF5ZXIpKSB7XG4gICAgICB0aGlzLmxheWVycy5kZWxldGUobGF5ZXIpO1xuICAgICAgbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5lbWl0KCdyZW1vdmUnLCBsYXllcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTGF5ZXIgbm90IGZvdW5kJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRlc3RzIGlmIGEgZ2l2ZW4gZWxlbWVudCBiZWxvbmdzIHRvIHRoZSB0cmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSAkZWxcbiAgICogQHJldHVybiB7Ym9vbH1cbiAgICovXG4gIGhhc0VsZW1lbnQoJGVsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGVwcmVjYXRlZFwiKTtcblxuICAgIC8vIGRvIHtcbiAgICAvLyAgIGlmICgkZWwgPT09IHRoaXMuJGVsKSB7XG4gICAgLy8gICAgIHJldHVybiB0cnVlO1xuICAgIC8vICAgfVxuXG4gICAgLy8gICAkZWwgPSAkZWwucGFyZW50Tm9kZTtcbiAgICAvLyB9IHdoaWxlICgkZWwgIT09IG51bGwpO1xuXG4gICAgLy8gcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaGFzTGF5ZXIobGF5ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllcnMuaGFzKGxheWVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYWxsIHRoZSBsYXllcnMgYWRkZWQgdG8gdGhlIHRyYWNrLlxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIGZvciAobGV0IGxheWVyIG9mIHRoaXMpIHsgbGF5ZXIucmVuZGVyKCk7IH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB0cmFjayBLb252YSBzdHJ1Y3R1cmUgYW5kIHVwZGF0ZXMgdGhlIGxheWVycy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxMYXllcj59IFtsYXllcnM9bnVsbF0gLSBpZiBub3QgbnVsbCwgYSBzdWJzZXQgb2YgdGhlIGxheWVycyB0byB1cGRhdGUuXG4gICAqL1xuICB1cGRhdGUobGF5ZXJzKSB7XG4gICAgaWYgKGxheWVycyA9PT0gdW5kZWZpbmVkKVxuICAgICAgbGF5ZXJzID0gbnVsbDtcblxuICAgIHRoaXMudXBkYXRlQ29udGFpbmVyKCk7XG4gICAgdGhpcy51cGRhdGVMYXllcnMobGF5ZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB0cmFjayBLb252YSBzdHJ1Y3R1cmUuXG4gICAqL1xuICB1cGRhdGVDb250YWluZXIoKSB7XG4gICAgLy8gU2hvdWxkIGJlIGluIHNvbWUgdXBkYXRlIGxheW91dFxuICAgIGNvbnN0IHJlbmRlcmluZ0NvbnRleHQgPSB0aGlzLnJlbmRlcmluZ0NvbnRleHQ7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLnJvdW5kKHJlbmRlcmluZ0NvbnRleHQudmlzaWJsZVdpZHRoKTtcbiAgICBjb25zdCBvZmZzZXRYID0gLU1hdGgucm91bmQocmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChyZW5kZXJpbmdDb250ZXh0Lm9mZnNldCkpO1xuXG4gICAgdGhpcy4kc3RhZ2Uud2lkdGgod2lkdGgpLmhlaWdodCh0aGlzLmhlaWdodCkub2Zmc2V0WChvZmZzZXRYKTtcbiAgICB0aGlzLiRpbnRlcmFjdGlvbnNMYXllci5vZmZzZXRYKC1vZmZzZXRYKTtcbiAgICB0aGlzLiRiYWNrZ3JvdW5kTGF5ZXIub2Zmc2V0WCgtb2Zmc2V0WCk7XG4gICAgdGhpcy4kYmFja2dyb3VuZExheWVyLmNoaWxkcmVuWzBdLngoMCkueSgwKS53aWR0aCh3aWR0aCkuaGVpZ2h0KHRoaXMuaGVpZ2h0KS5vcGFjaXR5KDApLm1vdmVUb0JvdHRvbSgpO1xuICAgIHRoaXMuJGJhY2tncm91bmRMYXllci5iYXRjaERyYXcoKTtcblxuICAgIC8qXG4gICAgICogQ2hhbmdlIHRoZSBsYXllciBzdGFjayBvcmRlciBhY2NvcmRpbmcgdG8gTGF5ZXIuekluZGV4LlxuICAgICAqL1xuICAgIC8vIHZhciB6SW5kZXhDb3VudGVyID0gMDtcbiAgICAvLyB2YXIgbWF4WkluZGV4ID0gLUluZmluaXR5O1xuICAgIC8vIHRoaXMuJGJhY2tncm91bmRMYXllci5zZXRaSW5kZXgoekluZGV4Q291bnRlcisrKTtcbiAgICAvLyB0aGlzLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgIC8vICAgbGF5ZXIuX2NvbnRleHRMYXllci5zZXRaSW5kZXgobGF5ZXIuekluZGV4ICsgekluZGV4Q291bnRlcisrKTtcbiAgICAvLyAgIGxheWVyLl9jb21tb25TaGFwZUxheWVyLnNldFpJbmRleChsYXllci56SW5kZXggKyB6SW5kZXhDb3VudGVyKyspO1xuICAgIC8vICAgbGF5ZXIuY29udGVudExheWVycy5mb3JFYWNoKChrb252YUxheWVyKSA9PiBrb252YUxheWVyLnNldFpJbmRleChsYXllci56SW5kZXggKyB6SW5kZXhDb3VudGVyKyspKTtcbiAgICAvLyAgIGxheWVyLl9kcmFnTGF5ZXIuc2V0WkluZGV4KGxheWVyLnpJbmRleCArIHpJbmRleENvdW50ZXIrKyk7XG4gICAgLy8gICBtYXhaSW5kZXggPSBNYXRoLm1heChtYXhaSW5kZXgsIGxheWVyLnpJbmRleCk7XG4gICAgLy8gfSlcbiAgICAvLyB0aGlzLiRpbnRlcmFjdGlvbnNMYXllci5zZXRaSW5kZXgobWF4WkluZGV4ICsgekluZGV4Q291bnRlcik7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbGF5ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PExheWVyPn0gW2xheWVycz1udWxsXSAtIGlmIG5vdCBudWxsLCBhIHN1YnNldCBvZiB0aGUgbGF5ZXJzIHRvIHVwZGF0ZS5cbiAgICovXG4gIHVwZGF0ZUxheWVycyhsYXllcnMpIHtcbiAgICBpZiAobGF5ZXJzID09PSB1bmRlZmluZWQpIFxuICAgICAgbGF5ZXJzID0gbnVsbDtcblxuICAgIGxheWVycyA9IChsYXllcnMgPT09IG51bGwpID8gdGhpcy5sYXllcnMgOiBsYXllcnM7XG5cbiAgICBpZiAoIShsYXllcnMgaW5zdGFuY2VvZiBTZXQpICYmICEobGF5ZXJzIGluc3RhbmNlb2YgQXJyYXkpKSBcbiAgICAgIGxheWVycyA9IFtsYXllcnNdO1xuXG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XG5cbiAgICBsYXllcnMuZm9yRWFjaCgobGF5ZXIpID0+IHtcbiAgICAgIGlmICghdGhpcy5sYXllcnMuaGFzKGxheWVyKSkgeyByZXR1cm47IH1cbiAgICAgIGxheWVyLmhlaWdodCA9IHRoYXQuaGVpZ2h0O1xuICAgICAgbGF5ZXIudXBkYXRlKCk7XG4gICAgfSk7XG4gICAgdGhpcy4kYmFja2dyb3VuZExheWVyLm1vdmVUb0JvdHRvbSgpO1xuICB9XG5cbiAgbWluaW1pemUoKSB7XG4gICAgLy8gVE9ET1xuICB9XG5cbiAgbWF4aW1pemUoKSB7XG4gICAgLy8gVE9ET1xuICB9XG5cbiAgbW92ZVRvVG9wKGxheWVyKSB7XG4gICAgbGF5ZXIuX2NvbnRleHRMYXllci5tb3ZlVG9Ub3AoKTtcbiAgICBsYXllci5fY29tbW9uU2hhcGVMYXllci5tb3ZlVG9Ub3AoKTtcbiAgICBsYXllci5jb250ZW50TGF5ZXJzLmZvckVhY2goKGtvbnZhTGF5ZXIpID0+IGtvbnZhTGF5ZXIubW92ZVRvVG9wKCkpO1xuXG4gICAgdGhpcy4kaW50ZXJhY3Rpb25zTGF5ZXIubW92ZVRvVG9wKCk7XG4gICAgdGhpcy4kYmFja2dyb3VuZExheWVyLm1vdmVUb0JvdHRvbSgpO1xuICB9XG5cbiAgbW92ZVRvQm90dG9tKGxheWVyKSB7XG4gICAgdGhpcy4kaW50ZXJhY3Rpb25zTGF5ZXIubW92ZVRvVG9wKCk7XG4gICAgXG4gICAgbGF5ZXIuY29udGVudExheWVycy5mb3JFYWNoKChrb252YUxheWVyKSA9PiBrb252YUxheWVyLm1vdmVUb0JvdHRvbSgpKTtcbiAgICBsYXllci5fY29tbW9uU2hhcGVMYXllci5tb3ZlVG9Cb3R0b20oKTtcbiAgICBsYXllci5fY29udGV4dExheWVyLm1vdmVUb0JvdHRvbSgpO1xuICAgIFxuICAgIHRoaXMuJGJhY2tncm91bmRMYXllci5tb3ZlVG9Cb3R0b20oKTtcbiAgfVxuXG5cblxuICAvKipcbiAgICogSXRlcmF0ZXMgdGhyb3VnaCB0aGUgYWRkZWQgbGF5ZXJzLlxuICAgKi9cbiAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHlpZWxkKiB0aGlzLmxheWVyc1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cbn1cbiIsImltcG9ydCBBbm5vdGF0ZWRNYXJrZXIgZnJvbSAnLi4vc2hhcGVzL2Fubm90YXRlZC1tYXJrZXInO1xuaW1wb3J0IExheWVyIGZyb20gJy4uL2NvcmUvbGF5ZXInO1xuaW1wb3J0IE1hcmtlckJlaGF2aW9yIGZyb20gJy4uL2JlaGF2aW9ycy9tYXJrZXItYmVoYXZpb3InO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFubm90YXRlZE1hcmtlckxheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBjb25zdHJ1Y3RvcihkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcignY29sbGVjdGlvbicsIGRhdGEsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5jb25maWd1cmVTaGFwZShBbm5vdGF0ZWRNYXJrZXIpO1xuICAgIHRoaXMuc2V0QmVoYXZpb3IobmV3IE1hcmtlckJlaGF2aW9yKCkpO1xuICB9XG59XG4iLCJpbXBvcnQgTGF5ZXIgZnJvbSAnLi4vY29yZS9sYXllcic7XG5pbXBvcnQgQW5ub3RhdGVkU2VnbWVudCBmcm9tICcuLi9zaGFwZXMvYW5ub3RhdGVkLXNlZ21lbnQnO1xuaW1wb3J0IFNlZ21lbnRCZWhhdmlvciBmcm9tICcuLi9iZWhhdmlvcnMvc2VnbWVudC1iZWhhdmlvcic7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5ub3RhdGVkU2VnbWVudExheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBjb25zdHJ1Y3RvcihkYXRhLCBvcHRpb25zID0ge30sIGFjY2Vzc29ycyA9IHt9KSB7XG4gICAgc3VwZXIoJ2NvbGxlY3Rpb24nLCBkYXRhLCBvcHRpb25zKTtcblxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGRpc3BsYXlIYW5kbGVyczogdHJ1ZSxcbiAgICAgIG9wYWNpdHk6IDAuNlxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5jb25maWd1cmVTaGFwZShBbm5vdGF0ZWRTZWdtZW50LCBhY2Nlc3NvcnMsIHtcbiAgICAgIGRpc3BsYXlIYW5kbGVyczogb3B0aW9ucy5kaXNwbGF5SGFuZGxlcnMsXG4gICAgICBvcGFjaXR5OiBvcHRpb25zLm9wYWNpdHksXG4gICAgfSk7XG5cbiAgICB0aGlzLnNldEJlaGF2aW9yKG5ldyBTZWdtZW50QmVoYXZpb3IoKSk7XG4gIH1cbn1cbiIsImltcG9ydCBBeGlzTGF5ZXIgZnJvbSAnLi4vYXhpcy9heGlzLWxheWVyJztcbmltcG9ydCBUaWNrcyBmcm9tICcuLi9zaGFwZXMvdGlja3MnO1xuaW1wb3J0IGJlYXRHcmlkQXhpc0dlbmVyYXRvciBmcm9tICcuLi9heGlzL2JlYXQtZ3JpZC1heGlzLWdlbmVyYXRvcic7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmVhdEdyaWRBeGlzTGF5ZXIgZXh0ZW5kcyBBeGlzTGF5ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgY29sb3I6ICdzdGVlbGJsdWUnLFxuICAgICAgc2lnbmF0dXJlOiAnNC80J1xuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgc3VwZXIoYmVhdEdyaWRBeGlzR2VuZXJhdG9yKG9wdGlvbnMuYmVhdEdyaWQsIG9wdGlvbnMuc2lnbmF0dXJlKSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmNvbmZpZ3VyZVNoYXBlKFRpY2tzLCB7fSwge1xuICAgICAgY29sb3I6IG9wdGlvbnMuY29sb3JcbiAgICB9KTtcbiAgfVxufSIsImltcG9ydCBMYXllciBmcm9tICcuLi9jb3JlL2xheWVyJztcbmltcG9ydCBNYXJrZXIgZnJvbSAnLi4vc2hhcGVzL21hcmtlcic7XG5pbXBvcnQgQnJlYWtwb2ludEJlaGF2aW9yIGZyb20gJy4uL2JlaGF2aW9ycy9tYXJrZXItYmVoYXZpb3InO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJlYXRHcmlkTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMgPSB7fSwgYWNjZXNzb3JzID0ge30pIHtcbiAgICBzdXBlcignY29sbGVjdGlvbicsIGRhdGEsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5zb3J0X2RhdGEgPSBvcHRpb25zLnNvcnRfZGF0YTtcbiAgICB0aGlzLnZpc2libGVfZGF0YSA9IG9wdGlvbnMudmlzaWJsZV9kYXRhO1xuXG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBkaXNwbGF5SGFuZGxlcnM6IHRydWUgfSwgb3B0aW9ucyk7XG4gICAgY29uc3QgY29sb3IgPSBvcHRpb25zLmNvbG9yO1xuICAgIGlmIChjb2xvcikge1xuICAgICAgYWNjZXNzb3JzLmNvbG9yID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb2xvcjsgfTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmZpZ3VyZVNoYXBlKE1hcmtlciwgYWNjZXNzb3JzLCB7XG4gICAgICBkaXNwbGF5SGFuZGxlcnM6IG9wdGlvbnMuZGlzcGxheUhhbmRsZXJzXG4gICAgfSk7XG5cbiAgICB0aGlzLnNldEJlaGF2aW9yKG5ldyBCcmVha3BvaW50QmVoYXZpb3IoKSk7XG4gIH1cbn1cbiIsImltcG9ydCBCcmVha3BvaW50QmVoYXZpb3IgZnJvbSAnLi4vYmVoYXZpb3JzL2JyZWFrcG9pbnQtYmVoYXZpb3InO1xuaW1wb3J0IERvdCBmcm9tICcuLi9zaGFwZXMvZG90JztcbmltcG9ydCBMYXllciBmcm9tICcuLi9jb3JlL2xheWVyJztcbmltcG9ydCBMaW5lIGZyb20gJy4uL3NoYXBlcy9saW5lJztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCcmVha3BvaW50TGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMgPSB7fSwgYWNjZXNzb3JzID0ge30pIHtcbiAgICBzdXBlcignY29sbGVjdGlvbicsIGRhdGEsIG9wdGlvbnMpO1xuICAgIFxuICAgIHRoaXMuc29ydF9kYXRhID0gb3B0aW9ucy5zb3J0X2RhdGE7XG4gICAgdGhpcy52aXNpYmxlX2RhdGEgPSBvcHRpb25zLnZpc2libGVfZGF0YTtcblxuICAgIGNvbnN0IGNvbG9yID0gb3B0aW9ucy5jb2xvcjtcbiAgICBsZXQgY29tbW9uU2hhcGVPcHRpb25zID0ge307XG5cbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIGFjY2Vzc29ycy5jb2xvciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29sb3I7IH07XG4gICAgICBjb21tb25TaGFwZU9wdGlvbnMuY29sb3IgPSBjb2xvcjtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmZpZ3VyZUNvbW1vblNoYXBlKExpbmUsIGFjY2Vzc29ycywgY29tbW9uU2hhcGVPcHRpb25zKTtcbiAgICB0aGlzLmNvbmZpZ3VyZVNoYXBlKERvdCwgYWNjZXNzb3JzLCB7fSk7XG4gICAgdGhpcy5zZXRCZWhhdmlvcihuZXcgQnJlYWtwb2ludEJlaGF2aW9yKCkpO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgS29udmEgZnJvbSAna29udmEnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCcnVzaENvbnRyb2xsZXIge1xuXHRjb25zdHJ1Y3Rvcih0cmFjaywgc3R5bGUpIHtcblx0XHRpZiAoc3R5bGUgPT09IHVuZGVmaW5lZCkgXG5cdFx0XHRzdHlsZSA9IHt9O1xuXHRcdHRoaXMudHJhY2sgPSB0cmFjaztcblx0XHR0aGlzLmlubmVyQ29sb3IgPSBzdHlsZS5pbm5lckNvbG9yIHx8ICcjNjg2ODY4Jztcblx0XHR0aGlzLm9wYWNpdHkgPSBzdHlsZS5vcGFjaXR5IHx8IDAuNTtcblx0fVxuXG5cdGdldCBicnVzaEFyZWEoKSB7XG5cdFx0Y29uc3QgJGJydXNoID0gdGhpcy50cmFjay4kYnJ1c2g7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogJGJydXNoLngoKSwgXG5cdFx0XHR5OiAkYnJ1c2gueSgpLCBcblx0XHRcdHdpZHRoOiAkYnJ1c2gud2lkdGgoKSwgXG5cdFx0XHRoZWlnaHQ6ICRicnVzaC5oZWlnaHQoKVxuXHRcdH07XG5cdH1cblxuXHRzZXQgYnJ1c2hBcmVhKEEpIHtcblx0XHR2YXIgeCA9IEEueCwgXG5cdFx0XHR5ID0gKEEueSB8fCAwKSwgXG5cdFx0XHR3aWR0aCA9IEEud2lkdGgsIFxuXHRcdFx0aGVpZ2h0ID0gKEEuaGVpZ2h0IHx8IHRoaXMudHJhY2suaGVpZ2h0KTtcblxuXHRcdHRoaXMudHJhY2suJGJydXNoLngoeCkueSh5KS53aWR0aCh3aWR0aCkuaGVpZ2h0KGhlaWdodCk7XG5cdFx0XG5cdFx0dGhpcy50cmFjay4kaW50ZXJhY3Rpb25zTGF5ZXIuYmF0Y2hEcmF3KCk7XG5cdH1cblxuXHRzZXQgb3BhY2l0eSh2YWx1ZSkge1xuXHRcdHRoaXMuX29wYWNpdHkgPSB2YWx1ZTtcblx0XHRpZiAodGhpcy50cmFjay4kYnJ1c2gpXG5cdFx0XHR0aGlzLnRyYWNrLiRicnVzaC5vcGFjaXR5KHRoaXMuX29wYWNpdHkpO1xuXHRcdHRoaXMudHJhY2suJGludGVyYWN0aW9uc0xheWVyLmJhdGNoRHJhdygpO1xuXHR9XG5cblx0Z2V0IG9wYWNpdHkoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX29wYWNpdHk7XG5cdH1cblxuXHRzZXQgaW5uZXJDb2xvcih2YWx1ZSkge1xuXHRcdHRoaXMuX2lubmVyQ29sb3IgPSB2YWx1ZTtcblx0XHRpZiAodGhpcy50cmFjay4kYnJ1c2gpXG5cdFx0XHR0aGlzLnRyYWNrLiRicnVzaC5maWxsKHRoaXMuX2lubmVyQ29sb3IpO1xuXHRcdHRoaXMudHJhY2suJGludGVyYWN0aW9uc0xheWVyLmJhdGNoRHJhdygpO1xuXHR9XG5cblx0Z2V0IGlubmVyQ29sb3IoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lubmVyQ29sb3I7XG5cdH1cblxuXG5cblx0YWRkQnJ1c2goKSB7XG5cdFx0aWYgKHRoaXMudHJhY2suJGJydXNoKSByZXR1cm47IFxuXG5cdFx0Y29uc3QgYnJ1c2ggPSBuZXcgS29udmEuUmVjdCh7fSk7XG5cdFx0YnJ1c2guZmlsbCh0aGlzLmlubmVyQ29sb3IpLm9wYWNpdHkodGhpcy5vcGFjaXR5KTtcblxuXHRcdHRoaXMudHJhY2suJGludGVyYWN0aW9uc0xheWVyLmFkZChicnVzaCk7XG5cdFx0dGhpcy50cmFjay4kaW50ZXJhY3Rpb25zTGF5ZXIubW92ZVRvVG9wKCk7XG5cblx0XHR0aGlzLnRyYWNrLiRicnVzaCA9IGJydXNoO1xuXG5cdFx0dGhpcy50cmFjay4kaW50ZXJhY3Rpb25zTGF5ZXIuYmF0Y2hEcmF3KCk7XG5cdH1cblxuXHRyZW1vdmVCcnVzaCgpIHtcblx0XHRpZiAodGhpcy50cmFjay4kYnJ1c2ggPT09IHVuZGVmaW5lZCkgcmV0dXJuOyBcblxuXHRcdHRoaXMucmVzZXRCcnVzaCgpO1xuXG5cdFx0dGhpcy50cmFjay4kYnJ1c2guZGVzdHJveSgpO1xuXG5cdFx0dGhpcy50cmFjay4kaW50ZXJhY3Rpb25zTGF5ZXIuYmF0Y2hEcmF3KCk7XG5cblx0XHRkZWxldGUgdGhpcy50cmFjay4kYnJ1c2g7XG5cdH1cblxuXHRyZXNldEJydXNoKCkge1xuXHRcdGNvbnN0ICRicnVzaCA9IHRoaXMudHJhY2suJGJydXNoO1xuXHRcdC8vIHJlc2V0IGJydXNoIGVsZW1lbnRcblx0XHQkYnJ1c2gueCgwKS55KDApLndpZHRoKDApLmhlaWdodCgwKTtcblx0XHR0aGlzLnRyYWNrLiRpbnRlcmFjdGlvbnNMYXllci5iYXRjaERyYXcoKTtcblx0fVxuXG5cdHVwZGF0ZUJydXNoKGUpIHtcblx0XHRjb25zdCAkYnJ1c2ggPSB0aGlzLnRyYWNrLiRicnVzaDtcblxuXHRcdCRicnVzaC54KGUuYXJlYS5sZWZ0KS55KDApLndpZHRoKGUuYXJlYS53aWR0aCkuaGVpZ2h0KHRoaXMudHJhY2suaGVpZ2h0KTtcblxuXHRcdHRoaXMudHJhY2suJGludGVyYWN0aW9uc0xheWVyLmJhdGNoRHJhdygpO1xuXHR9XG59IiwiaW1wb3J0IExheWVyIGZyb20gJy4uL2NvcmUvbGF5ZXInO1xuaW1wb3J0IEN1cnNvciBmcm9tICcuLi9zaGFwZXMvY3Vyc29yJztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXJzb3JMYXllciBleHRlbmRzIExheWVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICBjb2xvcjogJ3JlZCcsXG4gICAgICBoaXR0YWJsZTogZmFsc2UsIC8vIGtpbmQgb2YgcGFzcyB0aHJvdWdoIGxheWVyXG4gICAgfTtcblxuICAgIGNvbnN0IGRhdGEgPSB7IGN1cnJlbnRQb3NpdGlvbjogMCB9O1xuXG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgIHN1cGVyKCdlbnRpdHknLCBkYXRhLCBvcHRpb25zKTtcblxuICAgIHRoaXMuY29uZmlndXJlU2hhcGUoQ3Vyc29yLCB7IHg6IChkKSA9PiBkLmN1cnJlbnRQb3NpdGlvbiB9LCB7XG4gICAgICBjb2xvcjogb3B0aW9ucy5jb2xvclxuICAgIH0pO1xuXG4gICAgdGhpcy5kYXRhWzBdID0gZGF0YTtcbiAgfVxuXG4gIHNldCBjdXJyZW50UG9zaXRpb24odmFsdWUpIHtcbiAgICB0aGlzLmRhdGFbMF0uY3VycmVudFBvc2l0aW9uID0gdmFsdWU7XG4gIH1cblxuICBnZXQgY3VycmVudFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFbMF0uY3VycmVudFBvc2l0aW9uO1xuICB9XG59XG4iLCJpbXBvcnQgQXhpc0xheWVyIGZyb20gJy4uL2F4aXMvYXhpcy1sYXllcic7XG5pbXBvcnQgVGlja3MgZnJvbSAnLi4vc2hhcGVzL3RpY2tzJztcbmltcG9ydCBncmlkQXhpc0dlbmVyYXRvciBmcm9tICcuLi9heGlzL2dyaWQtYXhpcy1nZW5lcmF0b3InO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyaWRBeGlzTGF5ZXIgZXh0ZW5kcyBBeGlzTGF5ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgY29sb3I6ICdzdGVlbGJsdWUnLFxuICAgICAgYnBtOiA2MCxcbiAgICAgIHNpZ25hdHVyZTogJzQvNCdcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHN1cGVyKGdyaWRBeGlzR2VuZXJhdG9yKG9wdGlvbnMuYnBtLCBvcHRpb25zLnNpZ25hdHVyZSksIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5jb25maWd1cmVTaGFwZShUaWNrcywge30sIHtcbiAgICAgIGNvbG9yOiBvcHRpb25zLmNvbG9yXG4gICAgfSk7XG4gIH1cbn0iLCJpbXBvcnQgTGF5ZXIgZnJvbSAnLi4vY29yZS9sYXllcic7XG5pbXBvcnQgTWFya2VyIGZyb20gJy4uL3NoYXBlcy9tYXJrZXInO1xuaW1wb3J0IE1hcmtlckJlaGF2aW9yIGZyb20gJy4uL2JlaGF2aW9ycy9tYXJrZXItYmVoYXZpb3InO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcmtlckxheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBjb25zdHJ1Y3RvcihkYXRhLCBvcHRpb25zID0ge30sIGFjY2Vzc29ycyA9IHt9KSB7XG4gICAgc3VwZXIoJ2NvbGxlY3Rpb24nLCBkYXRhLCBvcHRpb25zKTtcblxuICAgIHRoaXMuc29ydF9kYXRhID0gb3B0aW9ucy5zb3J0X2RhdGE7XG4gICAgdGhpcy52aXNpYmxlX2RhdGEgPSBvcHRpb25zLnZpc2libGVfZGF0YTtcblxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgZGlzcGxheUhhbmRsZXJzOiB0cnVlIH0sIG9wdGlvbnMpO1xuICAgIGNvbnN0IGNvbG9yID0gb3B0aW9ucy5jb2xvcjtcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIGFjY2Vzc29ycy5jb2xvciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29sb3I7IH07XG4gICAgfVxuXG4gICAgdGhpcy5jb25maWd1cmVTaGFwZShNYXJrZXIsIGFjY2Vzc29ycywge1xuICAgICAgZGlzcGxheUhhbmRsZXJzOiBvcHRpb25zLmRpc3BsYXlIYW5kbGVyc1xuICAgIH0pO1xuXG4gICAgdGhpcy5zZXRCZWhhdmlvcihuZXcgTWFya2VyQmVoYXZpb3IoKSk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBldmVudHMgZnJvbSAnZXZlbnRzJztcbmltcG9ydCBUaW1lbGluZSBmcm9tICcuLi9jb3JlL3RpbWVsaW5lJztcbmltcG9ydCBUcmFjayBmcm9tICcuLi9jb3JlL3RyYWNrJztcbmltcG9ydCBMYXllciBmcm9tICcuLi9jb3JlL2xheWVyJztcbmltcG9ydCBMYXllclRpbWVDb250ZXh0IGZyb20gJy4uL2NvcmUvbGF5ZXItdGltZS1jb250ZXh0JztcbmltcG9ydCBTY3JvbGxTZWdtZW50QmVoYXZpb3IgZnJvbSAnLi4vYmVoYXZpb3JzL3Njcm9sbC1zZWdtZW50LWJlaGF2aW9yJztcbmltcG9ydCBTZWdtZW50IGZyb20gJy4uL3NoYXBlcy9zZWdtZW50JztcbmltcG9ydCBTaW1wbGVFZGl0aW9uU3RhdGUgZnJvbSAnLi4vc3RhdGVzL3NpbXBsZS1lZGl0aW9uLXN0YXRlJztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY3JvbGxlciBleHRlbmRzIGV2ZW50cy5FdmVudEVtaXR0ZXIge1xuXHRjb25zdHJ1Y3RvcigkZWwsIHRhcmdldFRpbWVsaW5lcywgcGl4ZWxzUGVyU2Vjb25kLCB3aWR0aCwgaGVpZ2h0LCBzdGFydCwgZHVyYXRpb24pIHtcblx0XHRzdXBlcigpO1xuXHRcdGNvbnN0IHRoYXQgPSB0aGlzO1xuXHRcdHRoaXMuaGFuZGxlcnMgPSB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKHRpbWVsaW5lcywgaW5kZXgsIHZhbHVlKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFt0aW1lbGluZXMsIGluZGV4LCB2YWx1ZV0pO1xuXHRcdFx0XHRpZiAoIWlzTmFOKHBhcnNlSW50KGluZGV4KSkpIHtcblx0XHRcdFx0XHR0aW1lbGluZXNbaW5kZXhdID0gdmFsdWU7XG5cdFx0XHRcdFx0dmFyIGludGVydmFsID0ge1xuXHRcdFx0XHRcdFx0c3RhcnQ6IHRoYXQudmlzaWJsZVJhbmdlLnN0YXJ0LCBcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiB0aGF0LnZpc2libGVSYW5nZS5kdXJhdGlvblxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0dGltZWxpbmVzW2luZGV4XS52aXNpYmxlSW50ZXJ2YWwgPSBpbnRlcnZhbDtcblx0XHRcdFx0XHR0aW1lbGluZXNbaW5kZXhdLnRyYWNrcy51cGRhdGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHRoaXMuYXV4VGltZWxpbmUgPSBuZXcgVGltZWxpbmUocGl4ZWxzUGVyU2Vjb25kLCB3aWR0aCk7XG5cdFx0dmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHR0LmNsYXNzTGlzdC5hZGQoXCJzY3JvbGwtZGl2XCIpO1xuXHRcdCRlbC5hcHBlbmRDaGlsZCh0KTtcblxuXHRcdHRoaXMuYXV4VHJhY2sgPSBuZXcgVHJhY2sodCwgMjAsIHdpZHRoKTtcblxuXHRcdHRoaXMuYXV4U2Nyb2xsTGF5ZXIgPSBuZXcgTGF5ZXIoJ2NvbGxlY3Rpb24nLCBbXSwge1xuXHRcdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0XHR5RG9tYWluOiBbMCwgMV1cblx0XHR9KTtcblx0XHR0aGlzLmF1eFNjcm9sbExheWVyLnNldEJlaGF2aW9yKG5ldyBTY3JvbGxTZWdtZW50QmVoYXZpb3IobmV3IFByb3h5KFtdLCB0aGlzLmhhbmRsZXJzKSkpO1xuXHRcdHRoaXMuYXV4U2Nyb2xsTGF5ZXIuc2V0VGltZUNvbnRleHQobmV3IExheWVyVGltZUNvbnRleHQodGhpcy5hdXhUaW1lbGluZS50aW1lQ29udGV4dCkpO1xuXHRcdHRoaXMuYXV4U2Nyb2xsTGF5ZXIuY29uZmlndXJlU2hhcGUoU2VnbWVudCwge30pO1xuXHRcdHRoaXMuYXV4U2Nyb2xsTGF5ZXIudGltZUNvbnRleHQubG9ja2VkVG9QYXJlbnRJbnRlcnZhbCA9IHRydWU7XG5cblx0XHR0aGlzLmF1eFNjcm9sbExheWVyLnNvcnRfZGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHt9O1xuXHRcdHRoaXMuYXV4U2Nyb2xsTGF5ZXIudmlzaWJsZV9kYXRhID0gZnVuY3Rpb24odGltZUNvbnRleHQsIGRhdGEpIHsgcmV0dXJuIFswLCBkYXRhLmxlbmd0aC0xXTsgfTtcblx0XHR0aGlzLmF1eFNjcm9sbExheWVyLnRpbWVDb250ZXh0LmxvY2tlZFRvUGFyZW50SW50ZXJ2YWwgPSB0cnVlO1xuXG5cdFx0dmFyIHZpc2libGVJbnRlcnZhbCA9IHsgc3RhcnQ6IHN0YXJ0IHx8IDAsIGR1cmF0aW9uOiBkdXJhdGlvbiB8fCAxMH07XG5cblx0XHR0aGlzLnNjcm9sbERhdHVtID0ge3g6IHZpc2libGVJbnRlcnZhbC5zdGFydCwgZHVyYXRpb246IHZpc2libGVJbnRlcnZhbC5kdXJhdGlvbn07XG5cdFx0dGhpcy5hdXhTY3JvbGxMYXllci5hZGQodGhpcy5zY3JvbGxEYXR1bSk7XG5cblx0XHR0aGlzLmF1eFRpbWVsaW5lLnZpc2libGVJbnRlcnZhbCA9IHZpc2libGVJbnRlcnZhbDtcblxuXHRcdHRhcmdldFRpbWVsaW5lcyA9ICh0YXJnZXRUaW1lbGluZXMgaW5zdGFuY2VvZiBBcnJheSk/IHRhcmdldFRpbWVsaW5lcyA6IFt0YXJnZXRUaW1lbGluZXNdO1xuXHRcdHRhcmdldFRpbWVsaW5lcy5mb3JFYWNoKCh0aW1lbGluZSkgPT4ge1xuXHRcdFx0dGhhdC50aW1lbGluZXMucHVzaCh0aW1lbGluZSk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLmF1eFRyYWNrLmFkZCh0aGlzLmF1eFNjcm9sbExheWVyKTtcblx0XHR0aGlzLmF1eFRpbWVsaW5lLmFkZCh0aGlzLmF1eFRyYWNrKTtcblx0XHR0aGlzLmF1eFRpbWVsaW5lLnRyYWNrcy51cGRhdGUoKTtcblxuXHRcdHRoaXMuYXV4U2Nyb2xsTGF5ZXIuZWRpdChbdGhpcy5zY3JvbGxEYXR1bV0sIDAsIDAsIHRoaXMuYXV4U2Nyb2xsTGF5ZXIuZ2V0U2hhcGVGcm9tRGF0dW0odGhpcy5zY3JvbGxEYXR1bSkuJHNlZ21lbnQpO1xuXG5cdFx0dGhpcy5hdXhUaW1lbGluZS5zdGF0ZSA9IG5ldyBTaW1wbGVFZGl0aW9uU3RhdGUodGhpcy5hdXhUaW1lbGluZSk7XG5cblx0XHRcblx0XHR0aGlzLmF1eFRpbWVsaW5lLm9uKCdldmVudCcsIChlKT0+IHtcblx0XHRcdGlmIChlLnR5cGUgPT0gJ2NsaWNrJyAmJiBlLnRhcmdldCAmJiAhZS50YXJnZXQuc2hhcGUpIHtcblx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gKC10aGF0LmF1eFRpbWVsaW5lLnRpbWVDb250ZXh0Lm9mZnNldCk7XG5cdFx0XHRcdGNvbnN0IHRpbWUgPSB0aGF0LmF1eFRpbWVsaW5lLnRpbWVDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydChlLngpO1xuXHRcdFx0XHRjb25zdCBjdXJyZW50VGltZSA9IG9mZnNldCArIHRpbWU7XG5cdFx0XHRcdGNvbnN0IGR4ID0gZS54IC0gdGhhdC5hdXhUaW1lbGluZS50aW1lQ29udGV4dC50aW1lVG9QaXhlbCh0aGF0LnNjcm9sbERhdHVtLngpO1xuXHRcdFx0XHRjb25zdCBzaGFwZSA9IHRoYXQuYXV4U2Nyb2xsTGF5ZXIuZ2V0U2hhcGVGcm9tRGF0dW0odGhhdC5zY3JvbGxEYXR1bSk7XG5cblx0XHRcdFx0dGhhdC5hdXhTY3JvbGxMYXllci5lZGl0KFt0aGF0LnNjcm9sbERhdHVtXSwgZHgsIDAsIHNoYXBlLiRzZWdtZW50KTtcblx0XHRcdFx0dGhhdC5hdXhUaW1lbGluZS50cmFja3MudXBkYXRlKCk7XG5cdFx0XHRcdHRoYXQuZW1pdCgnZHJhZycpO1xuXHRcdFx0fSBlbHNlIGlmIChlLnR5cGUgPT0gJ21vdXNlbW92ZScpIHtcblx0XHRcdFx0dGhhdC5lbWl0KCdkcmFnJyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRzZXQgYXZhaWxhYmxlU2Nyb2xsUmFuZ2UoaW50ZXJ2YWwpIHtcblx0XHR0aGlzLmF1eFRpbWVsaW5lLnZpc2libGVJbnRlcnZhbCA9IGludGVydmFsO1xuXHRcdHRoaXMuYXV4VGltZWxpbmUudHJhY2tzLnVwZGF0ZSgpO1xuXHR9XG5cdFxuXHRnZXQgYXZhaWxhYmxlU2Nyb2xsUmFuZ2UoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXV4VGltZWxpbmUudmlzaWJsZUludGVydmFsO1xuXHR9XG5cblx0c2V0IHZpc2libGVSYW5nZShpbnRlcnZhbCkge1xuXHRcdGNvbnN0IHRhcmdldFggPSB0aGlzLmF1eFRpbWVsaW5lLnRpbWVDb250ZXh0LnRpbWVUb1BpeGVsKGludGVydmFsLnN0YXJ0KTtcblx0XHRjb25zdCB4ID0gdGhpcy5hdXhUaW1lbGluZS50aW1lQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLnNjcm9sbERhdHVtLngpO1xuXHRcdGNvbnN0IGR4ID0gdGFyZ2V0WCAtIHg7XG5cdFx0dGhpcy5zY3JvbGxEYXR1bS53aWR0aCA9IGludGVydmFsLmR1cmF0aW9uO1xuXG5cdFx0Y29uc3Qgc2hhcGUgPSB0aGlzLmF1eFNjcm9sbExheWVyLmdldFNoYXBlRnJvbURhdHVtKHRoaXMuc2Nyb2xsRGF0dW0pO1xuXHRcdHRoaXMuYXV4U2Nyb2xsTGF5ZXIuZWRpdChbdGhpcy5zY3JvbGxEYXR1bV0sIGR4LCAwLCBzaGFwZS4kc2VnbWVudCk7XG5cblx0XHR0aGlzLmF1eFRpbWVsaW5lLnRyYWNrcy51cGRhdGUoKTtcblx0fVxuXG5cdGdldCB2aXNpYmxlUmFuZ2UoKSB7XG5cdFx0cmV0dXJuIHtzdGFydDogdGhpcy5zY3JvbGxEYXR1bS54LCBkdXJhdGlvbjogdGhpcy5zY3JvbGxEYXR1bS53aWR0aCB8fCAxMH07XG5cdH1cblxuXHRzZXQgY29sb3IodmFsdWUpIHtcblx0XHR0aGlzLmF1eFNjcm9sbExheWVyLmdldFNoYXBlRnJvbURhdHVtKHRoaXMuc2Nyb2xsRGF0dW0pLnBhcmFtcy5jb2xvciA9IHZhbHVlO1xuXHRcdHRoaXMuYXV4VGltZWxpbmUudHJhY2tzLnVwZGF0ZSgpO1xuXHR9XG5cblx0Z2V0IGNvbG9yKCkge1xuXHRcdHJldHVybiB0aGlzLmF1eFNjcm9sbExheWVyLmdldFNoYXBlRnJvbURhdHVtKHRoaXMuc2Nyb2xsRGF0dW0pLnBhcmFtcy5jb2xvcjtcblx0fVxuXG5cdHNldCB0aW1lbGluZXModGltZWxpbmVzKSB7XG5cdFx0dGhpcy5hdXhTY3JvbGxMYXllci5fYmVoYXZpb3IudGFyZ2V0VGltZWxpbmVzID0gbmV3IFByb3h5KHRpbWVsaW5lcywgdGhpcy5oYW5kbGVycyk7XG5cdFx0dGhpcy5hdXhTY3JvbGxMYXllci5fYmVoYXZpb3IuX3JlZnJlc2goKTtcblx0fVxuXG5cdGdldCB0aW1lbGluZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXV4U2Nyb2xsTGF5ZXIuX2JlaGF2aW9yLnRhcmdldFRpbWVsaW5lcztcblx0fVxufSIsImltcG9ydCBMYXllciBmcm9tICcuLi9jb3JlL2xheWVyJztcbmltcG9ydCBTZWdtZW50IGZyb20gJy4uL3NoYXBlcy9zZWdtZW50JztcbmltcG9ydCBTZWdtZW50QmVoYXZpb3IgZnJvbSAnLi4vYmVoYXZpb3JzL3NlZ21lbnQtYmVoYXZpb3InO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlZ21lbnRMYXllciBleHRlbmRzIExheWVyIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucyA9IHt9LCBhY2Nlc3NvcnMgPSB7fSkge1xuICAgIHN1cGVyKCdjb2xsZWN0aW9uJywgZGF0YSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnNvcnRfZGF0YSA9IG9wdGlvbnMuc29ydF9kYXRhO1xuICAgIHRoaXMudmlzaWJsZV9kYXRhID0gb3B0aW9ucy52aXNpYmxlX2RhdGE7XG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBkaXNwbGF5SGFuZGxlcnM6IHRydWUsXG4gICAgICBvcGFjaXR5OiAwLjZcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHRoaXMuY29uZmlndXJlU2hhcGUoU2VnbWVudCwgYWNjZXNzb3JzLCB7XG4gICAgICBkaXNwbGF5SGFuZGxlcnM6IG9wdGlvbnMuZGlzcGxheUhhbmRsZXJzLFxuICAgICAgb3BhY2l0eTogb3B0aW9ucy5vcGFjaXR5LFxuICAgIH0pO1xuXG4gICAgdGhpcy5zZXRCZWhhdmlvcihuZXcgU2VnbWVudEJlaGF2aW9yKCkpO1xuICB9XG59XG4iLCJpbXBvcnQgTGF5ZXIgZnJvbSAnLi4vY29yZS9sYXllcic7XG5pbXBvcnQgVGlja3MgZnJvbSAnLi4vc2hhcGVzL3RpY2tzJztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaWNrTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMsIGFjY2Vzc29ycykge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgc3VwZXIoJ2VudGl0eScsIGRhdGEsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5zb3J0X2RhdGEgPSBvcHRpb25zLnNvcnRfZGF0YTtcbiAgICB0aGlzLnZpc2libGVfZGF0YSA9IG9wdGlvbnMudmlzaWJsZV9kYXRhO1xuXG4gICAgY29uc3QgY29uZmlnID0gb3B0aW9ucy5jb2xvciA/IHsgY29sb3I6IG9wdGlvbnMuY29sb3IgfSA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbmZpZ3VyZVNoYXBlKFRpY2tzLCBhY2Nlc3NvcnMsIGNvbmZpZyk7XG4gIH1cbn0iLCJpbXBvcnQgQXhpc0xheWVyIGZyb20gJy4uL2F4aXMvYXhpcy1sYXllcic7XG5pbXBvcnQgVGlja3MgZnJvbSAnLi4vc2hhcGVzL3RpY2tzJztcbmltcG9ydCB0aW1lQXhpc0dlbmVyYXRvciBmcm9tICcuLi9heGlzL3RpbWUtYXhpcy1nZW5lcmF0b3InO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVBeGlzTGF5ZXIgZXh0ZW5kcyBBeGlzTGF5ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBjb2xvcjogJ3N0ZWVsYmx1ZScgfSwgb3B0aW9ucyk7XG4gICAgc3VwZXIodGltZUF4aXNHZW5lcmF0b3IoKSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnNvcnRfZGF0YSA9IG9wdGlvbnMuc29ydF9kYXRhO1xuICAgIHRoaXMudmlzaWJsZV9kYXRhID0gb3B0aW9ucy52aXNpYmxlX2RhdGE7XG5cbiAgICB0aGlzLmNvbmZpZ3VyZVNoYXBlKFRpY2tzLCB7fSwge1xuICAgICAgY29sb3I6IG9wdGlvbnMuY29sb3JcbiAgICB9KTtcbiAgfVxufSIsImltcG9ydCBMYXllciBmcm9tICcuLi9jb3JlL2xheWVyJztcbmltcG9ydCBUcmFjZVBhdGggZnJvbSAnLi4vc2hhcGVzL3RyYWNlLXBhdGgnO1xuaW1wb3J0IFRyYWNlRG90cyBmcm9tICcuLi9zaGFwZXMvdHJhY2UtZG90cyc7XG5pbXBvcnQgVHJhY2VCZWhhdmlvciBmcm9tICcuLi9iZWhhdmlvcnMvdHJhY2UtYmVoYXZpb3InO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYWNlTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMgPSB7fSwgYWNjZXNzb3JzID0ge30pIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGRpc3BsYXlEb3RzOiB0cnVlIH0sIG9wdGlvbnMpO1xuICAgIHN1cGVyKG9wdGlvbnMuZGlzcGxheURvdHMgPyAnY29sbGVjdGlvbicgOiAnZW50aXR5JywgZGF0YSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnNvcnRfZGF0YSA9IG9wdGlvbnMuc29ydF9kYXRhO1xuICAgIHRoaXMudmlzaWJsZV9kYXRhID0gb3B0aW9ucy52aXNpYmxlX2RhdGE7XG5cbiAgICBjb25zdCBzaGFwZU9wdGlvbnMgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5tZWFuQ29sb3IgIT09IHVuZGVmaW5lZCkgeyBzaGFwZU9wdGlvbnMubWVhbkNvbG9yID0gb3B0aW9ucy5tZWFuQ29sb3I7IH1cbiAgICBpZiAob3B0aW9ucy5yYW5nZUNvbG9yICE9PSB1bmRlZmluZWQpIHsgc2hhcGVPcHRpb25zLnJhbmdlQ29sb3IgPSBvcHRpb25zLnJhbmdlQ29sb3I7IH1cbiAgICBpZiAob3B0aW9ucy5kaXNwbGF5TWVhbiAhPT0gdW5kZWZpbmVkKSB7IHNoYXBlT3B0aW9ucy5kaXNwbGF5TWVhbiA9IG9wdGlvbnMuZGlzcGxheU1lYW47IH1cblxuICAgIGlmIChvcHRpb25zLmRpc3BsYXlEb3RzKSB7XG4gICAgICB0aGlzLmNvbmZpZ3VyZUNvbW1vblNoYXBlKFRyYWNlUGF0aCwgYWNjZXNzb3JzLCBzaGFwZU9wdGlvbnMpO1xuICAgICAgdGhpcy5jb25maWd1cmVTaGFwZShUcmFjZURvdHMsIGFjY2Vzc29ycywgc2hhcGVPcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb25maWd1cmVTaGFwZShUcmFjZVBhdGgsIGFjY2Vzc29ycywgc2hhcGVPcHRpb25zKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEJlaGF2aW9yKG5ldyBUcmFjZUJlaGF2aW9yKCkpO1xuICB9XG59IiwiaW1wb3J0IExheWVyIGZyb20gJy4uL2NvcmUvbGF5ZXInO1xuaW1wb3J0IFdhdmVmb3JtIGZyb20gJy4uL3NoYXBlcy93YXZlZm9ybSc7XG5cblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gIHlEb21haW46IFstMSwgMV0sXG4gIGNoYW5uZWw6IDAsXG4gIGNvbG9yOiAnc3RlZWxibHVlJyxcbiAgcmVuZGVyaW5nU3RyYXRlZ3k6ICdzdmcnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXYXZlZm9ybUxheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBjb25zdHJ1Y3RvcihkYXRhLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgIHN1cGVyKCdjb2xsZWN0aW9uJywgZGF0YSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnNvcnRfZGF0YSA9IG9wdGlvbnMuc29ydF9kYXRhO1xuICAgIHRoaXMudmlzaWJsZV9kYXRhID0gb3B0aW9ucy52aXNpYmxlX2RhdGE7XG5cbiAgICB0aGlzLmNvbmZpZ3VyZVNoYXBlKFdhdmVmb3JtLCB7fSwge1xuICAgICAgc2FtcGxlUmF0ZTogYnVmZmVyLnNhbXBsZVJhdGUsXG4gICAgICBjb2xvcjogb3B0aW9ucy5jb2xvcixcbiAgICAgIHJlbmRlcmluZ1N0cmF0ZWd5OiBvcHRpb25zLnJlbmRlcmluZ1N0cmF0ZWd5XG4gICAgfSk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBldmVudHMgZnJvbSAnZXZlbnRzJztcblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyB0byBleHRlbmQgdG8gY3JlYXRlIG5ldyBzb3VyY2VzIG9mIGludGVyYWN0aW9ucy5cbiAqIEEgYFN1cmZhY2VgIGFuZCBgS2V5Ym9hcmRgIGV2ZW50IHNvdXJjZXMgYXJlIHByb3ZpZGVkLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudFNvdXJjZSBleHRlbmRzIGV2ZW50cy5FdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigkZWwpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIFRoZSBlbGVtZW50IG9uIHdoaWNoIHRoZSBsaXN0ZW5lciBpcyBhZGRlZFxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuJGVsID0gJGVsO1xuXG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICB9XG5cbiAgX2NyZWF0ZUV2ZW50KHR5cGUsIGUpIHt9XG5cbiAgX2JpbmRFdmVudHMoKSB7fVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEV2ZW50U291cmNlIGZyb20gJy4vZXZlbnQtc291cmNlJztcbmltcG9ydCBXYXZlRXZlbnQgZnJvbSAnLi93YXZlLWV2ZW50JztcblxuLyoqXG4gKiBBIGdsb2JhbCBldmVudCBzb3VydmUgZm9yIHRoZSBrZXlib2FyZC4gT25seSBvbmUgaW5zdGFuY2Ugb2YgdGhpcyBzb3VyY2VcbiAqIGNhbiBiZSBjcmVhdGVkLiBUaGUgZmlyc3QgY3JlYXRlZCB0aW1lbGluZSBpbnN0YW5jaWF0ZSB0aGUgc2luZ2xldG9uLCBlYWNoXG4gKiBzdWJzZXF1ZW50IGluc3RhbmNpYXRpb24gcmV0dXJucyB0aGUgZmlyc3QgY3JlYXRlZCBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2V5Ym9hcmQgZXh0ZW5kcyBFdmVudFNvdXJjZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9ICRlbCAtIFRoZSBlbGVtZW50IG9uIHdoaWNoIHRvIGluc3RhbGwgdGhlIGxpc3RlbmVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IoJGVsKSB7XG4gICAgLy8ga2luZCBvZiBzaW5nbGV0b25cbiAgICBpZiAoS2V5Ym9hcmQuX2luc3RhbmNlKSB7IHJldHVybiBLZXlib2FyZC5faW5zdGFuY2U7IH1cblxuICAgIHN1cGVyKCRlbCk7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHNvdXJjZVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VOYW1lID0gJ2tleWJvYXJkJztcblxuICAgIEtleWJvYXJkLl9pbnN0YW5jZSA9IHRoaXM7XG5cbiAgICB0aGlzLl9iZWluZ1ByZXNzZWQgPSBuZXcgU2V0KCk7XG4gIH1cblxuICBfY3JlYXRlRXZlbnQodHlwZSwgZSkge1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IFdhdmVFdmVudCh0aGlzLnNvdXJjZU5hbWUsIHR5cGUsIGUpO1xuXG4gICAgZXZlbnQuc2hpZnRLZXkgPSBlLnNoaWZ0S2V5O1xuICAgIGV2ZW50LmN0cmxLZXkgPSBlLmN0cmxLZXk7XG4gICAgZXZlbnQuYWx0S2V5ID0gZS5hbHRLZXk7XG4gICAgZXZlbnQubWV0YUtleSA9IGUubWV0YUtleTtcblxuICAgIGV2ZW50LmtleUNvZGUgPSBlLmtleUNvZGU7XG4gICAgZXZlbnQuY2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZS5rZXlDb2RlKTtcblxuICAgIHJldHVybiBldmVudDtcbiAgfVxuXG4gIF9iaW5kRXZlbnRzKCkge1xuICAgIGNvbnN0IG9uS2V5RG93biA9IChlKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2JlaW5nUHJlc3NlZC5oYXMoZS5rZXlDb2RlKSkge1xuICAgICAgICBsZXQgZXZlbnQgPSB0aGlzLl9jcmVhdGVFdmVudCgna2V5ZG93bicsIGUpO1xuICAgICAgICB0aGlzLmVtaXQoJ2V2ZW50JywgZXZlbnQpO1xuICAgICAgICB0aGlzLl9iZWluZ1ByZXNzZWQuYWRkKGUua2V5Q29kZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG9uS2V5VXAgPSAoZSkgPT4ge1xuICAgICAgbGV0IGV2ZW50MSA9IHRoaXMuX2NyZWF0ZUV2ZW50KCdrZXl1cCcsIGUpO1xuICAgICAgdGhpcy5lbWl0KCdldmVudCcsIGV2ZW50MSk7XG5cbiAgICAgIGxldCBldmVudDIgPSB0aGlzLl9jcmVhdGVFdmVudCgna2V5cHJlc3MnLCBlKTtcbiAgICAgIHRoaXMuZW1pdCgnZXZlbnQnLCBldmVudDIpO1xuXG4gICAgICB0aGlzLl9iZWluZ1ByZXNzZWQuZGVsZXRlKGUua2V5Q29kZSk7XG4gICAgfTtcblxuICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24sIGZhbHNlKTtcbiAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIG9uS2V5VXAsIGZhbHNlKTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEV2ZW50U291cmNlIGZyb20gJy4vZXZlbnQtc291cmNlJztcbmltcG9ydCBLb252YVdhdmVFdmVudCBmcm9tICcuL2tvbnZhLXdhdmUtZXZlbnQnO1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgbW91c2UgdXNlciBpbnRlcmFjdGlvbnMgd2l0aCB0aGUgdGltZWxpbmUgdXBvbiB0aGUgRE9NXG4gKiBjb250YWluZXIgZWxlbWVudCBvZiBgVHJhY2tgIGluc3RhbmNlcy4gQXMgc29vbiBhcyBhIGB0cmFja2AgaXMgYWRkZWQgdG8gYVxuICogYHRpbWVsaW5lYCwgaXRzIGF0dGFjaGVkIGBTdXJmYWNlYCBpbnN0YW5jZSB3aWxsIGVtaXQgdGhlIG1vdXNlIGV2ZW50cy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3VyZmFjZSBleHRlbmRzIEV2ZW50U291cmNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWwgLSBUaGUgRE9NIGVsZW1lbnQgdG8gbGlzdGVuLlxuICAgKiBAdG9kbyAtIEFkZCBzb21lIHBhZGRpbmcgdG8gdGhlIHN1cmZhY2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigkZWwpIHtcbiAgICBzdXBlcigkZWwpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHNvdXJjZS5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlTmFtZSA9ICdzdXJmYWNlJztcbiAgICB0aGlzLl9tb3VzZURvd25FdmVudCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGYWN0b3J5IG1ldGhvZCBmb3IgYEV2ZW50YCBjbGFzc1xuICAgKi9cbiAgX2NyZWF0ZUV2ZW50KHR5cGUsIGUpIHtcbiAgICBjb25zdCBldmVudCA9IG5ldyBLb252YVdhdmVFdmVudCh0aGlzLnNvdXJjZU5hbWUsIHR5cGUsIGUpO1xuXG4gICAgY29uc3QgcG9zID0gdGhpcy5fZ2V0UmVsYXRpdmVQb3NpdGlvbihlKTtcbiAgICBldmVudC54ID0gcG9zLng7XG4gICAgZXZlbnQueSA9IHBvcy55O1xuXG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHgsIHkgY29vcmRpbmF0ZXMgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gdGhlIHN1cmZhY2UgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZSAtIFJhdyBldmVudCBmcm9tIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEB0b2RvIC0gaGFuZGxlIHBhZGRpbmcuXG4gICAqL1xuICBfZ2V0UmVsYXRpdmVQb3NpdGlvbihlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KSB7XG4gICAgICBsZXQgeCA9IGUub2Zmc2V0WDtcbiAgICAgIGxldCB5ID0gZS5vZmZzZXRZO1xuICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgeCA9IGUuZXZ0Lm9mZnNldFg7XG4gICAgICBsZXQgeSA9IGUuZXZ0Lm9mZnNldFk7XG4gICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfVxuICB9XG5cbiAgX2RlZmluZUFyZWEoZSwgbW91c2VEb3duRXZlbnQsIGxhc3RFdmVudCkge1xuICAgIGlmICghbW91c2VEb3duRXZlbnQgfHwgIWxhc3RFdmVudCkgeyByZXR1cm47IH1cbiAgICBlLmR4ID0gZS54IC0gbGFzdEV2ZW50Lng7XG4gICAgZS5keSA9IGUueSAtIGxhc3RFdmVudC55O1xuXG4gICAgY29uc3QgbGVmdCA9IG1vdXNlRG93bkV2ZW50LnggPCBlLnggPyBtb3VzZURvd25FdmVudC54IDogZS54O1xuICAgIGNvbnN0IHRvcCAgPSBtb3VzZURvd25FdmVudC55IDwgZS55ID8gbW91c2VEb3duRXZlbnQueSA6IGUueTtcbiAgICBjb25zdCB3aWR0aCAgPSBNYXRoLmFicyhNYXRoLnJvdW5kKGUueCAtIG1vdXNlRG93bkV2ZW50LngpKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmFicyhNYXRoLnJvdW5kKGUueSAtIG1vdXNlRG93bkV2ZW50LnkpKTtcblxuICAgIGUuYXJlYSA9IHsgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IH07XG4gIH1cblxuICAvKipcbiAgICogS2VlcCB0aGlzIHByaXZhdGUgdG8gYXZvaWQgZG91YmxlIGV2ZW50IGJpbmRpbmcuIE1haW4gbG9naWMgb2YgdGhlIHN1cmZhY2VcbiAgICogaXMgaGVyZS4gU2hvdWxkIGJlIGV4dGVuZGVkIHdpdGggbmVlZGVkIGV2ZW50cyAobW91c2VlbnRlciwgbW91c2VsZWF2ZSxcbiAgICogd2hlZWwgLi4uKS5cbiAgICovXG4gIF9iaW5kRXZlbnRzKCkge1xuICAgIFxuICAgIGNvbnN0IG9uTW91c2VEcmFnID0gKGUpID0+IHtcblxuICAgICAgbGV0IGV2ZW50ID0gdGhpcy5fY3JlYXRlRXZlbnQoJ21vdXNlbW92ZScsIGUpO1xuICAgICAgdGhpcy5fZGVmaW5lQXJlYShldmVudCwgdGhpcy5fbW91c2VEb3duRXZlbnQsIHRoaXMuX2xhc3RFdmVudCk7XG4gICAgICAvLyBVcGRhdGUgYGxhc3RFdmVudGAgZm9yIG5leHQgY2FsbFxuICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gZXZlbnQ7XG5cbiAgICAgIHRoaXMuZW1pdCgnZXZlbnQnLCBldmVudCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uTW91c2VVcCA9IChlKSA9PiB7XG5cbiAgICAgIGlmICh0aGlzLl9sYXN0RXZlbnQudHlwZSA9PSAnbW91c2Vtb3ZlJykge1xuXG4gICAgICAgIGxldCBldmVudCA9IHRoaXMuX2NyZWF0ZUV2ZW50KCdtb3VzZXVwJywgZSk7XG4gICAgICAgIHRoaXMuX2RlZmluZUFyZWEoZXZlbnQsIHRoaXMuX21vdXNlRG93bkV2ZW50LCB0aGlzLl9sYXN0RXZlbnQpO1xuXG4gICAgICAgIHRoaXMuX21vdXNlRG93bkV2ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gbnVsbDtcbiAgICAgICAgLy8gUmVtb3ZlIG1vdXNlbW92ZSBhbmQgbW91c2V1cCBsaXN0ZW5lcnMgb24gd2luZG93XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcblxuICAgICAgICB0aGlzLmVtaXQoJ2V2ZW50JywgZXZlbnQpO1xuXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2xhc3RFdmVudC50eXBlID09ICdtb3VzZWRvd24nKSB7XG5cbiAgICAgICAgbGV0IGV2ZW50MSA9IHRoaXMuX2NyZWF0ZUV2ZW50KCdtb3VzZXVwJywgZSk7XG4gICAgICAgIGxldCBldmVudDIgPSB0aGlzLl9jcmVhdGVFdmVudCgnY2xpY2snLCBlKTtcbiAgICAgICAgZXZlbnQyLnRhcmdldCA9IHRoaXMuX21vdXNlRG93bkV2ZW50LnRhcmdldDtcblxuICAgICAgICB0aGlzLl9tb3VzZURvd25FdmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG5cbiAgICAgICAgLy8gUmVtb3ZlIG1vdXNlbW92ZSBhbmQgbW91c2V1cCBsaXN0ZW5lcnMgb24gd2luZG93XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcblxuICAgICAgICB0aGlzLmVtaXQoJ2V2ZW50JywgZXZlbnQxKTtcbiAgICAgICAgdGhpcy5lbWl0KCdldmVudCcsIGV2ZW50Mik7XG5cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgb25Nb3VzZURvd24gPSAoZSkgPT4ge1xuICAgICAgLy8gQnkgcmVtb3ZpbmcgdGhlIHByZXZpb3VzIHNlbGVjdGlvbiB3ZSBwcmV2ZW50IGJ5cGFzc2luZyB0aGUgbW91c2Vtb3ZlIGV2ZW50cyBjb21pbmcgZnJvbSBTVkcgaW4gRmlyZWZveC5cbiAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5fY3JlYXRlRXZlbnQoJ21vdXNlZG93bicsIGUpO1xuXG5cbiAgICAgIHRoaXMuX21vdXNlRG93bkV2ZW50ID0gZXZlbnQ7XG4gICAgICB0aGlzLl9sYXN0RXZlbnQgPSBldmVudDtcbiAgICAgIC8vIFJlZ2lzdGVyIG1vdXNlbW92ZSBhbmQgbW91c2V1cCBsaXN0ZW5lcnMgb24gd2luZG93XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcsIGZhbHNlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwLCBmYWxzZSk7XG5cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG5cbiAgICAgIHRoaXMuZW1pdCgnZXZlbnQnLCBldmVudCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uQ2xpY2sgPSAoZSkgPT4ge1xuICAgICAgbGV0IGV2ZW50ID0gdGhpcy5fY3JlYXRlRXZlbnQoJ2NsaWNrJywgZSk7XG4gICAgICB0aGlzLmVtaXQoJ2V2ZW50JywgZXZlbnQpO1xuICAgIH07XG5cbiAgICBjb25zdCBvbkRibENsaWNrID0gKGUpID0+IHtcbiAgICAgIGxldCBldmVudCA9IHRoaXMuX2NyZWF0ZUV2ZW50KCdkYmxjbGljaycsIGUpO1xuICAgICAgdGhpcy5lbWl0KCdldmVudCcsIGV2ZW50KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb25Nb3VzZU92ZXIgPSAoZSkgPT4ge1xuICAgICAgbGV0IGV2ZW50ID0gdGhpcy5fY3JlYXRlRXZlbnQoJ21vdXNlb3ZlcicsIGUpO1xuICAgICAgdGhpcy5lbWl0KCdldmVudCcsIGV2ZW50KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb25Nb3VzZU91dCA9IChlKSA9PiB7XG4gICAgICBsZXQgZXZlbnQgPSB0aGlzLl9jcmVhdGVFdmVudCgnbW91c2VvdXQnLCBlKTtcbiAgICAgIHRoaXMuZW1pdCgnZXZlbnQnLCBldmVudCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uTW91c2VEb3duVGltZWxpbmUgPSAoZSkgPT4ge1xuICAgICAgbGV0IGV2ZW50ID0gdGhpcy5fY3JlYXRlRXZlbnQoJ21vdXNlZG93bicsIGUpO1xuICAgICAgdGhpcy5lbWl0KCdldmVudCcsIGV2ZW50KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb25Eb21EcmFnU3RhcnQgPSAoZSkgPT4ge1xuICAgICAgbGV0IGV2ZW50ID0gdGhpcy5fY3JlYXRlRXZlbnQoJ2RyYWdzdGFydCcsIGUpO1xuICAgICAgdGhpcy5lbWl0KCdldmVudCcsIGV2ZW50KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb25Eb21EcmFnT3ZlciA9IChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBsZXQgZXZlbnQgPSB0aGlzLl9jcmVhdGVFdmVudCgnZHJhZ292ZXInLCBlKTtcbiAgICAgIHRoaXMuZW1pdCgnZXZlbnQnLCBldmVudCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uRG9tRHJvcCA9IChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBsZXQgZXZlbnQgPSB0aGlzLl9jcmVhdGVFdmVudCgnZHJvcCcsIGUpO1xuICAgICAgdGhpcy5lbWl0KCdldmVudCcsIGV2ZW50KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb25Eb21EcmFnTGVhdmUgPSAoZSkgPT4ge1xuICAgICAgbGV0IGV2ZW50ID0gdGhpcy5fY3JlYXRlRXZlbnQoJ2RyYWdsZWF2ZScsIGUpO1xuICAgICAgdGhpcy5lbWl0KCdldmVudCcsIGV2ZW50KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb25Eb21EcmFnRW50ZXIgPSAoZSkgPT4ge1xuICAgICAgbGV0IGV2ZW50ID0gdGhpcy5fY3JlYXRlRXZlbnQoJ2RyYWdlbnRlcicsIGUpO1xuICAgICAgdGhpcy5lbWl0KCdldmVudCcsIGV2ZW50KTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBXaGVuIEkgbGlzdGVuIGZvciB0aGUgJ2NsaWNrJyBldmVudCwgdGhlcmUgaXMgdGhlIGZvbGxvd2luZyBpc3N1ZSBmb3IgJ2RyYWcnIHNlcXVlbmNlczpcbiAgICAgKlxuICAgICAqICgxKSBbbW91c2Vkb3duIC0+IG1vdXNlbW92ZSAtPiBjbGljayAtPiBtb3VzZXVwXSBcbiAgICAgKiAgaW5zdGVhZCBvZiBcbiAgICAgKiAoMikgW21vdXNlZG93biAtPiBtb3VzZW1vdmUgLT4gbW91c2V1cF1cbiAgICAgKiBcbiAgICAgKiBGb3IgdGhpcyByZWFzb24sIGluc3RlYWQgb2YgZGlyZWN0bHkgbGlzdGVuaW5nIGZvciAnY2xpY2snLCBJIGFkYXB0ZWQgdGhlICdtb3VzZXVwJyBcbiAgICAgKiBsaXN0ZW5lciB0byBlbmZvcmNlIHRoZSBzZXF1ZW5jZSAoMikgYW5kIFttb3VzZWRvd24gLT4gbW91c2V1cCAtPiBjbGlja10gLlxuICAgICAqL1xuXG4gICAgLy8gQmluZCBjYWxsYmFja3NcbiAgICAvLyB0aGlzLiRlbC4kc3RhZ2Uub24oJ2NvbnRlbnRNb3VzZWRvd24nLCBvbk1vdXNlRG93blRpbWVsaW5lKTtcbiAgICB0aGlzLiRlbC4kc3RhZ2Uub24oJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICAvLyB0aGlzLiRlbC4kc3RhZ2Uub24oJ2NsaWNrJywgb25DbGljayk7IFxuICAgIHRoaXMuJGVsLiRzdGFnZS5vbignZGJsY2xpY2snLCBvbkRibENsaWNrKTtcbiAgICB0aGlzLiRlbC4kc3RhZ2Uub24oJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKTtcbiAgICB0aGlzLiRlbC4kc3RhZ2Uub24oJ21vdXNlb3V0Jywgb25Nb3VzZU91dCk7XG4gICAgdGhpcy4kZWwuJHN0YWdlLm9uKCdtb3VzZW92ZXInLCBvbk1vdXNlT3Zlcik7XG4gICAgdGhpcy4kZWwuJHN0YWdlLmNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0Jywgb25Eb21EcmFnU3RhcnQpO1xuICAgIHRoaXMuJGVsLiRzdGFnZS5jb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdlbnRlcicsIG9uRG9tRHJhZ0VudGVyKTtcbiAgICB0aGlzLiRlbC4kc3RhZ2UuY29udGVudC5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgb25Eb21Ecm9wKTtcbiAgICB0aGlzLiRlbC4kc3RhZ2UuY29udGVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIG9uRG9tRHJhZ092ZXIpO1xuICAgIHRoaXMuJGVsLiRzdGFnZS5jb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdsZWF2ZScsIG9uRG9tRHJhZ0xlYXZlKTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IFdhdmVFdmVudCBmcm9tICcuL3dhdmUtZXZlbnQnO1xuXG4vKipcbiAqIE9iamVjdCB0ZW1wbGF0ZSBmb3IgYWxsIGV2ZW50cy4gRXZlbnQgc291cmNlcyBzaG91bGQgdXNlIHRoaXMgZXZlbnQgdGVtcGxhdGVcbiAqIGluIG9yZGVyIHRvIGtlZXAgY29uc2lzdGVuY3kgd2l0aCBleGlzdGluZyBzb3VyY2VzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLb252YVdhdmVFdmVudCBleHRlbmRzIFdhdmVFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlIC0gVGhlIG5hbWUgb2YgdGhlIHNvdXJjZSAoYGtleWJvYXJkYCwgYHN1cmZhY2VgLCAuLi4pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBzb3VyY2UgKGBtb3VzZWRvd25gLCBga2V5dXBgLCAuLi4pLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBvcmlnaW5hbEV2ZW50IC0gVGhlIG9yaWdpbmFsIGV2ZW50IGFzIGVtaXR0ZWQgYnkgdGhlIGJyb3dzZXIuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHR5cGUsIG9yaWdpbmFsRXZlbnQpIHtcbiAgICBzdXBlcihzb3VyY2UsIHR5cGUsIG9yaWdpbmFsRXZlbnQpO1xuICAgIGlmICghKG9yaWdpbmFsRXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KSkge1xuICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudC5ldnQ7XG4gICAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBvcmlnaW5hbEV2ZW50LmV2dC5jdXJyZW50VGFyZ2V0O1xuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE9iamVjdCB0ZW1wbGF0ZSBmb3IgYWxsIGV2ZW50cy4gRXZlbnQgc291cmNlcyBzaG91bGQgdXNlIHRoaXMgZXZlbnQgdGVtcGxhdGVcbiAqIGluIG9yZGVyIHRvIGtlZXAgY29uc2lzdGVuY3kgd2l0aCBleGlzdGluZyBzb3VyY2VzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXYXZlRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZSAtIFRoZSBuYW1lIG9mIHRoZSBzb3VyY2UgKGBrZXlib2FyZGAsIGBzdXJmYWNlYCwgLi4uKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgc291cmNlIChgbW91c2Vkb3duYCwgYGtleXVwYCwgLi4uKS5cbiAgICogQHBhcmFtIHtFdmVudH0gb3JpZ2luYWxFdmVudCAtIFRoZSBvcmlnaW5hbCBldmVudCBhcyBlbWl0dGVkIGJ5IHRoZSBicm93c2VyLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc291cmNlLCB0eXBlLCBvcmlnaW5hbEV2ZW50KSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xuXG4gICAgdGhpcy50YXJnZXQgPSBvcmlnaW5hbEV2ZW50LnRhcmdldDtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBvcmlnaW5hbEV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBEb3QgZnJvbSAnLi9kb3QnO1xuaW1wb3J0IEtvbnZhIGZyb20gJ2tvbnZhJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5ub3RhdGVkRG90IGV4dGVuZHMgRG90IHtcblxuXHRkZXN0cm95KCkge1xuXHRcdHRoaXMuJGxhYmVsLmRlc3Ryb3koKTtcblx0XHR0aGlzLiRsYWJlbCA9IG51bGw7XG5cdFx0c3VwZXIuZGVzdHJveSgpO1xuXHR9XG5cblx0Z2V0Q2xhc3NOYW1lKCkgeyByZXR1cm4gJ2Fubm90YXRlZC1kb3QnOyB9XG5cblx0X2dldEFjY2Vzc29yTGlzdCgpIHtcblx0XHRsZXQgbGlzdCA9IHN1cGVyLl9nZXRBY2Nlc3Nvckxpc3QoKTtcblx0XHRsaXN0LnRleHQgPSAnZGVmYXVsdCc7XG5cdFx0cmV0dXJuIGxpc3Q7XG5cdH1cblxuXHRyZW5kZXIocmVuZGVyaW5nQ29udGV4dCkge1xuXHRcdGlmICh0aGlzLiRlbCkgeyByZXR1cm4gdGhpcy4kZWw7IH1cblx0XHRcblx0XHR0aGlzLiRlbCA9IHN1cGVyLnJlbmRlcihyZW5kZXJpbmdDb250ZXh0KTtcblxuXHRcdHRoaXMuJGxhYmVsID0gbmV3IEtvbnZhLlRleHQoeyBsaXN0ZW5pbmc6IGZhbHNlIH0pO1xuXHRcdHRoaXMuJGxhYmVsLmFkZE5hbWUoJ3RleHQnKTtcblxuXHRcdHRoaXMuJGVsLnB1c2godGhpcy4kbGFiZWwpO1xuXG5cdFx0cmV0dXJuIHRoaXMuJGVsO1xuXHR9XG5cblx0dXBkYXRlKHJlbmRlcmluZ0NvbnRleHQsIGRhdHVtKSB7XG5cdFx0dmFyIGQgPSBkYXR1bSB8fCB0aGlzLmRhdHVtO1xuXG5cdFx0c3VwZXIudXBkYXRlKHJlbmRlcmluZ0NvbnRleHQsIGQpO1xuXG5cdFx0Y29uc3QgeCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwodGhpcy54KGQpKTtcblx0XHRjb25zdCB5ID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwodGhpcy55KGQpKTtcblx0XHRjb25zdCB0ZXh0ID0gdGhpcy50ZXh0KGQpO1xuXG5cdFx0dGhpcy4kbGFiZWwueCh4ICsgMykueSh5KTtcblx0XHR0aGlzLiRsYWJlbC5oZWlnaHQoTWF0aC5taW4oeSwgcmVuZGVyaW5nQ29udGV4dC5oZWlnaHQgKyAxMCkpO1xuXHRcdHRoaXMuJGxhYmVsLmZpbGwoJyMyNDI0MjQnKTtcblx0XHR0aGlzLiRsYWJlbC5mb250U2l6ZSgxMCk7XG5cdFx0dGhpcy4kbGFiZWwuZm9udEZhbWlseSgnbW9ub3NwYWNlJyk7XG5cdFx0dGhpcy4kbGFiZWwudGV4dCh0ZXh0KTtcblx0fVxuXG59IiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IE1hcmtlciBmcm9tICcuL21hcmtlcic7XG5pbXBvcnQgS29udmEgZnJvbSAna29udmEnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbm5vdGF0ZWRNYXJrZXIgZXh0ZW5kcyBNYXJrZXIge1xuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4kbGFiZWwuZGVzdHJveSgpO1xuICAgIHRoaXMuJGxhYmVsID0gbnVsbDtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cblxuICBnZXRDbGFzc05hbWUoKSB7IHJldHVybiAnYW5ub3RhdGVkLXNlZ21lbnQnOyB9XG5cbiAgX2dldEFjY2Vzc29yTGlzdCgpIHtcbiAgICBsZXQgbGlzdCA9IHN1cGVyLl9nZXRBY2Nlc3Nvckxpc3QoKTtcbiAgICBsaXN0LnRleHQgPSAnZGVmYXVsdCc7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICByZW5kZXIocmVuZGVyaW5nQ29udGV4dCkge1xuICAgIGlmICh0aGlzLiRlbCkgeyByZXR1cm4gdGhpcy4kZWw7IH1cbiAgICBcbiAgICB0aGlzLiRlbCA9IHN1cGVyLnJlbmRlcihyZW5kZXJpbmdDb250ZXh0KTtcblxuICAgIHRoaXMuJGxhYmVsID0gbmV3IEtvbnZhLlRleHQoeyBsaXN0ZW5pbmc6IGZhbHNlIH0pO1xuICAgIHRoaXMuJGxhYmVsLmFkZE5hbWUoJ3RleHQnKTtcblxuICAgIHRoaXMuJGVsLnB1c2godGhpcy4kbGFiZWwpO1xuXG4gICAgcmV0dXJuIHRoaXMuJGVsO1xuICB9XG5cbiAgdXBkYXRlKHJlbmRlcmluZ0NvbnRleHQsIGRhdHVtKSB7XG4gICAgdmFyIGQgPSBkYXR1bSB8fCB0aGlzLmRhdHVtO1xuXG4gICAgc3VwZXIudXBkYXRlKHJlbmRlcmluZ0NvbnRleHQsIGQpO1xuXG4gICAgY29uc3Qgd2lkdGggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMud2lkdGgoZCkpO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGguYWJzKHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHRoaXMueShkKSArIHRoaXMuaGVpZ2h0KGQpKSAtIHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHRoaXMueShkKSkpO1xuICAgIGNvbnN0IHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMueChkKSk7XG4gICAgY29uc3QgeSA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHRoaXMueShkKSArIHRoaXMuaGVpZ2h0KGQpKTtcbiAgICBjb25zdCB0ZXh0ID0gdGhpcy50ZXh0KGQpO1xuXG4gICAgdGhpcy4kbGFiZWwueCh4ICsgMykueSh5ICsgMTEpO1xuICAgIHRoaXMuJGxhYmVsLmhlaWdodCh5KTtcbiAgICB0aGlzLiRsYWJlbC5maWxsKCcjMjQyNDI0Jyk7XG4gICAgdGhpcy4kbGFiZWwuZm9udFNpemUoMTApO1xuICAgIHRoaXMuJGxhYmVsLmZvbnRGYW1pbHkoJ21vbm9zcGFjZScpO1xuICAgIHRoaXMuJGxhYmVsLnRleHQodGV4dCk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBTZWdtZW50IGZyb20gJy4vc2VnbWVudCc7XG5pbXBvcnQgS29udmEgZnJvbSAna29udmEnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbm5vdGF0ZWRTZWdtZW50IGV4dGVuZHMgU2VnbWVudCB7XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiRsYWJlbC5kZXN0cm95KCk7XG4gICAgdGhpcy4kbGFiZWwgPSBudWxsO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuXG4gIGdldENsYXNzTmFtZSgpIHsgcmV0dXJuICdhbm5vdGF0ZWQtc2VnbWVudCc7IH1cblxuICBfZ2V0QWNjZXNzb3JMaXN0KCkge1xuICAgIGxldCBsaXN0ID0gc3VwZXIuX2dldEFjY2Vzc29yTGlzdCgpO1xuICAgIGxpc3QudGV4dCA9ICdkZWZhdWx0JztcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuXG4gIHJlbmRlcihyZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgaWYgKHRoaXMuJGVsKSB7IHJldHVybiB0aGlzLiRlbDsgfVxuICAgIFxuICAgIHRoaXMuJGVsID0gc3VwZXIucmVuZGVyKHJlbmRlcmluZ0NvbnRleHQpO1xuXG4gICAgdGhpcy4kbGFiZWwgPSBuZXcgS29udmEuVGV4dCh7IGxpc3RlbmluZzogZmFsc2UgfSk7XG4gICAgdGhpcy4kbGFiZWwuYWRkTmFtZSgndGV4dCcpO1xuXG4gICAgdGhpcy4kZWwucHVzaCh0aGlzLiRsYWJlbCk7XG5cbiAgICByZXR1cm4gdGhpcy4kZWw7XG4gIH1cblxuICB1cGRhdGUocmVuZGVyaW5nQ29udGV4dCwgZGF0dW0pIHtcbiAgICB2YXIgZCA9IGRhdHVtIHx8IHRoaXMuZGF0dW07XG5cbiAgICBzdXBlci51cGRhdGUocmVuZGVyaW5nQ29udGV4dCwgZCk7XG5cbiAgICBjb25zdCB3aWR0aCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwodGhpcy53aWR0aChkKSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5hYnMocmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwodGhpcy55KGQpICsgdGhpcy5oZWlnaHQoZCkpIC0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwodGhpcy55KGQpKSk7XG4gICAgY29uc3QgeCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwodGhpcy54KGQpKTtcbiAgICBjb25zdCB5ID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwodGhpcy55KGQpICsgdGhpcy5oZWlnaHQoZCkpO1xuICAgIGNvbnN0IHRleHQgPSB0aGlzLnRleHQoZCk7XG5cbiAgICB0aGlzLiRsYWJlbC54KHggKyAzKS55KHkgKyAxMSk7XG4gICAgdGhpcy4kbGFiZWwuaGVpZ2h0KHkpO1xuICAgIHRoaXMuJGxhYmVsLmZpbGwoJyMyNDI0MjQnKTtcbiAgICB0aGlzLiRsYWJlbC5mb250U2l6ZSgxMCk7XG4gICAgdGhpcy4kbGFiZWwuZm9udEZhbWlseSgnbW9ub3NwYWNlJyk7XG4gICAgdGhpcy4kbGFiZWwudGV4dCh0ZXh0KTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IFNlZ21lbnQgZnJvbSAnLi9zZWdtZW50JztcbmltcG9ydCBLb252YSBmcm9tICdrb252YSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VTaGFwZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG92ZXJyaWRlIGRlZmF1bHQgY29uZmlndXJhdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIFxuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIC8qKiBAdHlwZSB7RWxlbWVudH0gLSBLb252YS5Hcm91cCB0byBiZSByZXR1cm5lZCBieSB0aGUgYHJlbmRlcmAgbWV0aG9kLiAqL1xuICAgIHRoaXMuJGVsID0gbnVsbDtcbiAgICAvKiogQHR5cGUge09iamVjdH0gLSBPYmplY3QgY29udGFpbmluZyB0aGUgZ2xvYmFsIHBhcmFtZXRlcnMgb2YgdGhlIHNoYXBlICovXG4gICAgdGhpcy5wYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9nZXREZWZhdWx0cygpLCBvcHRpb25zKTtcblxuICAgIHRoaXMubGF5ZXIgPSBudWxsO1xuXG4gICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5faGlnaGxpZ2h0ID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0dW0gPSBudWxsO1xuXG4gICAgLy8gY3JlYXRlIGFjY2Vzc29ycyBtZXRob2RzIGFuZCBzZXQgZGVmYXVsdCBhY2Nlc3NvciBmdW5jdGlvbnNcbiAgICBjb25zdCBhY2Nlc3NvcnMgPSB0aGlzLl9nZXRBY2Nlc3Nvckxpc3QoKTtcbiAgICB0aGlzLl9jcmVhdGVBY2Nlc3NvcnMoYWNjZXNzb3JzKTtcbiAgICB0aGlzLl9zZXREZWZhdWx0QWNjZXNzb3JzKGFjY2Vzc29ycyk7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgc2hhcGUgYW5kIGNsZWFuIHJlZmVyZW5jZXMuIEludGVyZmFjZSBtZXRob2QgY2FsbGVkIGZyb20gdGhlIGBsYXllcmAuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLiRlbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy4kZWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy4kZWxbaV0uc2hhcGUgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy4kZWwubGVuZ3RoID0gMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuJGVsKSB7XG4gICAgICB0aGlzLiRlbC5zaGFwZSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuJGVsID0gbnVsbDtcbiAgICB0aGlzLiRwYXJhbXMgPSBudWxsO1xuICAgIHRoaXMuX2FjY2Vzc29ycyA9IG51bGw7XG4gICAgdGhpcy5fZGF0dW0gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVyZmFjZSBtZXRob2QgdG8gb3ZlcnJpZGUgd2hlbiBleHRlbmRpbmcgdGhpcyBiYXNlIGNsYXNzLiBUaGUgbWV0aG9kXG4gICAqIGlzIGNhbGxlZCBieSB0aGUgYExheWVyfnJlbmRlcmAgbWV0aG9kLiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBzaGFwZSxcbiAgICogdXNlZCBhcyBhIGNsYXNzIGluIHRoZSBlbGVtZW50IGdyb3VwIChkZWZhdWx0cyB0byBgJ3NoYXBlJ2ApLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXRDbGFzc05hbWUoKSB7IHJldHVybiAnc2hhcGUnOyB9XG5cbiAgLyoqXG4gICAqIEB0b2RvIG5vdCBpbXBsZW1lbnRlZFxuICAgKiBhbGxvdyB0byBpbnN0YWxsIGRlZnMgaW4gdGhlIHRyYWNrIHN2ZyBlbGVtZW50LiBTaG91bGQgYmUgY2FsbGVkIHdoZW5cbiAgICogYWRkaW5nIHRoZSBgTGF5ZXJgIHRvIHRoZSBgVHJhY2tgLlxuICAgKi9cbiAgLy8gc2V0U3ZnRGVmaW5pdGlvbihkZWZzKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0cyBmb3IgZ2xvYmFsIGNvbmZpZ3VyYXRpb24gb2YgdGhlIHNoYXBlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIF9nZXREZWZhdWx0cygpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3Qgd2hlcmUga2V5cyBhcmUgdGhlIGFjY2Vzc29ycyBtZXRob2RzIG5hbWVzIHRvIGNyZWF0ZVxuICAgKiBhbmQgdmFsdWVzIGFyZSB0aGUgZGVmYXVsdCB2YWx1ZXMgZm9yIGVhY2ggZ2l2ZW4gYWNjZXNzb3IuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHRvZG8gcmVuYW1lID9cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgX2dldEFjY2Vzc29yTGlzdCgpIHsgcmV0dXJuIHt9OyB9XG5cblxuICAvKipcbiAgICogSW50ZXJmYWNlIG1ldGhvZCBjYWxsZWQgYnkgTGF5ZXIgd2hlbiBjcmVhdGluZyBhIHNoYXBlLiBJbnN0YWxsIHRoZVxuICAgKiBnaXZlbiBhY2Nlc3NvcnMgb24gdGhlIHNoYXBlLCBvdmVycmlkaW5nIHRoZSBkZWZhdWx0IGFjY2Vzc29ycy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3Q8U3RyaW5nLCBmdW5jdGlvbj59IGFjY2Vzc29yc1xuICAgKi9cbiAgaW5zdGFsbChhY2Nlc3NvcnMpIHtcbiAgICBmb3IgKGxldCBrZXkgaW4gYWNjZXNzb3JzKSB7IHRoaXNba2V5XSA9IGFjY2Vzc29yc1trZXldOyB9XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJpYyBtZXRob2QgdG8gY3JlYXRlIGFjY2Vzc29ycy4gQWRkcyBnZXR0ZXJzIGVuIHNldHRlcnMgdG8gdGhlXG4gICAqIHByb3RvdHlwZSBpZiBub3QgYWxyZWFkeSBwcmVzZW50LlxuICAgKi9cbiAgX2NyZWF0ZUFjY2Vzc29ycyhhY2Nlc3NvcnMpIHtcbiAgICB0aGlzLl9hY2Nlc3NvcnMgPSB7fTtcbiAgICAvLyBhZGQgaXQgdG8gdGhlIHByb3RvdHlwZVxuICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpO1xuICAgIC8vIGNyZWF0ZSBhIGdldHRlciAvIHNldHRlciBmb3IgZWFjaCBhY2Nlc3NvcnNcbiAgICAvLyBzZXR0ZXIgOiBgdGhpcy54ID0gY2FsbGJhY2tgXG4gICAgLy8gZ2V0dGVyIDogYHRoaXMueChkYXR1bSlgXG4gICAgT2JqZWN0LmtleXMoYWNjZXNzb3JzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkobmFtZSkpIHsgcmV0dXJuOyB9XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgbmFtZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fYWNjZXNzb3JzW25hbWVdOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgICB0aGlzLl9hY2Nlc3NvcnNbbmFtZV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBmdW5jdGlvbiB0byBiZSB1c2VkIGFzIGEgZGVmYXVsdCBhY2Nlc3NvciBmb3IgZWFjaCBhY2Nlc29yc1xuICAgKi9cbiAgX3NldERlZmF1bHRBY2Nlc3NvcnMoYWNjZXNzb3JzKSB7XG4gICAgT2JqZWN0LmtleXMoYWNjZXNzb3JzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBhY2Nlc3NvcnNbbmFtZV07XG4gICAgICBsZXQgYWNjZXNzb3IgPSBmdW5jdGlvbihkLCB2KSB7XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHYgPSBudWxsO1xuICAgICAgICBpZiAodiA9PT0gbnVsbCkgeyByZXR1cm4gZFtuYW1lXSB8fCBkZWZhdWx0VmFsdWU7IH1cbiAgICAgICAgZFtuYW1lXSA9IHY7XG4gICAgICB9O1xuICAgICAgLy8gc2V0IGFjY2Vzc29yIGFzIHRoZSBkZWZhdWx0IG9uZVxuICAgICAgdGhpc1tuYW1lXSA9IGFjY2Vzc29yO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVyZmFjZSBtZXRob2QgY2FsbGVkIGJ5IGBMYXllcn5yZW5kZXJgLiBDcmVhdGVzIHRoZSBET00gc3RydWN0dXJlIG9mXG4gICAqIHRoZSBzaGFwZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlbmRlcmluZ0NvbnRleHQgLSB0aGUgcmVuZGVyaW5nQ29udGV4dCBvZiB0aGUgbGF5ZXJcbiAgICogICAgd2hpY2ggb3ducyB0aGlzIHNoYXBlLlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSAtIHRoZSBET00gZWxlbWVudCB0byBpbnNlcnQgaW4gdGhlIGl0ZW0ncyBncm91cC5cbiAgICovXG4gIHJlbmRlcihyZW5kZXJpbmdDb250ZXh0KSB7fVxuXG4gIC8qKlxuICAgKiBJbnRlcmZhY2UgbWV0aG9kIGNhbGxlZCBieSBgTGF5ZXJ+dXBkYXRlYC4gVXBkYXRlcyB0aGUgRE9NIHN0cnVjdHVyZSBvZiB0aGUgc2hhcGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZW5kZXJpbmdDb250ZXh0IC0gVGhlIGByZW5kZXJpbmdDb250ZXh0YCBvZiB0aGUgbGF5ZXJcbiAgICogICAgd2hpY2ggb3ducyB0aGlzIHNoYXBlLlxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gZGF0dW0gLSBUaGUgZGF0dW0gYXNzb2NpYXRlZCB0byB0aGUgc2hhcGUuXG4gICAqL1xuICB1cGRhdGUocmVuZGVyaW5nQ29udGV4dCwgZGF0dW0pIHt9XG5cbiAgLyoqXG4gICAqICBUT0RPXG4gICAqL1xuICBkcmF3KCkge1xuICAgIGlmICh0aGlzLiRlbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy4kZWwubGVuZ3RoOyBpKyspIFxuICAgICAgICB0aGlzLiRlbFtpXS5kcmF3KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGVsLmRyYXcoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJmYWNlIG1ldGhvZCB0byBvdmVycmlkZSBjYWxsZWQgYnkgYExheWVyfmdldEl0ZW1zSW5BcmVhYC4gRGVmaW5lcyBpZlxuICAgKiB0aGUgc2hhcGUgaXMgY29uc2lkZXJlZCB0byBiZSB0aGUgZ2l2ZW4gYXJlYS4gQXJndW1lbnRzIGFyZSBwYXNzZWQgaW4gcGl4ZWwgZG9tYWluLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVuZGVyaW5nQ29udGV4dCAtIHRoZSByZW5kZXJpbmdDb250ZXh0IG9mIHRoZSBsYXllciB3aGljaFxuICAgKiAgICBvd25zIHRoaXMgc2hhcGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBkYXR1bSAtIFRoZSBkYXR1bSBhc3NvY2lhdGVkIHRvIHRoZSBzaGFwZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgxIC0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGFyZWEgdG8gdGVzdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkxIC0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGFyZWEgdG8gdGVzdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgyIC0gVGhlIHggY29tcG9uZW50IG9mIHRoZSBib3R0b20tcmlnaHQgY29ybmVyIG9mIHRoZSBhcmVhIHRvIHRlc3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MiAtIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgYm90dG9tLXJpZ2h0IGNvcm5lciBvZiB0aGUgYXJlYSB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAtIFJldHVybnMgYHRydWVgIGlmIHRoZSBpcyBjb25zaWRlcmVkIHRvIGJlIGluIHRoZSBnaXZlbiBhcmVhLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICovXG4gIGluQXJlYShyZW5kZXJpbmdDb250ZXh0LCBkYXR1bSwgeDEsIHkxLCB4MiwgeTIpIHt9XG5cbiAgLypcbiAgICogVE9ET1xuICAgKi9cbiAgbWluaW1pemUoKSB7fVxuXG4gIG1heGltaXplKCkge31cblxuICAvKlxuICAgKiBUT0RPXG4gICAqL1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgfVxuXG4gIHNldCB2aXNpYmxlKGlzVmlzaWJsZSkge1xuICAgIHRoaXMuX3Zpc2libGUgPSBpc1Zpc2libGU7XG4gIH1cblxuICAvKlxuICAgKiBUT0RPXG4gICAqL1xuICBnZXQgZGF0dW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdHVtO1xuICB9XG5cbiAgc2V0IGRhdHVtKGRhdHVtKSB7XG4gICAgdGhpcy5fZGF0dW0gPSBkYXR1bTtcbiAgfVxuXG5cbiAgc3RhcnREcmFnKCkge1xuICAgIGlmICh0aGlzLiRlbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB0aGlzLiRlbC5mb3JFYWNoKChlbCkgPT4gZWwuc3RhcnREcmFnKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRlbC5zdGFydERyYWcoKTtcbiAgICB9XG4gIH1cblxuICBzdG9wRHJhZygpIHtcbiAgICBpZiAodGhpcy4kZWwgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgdGhpcy4kZWwuZm9yRWFjaCgoZWwpID0+IGVsLnN0b3BEcmFnKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRlbC5zdG9wRHJhZygpO1xuICAgIH1cbiAgfVxufSIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlU2hhcGUgZnJvbSAnLi9iYXNlLXNoYXBlJztcbmltcG9ydCBLb252YSBmcm9tICdrb252YSc7XG5cbi8qKlxuICogQSBzaGFwZSB0byBkaXNwbGF5IGEgY3Vyc29yLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXJzb3IgZXh0ZW5kcyBCYXNlU2hhcGUge1xuICBnZXRDbGFzc05hbWUoKSB7IHJldHVybiAnY3Vyc29yJzsgfVxuXG4gIF9nZXRBY2Nlc3Nvckxpc3QoKSB7XG4gICAgcmV0dXJuIHsgeDogMCB9O1xuICB9XG5cbiAgX2dldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogJyMwMDAwMDAnLFxuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHdpZHRoOiAyXG4gICAgfTtcbiAgfVxuXG4gIHJlbmRlcihyZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgaWYgKHRoaXMuJGVsKSB7IHJldHVybiB0aGlzLiRlbDsgfVxuXG4gICAgdGhpcy4kZWwgPSBuZXcgS29udmEuUmVjdCh7fSk7XG5cbiAgICByZXR1cm4gdGhpcy4kZWw7XG4gIH1cblxuICB1cGRhdGUocmVuZGVyaW5nQ29udGV4dCwgZGF0dW0pIHtcbiAgICAvLyBjb25zdCB4ID0gTWF0aC5yb3VuZChyZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMueChkYXR1bSkpKSArIDAuNTtcbiAgICBjb25zdCB4ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLngoZGF0dW0pKTtcblxuICAgIHRoaXMuJGVsLngoeClcbiAgICAgICAgICAgIC55KDApXG4gICAgICAgICAgICAud2lkdGgodGhpcy5wYXJhbXMud2lkdGgpXG4gICAgICAgICAgICAuaGVpZ2h0KHJlbmRlcmluZ0NvbnRleHQuaGVpZ2h0KVxuICAgICAgICAgICAgLmZpbGwodGhpcy5wYXJhbXMuY29sb3IpXG4gICAgICAgICAgICAub3BhY2l0eSh0aGlzLnBhcmFtcy5vcGFjaXR5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY3Vyc29yIGNhbm5vdCBiZSBzZWxlY3RlZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gZmFsc2VcbiAgICovXG4gIGluQXJlYSgpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgQmFzZVNoYXBlIGZyb20gJy4vYmFzZS1zaGFwZSc7XG5pbXBvcnQgS29udmEgZnJvbSAna29udmEnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvdCBleHRlbmRzIEJhc2VTaGFwZSB7XG5cblx0ZGVzdHJveSgpIHtcblx0XHR0aGlzLiRlbFswXS5kZXN0cm95KCk7XG5cdFx0c3VwZXIuZGVzdHJveSgpO1xuXHR9XG5cblx0Z2V0Q2xhc3NOYW1lKCkgeyByZXR1cm4gJ2RvdCc7IH1cblxuXHQvLyBAVE9ETyByZW5hbWUgOiBjb25mdXNpb24gYmV0d2VlbiBhY2Nlc3NvcnMgYW5kIG1ldGEtYWNjZXNzb3JzXG5cdF9nZXRBY2Nlc3Nvckxpc3QoKSB7XG5cdFx0cmV0dXJuIHsgeDogMCwgeTogMCB9O1xuXHR9XG5cblx0X2dldERlZmF1bHRzKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRjb2xvcjogJ2JsYWNrJywgXG5cdFx0XHRyOiAzXG5cdFx0fTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRpZiAodGhpcy4kZWwpIHsgcmV0dXJuIHRoaXMuJGVsOyB9XG5cblx0XHR0aGlzLiRlbCA9IFtuZXcgS29udmEuQ2lyY2xlKHt9KV07XG5cdFx0dGhpcy4kZWxbMF0uc2hhcGUgPSB0aGlzO1xuXHRcdHRoaXMuJGVsWzBdLnBlcmZlY3REcmF3RW5hYmxlZChmYWxzZSk7XG5cblx0XHRyZXR1cm4gdGhpcy4kZWw7XG5cdH1cblxuXHR1cGRhdGUocmVuZGVyaW5nQ29udGV4dCwgZGF0dW0pIHtcblx0XHRjb25zdCBkID0gZGF0dW0gfHwgdGhpcy5kYXR1bTtcblxuXHRcdGNvbnN0IHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMueChkKSk7XG5cdFx0Y29uc3QgeSA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHRoaXMueShkKSk7XG5cdFx0Ly8gY29uc3Qgclx0PSB0aGlzLnIoZCk7XG5cdFx0Ly8gY29uc3QgY29sb3IgPSB0aGlzLmNvbG9yKGQpO1xuXHRcdGNvbnN0IHIgPSB0aGlzLnIoZCk7XG5cdFx0Y29uc3QgY29sb3IgPSB0aGlzLnBhcmFtcy5jb2xvcjtcblx0XHRcblx0XHR0aGlzLiRlbFswXS54KHgpO1xuXHRcdHRoaXMuJGVsWzBdLnkoeSk7XG5cdFx0dGhpcy4kZWxbMF0ucmFkaXVzKHIpO1xuXHRcdHRoaXMuJGVsWzBdLmZpbGwoY29sb3IpO1xuXHR9XG5cblx0Ly8geDEsIHgyLCB5MSwgeTIgPT4gaW4gcGl4ZWwgZG9tYWluXG5cdGluQXJlYShyZW5kZXJpbmdDb250ZXh0LCBkYXR1bSwgeDEsIHkxLCB4MiwgeTIpIHtcblx0XHRjb25zdCB4ID0gdGhpcy4kZWxbMF0uZ2V0QWJzb2x1dGVQb3NpdGlvbigpLng7XG5cdFx0Y29uc3QgeSA9IHRoaXMuJGVsWzBdLmdldEFic29sdXRlUG9zaXRpb24oKS55O1xuXG5cdFx0aWYgKCh4ID49IHgxICYmIHggPD0geDIpICYmICh5ID49IHkxICYmIHkgPD0geTIpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlU2hhcGUgZnJvbSAnLi9iYXNlLXNoYXBlJztcbmltcG9ydCBLb252YSBmcm9tICdrb252YSc7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZSBleHRlbmRzIEJhc2VTaGFwZSB7XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiRlbC5kZXN0cm95KCk7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG5cbiAgZ2V0Q2xhc3NOYW1lKCkgeyByZXR1cm4gJ2xpbmUnOyB9XG5cbiAgX2dldEFjY2Vzc29yTGlzdCgpIHtcbiAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gIH1cblxuICBfZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHsgY29sb3I6ICcjMDAwMDAwJywgc3Ryb2tlV2lkdGg6IDEgfTtcbiAgfVxuXG4gIHJlbmRlcihyZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgaWYgKHRoaXMuJGVsKSB7IHJldHVybiB0aGlzLiRlbDsgfVxuXG4gICAgdGhpcy4kZWwgPSBuZXcgS29udmEuUGF0aCh7fSk7XG4gICAgdGhpcy4kZWwucGVyZmVjdERyYXdFbmFibGVkKGZhbHNlKTtcblxuICAgIHJldHVybiB0aGlzLiRlbDtcbiAgfVxuXG4gIHVwZGF0ZShyZW5kZXJpbmdDb250ZXh0LCBkYXRhKSB7XG5cbiAgICBkYXRhID0gZGF0YS5zbGljZSgwKTtcbiAgICBkYXRhLnNvcnQoKGEsIGIpID0+IHRoaXMueChhKSA8IHRoaXMueChiKSA/IC0xIDogMSk7XG5cbiAgICB0aGlzLiRlbC5kYXRhKHRoaXMuX2J1aWxkTGluZShyZW5kZXJpbmdDb250ZXh0LCBkYXRhKSk7XG4gICAgdGhpcy4kZWwuc3Ryb2tlKHRoaXMucGFyYW1zLmNvbG9yKTtcbiAgICB0aGlzLiRlbC5zdHJva2VXaWR0aCh0aGlzLnBhcmFtcy5zdHJva2VXaWR0aCk7XG5cbiAgICBkYXRhID0gbnVsbDtcbiAgfVxuXG4gIC8vIGJ1aWxkcyB0aGUgYHBhdGguZGAgYXR0cmlidXRlXG4gIC8vIEBUT0RPIGNyZWF0ZSBzb21lIFNoYXBlSGVscGVyID9cbiAgX2J1aWxkTGluZShyZW5kZXJpbmdDb250ZXh0LCBkYXRhKSB7XG4gICAgaWYgKCFkYXRhLmxlbmd0aCkgeyByZXR1cm4gJyc7IH1cbiAgICAvLyBzb3J0IGRhdGFcbiAgICBsZXQgaW5zdHJ1Y3Rpb25zID0gZGF0YS5tYXAoKGRhdHVtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgeCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwodGhpcy54KGRhdHVtKSk7XG4gICAgICBjb25zdCB5ID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwodGhpcy55KGRhdHVtKSkgLSAwLjU7XG4gICAgICByZXR1cm4gYCR7eH0sJHt5fWA7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gJ00nICsgaW5zdHJ1Y3Rpb25zLmpvaW4oJ0wnKTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEJhc2VTaGFwZSBmcm9tICcuL2Jhc2Utc2hhcGUnO1xuaW1wb3J0IEtvbnZhIGZyb20gJ2tvbnZhJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFya2VyIGV4dGVuZHMgQmFzZVNoYXBlIHtcblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuJGxpbmUuZGVzdHJveSgpO1xuICAgIHRoaXMuJGxpbmUgPSBudWxsO1xuICAgIHRoaXMuJGhhbmRsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuJGhhbmRsZXIgPSBudWxsO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuXG4gIGdldENsYXNzTmFtZSgpIHsgcmV0dXJuICdtYXJrZXInOyB9XG5cbiAgX2dldEFjY2Vzc29yTGlzdCgpIHtcbiAgICByZXR1cm4geyBcbiAgICAgIHg6IDAsIFxuICAgICAgaGFuZGxlcldpZHRoOiA3LFxuICAgICAgaGFuZGxlckhlaWdodDogMTAsXG4gICAgICBkaXNwbGF5SGFuZGxlcjogdHJ1ZSxcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICBzdHJva2VXaWR0aDogMiwgXG4gICAgICBjb2xvcjogJ2JsYWNrJyxcbiAgICAgIGhhbmRsZXJDb2xvcjogJ2JsYWNrJ1xuICAgIH07XG4gIH1cblxuICBfZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbmRsZXJXaWR0aDogdW5kZWZpbmVkLFxuICAgICAgaGFuZGxlckhlaWdodDogdW5kZWZpbmVkLFxuICAgICAgZGlzcGxheUhhbmRsZXI6IHVuZGVmaW5lZCxcbiAgICAgIG9wYWNpdHk6IHVuZGVmaW5lZCxcbiAgICAgIHN0cm9rZVdpZHRoOiB1bmRlZmluZWQsIFxuICAgICAgY29sb3I6IHVuZGVmaW5lZCxcbiAgICAgIGhhbmRsZXJDb2xvcjogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuXG4gIHJlbmRlcihyZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgaWYgKHRoaXMuJGVsKSB7IHJldHVybiB0aGlzLiRlbDsgfVxuXG4gICAgdGhpcy4kZWwgPSBbXTtcblxuICAgIHRoaXMuJGxpbmUgPSBuZXcgS29udmEuUmVjdCh7fSk7XG4gICAgdGhpcy4kbGluZS5hZGROYW1lKCdtYXJrZXInKTtcbiAgICB0aGlzLiRsaW5lLnNoYXBlID0gdGhpcztcblxuICAgIHRoaXMuJGhhbmRsZXIgPSBuZXcgS29udmEuUmVjdCh7fSk7XG4gICAgdGhpcy4kaGFuZGxlci5hZGROYW1lKCdoYW5kbGVyJyk7XG4gICAgdGhpcy4kaGFuZGxlci5zaGFwZSA9IHRoaXM7XG5cbiAgICB0aGlzLiRlbC5wdXNoKHRoaXMuJGxpbmUpO1xuICAgIHRoaXMuJGVsLnB1c2godGhpcy4kaGFuZGxlcik7XG5cbiAgICByZXR1cm4gdGhpcy4kZWw7XG4gIH1cblxuICB1cGRhdGUocmVuZGVyaW5nQ29udGV4dCwgZGF0dW0pIHtcbiAgICBjb25zdCBkID0gZGF0dW0gfHwgdGhpcy5kYXR1bTtcblxuICAgIGNvbnN0IGRpc3BsYXlIYW5kbGVyID0gdGhpcy5wYXJhbXMuZGlzcGxheUhhbmRsZXIgfHwgdGhpcy5kaXNwbGF5SGFuZGxlcihkKTtcblxuICAgIHRoaXMuJGxpbmUudmlzaWJsZSh0aGlzLnZpc2libGUpO1xuICAgIHRoaXMuJGhhbmRsZXIudmlzaWJsZSh0aGlzLnZpc2libGUgJiYgZGlzcGxheUhhbmRsZXIpO1xuXG4gICAgaWYgKCF0aGlzLnZpc2libGUpICByZXR1cm47XG5cbiAgICBjb25zdCB4ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLngoZCkpIC0gMC41O1xuICAgIGNvbnN0IGhlaWdodCA9IHJlbmRlcmluZ0NvbnRleHQuaGVpZ2h0O1xuICAgIGNvbnN0IGhhbmRsZXJXaWR0aCA9IHRoaXMucGFyYW1zLmhhbmRsZXJXaWR0aCB8fCB0aGlzLmhhbmRsZXJXaWR0aChkKTtcbiAgICBjb25zdCBoYW5kbGVySGVpZ2h0ID0gdGhpcy5wYXJhbXMuaGFuZGxlckhlaWdodCB8fCB0aGlzLmhhbmRsZXJIZWlnaHQoZCk7XG4gICAgY29uc3Qgb3BhY2l0eSA9IHRoaXMucGFyYW1zLm9wYWNpdHkgfHwgdGhpcy5vcGFjaXR5KGQpO1xuICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gdGhpcy5wYXJhbXMuc3Ryb2tlV2lkdGggfHwgdGhpcy5zdHJva2VXaWR0aChkKTtcbiAgICBjb25zdCBjb2xvciA9IHRoaXMucGFyYW1zLmNvbG9yIHx8IHRoaXMuY29sb3IoZCk7XG4gICAgY29uc3QgaGFuZGxlckNvbG9yID0gdGhpcy5wYXJhbXMuaGFuZGxlckNvbG9yIHx8IHRoaXMuaGFuZGxlckNvbG9yKGQpO1xuXG4gICAgdGhpcy4kbGluZVxuICAgICAgICAgICAgLngoeClcbiAgICAgICAgICAgIC55KDApXG4gICAgICAgICAgICAud2lkdGgoc3Ryb2tlV2lkdGgpXG4gICAgICAgICAgICAuaGVpZ2h0KGhlaWdodClcbiAgICAgICAgICAgIC5maWxsKGNvbG9yKVxuICAgICAgICAgICAgLm9wYWNpdHkob3BhY2l0eSk7XG5cbiAgICB0aGlzLiRoYW5kbGVyXG4gICAgICAgICAgICAueCh4KVxuICAgICAgICAgICAgLnkoMClcbiAgICAgICAgICAgIC53aWR0aChoYW5kbGVyV2lkdGgpXG4gICAgICAgICAgICAuaGVpZ2h0KGhhbmRsZXJIZWlnaHQpXG4gICAgICAgICAgICAuZmlsbChoYW5kbGVyQ29sb3IpXG4gICAgICAgICAgICAub3BhY2l0eShvcGFjaXR5KTtcbiAgfVxuXG4gIGluQXJlYShyZW5kZXJpbmdDb250ZXh0LCBkYXR1bSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICBjb25zdCBkID0gZGF0dW0gfHwgdGhpcy5kYXR1bTtcblxuICAgIC8vIGhhbmRsZXJzIG9ubHkgYXJlIHNlbGVjdGFibGVcbiAgICBjb25zdCB4ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLngoZCkpO1xuICAgIGNvbnN0IGhhbmRsZXJXaWR0aCA9IHRoaXMucGFyYW1zLmhhbmRsZXJXaWR0aCB8fCB0aGlzLmhhbmRsZXJXaWR0aChkKTtcbiAgICBjb25zdCBoYW5kbGVySGVpZ2h0ID0gdGhpcy5wYXJhbXMuaGFuZGxlckhlaWdodCB8fCB0aGlzLmhhbmRsZXJIZWlnaHQoZCk7XG4gICAgY29uc3Qgc2hhcGVYMSA9IHggLSAoaGFuZGxlcldpZHRoIC0gMSkgLyAyO1xuICAgIGNvbnN0IHNoYXBlWDIgPSBzaGFwZVgxICsgaGFuZGxlcldpZHRoO1xuICAgIGNvbnN0IHNoYXBlWTEgPSByZW5kZXJpbmdDb250ZXh0LmhlaWdodCAtIGhhbmRsZXJIZWlnaHQ7XG4gICAgY29uc3Qgc2hhcGVZMiA9IHJlbmRlcmluZ0NvbnRleHQuaGVpZ2h0O1xuXG4gICAgY29uc3QgeE92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih4Miwgc2hhcGVYMikgLSBNYXRoLm1heCh4MSwgc2hhcGVYMSkpO1xuICAgIGNvbnN0IHlPdmVybGFwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oeTIsIHNoYXBlWTIpIC0gTWF0aC5tYXgoeTEsIHNoYXBlWTEpKTtcbiAgICBjb25zdCBhcmVhID0geE92ZXJsYXAgKiB5T3ZlcmxhcDtcblxuICAgIHJldHVybiBhcmVhID4gMDtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEJhc2VTaGFwZSBmcm9tICcuL2Jhc2Utc2hhcGUnO1xuaW1wb3J0IEtvbnZhIGZyb20gJ2tvbnZhJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VnbWVudCBleHRlbmRzIEJhc2VTaGFwZSB7XG5cblx0ZGVzdHJveSgpIHtcblx0XHR0aGlzLiRzZWdtZW50LmRlc3Ryb3koKTtcblx0XHR0aGlzLiRzZWdtZW50ID0gbnVsbDtcblx0XHR0aGlzLiRsZWZ0SGFuZGxlci5kZXN0cm95KCk7XG5cdFx0dGhpcy4kbGVmdEhhbmRsZXIgPSBudWxsO1xuXHRcdHRoaXMuJHJpZ2h0SGFuZGxlci5kZXN0cm95KCk7XG5cdFx0dGhpcy4kcmlnaHRIYW5kbGVyID0gbnVsbDtcblx0XHR0aGlzLiR0b3BIYW5kbGVyLmRlc3Ryb3koKTtcblx0XHR0aGlzLiR0b3BIYW5kbGVyID0gbnVsbDtcblx0XHR0aGlzLiRib3R0b21IYW5kbGVyLmRlc3Ryb3koKTtcblx0XHR0aGlzLiRib3R0b21IYW5kbGVyID0gbnVsbDtcblx0XHRzdXBlci5kZXN0cm95KCk7XG5cdH1cblxuXHRnZXRDbGFzc05hbWUoKSB7IHJldHVybiAnc2VnbWVudCc7IH1cblxuXHRfZ2V0QWNjZXNzb3JMaXN0KCkge1xuXHRcdHJldHVybiB7IFxuXHRcdFx0eDogMCwgXG5cdFx0XHR5OiAwLCBcblx0XHRcdHdpZHRoOiAxLCBcblx0XHRcdGhlaWdodDogMSwgXG5cblx0XHRcdGRpc3BsYXlIYW5kbGVyczogdHJ1ZSxcblx0XHRcdGhhbmRsZXJXaWR0aDogMixcblx0XHRcdGhhbmRsZXJPcGFjaXR5OiAwLjgsXG5cdFx0XHRvcGFjaXR5OiAwLjYsIFxuXHRcdFx0aGFuZGxlckNvbG9yOiAnIzAwMDAwMCcsIFxuXHRcdFx0Y29sb3I6ICcjMDAwMDAwJyxcblx0XHR9O1xuXHR9XG5cblx0X2dldERlZmF1bHRzKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRkaXNwbGF5SGFuZGxlcnM6IHVuZGVmaW5lZCxcblx0XHRcdGhhbmRsZXJXaWR0aDogdW5kZWZpbmVkLFxuXHRcdFx0aGFuZGxlck9wYWNpdHk6IHVuZGVmaW5lZCxcblx0XHRcdG9wYWNpdHk6IHVuZGVmaW5lZCwgXG5cdFx0XHRoYW5kbGVyQ29sb3I6IHVuZGVmaW5lZCwgXG5cdFx0XHRjb2xvcjogdW5kZWZpbmVkLFxuXHRcdH07XG5cdH1cblxuXHRyZW5kZXIocmVuZGVyaW5nQ29udGV4dCkge1xuXHRcdGlmICh0aGlzLiRlbCkgeyByZXR1cm4gdGhpcy4kZWw7IH1cblxuXHRcdHRoaXMuJGVsID0gW107XG5cblx0XHR0aGlzLiRzZWdtZW50ID0gbmV3IEtvbnZhLlJlY3Qoe30pO1xuXHRcdHRoaXMuJHNlZ21lbnQubmFtZSgnc2VnbWVudCcpO1xuXHRcdHRoaXMuJHNlZ21lbnQuc2hhcGUgPSB0aGlzO1xuXG5cdFx0dGhpcy4kZWwucHVzaCh0aGlzLiRzZWdtZW50KTtcblxuXHRcdHRoaXMuJGxlZnRIYW5kbGVyID0gbmV3IEtvbnZhLlJlY3Qoe30pO1xuXHRcdHRoaXMuJGxlZnRIYW5kbGVyLmFkZE5hbWUoJ2xlZnQnKTtcblx0XHR0aGlzLiRsZWZ0SGFuZGxlci5hZGROYW1lKCdoYW5kbGVyJyk7XG5cdFx0dGhpcy4kbGVmdEhhbmRsZXIuc2hhcGUgPSB0aGlzO1xuXG5cdFx0dGhpcy4kcmlnaHRIYW5kbGVyID0gbmV3IEtvbnZhLlJlY3Qoe30pO1xuXHRcdHRoaXMuJHJpZ2h0SGFuZGxlci5hZGROYW1lKCdyaWdodCcpO1xuXHRcdHRoaXMuJHJpZ2h0SGFuZGxlci5hZGROYW1lKCdoYW5kbGVyJyk7XG5cdFx0dGhpcy4kcmlnaHRIYW5kbGVyLnNoYXBlID0gdGhpcztcblxuXHRcdHRoaXMuJHRvcEhhbmRsZXIgPSBuZXcgS29udmEuUmVjdCh7fSk7XG5cdFx0dGhpcy4kdG9wSGFuZGxlci5hZGROYW1lKCd0b3AnKTtcblx0XHR0aGlzLiR0b3BIYW5kbGVyLmFkZE5hbWUoJ2hhbmRsZXInKTtcblx0XHR0aGlzLiR0b3BIYW5kbGVyLnNoYXBlID0gdGhpcztcblxuXHRcdHRoaXMuJGJvdHRvbUhhbmRsZXIgPSBuZXcgS29udmEuUmVjdCh7fSk7XG5cdFx0dGhpcy4kYm90dG9tSGFuZGxlci5hZGROYW1lKCdib3R0b20nKTtcblx0XHR0aGlzLiRib3R0b21IYW5kbGVyLmFkZE5hbWUoJ2hhbmRsZXInKTtcblx0XHR0aGlzLiRib3R0b21IYW5kbGVyLnNoYXBlID0gdGhpcztcblxuXHRcdHRoaXMuJHNlZ21lbnQucGVyZmVjdERyYXdFbmFibGVkKGZhbHNlKTtcblx0XHR0aGlzLiRsZWZ0SGFuZGxlci5wZXJmZWN0RHJhd0VuYWJsZWQoZmFsc2UpO1xuXHRcdHRoaXMuJHJpZ2h0SGFuZGxlci5wZXJmZWN0RHJhd0VuYWJsZWQoZmFsc2UpO1xuXHRcdHRoaXMuJHRvcEhhbmRsZXIucGVyZmVjdERyYXdFbmFibGVkKGZhbHNlKTtcblx0XHR0aGlzLiRib3R0b21IYW5kbGVyLnBlcmZlY3REcmF3RW5hYmxlZChmYWxzZSk7XG5cblx0XHR0aGlzLiRlbC5wdXNoKHRoaXMuJGxlZnRIYW5kbGVyKTtcblx0XHR0aGlzLiRlbC5wdXNoKHRoaXMuJHJpZ2h0SGFuZGxlcik7XG5cdFx0dGhpcy4kZWwucHVzaCh0aGlzLiR0b3BIYW5kbGVyKTtcblx0XHR0aGlzLiRlbC5wdXNoKHRoaXMuJGJvdHRvbUhhbmRsZXIpO1xuXG5cdFx0cmV0dXJuIHRoaXMuJGVsO1xuXHR9XG5cblx0dXBkYXRlKHJlbmRlcmluZ0NvbnRleHQsIGRhdHVtKSB7XG5cdFx0Y29uc3QgZCA9IGRhdHVtIHx8IHRoaXMuZGF0dW07XG5cblx0XHR0aGlzLiRzZWdtZW50LnZpc2libGUodGhpcy52aXNpYmxlKTtcblx0XHR0aGlzLiRsZWZ0SGFuZGxlci52aXNpYmxlKHRoaXMudmlzaWJsZSAmJiB0aGlzLnBhcmFtcy5kaXNwbGF5SGFuZGxlcnMpO1xuXHRcdHRoaXMuJHJpZ2h0SGFuZGxlci52aXNpYmxlKHRoaXMudmlzaWJsZSAmJiB0aGlzLnBhcmFtcy5kaXNwbGF5SGFuZGxlcnMpO1xuXHRcdHRoaXMuJHRvcEhhbmRsZXIudmlzaWJsZSh0aGlzLnZpc2libGUgJiYgdGhpcy5wYXJhbXMudG9wSGFuZGxlcik7XG5cdFx0dGhpcy4kYm90dG9tSGFuZGxlci52aXNpYmxlKHRoaXMudmlzaWJsZSAmJiB0aGlzLnBhcmFtcy5ib3R0b21IYW5kbGVyKTtcblxuXHRcdGlmICghdGhpcy52aXNpYmxlKVx0cmV0dXJuO1xuXG5cdFx0Y29uc3Qgd2lkdGggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMud2lkdGgoZCkpO1xuXHRcdGNvbnN0IGhlaWdodCA9IE1hdGguYWJzKHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHRoaXMueShkKSArIHRoaXMuaGVpZ2h0KGQpKSAtIHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHRoaXMueShkKSkpO1xuXHRcdGNvbnN0IHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMueChkKSk7XG5cdFx0Y29uc3QgeSA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHRoaXMueShkKSArIHRoaXMuaGVpZ2h0KGQpKTtcblx0XHRjb25zdCBjb2xvciA9IHRoaXMucGFyYW1zLmNvbG9yIHx8IHRoaXMuY29sb3IoZCk7XG5cdFx0Y29uc3QgaGFuZGxlckNvbG9yID0gdGhpcy5wYXJhbXMuaGFuZGxlckNvbG9yIHx8IHRoaXMuaGFuZGxlckNvbG9yKGQpO1xuXHRcdGNvbnN0IG9wYWNpdHkgPSB0aGlzLnBhcmFtcy5vcGFjaXR5IHx8IHRoaXMub3BhY2l0eShkKTtcblx0XHRjb25zdCBoYW5kbGVyT3BhY2l0eSA9IHRoaXMucGFyYW1zLmhhbmRsZXJPcGFjaXR5IHx8IHRoaXMuaGFuZGxlck9wYWNpdHkoZCk7XG5cdFx0Y29uc3QgaGFuZGxlcldpZHRoID0gdGhpcy5wYXJhbXMuaGFuZGxlcldpZHRoIHx8IHRoaXMuaGFuZGxlcldpZHRoKGQpO1xuXG5cdFx0dGhpcy4kc2VnbWVudFxuXHRcdFx0XHQueCh4KVxuXHRcdFx0XHQueSh5KVxuXHRcdFx0XHQud2lkdGgoTWF0aC5tYXgod2lkdGgsIDApKVxuXHRcdFx0XHQuaGVpZ2h0KGhlaWdodClcblx0XHRcdFx0LmZpbGwoY29sb3IpXG5cdFx0XHRcdC5vcGFjaXR5KG9wYWNpdHkpO1xuXG5cdFx0dGhpcy4kbGVmdEhhbmRsZXJcblx0XHRcdFx0LngoeClcblx0XHRcdFx0LnkoeSlcblx0XHRcdFx0LndpZHRoKGhhbmRsZXJXaWR0aClcblx0XHRcdFx0LmhlaWdodChoZWlnaHQpXG5cdFx0XHRcdC5maWxsKGhhbmRsZXJDb2xvcilcblx0XHRcdFx0Lm9wYWNpdHkoaGFuZGxlck9wYWNpdHkpO1xuXHRcdFx0XHRcblx0XHR0aGlzLiRyaWdodEhhbmRsZXJcblx0XHRcdFx0LngoeCArIHdpZHRoIC0gaGFuZGxlcldpZHRoKVxuXHRcdFx0XHQueSh5KVxuXHRcdFx0XHQuaGVpZ2h0KGhlaWdodClcblx0XHRcdFx0LndpZHRoKGhhbmRsZXJXaWR0aClcblx0XHRcdFx0LmZpbGwoaGFuZGxlckNvbG9yKVxuXHRcdFx0XHQub3BhY2l0eShoYW5kbGVyT3BhY2l0eSk7XG5cblx0XHR0aGlzLiR0b3BIYW5kbGVyXG5cdFx0XHRcdC54KHgpXG5cdFx0XHRcdC55KHkpXG5cdFx0XHRcdC5oZWlnaHQoaGFuZGxlcldpZHRoKVxuXHRcdFx0XHQud2lkdGgod2lkdGgpXG5cdFx0XHRcdC5maWxsKGhhbmRsZXJDb2xvcilcblx0XHRcdFx0Lm9wYWNpdHkoaGFuZGxlck9wYWNpdHkpO1xuXG5cdFx0dGhpcy4kYm90dG9tSGFuZGxlclxuXHRcdFx0XHQueCh4KVxuXHRcdFx0XHQueSh5K2hlaWdodC1oYW5kbGVyV2lkdGgpXG5cdFx0XHRcdC5oZWlnaHQoaGFuZGxlcldpZHRoKVxuXHRcdFx0XHQud2lkdGgod2lkdGgpXG5cdFx0XHRcdC5maWxsKGhhbmRsZXJDb2xvcilcblx0XHRcdFx0Lm9wYWNpdHkoaGFuZGxlck9wYWNpdHkpO1xuXHR9XG5cblx0aW5BcmVhKHJlbmRlcmluZ0NvbnRleHQsIGRhdHVtLCB4MSwgeTEsIHgyLCB5Mikge1xuXHRcdGNvbnN0IGQgPSBkYXR1bSB8fCB0aGlzLmRhdHVtO1xuXG5cdFx0Y29uc3Qgc2hhcGVYMSA9IHRoaXMuJHNlZ21lbnQuZ2V0QWJzb2x1dGVQb3NpdGlvbigpLng7XG5cdFx0Y29uc3Qgc2hhcGVZMSA9IHRoaXMuJHNlZ21lbnQuZ2V0QWJzb2x1dGVQb3NpdGlvbigpLnk7XG5cdFx0Y29uc3Qgc2hhcGVYMiA9IHNoYXBlWDEgKyB0aGlzLiRzZWdtZW50LndpZHRoKCk7XG5cdFx0Y29uc3Qgc2hhcGVZMiA9IHNoYXBlWTEgKyB0aGlzLiRzZWdtZW50LmhlaWdodCgpO1xuXG5cdFx0Lypcblx0XHQgKlx0VGhlIHNlZ21lbnQgaXMgZW50aXJlbHkgd2l0aGluIHRoZSBwcm92aWRlZCBhcmVhLlxuXHRcdCAqL1xuXHRcdC8vIGlmICh4MSA8PSBzaGFwZVgxICYmIHgyID49IHNoYXBlWDIgJiYgeTEgPD0gc2hhcGVZMSAmJiB5MiA+PSBzaGFwZVkyKVxuXHRcdC8vIFx0cmV0dXJuIHRydWU7XG5cdFx0Ly8gZWxzZVxuXHRcdC8vIFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0Lypcblx0XHQgKlx0VGhlIHNlZ21lbnQgb3ZlcmxhcHMgdGhlIHByb3ZpZGVkIGFyZWEuXG5cdFx0ICovXG5cdFx0Y29uc3QgeE92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih4Miwgc2hhcGVYMikgLSBNYXRoLm1heCh4MSwgc2hhcGVYMSkpO1xuXHRcdGNvbnN0IHlPdmVybGFwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oeTIsIHNoYXBlWTIpIC0gTWF0aC5tYXgoeTEsIHNoYXBlWTEpKTtcblx0XHRjb25zdCBhcmVhID0geE92ZXJsYXAgKiB5T3ZlcmxhcDtcblxuXHRcdHJldHVybiBhcmVhID4gMDtcblx0fVxuXG59IiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEJhc2VTaGFwZSBmcm9tICcuL2Jhc2Utc2hhcGUnO1xuaW1wb3J0IEtvbnZhIGZyb20gJ2tvbnZhJztcblxuLyoqXG4gKiBLaW5kIG9mIE1hcmtlciBmb3IgZW50aXR5IG9yaWVudGVkIGRhdGEuIFVzZWZ1bCB0byBkaXNwbGF5IGEgZ3JpZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlja3MgZXh0ZW5kcyBCYXNlU2hhcGUge1xuXHRfZ2V0Q2xhc3NOYW1lKCkge1xuXHRcdHJldHVybiAndGljayc7XG5cdH1cblxuXHRfZ2V0QWNjZXNzb3JMaXN0KCkge1xuXHRcdHJldHVybiB7IHRpbWU6IDAsIGxhYmVsOiAnJywgZm9jdXNlZDogZmFsc2UgfTtcblx0fVxuXG5cdF9nZXREZWZhdWx0cygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGVmYXVsdDoge1xuXHRcdFx0XHRjb2xvcjogJ3N0ZWVsYmx1ZScsXG5cdFx0XHRcdG9wYWNpdHk6IDAuMyxcblx0XHRcdFx0d2lkdGg6IDEsXG5cdFx0XHR9LFxuXHRcdFx0Zm9jdXNlZDoge1xuXHRcdFx0XHRjb2xvcjogJ2JsYWNrJyxcblx0XHRcdFx0b3BhY2l0eTogMC44LFxuXHRcdFx0XHR3aWR0aDogMixcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0cmVuZGVyKHJlbmRlcmluZ0NvbnRleHQpIHtcblx0XHR0aGlzLiRlbCA9IG5ldyBTZXQoKTtcblxuXHRcdHRoaXMuJHRpY2tzID0gbmV3IEtvbnZhLlNoYXBlKHsgbGlzdGVuaW5nOiBmYWxzZSB9KTtcblx0XHR0aGlzLiR0aWNrcy5hZGROYW1lKCd0aWNrcycpO1xuXHRcdHRoaXMuJHRpY2tzLnBlcmZlY3REcmF3RW5hYmxlZChmYWxzZSk7XG5cblx0XHR0aGlzLiRlbC5hZGQodGhpcy4kdGlja3MpO1xuXHRcdFxuXHRcdHJldHVybiB0aGlzLiRlbDtcblx0fVxuXG5cdHVwZGF0ZShyZW5kZXJpbmdDb250ZXh0LCBkYXRhKSB7XG5cblx0XHRjb25zdCB0aGF0ID0gdGhpcztcblx0XHQvKlxuXHRcdCAqIE1haW50YWluIHRoZSBzYW1lIG51bWJlciBvZiB0aWNrcyBhbmQgbGFiZWxzIGluIHRoZSBTaGFwZSBtZW1vcnkgYXMgdGhlIG51bWJlciBvZiBkYXR1bXMuXG5cdFx0ICogRGVzdHJveSB0aGUgcmVtYWluaW5nIGtvbnZhIG5vZGVzLlxuXHRcdCAqL1xuXHRcdHRoaXMuJHRpY2tzLnNjZW5lRnVuYyhmdW5jdGlvbihjb250ZXh0KSB7XG5cdFx0XHRjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG5cdFx0XHRkYXRhLmZvckVhY2goZnVuY3Rpb24oZGF0dW0pIHtcblxuXHRcdFx0XHRjb25zdCB4ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbCh0aGF0LnRpbWUoZGF0dW0pKTtcblx0XHRcdFx0Y29uc3QgaGVpZ2h0ID0gcmVuZGVyaW5nQ29udGV4dC5oZWlnaHQ7XG5cdFx0XHRcdGNvbnN0IGlzRm9jdXNlZCA9IHRoYXQuZm9jdXNlZChkYXR1bSk7XG5cdFx0XHRcdGNvbnN0IGxhYmVsID0gdGhhdC5sYWJlbChkYXR1bSk7XG5cdFx0XHRcdGNvbnN0IHdpZHRoID0gKGlzRm9jdXNlZCk/IHRoYXQucGFyYW1zLmZvY3VzZWQud2lkdGggOiB0aGF0LnBhcmFtcy5kZWZhdWx0LndpZHRoO1xuXHRcdFx0XHRjb25zdCBjb2xvciA9IChpc0ZvY3VzZWQpPyB0aGF0LnBhcmFtcy5mb2N1c2VkLmNvbG9yIDogdGhhdC5wYXJhbXMuZGVmYXVsdC5jb2xvcjtcblxuXHRcdFx0XHRjb250ZXh0Lm1vdmVUbyh4LCAwKTtcblx0XHRcdFx0Y29udGV4dC5maWxsU3R5bGUgPSBjb2xvcjtcblx0XHRcdFx0Y29udGV4dC5maWxsUmVjdCh4LCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuXHRcdFx0XHQvLyBUT0RPOiB0ZXh0XG5cdFx0XHRcdGlmIChsYWJlbCAhPT0gdW5kZWZpbmVkICYmIGxhYmVsICE9PSAnJykge1xuXHRcdFx0XHRcdGNvbnRleHQuZ2xvYmFsQWxwaGEgPSAwLjk7XG5cdFx0XHRcdFx0Y29udGV4dC5mb250ID0gJzEwcHggbW9ub3NwYWNlJztcblx0XHRcdFx0XHRjb250ZXh0LmZpbGxTdHlsZSA9ICcjNjc2NzY3Jztcblx0XHRcdFx0XHRjb250ZXh0LmZpbGxUZXh0KGxhYmVsLCB4ICsgNSwgMTApO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0pO1xuXG5cdFx0XHRjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG5cdFx0XHRjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcblx0XHR9KTtcblxuXHR9XG59IiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEJhc2VTaGFwZSBmcm9tICcuL2Jhc2Utc2hhcGUnO1xuaW1wb3J0IEtvbnZhIGZyb20gJ2tvbnZhJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhY2VEb3RzIGV4dGVuZHMgQmFzZVNoYXBlIHtcbiAgZ2V0Q2xhc3NOYW1lKCkgeyByZXR1cm4gJ3RyYWNlLWRvdHMnOyB9XG5cbiAgX2dldEFjY2Vzc29yTGlzdCgpIHtcbiAgICByZXR1cm4geyB4OiAwLCBtZWFuOiAwLCByYW5nZTogMCB9O1xuICB9XG5cbiAgX2dldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtZWFuUmFkaXVzOiAzLFxuICAgICAgcmFuZ2VSYWRpdXM6IDMsXG4gICAgICBtZWFuQ29sb3I6ICcjMjMyMzIzJyxcbiAgICAgIHJhbmdlQ29sb3I6ICdzdGVlbGJsdWUnXG4gICAgfTtcbiAgfVxuXG4gIHJlbmRlcihyZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgaWYgKHRoaXMuJGVsKSB7IHJldHVybiB0aGlzLiRlbDsgfVxuICAgIC8vIGNvbnRhaW5lclxuICAgIHRoaXMuJGVsID0gW107XG4gICAgLy8gZHJhdyBtZWFuIGRvdFxuICAgIHRoaXMuJG1lYW4gPSBuZXcgS29udmEuQ2lyY2xlKHt9KTtcbiAgICB0aGlzLiRtZWFuLnNoYXBlID0gdGhpcztcblxuICAgIC8vIHJhbmdlIGRvdHMgKDAgPT4gdG9wLCAxID0+IGJvdHRvbSlcbiAgICB0aGlzLiRtYXggPSBuZXcgS29udmEuQ2lyY2xlKHt9KTtcbiAgICB0aGlzLiRtYXguc2hhcGUgPSB0aGlzO1xuXG4gICAgdGhpcy4kbWluID0gbmV3IEtvbnZhLkNpcmNsZSh7fSk7XG4gICAgdGhpcy4kbWluLnNoYXBlID0gdGhpcztcblxuICAgIHRoaXMuJGVsLnB1c2godGhpcy4kbWVhbik7XG4gICAgdGhpcy4kZWwucHVzaCh0aGlzLiRtYXgpO1xuICAgIHRoaXMuJGVsLnB1c2godGhpcy4kbWluKTtcblxuICAgIHJldHVybiB0aGlzLiRlbDtcbiAgfVxuXG4gIC8vIEBUT0RPIHVzZSBhY2Nlc3NvcnNcbiAgdXBkYXRlKHJlbmRlcmluZ0NvbnRleHQsIGRhdHVtKSB7XG4gICAgY29uc3QgbWVhbiA9IHRoaXMubWVhbihkYXR1bSk7XG4gICAgY29uc3QgcmFuZ2UgPSB0aGlzLnJhbmdlKGRhdHVtKTtcbiAgICBjb25zdCB4ID0gdGhpcy54KGRhdHVtKTtcbiAgICBjb25zdCBtZWFuUG9zID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwobWVhbik7XG4gICAgY29uc3QgaGFsZlJhbmdlID0gcmFuZ2UgLyAyO1xuICAgIGNvbnN0IG1heCA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKG1lYW4gKyBoYWxmUmFuZ2UpO1xuICAgIGNvbnN0IG1pbiA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKG1lYW4gLSBoYWxmUmFuZ2UpO1xuICAgIGNvbnN0IHhQb3MgPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHgpO1xuICAgIFxuXG4gICAgdGhpcy4kbWVhbi54KHhQb3MpXG4gICAgICAgICAgICAgIC55KG1lYW5Qb3MpXG4gICAgICAgICAgICAgIC5yYWRpdXModGhpcy5wYXJhbXMubWVhblJhZGl1cylcbiAgICAgICAgICAgICAgLnN0cm9rZSh0aGlzLnBhcmFtcy5yYW5nZUNvbG9yKVxuICAgICAgICAgICAgICAuZmlsbCgndHJhbnNwYXJlbnQnKVxuICAgICAgICAgICAgICAuYWRkTmFtZSgnbWVhbicpO1xuXG4gICAgdGhpcy4kbWF4LngoeFBvcylcbiAgICAgICAgICAgICAgLnkobWF4KVxuICAgICAgICAgICAgICAucmFkaXVzKHRoaXMucGFyYW1zLm1lYW5SYWRpdXMpXG4gICAgICAgICAgICAgIC5zdHJva2UodGhpcy5wYXJhbXMucmFuZ2VDb2xvcilcbiAgICAgICAgICAgICAgLmZpbGwoJ3RyYW5zcGFyZW50JylcbiAgICAgICAgICAgICAgLmFkZE5hbWUoJ21heCcpO1xuXG4gICAgXG4gICAgdGhpcy4kbWluLngoeFBvcylcbiAgICAgICAgICAgICAgLnkobWluKVxuICAgICAgICAgICAgICAucmFkaXVzKHRoaXMucGFyYW1zLm1lYW5SYWRpdXMpXG4gICAgICAgICAgICAgIC5zdHJva2UodGhpcy5wYXJhbXMucmFuZ2VDb2xvcilcbiAgICAgICAgICAgICAgLmZpbGwoJ3RyYW5zcGFyZW50JylcbiAgICAgICAgICAgICAgLmFkZE5hbWUoJ21pbicpO1xuICB9XG5cbiAgaW5BcmVhKHJlbmRlcmluZ0NvbnRleHQsIGRhdHVtLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIGNvbnN0IHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMueChkYXR1bSkpO1xuICAgIGNvbnN0IG1lYW4gPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbCh0aGlzLm1lYW4oZGF0dW0pKTtcbiAgICBjb25zdCByYW5nZSA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHRoaXMucmFuZ2UoZGF0dW0pKTtcbiAgICBjb25zdCBtaW4gPSBtZWFuIC0gKHJhbmdlIC8gMik7XG4gICAgY29uc3QgbWF4ID0gbWVhbiArIChyYW5nZSAvIDIpO1xuXG4gICAgaWYgKHggPiB4MSAmJiB4IDwgeDIgJiYgKG1pbiA+IHkxIHx8IG1heCA8IHkyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgQmFzZVNoYXBlIGZyb20gJy4vYmFzZS1zaGFwZSc7XG5pbXBvcnQgS29udmEgZnJvbSAna29udmEnO1xuXG4vKipcbiAqIEEgc2hhcGUgdG8gZGlzcGxheSBwYXRocyBpbiBhIHRyYWNlIHZpc3VhbGl6YXRpb24gKG1lYW4gLyByYW5nZSkuIChlbnRpdHkgc2hhcGUpXG4gKlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFjZVBhdGggZXh0ZW5kcyBCYXNlU2hhcGUge1xuICBnZXRDbGFzc05hbWUoKSB7IHJldHVybiAndHJhY2UtY29tbW9uJzsgfVxuXG4gIF9nZXRBY2Nlc3Nvckxpc3QoKSB7XG4gICAgcmV0dXJuIHsgeDogMCwgbWVhbjogMCwgcmFuZ2U6IDAgfTtcbiAgfVxuXG4gIF9nZXREZWZhdWx0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmFuZ2VDb2xvcjogJ3N0ZWVsYmx1ZScsXG4gICAgICBtZWFuQ29sb3I6ICcjMjMyMzIzJyxcbiAgICAgIGRpc3BsYXlNZWFuOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIHJlbmRlcihyZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgaWYgKHRoaXMuJGVsKSB7IHJldHVybiB0aGlzLiRlbDsgfVxuXG4gICAgdGhpcy4kZWwgPSBbXTtcblxuICAgIHRoaXMuJHJhbmdlID0gbmV3IEtvbnZhLlBhdGgoe30pO1xuICAgIHRoaXMuJHJhbmdlLnNoYXBlID0gdGhpcztcblxuICAgIHRoaXMuJG1lYW4gPSBuZXcgS29udmEuUGF0aCh7fSk7XG4gICAgdGhpcy4kbWVhbi5zaGFwZSA9IHRoaXM7XG5cbiAgICB0aGlzLiRlbC5wdXNoKHRoaXMuJHJhbmdlKTtcbiAgICB0aGlzLiRlbC5wdXNoKHRoaXMuJG1lYW4pO1xuXG4gICAgcmV0dXJuIHRoaXMuJGVsO1xuICB9XG5cbiAgdXBkYXRlKHJlbmRlcmluZ0NvbnRleHQsIGRhdGEpIHtcbiAgICAvLyBvcmRlciBkYXRhIGJ5IHggcG9zaXRpb25cbiAgICBkYXRhID0gZGF0YS5zbGljZSgwKTtcbiAgICBkYXRhLnNvcnQoKGEsIGIpID0+IHRoaXMueChhKSA8IHRoaXMueChiKSA/IC0xIDogMSk7XG5cbiAgICBpZiAodGhpcy5wYXJhbXMuZGlzcGxheU1lYW4pIHtcbiAgICAgIHRoaXMuJG1lYW4udmlzaWJsZSh0cnVlKVxuICAgICAgICAgICAgICAgIC5kYXRhKHRoaXMuX2J1aWxkTWVhbkxpbmUocmVuZGVyaW5nQ29udGV4dCwgZGF0YSkpXG4gICAgICAgICAgICAgICAgLnN0cm9rZSh0aGlzLnBhcmFtcy5tZWFuQ29sb3IpXG4gICAgICAgICAgICAgICAgLmZpbGwoJ25vbmUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kbWVhbi52aXNpYmxlKGZhbHNlKTtcbiAgICB9XG5cbiAgICB0aGlzLiRyYW5nZS52aXNpYmxlKHRydWUpXG4gICAgICAgICAgICAgIC5kYXRhKHRoaXMuX2J1aWxkUmFuZ2Vab25lKHJlbmRlcmluZ0NvbnRleHQsIGRhdGEpKVxuICAgICAgICAgICAgICAuc3Ryb2tlKCdub25lJylcbiAgICAgICAgICAgICAgLmZpbGwodGhpcy5wYXJhbXMucmFuZ2VDb2xvcilcbiAgICAgICAgICAgICAgLm9wYWNpdHkoMC40KTtcblxuICAgIGRhdGEgPSBudWxsO1xuICB9XG5cbiAgX2J1aWxkTWVhbkxpbmUocmVuZGVyaW5nQ29udGV4dCwgZGF0YSkge1xuICAgIGxldCBpbnN0cnVjdGlvbnMgPSBkYXRhLm1hcCgoZGF0dW0sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB4ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLngoZGF0dW0pKTtcbiAgICAgIGNvbnN0IHkgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbCh0aGlzLm1lYW4oZGF0dW0pKTtcbiAgICAgIHJldHVybiBgJHt4fSwke3l9YDtcbiAgICB9KTtcblxuICAgIHJldHVybiAnTScgKyBpbnN0cnVjdGlvbnMuam9pbignTCcpO1xuICB9XG5cbiAgX2J1aWxkUmFuZ2Vab25lKHJlbmRlcmluZ0NvbnRleHQsIGRhdGEpIHtcbiAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAvLyBjb25zdCBsYXN0SW5kZXggPSBkYXRhXG4gICAgbGV0IGluc3RydWN0aW9uc1N0YXJ0ID0gJyc7XG4gICAgbGV0IGluc3RydWN0aW9uc0VuZCA9ICcnO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGF0dW0gPSBkYXRhW2ldO1xuICAgICAgY29uc3QgbWVhbiA9IHRoaXMubWVhbihkYXR1bSk7XG4gICAgICBjb25zdCBoYWxmUmFuZ2UgPSB0aGlzLnJhbmdlKGRhdHVtKSAvIDI7XG5cbiAgICAgIGNvbnN0IHggID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLngoZGF0dW0pKTtcbiAgICAgIGNvbnN0IHkwID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwobWVhbiArIGhhbGZSYW5nZSk7XG4gICAgICBjb25zdCB5MSA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKG1lYW4gLSBoYWxmUmFuZ2UpO1xuXG4gICAgICBjb25zdCBzdGFydCA9IGAke3h9LCR7eTB9YDtcbiAgICAgIGNvbnN0IGVuZCAgID0gYCR7eH0sJHt5MX1gO1xuXG4gICAgICBpbnN0cnVjdGlvbnNTdGFydCA9IGluc3RydWN0aW9uc1N0YXJ0ID09PSAnJyA/XG4gICAgICAgIHN0YXJ0IDogYCR7aW5zdHJ1Y3Rpb25zU3RhcnR9TCR7c3RhcnR9YDtcblxuICAgICAgaW5zdHJ1Y3Rpb25zRW5kID0gaW5zdHJ1Y3Rpb25zRW5kID09PSAnJyA/XG4gICAgICAgIGVuZCA6IGAke2VuZH1MJHtpbnN0cnVjdGlvbnNFbmR9YDtcbiAgICB9XG5cbiAgICBsZXQgaW5zdHJ1Y3Rpb25zID0gYE0ke2luc3RydWN0aW9uc1N0YXJ0fUwke2luc3RydWN0aW9uc0VuZH1aYDtcbiAgICByZXR1cm4gaW5zdHJ1Y3Rpb25zO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgQmFzZVNoYXBlIGZyb20gJy4vYmFzZS1zaGFwZSc7XG5pbXBvcnQgc2NhbGVzIGZyb20gJy4uL3V0aWxzL3NjYWxlcyc7XG5pbXBvcnQgS29udmEgZnJvbSAna29udmEnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXYXZlZm9ybSBleHRlbmRzIEJhc2VTaGFwZSB7XG5cblx0ZGVzdHJveSgpIHtcblx0XHR0aGlzLiRsYWJlbC5kZXN0cm95KCk7XG5cdFx0dGhpcy4kbGFiZWwgPSBudWxsO1xuXG5cdFx0dGhpcy4kaGVhZGVyLmRlc3Ryb3koKTtcblx0XHR0aGlzLiRoZWFkZXIgPSBudWxsO1xuXG5cdFx0dGhpcy4kYm9keS5kZXN0cm95KCk7XG5cdFx0dGhpcy4kYm9keSA9IG51bGw7XG5cblx0XHR0aGlzLiRsZWZ0SGFuZGxlci5kZXN0cm95KCk7XG5cdFx0dGhpcy4kbGVmdEhhbmRsZXIgPSBudWxsO1xuXG5cdFx0dGhpcy4kcmlnaHRIYW5kbGVyLmRlc3Ryb3koKTtcblx0XHR0aGlzLiRyaWdodEhhbmRsZXIgPSBudWxsO1xuXG5cdFx0dGhpcy4kd2F2ZWZvcm0uZGVzdHJveSgpO1xuXHRcdHRoaXMuJHdhdmVmb3JtID0gbnVsbDtcblxuXHRcdHN1cGVyLmRlc3Ryb3koKTtcblx0fVxuXG5cdGdldENsYXNzTmFtZSgpIHsgcmV0dXJuICd3YXZlZm9ybSc7IH1cblxuXHRfZ2V0QWNjZXNzb3JMaXN0KCkge1xuXHRcdC8vIHJldHVybiB7IHk6IDAgfTtcblx0XHQvLyBUT0RPOiBkZWxldGUgYWxsIGJ1dCBzYW1wbGVSYXRlLlxuXHRcdHJldHVybiB7IFxuXHRcdFx0ZGF0YTogW10sIFxuXHRcdFx0eDogMCwgXG5cdFx0XHR3aWR0aDogMTAwMDAsIFxuXHRcdFx0YnVmZmVyU3RhcnQ6IDAsIFxuXHRcdFx0YnVmZmVyRW5kOiAwLCBcblx0XHRcdHNhbXBsZVJhdGU6IDQ0MTAwLCBcblx0XHRcdGNvbG9yOiAnYmxhY2snLCBcblx0XHRcdHRleHQ6IFwiXCIgXG5cdFx0fTtcblx0fVxuXG5cdF9nZXREZWZhdWx0cygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0d2F2ZWZvcm1RdWFsaXR5OiAyMDAwLCBcblx0XHRcdHNxdWFyaW5nRmFjdG9yOiAxLCBcblx0XHRcdGRpc3BsYXlIYW5kbGVyczogdHJ1ZSwgXG5cdFx0XHRkaXNwbGF5Qm9keTogdHJ1ZSwgXG5cdFx0XHRkaXNwbGF5TGFiZWw6IHRydWUsIFxuXHRcdFx0ZGlzcGxheUhlYWRlcjogdHJ1ZSwgXG5cdFx0XHRoZWFkZXJIZWlnaHRSYXRpbzogMC4xLCAvLyAxMCUgb2YgdGhlIGJvZHkgaGVpZ2h0XG5cdFx0XHR3YXZlZm9ybToge1xuXHRcdFx0XHRjb2xvcjogJyMwMDAwMDAnLFxuXHRcdFx0XHRvcGFjaXR5OiAxLCBcblx0XHRcdH0sXG5cdFx0XHRoZWFkZXI6IHtcblx0XHRcdFx0Y29sb3I6ICdncmVlbicsXG5cdFx0XHRcdG9wYWNpdHk6IDAuNCwgXG5cdFx0XHR9LFxuXHRcdFx0Ym9keToge1xuXHRcdFx0XHRjb2xvcjogJ3llbGxvdycsXG5cdFx0XHRcdG9wYWNpdHk6IDAuMSwgXG5cdFx0XHR9LFxuXHRcdFx0aGFuZGxlcjoge1xuXHRcdFx0XHR3aWR0aDogMiwgXG5cdFx0XHRcdG9wYWNpdHk6IDEsXG5cdFx0XHRcdGNvbG9yOiAnb3JhbmdlJ1xuXHRcdFx0fSxcblx0XHR9O1xuXHR9XG5cblx0cmVuZGVyKHJlbmRlcmluZ0NvbnRleHQpIHtcblx0XHRpZiAodGhpcy4kZWwpIHsgcmV0dXJuIHRoaXMuJGVsOyB9XG5cblx0XHR0aGlzLiRlbCA9IFtdO1xuXG5cdFx0dGhpcy4kaGVhZGVyID0gbmV3IEtvbnZhLlJlY3Qoe30pO1xuXHRcdHRoaXMuJGhlYWRlci5hZGROYW1lKCdoZWFkZXInKTtcblx0XHR0aGlzLiRoZWFkZXIuc2hhcGUgPSB0aGlzO1xuXHRcdC8vIHRoaXMuJGhlYWRlci5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oKSB7IGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInOyB9KTtcblx0XHQvLyB0aGlzLiRoZWFkZXIub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oKSB7IGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnOyB9KTtcdFx0XG5cblx0XHR0aGlzLiRib2R5XHQgPSBuZXcgS29udmEuUmVjdCh7fSk7XG5cdFx0dGhpcy4kYm9keS5hZGROYW1lKCdib2R5Jyk7XG5cdFx0dGhpcy4kYm9keS5zaGFwZSA9IHRoaXM7XG5cdFx0Ly8gdGhpcy4kYm9keS5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oKSB7IGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInOyB9KTtcblx0XHQvLyB0aGlzLiRib2R5Lm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKCkgeyBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JzsgfSk7XG5cblx0XHR0aGlzLiRsZWZ0SGFuZGxlciA9IG5ldyBLb252YS5SZWN0KHt9KTtcblx0XHR0aGlzLiRsZWZ0SGFuZGxlci5hZGROYW1lKCdoYW5kbGVyJyk7XG5cdFx0dGhpcy4kbGVmdEhhbmRsZXIuYWRkTmFtZSgnbGVmdCcpO1xuXHRcdHRoaXMuJGxlZnRIYW5kbGVyLnNoYXBlID0gdGhpcztcblx0XHQvLyB0aGlzLiRsZWZ0SGFuZGxlci5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oKSB7IGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJ2V3LXJlc2l6ZSc7IH0pO1xuXHRcdC8vIHRoaXMuJGxlZnRIYW5kbGVyLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKCkgeyBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JzsgfSk7XG5cblx0XHR0aGlzLiRyaWdodEhhbmRsZXIgPSBuZXcgS29udmEuUmVjdCh7fSk7XG5cdFx0dGhpcy4kcmlnaHRIYW5kbGVyLmFkZE5hbWUoJ2hhbmRsZXInKTtcblx0XHR0aGlzLiRyaWdodEhhbmRsZXIuYWRkTmFtZSgncmlnaHQnKTtcblx0XHR0aGlzLiRyaWdodEhhbmRsZXIuc2hhcGUgPSB0aGlzO1xuXHRcdC8vIHRoaXMuJHJpZ2h0SGFuZGxlci5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oKSB7IGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJ2V3LXJlc2l6ZSc7IH0pO1xuXHRcdC8vIHRoaXMuJHJpZ2h0SGFuZGxlci5vbignbW91c2VvdXQnLCBmdW5jdGlvbigpIHsgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7IH0pO1xuXG5cdFx0dGhpcy4kbGFiZWwgPSBuZXcgS29udmEuVGV4dCh7IGxpc3RlbmluZzogZmFsc2UgfSk7XG5cdFx0dGhpcy4kbGFiZWwuc2hhcGUgPSB0aGlzO1xuXG5cdFx0dGhpcy4kd2F2ZWZvcm0gPSBuZXcgS29udmEuU2hhcGUoeyBsaXN0ZW5pbmc6IGZhbHNlIH0pO1xuXHRcdHRoaXMuJHdhdmVmb3JtLnNoYXBlID0gdGhpcztcblxuXHRcdHRoaXMuJGVsLnB1c2godGhpcy4kYm9keSk7XG5cdFx0dGhpcy4kZWwucHVzaCh0aGlzLiR3YXZlZm9ybSk7XG5cdFx0dGhpcy4kZWwucHVzaCh0aGlzLiRoZWFkZXIpO1xuXHRcdHRoaXMuJGVsLnB1c2godGhpcy4kbGFiZWwpO1xuXHRcdHRoaXMuJGVsLnB1c2godGhpcy4kbGVmdEhhbmRsZXIpO1xuXHRcdHRoaXMuJGVsLnB1c2godGhpcy4kcmlnaHRIYW5kbGVyKTtcblxuXHRcdHJldHVybiB0aGlzLiRlbDtcblx0fVxuXG5cdHVwZGF0ZShyZW5kZXJpbmdDb250ZXh0LCBkYXR1bSkge1xuXHRcdGNvbnN0IGQgPSBkYXR1bSB8fCB0aGlzLmRhdHVtO1xuXG5cdFx0dGhpcy4kaGVhZGVyLnZpc2libGUodGhpcy52aXNpYmxlICYmIHRoaXMucGFyYW1zLmRpc3BsYXlIZWFkZXIpO1xuXHRcdHRoaXMuJGxhYmVsLnZpc2libGUodGhpcy52aXNpYmxlICYmIHRoaXMucGFyYW1zLmRpc3BsYXlMYWJlbCk7XG5cdFx0dGhpcy4kYm9keS52aXNpYmxlKHRoaXMudmlzaWJsZSAmJiB0aGlzLnBhcmFtcy5kaXNwbGF5Qm9keSk7XG5cdFx0dGhpcy4kbGVmdEhhbmRsZXIudmlzaWJsZSh0aGlzLnZpc2libGUgJiYgdGhpcy5wYXJhbXMuZGlzcGxheUhhbmRsZXJzKTtcblx0XHR0aGlzLiRyaWdodEhhbmRsZXIudmlzaWJsZSh0aGlzLnZpc2libGUgJiYgdGhpcy5wYXJhbXMuZGlzcGxheUhhbmRsZXJzKTtcblx0XHR0aGlzLiR3YXZlZm9ybS52aXNpYmxlKHRoaXMudmlzaWJsZSk7XG5cblx0XHRpZiAoIXRoaXMudmlzaWJsZSlcdHJldHVybjtcblxuXG5cdFx0dmFyIHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMueChkKSk7XG5cdFx0dmFyIHdpZHRoID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLndpZHRoKGQpKTtcblx0XHR2YXIgaGVpZ2h0ID0gcmVuZGVyaW5nQ29udGV4dC5oZWlnaHQ7XG5cdFx0dmFyIGNvbG9yID0gdGhpcy5wYXJhbXMud2F2ZWZvcm0uY29sb3I7XG5cblx0XHR0aGlzLiRlbC5mb3JFYWNoKChlbCkgPT4gZWwueCh4KS55KDApKTtcblxuXHRcdHRoaXMuJGxhYmVsLnRleHQodGhpcy50ZXh0KGQpKS54KHgrMTApLnkoNSk7XG5cblx0XHR0aGlzLiRoZWFkZXIud2lkdGgoTWF0aC5tYXgod2lkdGgsIDApKVxuXHRcdFx0XHRcdFx0XHRcdC5oZWlnaHQoaGVpZ2h0ICogdGhpcy5wYXJhbXMuaGVhZGVySGVpZ2h0UmF0aW8pXG5cdFx0XHRcdFx0XHRcdFx0LmZpbGwodGhpcy5wYXJhbXMuaGVhZGVyLmNvbG9yKVxuXHRcdFx0XHRcdFx0XHRcdC5vcGFjaXR5KHRoaXMucGFyYW1zLmhlYWRlci5vcGFjaXR5KTtcblx0XHR0aGlzLiRib2R5LndpZHRoKE1hdGgubWF4KHdpZHRoLCAwKSlcblx0XHRcdFx0XHRcdFx0XHQuaGVpZ2h0KGhlaWdodClcblx0XHRcdFx0XHRcdFx0XHQuZmlsbCh0aGlzLnBhcmFtcy5ib2R5LmNvbG9yKVxuXHRcdFx0XHRcdFx0XHRcdC5vcGFjaXR5KHRoaXMucGFyYW1zLmJvZHkub3BhY2l0eSk7XG5cblx0XHR0aGlzLiRsZWZ0SGFuZGxlci53aWR0aCh0aGlzLnBhcmFtcy5oYW5kbGVyLndpZHRoKS5oZWlnaHQoaGVpZ2h0KS5maWxsKHRoaXMucGFyYW1zLmhhbmRsZXIuY29sb3IpO1xuXG5cdFx0dGhpcy4kcmlnaHRIYW5kbGVyLngoeCArIHdpZHRoIC0gdGhpcy5wYXJhbXMuaGFuZGxlci53aWR0aCkud2lkdGgodGhpcy5wYXJhbXMuaGFuZGxlci53aWR0aCkuaGVpZ2h0KGhlaWdodCkuZmlsbCh0aGlzLnBhcmFtcy5oYW5kbGVyLmNvbG9yKTtcblxuXHRcdHRoaXMuJHdhdmVmb3JtLmZpbGwodGhpcy5wYXJhbXMud2F2ZWZvcm0uY29sb3IpLm9wYWNpdHkodGhpcy5wYXJhbXMud2F2ZWZvcm0ub3BhY2l0eSkueSgwKTtcblxuXHRcdHRoaXMuJHdhdmVmb3JtLnBlcmZlY3REcmF3RW5hYmxlZCh0cnVlKTtcblxuXHRcdHRoaXMuJHdhdmVmb3JtLngoeCk7XG5cblxuXHRcdC8vIFdBVkVGT1JNIFBBUlRcblxuXG5cdFx0Ly8gZGVmaW5lIG5iciBvZiBzYW1wbGVzIHBlciBwaXhlbHNcblx0XHRjb25zdCBzbGljZU1ldGhvZCA9IHRoaXMuZGF0YShkKSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSA/ICdzdWJhcnJheScgOiAnc2xpY2UnO1xuXHRcdGNvbnN0IG5iclNhbXBsZXMgPSB0aGlzLmJ1ZmZlckVuZChkKSAtIHRoaXMuYnVmZmVyU3RhcnQoZCk7XG5cdFx0Ly8gY29uc3QgZHVyYXRpb24gPSBuYnJTYW1wbGVzIC8gdGhpcy5zYW1wbGVSYXRlKGQpO1xuXHRcdGNvbnN0IHNhbXBsZXNQZXJQaXhlbCA9IG5iclNhbXBsZXMgLyB3aWR0aDtcblxuXHRcdGlmICghc2FtcGxlc1BlclBpeGVsIHx8IHRoaXMuZGF0YShkKS5sZW5ndGggPCBzYW1wbGVzUGVyUGl4ZWwpIHsgcmV0dXJuOyB9XG5cblx0XHQvLyBjb21wdXRlL2RyYXcgdmlzaWJsZSBhcmVhIG9ubHlcblx0XHQvLyBAVE9ETyByZWZhY3RvciB0aGlzIHVudW5kZXJzdGFuZGFibGUgbWVzc1xuXHRcdC8vIGxldCBtaW5YID0gTWF0aC5tYXgoLXJlbmRlcmluZ0NvbnRleHQub2Zmc2V0WCwgcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLngoZCkpKTtcblx0XHQvLyBsZXQgbWF4WCA9IE1hdGgubWluKC1yZW5kZXJpbmdDb250ZXh0Lm9mZnNldFggKyByZW5kZXJpbmdDb250ZXh0LndpZHRoLCByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMueChkKSArIHRoaXMud2lkdGgoZCkpKTtcblx0XHRsZXQgbWluWCA9IDA7XG5cdFx0bGV0IG1heFggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMud2lkdGgoZCkpO1xuXG5cdFx0Ly8gZ2V0IG1pbi9tYXggcGVyIHBpeGVscywgY2xhbXBlZCB0byB0aGUgdmlzaWJsZSBhcmVhXG5cdFx0Y29uc3QgaW52ZXJ0ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQ7XG5cdFx0Y29uc3Qgc2FtcGxlUmF0ZSA9IHRoaXMuc2FtcGxlUmF0ZShkKTtcblx0XHRjb25zdCBNSUQgPSAwO1xuXHRcdGNvbnN0IHRoYXQgPSB0aGlzO1xuXHRcdHZhciBtaW4sIG1heCwgeTEsIHkyLCBzYW1wbGUsIHB4LCBpLCBidWZmZXJTdGFydCwgYnVmZmVyRW5kLCBjb2VmO1xuXG5cdFx0YnVmZmVyU3RhcnQgPSB0aGlzLmJ1ZmZlclN0YXJ0KGQpO1xuXHRcdGJ1ZmZlckVuZCA9IHRoaXMuYnVmZmVyRW5kKGQpO1xuXHRcdHZhciBidWZmZXJJbnRlcnZhbER1cmF0aW9uID0gYnVmZmVyRW5kIC0gYnVmZmVyU3RhcnQ7XG5cblx0XHRpZiAoeCA8IC1yZW5kZXJpbmdDb250ZXh0Lm9mZnNldFgpIHtcblx0XHRcdC8vIHJlY2FsY3VsYXRlIGJ1ZmZlclN0YXJ0XG5cdFx0XHRjb2VmID0gKC1yZW5kZXJpbmdDb250ZXh0Lm9mZnNldFggLSB4KSAvICh4ICsgd2lkdGgpO1xuXHRcdFx0YnVmZmVyU3RhcnQgKz0gY29lZiAqIGJ1ZmZlckludGVydmFsRHVyYXRpb247XG5cdFx0fVxuXHRcdGlmICh4ICsgd2lkdGggPiAtcmVuZGVyaW5nQ29udGV4dC5vZmZzZXRYICsgcmVuZGVyaW5nQ29udGV4dC53aWR0aCkge1xuXHRcdFx0Ly8gcmVjYWxjdWxhdGUgYnVmZmVyRW5kXG5cdFx0XHRjb2VmID0gKHggKyAtcmVuZGVyaW5nQ29udGV4dC5vZmZzZXRYICsgcmVuZGVyaW5nQ29udGV4dC53aWR0aCkgLyAoeCArIHdpZHRoKTtcblx0XHRcdGJ1ZmZlckVuZCA9IGJ1ZmZlclN0YXJ0ICsgY29lZiAqIGJ1ZmZlckludGVydmFsRHVyYXRpb247XG5cdFx0fVxuXG5cdFx0bWluWCA9IC1yZW5kZXJpbmdDb250ZXh0Lm9mZnNldFg7XG5cdFx0bWF4WCA9IG1pblggKyByZW5kZXJpbmdDb250ZXh0LnZpc2libGVXaWR0aDtcblxuXHRcdHRoaXMuJHdhdmVmb3JtLnNjZW5lRnVuYyhmdW5jdGlvbihjb250ZXh0KSB7XG5cblx0XHRcdGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cblx0XHRcdGNvbnRleHQubW92ZVRvKG1pblgsIGhlaWdodC8yKTtcblxuXHRcdFx0Zm9yIChpPWJ1ZmZlclN0YXJ0LCBweD1taW5YOyBpPGJ1ZmZlckVuZCAmJiBweDxtYXhYOyBpKz1zYW1wbGVzUGVyUGl4ZWwsIHB4KyspIHtcblx0XHRcdFx0Y29uc3QgZXh0cmFjdCA9IHRoYXQuZGF0YShkKVtzbGljZU1ldGhvZF0oaSwgTWF0aC5yb3VuZChpICsgc2FtcGxlc1BlclBpeGVsKSk7XG5cblx0XHRcdFx0bWluID0gSW5maW5pdHk7XG5cdFx0XHRcdG1heCA9IC1JbmZpbml0eTtcblxuXHRcdFx0XHRmb3IgKGxldCBqID0gMCwgbCA9IGV4dHJhY3QubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG5cdFx0XHRcdFx0c2FtcGxlID0gZXh0cmFjdFtqXTtcblx0XHRcdFx0XHRpZiAoc2FtcGxlIDwgbWluKSB7IG1pbiA9IHNhbXBsZTsgfVxuXHRcdFx0XHRcdGlmIChzYW1wbGUgPiBtYXgpIHsgbWF4ID0gc2FtcGxlOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gZGlzYWxsb3cgSW5maW5pdHlcblx0XHRcdFx0bWluID0gIWlzRmluaXRlKG1pbikgPyAwIDogbWluO1xuXHRcdFx0XHRtYXggPSAhaXNGaW5pdGUobWF4KSA/IDAgOiBtYXg7XG5cdFx0XHRcdGlmIChtaW4gPT09IDAgJiYgbWF4ID09PSAwKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0eTEgPSBNYXRoLnJvdW5kKHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKG1pbikpO1xuXHRcdFx0XHR5MiA9IE1hdGgucm91bmQocmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwobWF4KSk7XG5cblx0XHRcdFx0Y29udGV4dC5saW5lVG8ocHgsIHkxIC0gTUlEKTtcblx0XHRcdFx0Y29udGV4dC5saW5lVG8ocHgsIHkyIC0gTUlEKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb250ZXh0LmxpbmVUbyhtYXhYLCBoZWlnaHQvMik7XG5cblx0XHRcdGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cblx0XHRcdGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuXG5cdFx0fSk7XG5cblx0XHQvLyB0aGlzLiR3YXZlZm9ybS5jYWNoZSh7XG5cdFx0Ly8gXHR4OiAwLCBcblx0XHQvLyBcdHk6IDAsIFxuXHRcdC8vIFx0d2lkdGg6IHdpZHRoLCBcblx0XHQvLyBcdGhlaWdodDogaGVpZ2h0LCBcblx0XHQvLyBcdG9mZnNldDogMlxuXHRcdC8vIH0pO1xuXG5cdH1cblxuXHRpbkFyZWEocmVuZGVyaW5nQ29udGV4dCwgZGF0dW0sIHgxLCB5MSwgeDIsIHkyKSB7XG5cdFx0Y29uc3Qgc2hhcGVYMSA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwodGhpcy54KGRhdHVtKSk7XG5cdFx0Y29uc3Qgc2hhcGVYMiA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwodGhpcy54KGRhdHVtKSArIHRoaXMud2lkdGgoZGF0dW0pKTtcblx0XHRjb25zdCBzaGFwZVkxID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwoMCk7XG5cdFx0Y29uc3Qgc2hhcGVZMiA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHJlbmRlcmluZ0NvbnRleHQuaGVpZ2h0KTtcblxuXHRcdC8vIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvdXRoeVovIC0gY2hlY2sgb3ZlcmxhcGluZyBhcmVhXG5cdFx0Y29uc3QgeE92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih4Miwgc2hhcGVYMikgLSBNYXRoLm1heCh4MSwgc2hhcGVYMSkpO1xuXHRcdGNvbnN0IHlPdmVybGFwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oeTIsIHNoYXBlWTIpIC0gTWF0aC5tYXgoeTEsIHNoYXBlWTEpKTtcblx0XHRjb25zdCBhcmVhID0geE92ZXJsYXAgKiB5T3ZlcmxhcDtcblxuXHRcdHJldHVybiBhcmVhID4gMDtcblx0fVxuXG5cdGxpbmVhcl9pbnRlcnBvbGF0aW9uKGFyciwgcG9zKSB7XG5cdFx0Y29uc3QgZmlyc3RcdCA9IE1hdGguZmxvb3IocG9zKTtcblx0XHRjb25zdCBmcmFjXHRcdD0gcG9zIC0gZmlyc3Q7XG5cdFx0Y29uc3Qgc2Vjb25kXHQ9IChmaXJzdCArIDEpIDwgYXJyLmxlbmd0aCA/IChmaXJzdCArIDEpIDogMDtcblxuXHRcdHJldHVybiBhcnJbZmlyc3RdICogKDEgLSBmcmFjKSArIGFycltzZWNvbmRdICogZnJhYztcblx0fVxufSIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBgU3RhdGVgIGluc3RhbmNlcyBhcmUgdXNlZCB0byBkZWZpbmUgdGhlIGFwcGxpY2F0aW9uIGxvZ2ljIGJ5IHByZWNpc2luZ1xuICogc3BlY2lmaWMgdXNlciBpbnRlcmFjdGlvbiBjYXNlcywgYW5kIGhvdyB0aGV5IGltcGFjdCB0aGUgb3ZlcmFsIHRlbXBvcmFsXG4gKiByZXByZXNlbnRhdGlvbi4gVGhlIGFic3RyYWN0aW9ucyBleHRlbmRpbmcgdGhpcyBiYXNlIGNsYXNzIHNob3VsZCBiZVxuICogY29uc2lkZXJlZCBhcyB0aGUgbWFpbiBpbnRlcmZhY2UgYmV0d2VlbiB0aGUgdmlzdWFsaXphdGlvbiBhbmQgdGhlXG4gKiBhcHBsaWNhdGlvbiBsb2dpYy4gQWxsIHByb3ZpZGVkIHN0YXRlcyBzaG91bGQgYmUgc2VlbiBhcyBzaW1wbGUgZXhhbXBsZXMgZm9yXG4gKiByYXBpZCBwcm90b3R5cGluZyxcbiAqXG4gKiBTdGF0ZXMgbWFuYWdlIGludGVyYWN0aW9ucyBsaWtlIHpvb21pbmcsIGJyb3dzaW5nLCBvciBlZGl0aW5nIHRoZSB0aW1lbGluZS5cbiAqIEN1c3RvbWl6ZWQgc3RhdGVzIHNob3VsZCBleHRlbmQgdGhpcyBCYXNlU3RhdGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VTdGF0ZSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRpbWVsaW5lIHRyYWNrcyBjb2xsZWN0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7VHJhY2tDb2xsZWN0aW9ufVxuICAgKi9cbiAgY29uc3RydWN0b3IodGltZWxpbmUpIHtcbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgdGltZWxpbmUgb24gd2hpY2ggdGhlIHN0YXRlIHNob3VsZCBiZSBpbnN0YWxsZWQuXG4gICAgICogQHR5cGUge1RpbWVsaW5lfVxuICAgICAqL1xuICAgIHRoaXMudGltZWxpbmUgPSB0aW1lbGluZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRpbWVsaW5lIHRyYWNrcyBjb2xsZWN0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7VHJhY2tDb2xsZWN0aW9uPFRyYWNrPn1cbiAgICovXG4gIGdldCB0cmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudGltZWxpbmUudHJhY2tzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIHJlZ2lzdGVyZWQgbGF5ZXJzLlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8TGF5ZXI+fVxuICAgKi9cbiAgZ2V0IGxheWVycygpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lbGluZS50cmFja3MubGF5ZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSB0aW1lbGluZSBpcyBlbnRlcmluZyB0aGUgc3RhdGUuXG4gICAqL1xuICBlbnRlcigpIHt9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSB0aW1lbGluZSBpcyBsZWF2aW5nIHRoZSBzdGF0ZS5cbiAgICovXG4gIGV4aXQoKSB7fVxuXG4gIC8qKlxuICAgKiBNYWluIGludGVyZmFjZSBtZXRob2QgdG8gb3ZlcnJpZGUgd2hlbiBjcmVhdGluZyBhIG5ldyBgU3RhdGVgLiBIYW5kbGUgZXZlbnRcbiAgICogZnJvbSBtb3VzZSBvciBrZXlib2FyZCwgc2hvdWxkIGRlZmluZSBiZWhhdmlvciBhY2NvcmRpbmcgdG8gdGhlIGV2ZW50XG4gICAqIChha2EuIG1vdXNlZG93biwgbW91c2V1cCwgLi4uKS5cbiAgICpcbiAgICogQHBhcmFtIHtXYXZlRXZlbnR9IGUgLSB0aGUgZXZlbnQgdG8gcHJvY2Vzcy5cbiAgICogQHBhcmFtIHtBcnJheX0gaGl0TGF5ZXJzIC0gdGhlIGxheWVycyBoaXQgYnkgdGhlIG1vdXNlIGV2ZW50IChpZiBzdXJmYWNlXG4gICAqIGV2ZW50KS5cbiAgICovXG4gIGhhbmRsZUV2ZW50KGUsIGhpdExheWVycykge31cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlU3RhdGUgZnJvbSAnLi9iYXNlLXN0YXRlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJlYWtwb2ludFN0YXRlIGV4dGVuZHMgQmFzZVN0YXRlIHtcbiAgY29uc3RydWN0b3IodGltZWxpbmUsIGRhdHVtR2VuZXJhdG9yKSB7XG4gICAgc3VwZXIodGltZWxpbmUpO1xuXG4gICAgdGhpcy5kYXR1bUdlbmVyYXRvciA9IGRhdHVtR2VuZXJhdG9yO1xuICAgIHRoaXMuY3VycmVudEVkaXRlZExheWVyID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICB9XG5cbiAgZW50ZXIoKSB7fVxuICBleGl0KCkge31cblxuICBoYW5kbGVFdmVudChlLCBoaXRMYXllcnMpIHtcbiAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlRG93bihlLCBoaXRMYXllcnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmUoZSwgaGl0TGF5ZXJzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlVXAoZSwgaGl0TGF5ZXJzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgb25Nb3VzZURvd24oZSwgaGl0TGF5ZXJzKSB7XG5cbiAgICB0aGlzLm1vdXNlRG93biA9IHRydWU7XG4gICAgLy8ga2VlcCB0YXJnZXQgY29uc2lzdGVudCB3aXRoIG1vdXNlIGRvd25cbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBlLnRhcmdldDtcbiAgICBsZXQgdXBkYXRlZExheWVyID0gbnVsbDtcblxuICAgIGNvbnN0IGxheWVycyA9IGhpdExheWVycztcblxuICAgIGxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgICAgbGF5ZXIudW5zZWxlY3QoKTtcbiAgICAgIGNvbnN0IGl0ZW0gPSBlLnRhcmdldDtcblxuICAgICAgaWYgKGl0ZW0gPT09IG51bGwgfHwgaXRlbSA9PT0gdW5kZWZpbmVkIHx8IGxheWVyLmdldERhdHVtRnJvbVNoYXBlKGl0ZW0uc2hhcGUpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gY3JlYXRlIGFuIGl0ZW1cbiAgICAgICAgY29uc3QgdGltZSA9IGxheWVyLnRpbWVUb1BpeGVsLmludmVydChlLngpIC0gdGhpcy50aW1lbGluZS5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGF5ZXIudmFsdWVUb1BpeGVsLmludmVydChlLnkpO1xuICAgICAgICBjb25zdCBkYXR1bSA9IHRoaXMuZGF0dW1HZW5lcmF0b3IodGltZSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChkYXR1bSkge1xuICAgICAgICAgIGxheWVyLmFkZChkYXR1bSk7XG4gICAgICAgICAgdXBkYXRlZExheWVyID0gbGF5ZXI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHNoaWZ0IGlzIHByZXNzZWQsIHJlbW92ZSB0aGUgaXRlbVxuICAgICAgICBpZiAoZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgY29uc3QgZGF0dW0gPSBsYXllci5nZXREYXR1bUZyb21TaGFwZShpdGVtLnNoYXBlKTtcbiAgICAgICAgICBsYXllci5yZW1vdmUoZGF0dW0pO1xuICAgICAgICAgIHVwZGF0ZWRMYXllciA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY3VycmVudEVkaXRlZExheWVyID0gbGF5ZXI7XG4gICAgICAgICAgY29uc3QgZGF0dW0gPSBsYXllci5nZXREYXR1bUZyb21TaGFwZShpdGVtLnNoYXBlKTtcbiAgICAgICAgICBsYXllci5zZWxlY3QoW2RhdHVtXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGF5ZXIuc2VsZWN0ZWREYXR1bXMuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgICAgbGF5ZXIuZ2V0U2hhcGVGcm9tRGF0dW0oZGF0dW0pLnN0b3BEcmFnKCk7XG4gICAgICB9KTtcblxuICAgIH0pO1xuXG4gICAgXG5cbiAgICBpZiAodXBkYXRlZExheWVyKSB7XG4gICAgICB0aGlzLnRpbWVsaW5lLnRyYWNrcy51cGRhdGUodXBkYXRlZExheWVyKTtcbiAgICB9XG4gIH1cblxuICBvbk1vdXNlTW92ZShlLCBoaXRMYXllcnMpIHtcbiAgICBpZiAoIXRoaXMubW91c2VEb3duIHx8ICF0aGlzLmN1cnJlbnRFZGl0ZWRMYXllcikgeyByZXR1cm47IH1cblxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5jdXJyZW50RWRpdGVkTGF5ZXI7XG4gICAgY29uc3QgZGF0dW1zID0gbGF5ZXIuc2VsZWN0ZWREYXR1bXM7XG4gICAgLy8gdGhlIGxvb3Agc2hvdWxkIGJlIGluIGxheWVyIHRvIG1hdGNoIHNlbGVjdCAvIHVuc2VsZWN0IEFQSVxuICAgIGxheWVyLmVkaXQoZGF0dW1zLCBlLmR4LCBlLmR5LCB0aGlzLmN1cnJlbnRUYXJnZXQpO1xuXG4gICAgbGF5ZXIudXBkYXRlU2hhcGVzKGRhdHVtcyk7XG4gIH1cblxuICBvbk1vdXNlVXAoZSwgaGl0TGF5ZXJzKSB7XG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XG4gICAgaGl0TGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiB7XG4gICAgICBsYXllci5zZWxlY3RlZERhdHVtcy5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICBsYXllci5nZXRTaGFwZUZyb21EYXR1bShkYXR1bSkuc3RvcERyYWcoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuY3VycmVudEVkaXRlZExheWVyID0gbnVsbDtcbiAgICB0aGlzLm1vdXNlRG93biA9IGZhbHNlO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgQmFzZVN0YXRlIGZyb20gJy4vYmFzZS1zdGF0ZSc7XG5pbXBvcnQgS29udmEgZnJvbSAna29udmEnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCcnVzaFpvb21TdGF0ZSBleHRlbmRzIEJhc2VTdGF0ZSB7XG5cdGNvbnN0cnVjdG9yKHRpbWVsaW5lKSB7XG5cdFx0c3VwZXIodGltZWxpbmUpO1xuXHR9XG5cblx0aGFuZGxlRXZlbnQoZSkge1xuXHRcdHN3aXRjaChlLnR5cGUpIHtcblx0XHRcdGNhc2UgJ21vdXNlZG93bic6XG5cdFx0XHRcdHRoaXMub25Nb3VzZURvd24oZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnbW91c2Vtb3ZlJzpcblx0XHRcdFx0dGhpcy5vbk1vdXNlTW92ZShlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdtb3VzZXVwJzpcblx0XHRcdFx0dGhpcy5vbk1vdXNlVXAoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAna2V5ZG93bic6XG5cdFx0XHRcdHRoaXMub25LZXlEb3duKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHRvbk1vdXNlRG93bihlKSB7XG5cdFx0dGhpcy5icnVzaGVzID0gW107XG5cdFx0dGhpcy5zdGFydFggPSBlLng7XG5cdFx0Ly8gY3JlYXRlIGJydXNoIGluIGVhY2ggY29udGFpbmVyc1xuXHRcdHRoaXMudHJhY2tzLmZvckVhY2goKHRyYWNrKSA9PiB7XG5cdFx0XHRjb25zdCBpbnRlcmFjdGlvbnMgPSB0cmFjay4kaW50ZXJhY3Rpb25zTGF5ZXI7XG5cblx0XHRcdGNvbnN0IGJydXNoID0gbmV3IEtvbnZhLlJlY3Qoe30pO1xuXHRcdFx0YnJ1c2guaGVpZ2h0KHRyYWNrLmhlaWdodClcblx0XHRcdFx0LnkoMClcblx0XHRcdFx0LmZpbGwoJyM3ODc4NzgnKVxuXHRcdFx0XHQub3BhY2l0eSgwLjIpO1xuXHRcdFx0YnJ1c2gudHJhY2sgPSB0cmFjaztcblxuXHRcdFx0aW50ZXJhY3Rpb25zLmFkZChicnVzaCk7XG5cblx0XHRcdHRoaXMuYnJ1c2hlcy5wdXNoKGJydXNoKTtcblxuXHRcdFx0aW50ZXJhY3Rpb25zLmJhdGNoRHJhdygpO1xuXHRcdFx0Ly8gaW50ZXJhY3Rpb25zLm1vdmVUb1RvcCgpO1xuXHRcdH0pO1xuXHR9XG5cblx0b25Nb3VzZU1vdmUoZSkge1xuXHRcdC8vIHVwZGF0ZSBicnVzaFxuXHRcdGNvbnN0IHdpZHRoID0gTWF0aC5hYnMoZS54IC0gdGhpcy5zdGFydFgpO1xuXHRcdGNvbnN0IHggPSBNYXRoLm1pbihlLngsIHRoaXMuc3RhcnRYKTtcblxuXHRcdHRoaXMuYnJ1c2hlcy5mb3JFYWNoKChicnVzaCkgPT4ge1xuXHRcdFx0YnJ1c2gueCh4KS53aWR0aCh3aWR0aCk7XG5cdFx0XHRicnVzaC50cmFjay4kaW50ZXJhY3Rpb25zTGF5ZXIuYmF0Y2hEcmF3KCk7XG5cdFx0fSk7XG5cdH1cblxuXHRvbk1vdXNlVXAoZSkge1xuXHRcdC8vIHJlbW92ZSBicnVzaFxuXHRcdHRoaXMuYnJ1c2hlcy5mb3JFYWNoKChicnVzaCkgPT4ge1xuXHRcdFx0YnJ1c2guZGVzdHJveSgpO1xuXHRcdFx0YnJ1c2gudHJhY2suJGludGVyYWN0aW9uc0xheWVyLmJhdGNoRHJhdygpO1xuXHRcdFx0YnJ1c2gudHJhY2sgPSBudWxsO1xuXHRcdH0pO1xuXHRcdHRoaXMuYnJ1c2hlcy5sZW5ndGggPSAwO1xuXG5cdFx0Ly8gdXBkYXRlIHRpbWVDb250ZXh0XG5cdFx0Y29uc3Qgc3RhcnRYID0gdGhpcy5zdGFydFg7XG5cdFx0Y29uc3QgZW5kWCA9IGUueDtcblx0XHQvLyByZXR1cm4gaWYgbm8gZHJhZ1xuXHRcdGlmIChNYXRoLmFicyhzdGFydFggLSBlbmRYKSA8IDEpIHsgcmV0dXJuOyB9XG5cblx0XHRjb25zdCBsZWZ0WCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHN0YXJ0WCwgZW5kWCkpO1xuXHRcdGNvbnN0IHJpZ2h0WCA9IE1hdGgubWF4KHN0YXJ0WCwgZW5kWCk7XG5cblx0XHRsZXQgbWluVGltZSA9IHRoaXMudGltZWxpbmUudGltZVRvUGl4ZWwuaW52ZXJ0KGxlZnRYKTtcblx0XHRsZXQgbWF4VGltZSA9IHRoaXMudGltZWxpbmUudGltZVRvUGl4ZWwuaW52ZXJ0KHJpZ2h0WCk7XG5cblx0XHRjb25zdCBkZWx0YUR1cmF0aW9uID0gbWF4VGltZSAtIG1pblRpbWU7XG5cdFx0Y29uc3Qgem9vbSA9IHRoaXMudGltZWxpbmUudmlzaWJsZUR1cmF0aW9uIC8gZGVsdGFEdXJhdGlvbjtcblxuXHRcdHRoaXMudGltZWxpbmUub2Zmc2V0IC09IG1pblRpbWU7XG5cdFx0dGhpcy50aW1lbGluZS56b29tICo9IHpvb207XG5cblx0XHR0aGlzLnRyYWNrcy51cGRhdGUoKTtcblx0fVxuXG5cdG9uS2V5RG93bihlKSB7XG5cdFx0Ly8gcmVzZXQgb24gc3BhY2UgYmFyXG5cdFx0aWYgKGUub3JpZ2luYWxFdmVudC5rZXlDb2RlID09PSAzMikge1xuXHRcdFx0dGhpcy50aW1lbGluZS5vZmZzZXQgPSAwO1xuXHRcdFx0dGhpcy50aW1lbGluZS56b29tID0gMTtcblx0XHRcdHRoaXMudHJhY2tzLnVwZGF0ZSgpO1xuXHRcdH1cblx0fVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEJhc2VTdGF0ZSBmcm9tICcuL2Jhc2Utc3RhdGUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDZW50ZXJlZFNjcm9sbFN0YXRlIGV4dGVuZHMgQmFzZVN0YXRlIHtcbiAgY29uc3RydWN0b3IodGltZWxpbmUpIHtcbiAgICBzdXBlcih0aW1lbGluZSk7XG4gICAgdGhpcy5jdXJyZW50TGF5ZXIgPSBudWxsO1xuICAgIC8vIFNldCBtYXgvbWluIHpvb21cbiAgICAvLyBtYXhab29tOiAxcHggcGVyIHNhbXBsZVxuICAgIC8vIG1pblpvb206IDEwIDAwMCBweCBwZXIgMSBob3VyXG4gICAgLy8gd2l0aCBhIGRlZmF1bHQgdG8gNDQuMWtIeiBzYW1wbGUgcmF0ZVxuICAgIHRoaXMubWF4Wm9vbSA9IDQ0MTAwICogMSAvIHRoaXMudGltZWxpbmUudGltZUNvbnRleHQucGl4ZWxzUGVyU2Vjb25kO1xuICAgIHRoaXMubWluWm9vbSA9IDEwMDAwIC8gMzYwMCAvIHRoaXMudGltZWxpbmUudGltZUNvbnRleHQucGl4ZWxzUGVyU2Vjb25kO1xuICB9XG5cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIHN3aXRjaChlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICAgIHRoaXMub25Nb3VzZURvd24oZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlTW92ZShlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlVXAoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIG9uTW91c2VEb3duKGUpIHtcbiAgfVxuXG4gIG9uTW91c2VNb3ZlKGUpIHtcbiAgICAvLyBwcmV2ZW50IGFubm95aW5nIHRleHQgc2VsZWN0aW9uIHdoZW4gZHJhZ2dpbmdcbiAgICBlLm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IHRpbWVDb250ZXh0ID0gdGhpcy50aW1lbGluZS50aW1lQ29udGV4dDtcbiAgICBjb25zdCBsYXN0Q2VudGVyVGltZSA9IHRpbWVDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydChlLngpO1xuXG4gICAgY29uc3QgbmV3Q2VudGVyVGltZSA9IHRpbWVDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydChlLngpO1xuICAgIGNvbnN0IGRlbHRhID0gbmV3Q2VudGVyVGltZSAtIGxhc3RDZW50ZXJUaW1lO1xuXG4gICAgLy8gQXBwbHkgbmV3IG9mZnNldCB0byBrZWVwIGl0IGNlbnRlcmVkIHRvIHRoZSBtb3VzZVxuICAgIHRpbWVDb250ZXh0Lm9mZnNldCArPSAoZGVsdGEgKyB0aW1lQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQoZS5keCkpO1xuXG4gICAgLy8gT3RoZXIgcG9zc2libGUgZXhwZXJpbWVudHMgd2l0aCBjZW50ZXJlZC16b29tLXN0YXRlXG4gICAgLy9cbiAgICAvLyBFeGFtcGxlIDE6IFByZXZlbnQgdGltZWxpbmUub2Zmc2V0IHRvIGJlIG5lZ2F0aXZlXG4gICAgdGltZUNvbnRleHQub2Zmc2V0ID0gTWF0aC5taW4odGltZUNvbnRleHQub2Zmc2V0LCAwKTtcbiAgICBcblxuICAgIHRoaXMudGltZWxpbmUudHJhY2tzLnVwZGF0ZSgpO1xuICB9XG5cbiAgb25Nb3VzZVVwKGUpIHt9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgQmFzZVN0YXRlIGZyb20gJy4vYmFzZS1zdGF0ZSc7XG5pbXBvcnQgc2NhbGVzIGZyb20gJy4uL3V0aWxzL3NjYWxlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENlbnRlcmVkWm9vbVN0YXRlIGV4dGVuZHMgQmFzZVN0YXRlIHtcbiAgY29uc3RydWN0b3IodGltZWxpbmUpIHtcbiAgICBzdXBlcih0aW1lbGluZSk7XG4gICAgdGhpcy5jdXJyZW50TGF5ZXIgPSBudWxsO1xuICAgIC8vIFNldCBtYXgvbWluIHpvb21cbiAgICAvLyBtYXhab29tOiAxcHggcGVyIHNhbXBsZVxuICAgIC8vIG1pblpvb206IDEwIDAwMCBweCBwZXIgMSBob3VyXG4gICAgLy8gd2l0aCBhIGRlZmF1bHQgdG8gNDQuMWtIeiBzYW1wbGUgcmF0ZVxuICAgIHRoaXMubWF4Wm9vbSA9IDQ0MTAwICogMSAvIHRoaXMudGltZWxpbmUudGltZUNvbnRleHQucGl4ZWxzUGVyU2Vjb25kO1xuICAgIHRoaXMubWluWm9vbSA9IDEwMDAwIC8gMzYwMCAvIHRoaXMudGltZWxpbmUudGltZUNvbnRleHQucGl4ZWxzUGVyU2Vjb25kO1xuICB9XG5cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIHN3aXRjaChlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICAgIHRoaXMub25Nb3VzZURvd24oZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlTW92ZShlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlVXAoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIG9uTW91c2VEb3duKGUpIHtcbiAgICB0aGlzLmluaXRpYWxab29tID0gdGhpcy50aW1lbGluZS50aW1lQ29udGV4dC56b29tO1xuICAgIHRoaXMuaW5pdGlhbFkgPSBlLnk7XG5cbiAgICB0aGlzLl9waXhlbFRvRXhwb25lbnQgPSBzY2FsZXMubGluZWFyKClcbiAgICAgIC5kb21haW4oWzAsIDEwMF0pIC8vIDEwMHB4ID0+IGZhY3RvciAyXG4gICAgICAucmFuZ2UoWzAsIDFdKTtcbiAgfVxuXG4gIG9uTW91c2VNb3ZlKGUpIHtcbiAgICAvLyBwcmV2ZW50IGFubm95aW5nIHRleHQgc2VsZWN0aW9uIHdoZW4gZHJhZ2dpbmdcbiAgICBlLm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IHRpbWVDb250ZXh0ID0gdGhpcy50aW1lbGluZS50aW1lQ29udGV4dDtcbiAgICBjb25zdCBsYXN0Q2VudGVyVGltZSA9IHRpbWVDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydChlLngpO1xuICAgIGNvbnN0IGV4cG9uZW50ID0gdGhpcy5fcGl4ZWxUb0V4cG9uZW50KGUueSAtIHRoaXMuaW5pdGlhbFkpO1xuICAgIGNvbnN0IHRhcmdldFpvb20gPSB0aGlzLmluaXRpYWxab29tICogTWF0aC5wb3coMiwgZXhwb25lbnQpOyAvLyAtMS4uLjEgLT4gMS8yLi4uMlxuXG4gICAgdGltZUNvbnRleHQuem9vbSA9IE1hdGgubWluKE1hdGgubWF4KHRhcmdldFpvb20sIHRoaXMubWluWm9vbSksIHRoaXMubWF4Wm9vbSk7XG5cbiAgICBjb25zdCBuZXdDZW50ZXJUaW1lID0gdGltZUNvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KGUueCk7XG4gICAgY29uc3QgZGVsdGEgPSBuZXdDZW50ZXJUaW1lIC0gbGFzdENlbnRlclRpbWU7XG5cbiAgICAvLyBBcHBseSBuZXcgb2Zmc2V0IHRvIGtlZXAgaXQgY2VudGVyZWQgdG8gdGhlIG1vdXNlXG4gICAgdGltZUNvbnRleHQub2Zmc2V0ICs9IChkZWx0YSArIHRpbWVDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydChlLmR4KSk7XG5cbiAgICAvLyBPdGhlciBwb3NzaWJsZSBleHBlcmltZW50cyB3aXRoIGNlbnRlcmVkLXpvb20tc3RhdGVcbiAgICAvL1xuICAgIC8vIEV4YW1wbGUgMTogUHJldmVudCB0aW1lbGluZS5vZmZzZXQgdG8gYmUgbmVnYXRpdmVcbiAgICAvLyB0aW1lQ29udGV4dC5vZmZzZXQgPSBNYXRoLm1pbih0aW1lQ29udGV4dC5vZmZzZXQsIDApO1xuICAgIC8vXG4gICAgLy8gRXhhbXBsZSAyOiBLZWVwIGluIGNvbnRhaW5lciB3aGVuIHpvb21lZCBvdXRcbiAgICBpZiAodGltZUNvbnRleHQuc3RyZXRjaFJhdGlvIDwgMSkge1xuICAgICAgY29uc3QgbWluT2Zmc2V0ID0gdGltZUNvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KDApO1xuICAgICAgY29uc3QgbWF4T2Zmc2V0ID0gdGltZUNvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHZpZXcud2lkdGggLSB0aW1lQ29udGV4dC50aW1lVG9QaXhlbCh0aW1lQ29udGV4dC5kdXJhdGlvbikpO1xuICAgICAgdGltZUNvbnRleHQub2Zmc2V0ID0gTWF0aC5tYXgodGltZUNvbnRleHQub2Zmc2V0LCBtaW5PZmZzZXQpO1xuICAgICAgdGltZUNvbnRleHQub2Zmc2V0ID0gTWF0aC5taW4odGltZUNvbnRleHQub2Zmc2V0LCBtYXhPZmZzZXQpO1xuICAgIH1cblxuICAgIHRoaXMudGltZWxpbmUudHJhY2tzLnVwZGF0ZSgpO1xuICB9XG5cbiAgb25Nb3VzZVVwKGUpIHt9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgQmFzZVN0YXRlIGZyb20gJy4vYmFzZS1zdGF0ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRleHRFZGl0aW9uU3RhdGUgZXh0ZW5kcyBCYXNlU3RhdGUge1xuICBjb25zdHJ1Y3Rvcih0aW1lbGluZSkge1xuICAgIHN1cGVyKHRpbWVsaW5lKTtcbiAgfVxuXG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBzd2l0Y2goZS50eXBlKSB7XG4gICAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgICB0aGlzLm9uTW91c2VEb3duKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmUoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICAgIHRoaXMub25Nb3VzZVVwKGUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBvbk1vdXNlRG93bihlKSB7XG4gICAgdGhpcy5tb3VzZURvd24gPSB0cnVlO1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IGUudGFyZ2V0O1xuICAgIHRoaXMuY3VycmVudExheWVyID0gKHRoaXMuY3VycmVudFRhcmdldC5zaGFwZSk/IHRoaXMuY3VycmVudFRhcmdldC5zaGFwZS5sYXllciA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIG9uTW91c2VNb3ZlKGUpIHtcbiAgICBpZiAoIXRoaXMubW91c2VEb3duIHx8ICF0aGlzLmN1cnJlbnRMYXllcikgeyByZXR1cm47IH1cblxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5jdXJyZW50TGF5ZXI7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5jdXJyZW50VGFyZ2V0O1xuXG4gICAgLy8gaW4gdGhpcyBleGFtcGxlIHRoZSBjb250ZXh0IGlzIHN0cmV0Y2hlZCB3aGVuIHNoaWZ0IGlzIHByZXNzZWRcbiAgICBpZiAoIWUub3JpZ2luYWxFdmVudC5zaGlmdEtleSkge1xuICAgICAgbGF5ZXIuZWRpdENvbnRleHQoZS5keCwgZS5keSwgdGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5ZXIuc3RyZXRjaENvbnRleHQoZS5keCwgZS5keSwgdGFyZ2V0KTtcbiAgICB9XG5cbiAgICBsYXllci51cGRhdGUoKTtcbiAgfVxuXG4gIG9uTW91c2VVcChlKSB7XG4gICAgdGhpcy5tb3VzZURvd24gPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudExheWVyID0gbnVsbDtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEJhc2VTdGF0ZSBmcm9tICcuL2Jhc2Utc3RhdGUnO1xuaW1wb3J0IEJydXNoQ29udHJvbGxlciBmcm9tICcuLi9oZWxwZXJzL2JydXNoLWNvbnRyb2xsZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEcmFnQW5kRHJvcFN0YXRlIGV4dGVuZHMgQmFzZVN0YXRlIHtcblx0Y29uc3RydWN0b3IodGltZWxpbmUpIHtcblx0XHRzdXBlcih0aW1lbGluZSk7XG5cdFx0dGhpcy50YXJnZXRMYXllciA9IG5ldyBNYXAoKTtcblx0XHR0aGlzLmJydXNoQ29udHJvbGxlciA9IG51bGw7XG5cdH1cblxuXHRzZXRUYXJnZXRMYXllckZvclRyYWNrKHRyYWNrLCBsYXllcikge1xuXHRcdHRoaXMudGFyZ2V0TGF5ZXIuc2V0KHRyYWNrLCBsYXllcik7XG5cdFx0dGhpcy5icnVzaENvbnRyb2xsZXIgPSBudWxsO1xuXHR9XG5cblx0ZXhpdCgpIHtcblx0XHR0aGlzLnRhcmdldExheWVyLmNsZWFyKCk7XG5cdH1cblxuXHRoYW5kbGVFdmVudChlKSB7XG5cdFx0c3dpdGNoIChlLnR5cGUpIHtcblx0XHRcdGNhc2UgJ2RyYWdzdGFydCc6XG5cdFx0XHRcdHRoaXMub25EcmFnU3RhcnQoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnZHJhZ2VuZCc6XG5cdFx0XHRcdHRoaXMub25EcmFnRW5kKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2RyYWdvdmVyJzpcblx0XHRcdFx0dGhpcy5vbkRyYWdPdmVyKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2Ryb3AnOlxuXHRcdFx0XHR0aGlzLm9uRHJvcChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdkcmFnbGVhdmUnOlxuXHRcdFx0XHR0aGlzLm9uRHJhZ0xlYXZlKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2RyYWdlbnRlcic6XG5cdFx0XHRcdHRoaXMub25EcmFnRW50ZXIoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdG9uRHJhZ1N0YXJ0KGUpIHtcblx0XHQvLyBOL0Fcblx0XHRjb25zb2xlLmxvZygnRHJhZ0FuZERyb3BTdGF0ZSAtIGRyYWdTdGFydCcpO1xuXHR9XG5cblx0b25EcmFnRW5kKGUpIHtcblx0XHQvLyBUT0RPID9cblx0XHRjb25zb2xlLmxvZygnRHJhZ0FuZERyb3BTdGF0ZSAtIGRyYWdFbmQnKTtcblx0fVxuXG5cdG9uRHJhZ0VudGVyKGUpIHtcblx0XHRjb25zb2xlLmxvZygnRHJhZ0FuZERyb3BTdGF0ZSAtIGRyYWdFbnRlcicpO1x0XG5cdFx0aWYgKCF0aGlzLmJydXNoQ29udHJvbGxlcikge1xuXHRcdFx0dGhpcy5jdXJyZW50VHJhY2sgPSB0aGlzLnRpbWVsaW5lLmdldFRyYWNrRnJvbURPTUVsZW1lbnQoZS50YXJnZXQpO1xuXHRcdFx0dGhpcy5icnVzaENvbnRyb2xsZXIgPSBuZXcgQnJ1c2hDb250cm9sbGVyKHRoaXMuY3VycmVudFRyYWNrKTtcblx0XHR9XG5cdH1cblxuXHRvbkRyYWdPdmVyKGUpIHtcblx0XHR0aGlzLmJydXNoQ29udHJvbGxlci5hZGRCcnVzaCgpO1xuXG5cdFx0dmFyIHRpbWVUb1BpeGVsXHQ9IHRoaXMudGltZWxpbmUudGltZUNvbnRleHQudGltZVRvUGl4ZWw7XG5cdFx0dmFyIHRpbWUgPSAtdGhpcy50aW1lbGluZS50aW1lQ29udGV4dC5vZmZzZXQgKyB0aW1lVG9QaXhlbC5pbnZlcnQoZS54KTtcblx0XHR2YXIgZGF0YSA9IGUub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcInRleHRcIik7XG5cdFx0dmFyIGR1cmF0aW9uID0gdGhpcy5vbkRhdGFBdmFpbGFibGUodGltZSwgZGF0YSwgJ2RyYWcnKTtcblx0XHRcblx0XHR2YXIgeCA9IHRpbWVUb1BpeGVsKHRpbWUpO1xuXHRcdHZhciB3aWR0aCA9IHRpbWVUb1BpeGVsKGR1cmF0aW9uKTtcblxuXHRcdHRoaXMuYnJ1c2hDb250cm9sbGVyLmJydXNoQXJlYSA9IHsgeDogeCwgd2lkdGg6IHdpZHRoIH07XG5cblx0XHRjb25zb2xlLmxvZygnRHJhZ0FuZERyb3BTdGF0ZSAtIGRyYWdPdmVyJyk7XG5cdH1cblxuXHRvbkRyYWdMZWF2ZShlKSB7XG5cdFx0dGhpcy5icnVzaENvbnRyb2xsZXIucmVtb3ZlQnJ1c2goKTtcblxuXHRcdGNvbnNvbGUubG9nKCdEcmFnQW5kRHJvcFN0YXRlIC0gZHJhZ0xlYXZlJyk7XG5cdH1cblxuXHRvbkRyb3AoZSkge1xuXHRcdHZhciB0aW1lVG9QaXhlbFx0PSB0aGlzLnRpbWVsaW5lLnRpbWVDb250ZXh0LnRpbWVUb1BpeGVsO1xuXG5cdFx0dmFyIHRpbWUgPSAtdGhpcy50aW1lbGluZS50aW1lQ29udGV4dC5vZmZzZXQgKyB0aW1lVG9QaXhlbC5pbnZlcnQoZS54KTtcblx0XHR2YXIgZGF0YSA9IGUub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcInRleHRcIik7XG5cdFx0dGhpcy5vbkRhdGFBdmFpbGFibGUodGltZSwgZGF0YSwgJ2Ryb3AnKTtcblx0XHRcblx0XHRlLm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyLmNsZWFyRGF0YSgpO1xuXG5cdFx0dGhpcy5icnVzaENvbnRyb2xsZXIucmVtb3ZlQnJ1c2goKTtcblxuXHRcdGNvbnNvbGUubG9nKCdEcmFnQW5kRHJvcFN0YXRlIC0gZHJvcCcpO1xuXHR9XG59IiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEJhc2VTdGF0ZSBmcm9tICcuL2Jhc2Utc3RhdGUnO1xuaW1wb3J0IEJydXNoQ29udHJvbGxlciBmcm9tICcuLi9oZWxwZXJzL2JydXNoLWNvbnRyb2xsZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEcmFnVG9DcmVhdGVJbnRlcnZhbFN0YXRlIGV4dGVuZHMgQmFzZVN0YXRlIHtcblx0Y29uc3RydWN0b3IodGltZWxpbmUpIHtcblx0XHRzdXBlcih0aW1lbGluZSk7XG5cdFx0dGhpcy5icnVzaENvbnRyb2xsZXIgPSBudWxsO1xuXHRcdHRoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcblx0fVxuXG5cdGVudGVyKCkge31cblxuXHRleGl0KCkge1xuXHRcdHRoaXMuYnJ1c2hDb250cm9sbGVyID0gbnVsbDtcblx0XHR0aGlzLmN1cnJlbnRUcmFjayA9IG51bGw7XG5cdH1cblxuXHRvbkludGVydmFsQXZhaWxhYmxlKGludGVydmFsLCB0cmFjaykge1xuXHRcdHRocm93IG5ldyBFcnJvcignVGhlIGRldmVsb3BlciBtdXN0IGFzc2lnbiBhIHByb3BlciBmdW5jdGlvbicpO1xuXHR9XG5cblx0c25hcEludGVydmFsKGludGVydmFsLCB0cmFjaykge1xuXHRcdHRocm93IG5ldyBFcnJvcignVGhlIGRldmVsb3BlciBtdXN0IGFzc2lnbiBhIHByb3BlciBmdW5jdGlvbicpO1x0XG5cdH1cblxuXHRoYW5kbGVFdmVudChlKSB7XG5cdFx0c3dpdGNoIChlLnR5cGUpIHtcblx0XHRcdGNhc2UgJ21vdXNlZG93bic6XG5cdFx0XHRcdHRoaXMub25Nb3VzZURvd24oZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnbW91c2Vtb3ZlJzpcblx0XHRcdFx0dGhpcy5vbk1vdXNlTW92ZShlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdtb3VzZXVwJzpcblx0XHRcdFx0dGhpcy5vbk1vdXNlVXAoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnY2xpY2snOlxuXHRcdFx0XHR0aGlzLm9uQ2xpY2soZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdG9uTW91c2VEb3duKGUpIHtcblx0XHR0aGlzLmN1cnJlbnRUcmFjayA9IHRoaXMudGltZWxpbmUuZ2V0VHJhY2tGcm9tRE9NRWxlbWVudChlLnRhcmdldC5wYXJlbnQucGFyZW50LmNvbnRlbnQpO1xuXHRcdHRoaXMuYnJ1c2hDb250cm9sbGVyID0gbmV3IEJydXNoQ29udHJvbGxlcih0aGlzLmN1cnJlbnRUcmFjayk7XG5cdFx0dGhpcy5icnVzaENvbnRyb2xsZXIuYWRkQnJ1c2goKTtcblx0fVxuXG5cdG9uTW91c2VNb3ZlKGUpIHtcblx0XHR0aGlzLmJydXNoQ29udHJvbGxlci51cGRhdGVCcnVzaChlKTtcblx0fVxuXG5cdG9uTW91c2VVcChlKSB7XG5cdFx0bGV0IGFyZWEgPSB0aGlzLmJydXNoQ29udHJvbGxlci5icnVzaEFyZWE7XG5cblx0XHRsZXQgaW50ZXJ2YWwgPSB7XG5cdFx0XHR0aW1lOiAtdGhpcy50aW1lbGluZS50aW1lQ29udGV4dC5vZmZzZXQgKyB0aGlzLnRpbWVsaW5lLnRpbWVDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydChhcmVhLngpLCBcblx0XHRcdGR1cmF0aW9uOiB0aGlzLnRpbWVsaW5lLnRpbWVDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydChhcmVhLndpZHRoKVxuXHRcdH07XG5cblx0XHR0aGlzLm9uSW50ZXJ2YWxBdmFpbGFibGUoaW50ZXJ2YWwsIHRoaXMuY3VycmVudFRyYWNrKTtcblx0XHRcblx0XHR0aGlzLmJydXNoQ29udHJvbGxlci5yZW1vdmVCcnVzaCgpO1xuXHR9XG5cblx0b25DbGljayhlKSB7XG5cdFx0bGV0IGludGVydmFsID0geyB0aW1lOiAtdGhpcy50aW1lbGluZS50aW1lQ29udGV4dC5vZmZzZXQgKyB0aGlzLnRpbWVsaW5lLnRpbWVDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydChlLngpIH07XG5cblx0XHR0aGlzLm9uSW50ZXJ2YWxBdmFpbGFibGUoaW50ZXJ2YWwsIHRoaXMuY3VycmVudFRyYWNrKTtcblx0fVxufSIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlU3RhdGUgZnJvbSAnLi9iYXNlLXN0YXRlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRHJvcEFuZEFkZFN0YXRlIGV4dGVuZHMgQmFzZVN0YXRlIHtcblx0Y29uc3RydWN0b3IodGltZWxpbmUpIHtcblx0XHRzdXBlcih0aW1lbGluZSk7XG5cdFx0dGhpcy50YXJnZXRMYXllciA9IG5ldyBNYXAoKTtcblx0fVxuXG5cdHNldFRhcmdldExheWVyRm9yVHJhY2sodHJhY2ssIGxheWVyKSB7XG5cdFx0dGhpcy50YXJnZXRMYXllci5zZXQodHJhY2ssIGxheWVyKTtcblx0fVxuXG5cdGV4aXQoKSB7XG5cdFx0dGhpcy50YXJnZXRMYXllci5jbGVhcigpO1xuXHRcdC8vIFRPRE86IHJlbW92ZSB0cmFjayBoaWdobGlnaHQgP1xuXHR9XG5cblx0aGFuZGxlRXZlbnQoZSkge1xuXHRcdHN3aXRjaCAoZS50eXBlKSB7XG5cdFx0XHRjYXNlICdkcmFnc3RhcnQnOlxuXHRcdFx0XHR0aGlzLm9uRHJhZ1N0YXJ0KGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2RyYWdlbmQnOlxuXHRcdFx0XHR0aGlzLm9uRHJhZ0VuZChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdkcmFnb3Zlcic6XG5cdFx0XHRcdHRoaXMub25EcmFnT3ZlcihlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdkcm9wJzpcblx0XHRcdFx0dGhpcy5vbkRyb3AoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnZHJhZ2xlYXZlJzpcblx0XHRcdFx0dGhpcy5vbkRyYWdMZWF2ZShlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0b25EcmFnU3RhcnQoZSkge1xuXHRcdC8vIE4vQVxuXHR9XG5cblx0b25EcmFnRW5kKGUpIHtcblx0XHQvLyBUT0RPID9cblx0fVxuXG5cdG9uRHJhZ092ZXIoZSkge1xuXHRcdC8vIFRPRE86IGhpZ2hsaWdodCB0cmFjayA/XG5cdH1cblxuXHRvbkRyYWdMZWF2ZShlKSB7XG5cdFx0Ly8gVE9ETzogcmVtb3ZlIHRyYWNrIGhpZ2hsaWdodCA/XG5cdH1cblxuXHRvbkRyb3AoZSkge1xuXHRcdGNvbnN0IG9mZnNldCA9ICgtdGhpcy50aW1lbGluZS50aW1lQ29udGV4dC5vZmZzZXQpO1xuXHRcdGNvbnN0IHRpbWUgPSB0aGlzLnRpbWVsaW5lLnRpbWVDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydChlLngpO1xuXHRcdGNvbnN0IGN1cnJlbnRUaW1lID0gb2Zmc2V0ICsgdGltZTtcblxuXHRcdHZhciB0cmFjayA9IHRoaXMudGltZWxpbmUuZ2V0VHJhY2tGcm9tRE9NRWxlbWVudChlLmN1cnJlbnRUYXJnZXQpO1xuXHRcdHZhciBsYXllciA9IHRoaXMudGFyZ2V0TGF5ZXIuZ2V0KHRyYWNrKTtcblxuXHRcdGlmIChsYXllcikge1xuXHRcdFx0dmFyIGRhdHVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZS5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwiVGV4dFwiKSkuZ2V0RGF0dW0oKTtcblx0XHRcdGRhdHVtLnggPSBjdXJyZW50VGltZTtcblx0XHRcdGxheWVyLmFkZChkYXR1bSk7XG5cdFx0XHRsYXllci5nZXRTaGFwZUZyb21EYXR1bShkYXR1bSkucGFyYW1zLmNvbG9yID0gZGF0dW0uY29sb3I7XG5cdFx0XHRsYXllci51cGRhdGUoKTtcblx0XHR9XG5cdFx0XG5cdFx0ZS5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2Zlci5jbGVhckRhdGEoKTtcblx0fVxufSIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlU3RhdGUgZnJvbSAnLi9iYXNlLXN0YXRlJztcblxuLyoqXG4gKiBBIHN0YXRlIHRvIGVkaXQgc2hhcGVzIGluIHRoZSBtb3JlIGdlbmVyYWwgd2F5LiBJbnRlcmFjdCBvbmx5IHdpdGggc2VsZWN0ZWQgc2hhcGVzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFZGl0aW9uU3RhdGUgZXh0ZW5kcyBCYXNlU3RhdGUge1xuICBjb25zdHJ1Y3Rvcih0aW1lbGluZSkge1xuICAgIHN1cGVyKHRpbWVsaW5lKTtcblxuICAgIHRoaXMuY3VycmVudEVkaXRlZExheWVyID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICB9XG5cbiAgZW50ZXIoKSB7fVxuICBleGl0KCkge31cblxuICBoYW5kbGVFdmVudChlKSB7XG4gICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICAgIHRoaXMub25Nb3VzZURvd24oZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlTW92ZShlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlVXAoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIG9uTW91c2VEb3duKGUpIHtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBlLnRhcmdldDtcbiAgfVxuXG4gIG9uTW91c2VNb3ZlKGUpIHtcbiAgICB0aGlzLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgICAgY29uc3QgZGF0dW1zID0gbGF5ZXIuc2VsZWN0ZWREYXR1bXM7XG5cbiAgICAgIGxheWVyLmVkaXQoZGF0dW1zLCBlLmR4LCBlLmR5LCB0aGlzLmN1cnJlbnRUYXJnZXQpO1xuICAgICAgbGF5ZXIudXBkYXRlKGRhdHVtcyk7XG4gICAgfSk7XG4gIH1cblxuICBvbk1vdXNlVXAoZSkge1xuICAgIHRoaXMuY3VycmVudEVkaXRlZExheWVyID0gbnVsbDtcbiAgICB0aGlzLm1vdXNlRG93biA9IGZhbHNlO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgQmFzZVN0YXRlIGZyb20gJy4vYmFzZS1zdGF0ZSc7XG5pbXBvcnQgS29udmEgZnJvbSAna29udmEnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIb3Jpem9udGFsU2VsZWN0aW9uU3RhdGUgZXh0ZW5kcyBCYXNlU3RhdGUge1xuXG4gIGNvbnN0cnVjdG9yKHRpbWVsaW5lIC8qLCBvcHRpb25zID0ge30gKi8pIHtcbiAgICBzdXBlcih0aW1lbGluZSAvKiwgb3B0aW9ucyAqLyk7XG5cbiAgICB0aGlzLl9sYXllclNlbGVjdGVkSXRlbXNNYXAgPSBuZXcgTWFwKCk7XG5cbiAgICB0aGlzLnNoaWZ0S2V5ID0gZmFsc2U7XG5cbiAgICB0aGlzLndhc01vdmluZyA9IGZhbHNlO1xuICB9XG5cbiAgZW50ZXIoKSB7XG4gICAgLy8gVE9ET1xuICB9XG5cbiAgZXhpdCgpIHtcbiAgICAvLyBUT0RPXG4gICAgY29uc3QgY29udGFpbmVycyA9IHRoaXMudGltZWxpbmUuY29udGFpbmVycztcblxuICAgIGZvciAobGV0IGlkIGluIGNvbnRhaW5lcnMpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUJydXNoKGNvbnRhaW5lcnNbaWRdKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVFdmVudChlKSB7XG4gICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICAgIHRoaXMub25Nb3VzZURvd24oZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlTW92ZShlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlVXAoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2xpY2snOlxuICAgICAgICB0aGlzLm9uQ2xpY2soZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAna2V5ZG93bic6XG4gICAgICAgIHRoaXMub25LZXkoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAna2V5dXAnOlxuICAgICAgICB0aGlzLm9uS2V5KGUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBfYWRkQnJ1c2godHJhY2spIHtcbiAgICBpZiAodHJhY2suJGJydXNoKSB7IHJldHVybjsgfVxuXG4gICAgY29uc3QgYnJ1c2ggPSBuZXcgS29udmEuUmVjdCh7fSk7XG4gICAgYnJ1c2guZmlsbCgnIzY4Njg2OCcpLm9wYWNpdHkoMC41KTtcblxuICAgIHRyYWNrLiRpbnRlcmFjdGlvbnNMYXllci5hZGQoYnJ1c2gpO1xuICAgIHRyYWNrLiRpbnRlcmFjdGlvbnNMYXllci5tb3ZlVG9Ub3AoKTtcblxuICAgIHRyYWNrLiRicnVzaCA9IGJydXNoO1xuXG4gICAgdHJhY2suJGludGVyYWN0aW9uc0xheWVyLmJhdGNoRHJhdygpO1xuICB9XG5cbiAgX3JlbW92ZUJydXNoKHRyYWNrKSB7XG4gICAgaWYgKHRyYWNrLiRicnVzaCA9PT0gdW5kZWZpbmVkKSB7IHJldHVybjsgfVxuXG4gICAgdGhpcy5fcmVzZXRCcnVzaCh0cmFjayk7XG5cbiAgICB0cmFjay4kYnJ1c2guZGVzdHJveSgpO1xuXG4gICAgdHJhY2suJGludGVyYWN0aW9uc0xheWVyLmJhdGNoRHJhdygpO1xuXG4gICAgZGVsZXRlIHRyYWNrLiRicnVzaDtcbiAgfVxuXG4gIF9yZXNldEJydXNoKHRyYWNrKSB7XG4gICAgY29uc3QgJGJydXNoID0gdHJhY2suJGJydXNoO1xuICAgIC8vIHJlc2V0IGJydXNoIGVsZW1lbnRcbiAgICAkYnJ1c2gueCgwKS55KDApLndpZHRoKDApLmhlaWdodCgwKTtcbiAgICB0cmFjay4kaW50ZXJhY3Rpb25zTGF5ZXIuYmF0Y2hEcmF3KCk7XG4gIH1cblxuICBfdXBkYXRlQnJ1c2goZSwgdHJhY2spIHtcbiAgICBjb25zdCAkYnJ1c2ggPSB0cmFjay4kYnJ1c2g7XG5cbiAgICAkYnJ1c2gueChlLmFyZWEubGVmdCkueSgwKS53aWR0aChlLmFyZWEud2lkdGgpLmhlaWdodCh0cmFjay5oZWlnaHQpO1xuICAgIHRyYWNrLiRpbnRlcmFjdGlvbnNMYXllci5iYXRjaERyYXcoKTtcbiAgfVxuXG4gIG9uS2V5KGUpIHtcbiAgICB0aGlzLnNoaWZ0S2V5ID0gZS5zaGlmdEtleTtcbiAgfVxuXG4gIG9uTW91c2VEb3duKGUpIHtcbiAgICB0aGlzLl9jdXJyZW50VHJhY2sgPSB0aGlzLnRpbWVsaW5lLmdldFRyYWNrRnJvbURPTUVsZW1lbnQoZS5jdXJyZW50VGFyZ2V0KTtcblxuICAgIGlmICghdGhpcy5fY3VycmVudFRyYWNrKSB7IHJldHVybjsgfVxuXG4gICAgdGhpcy5fYWRkQnJ1c2godGhpcy5fY3VycmVudFRyYWNrKTtcblxuICAgIC8vIHJlY3JlYXRlIHRoZSBtYXBcbiAgICB0aGlzLl9sYXllclNlbGVjdGVkSXRlbXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgXG4gICAgdGhpcy5fY3VycmVudFRyYWNrLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgICAgXG4gICAgICBpZiAoIWUub3JpZ2luYWxFdmVudC5zaGlmdEtleSkge1xuICAgICAgICBjb25zdCBhdXggPSBuZXcgU2V0KGxheWVyLnNlbGVjdGVkRGF0dW1zKTtcbiAgICAgICAgbGF5ZXIudW5zZWxlY3QoYXV4KTtcbiAgICAgICAgbGF5ZXIudXBkYXRlU2hhcGVzKGF1eCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2xheWVyU2VsZWN0ZWRJdGVtc01hcC5zZXQobGF5ZXIsIG5ldyBTZXQobGF5ZXIuc2VsZWN0ZWREYXR1bXMpKTtcbiAgICAgIFxuICAgIH0pO1xuXG4gICAgdGhpcy5tb3VzZWRvd24gPSB0cnVlO1xuICB9XG5cbiAgb25Nb3VzZU1vdmUoZSkge1xuXG4gICAgaWYgKCF0aGlzLm1vdXNlZG93bikgcmV0dXJuO1xuXG5cbiAgICB0aGlzLndhc01vdmluZyA9IHRydWU7XG5cbiAgICBlLmFyZWEgPSB7bGVmdDogZS5hcmVhLmxlZnQsIHdpZHRoOmUuYXJlYS53aWR0aCwgdG9wOiAwLCBoZWlnaHQ6IHRoaXMuX2N1cnJlbnRUcmFjay5oZWlnaHQgfTtcblxuICAgIGxldCBpU3RhcnQgPSAtdGhpcy50aW1lbGluZS5vZmZzZXQgKyB0aGlzLnRpbWVsaW5lLnRpbWVUb1BpeGVsLmludmVydChlLmFyZWEubGVmdCk7XG4gICAgbGV0IGlEdXJhdGlvbiA9IC10aGlzLnRpbWVsaW5lLm9mZnNldCArIHRoaXMudGltZWxpbmUudGltZVRvUGl4ZWwuaW52ZXJ0KGUuYXJlYS5sZWZ0ICsgZS5hcmVhLndpZHRoKSAtIGlTdGFydDtcbiAgICBsZXQgaW50ZXJ2YWwgPSB7IHN0YXJ0OiBpU3RhcnQsIGR1cmF0aW9uOiBpRHVyYXRpb24gfTtcbiAgICAvLyBjb25zb2xlLmxvZyhpbnRlcnZhbCk7XG4gICAgXG4gICAgdGhpcy5fdXBkYXRlQnJ1c2goZSwgdGhpcy5fY3VycmVudFRyYWNrKTtcblxuICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xuXG4gICAgdGhpcy5fY3VycmVudFRyYWNrLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IGxheWVyLnNlbGVjdGVkRGF0dW1zO1xuICAgICAgY29uc3QgZGF0dW1zSW5JbnRlcnZhbCA9IGxheWVyLmdldERhdHVtc0luSW50ZXJ2YWwoaVN0YXJ0LCBpRHVyYXRpb24pO1xuXG4gICAgICB2YXIgdG9TZWxlY3Q7XG4gICAgICB2YXIgdG9VbnNlbGVjdDtcblxuICAgICAgLy8gaWYgaXMgbm90IHByZXNzZWRcbiAgICAgIGlmICghZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5KSB7ICAgICAgICBcblxuICAgICAgICB0b1Vuc2VsZWN0ID0gbmV3IFNldChjdXJyZW50U2VsZWN0aW9uKTtcbiAgICAgICAgdG9TZWxlY3QgPSBuZXcgU2V0KGRhdHVtc0luSW50ZXJ2YWwpO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHRvU2VsZWN0ID0gbmV3IFNldCgpO1xuICAgICAgICB0b1Vuc2VsZWN0ID0gbmV3IFNldCgpO1xuICAgICAgICAvLyB1c2UgdGhlIHNlbGVjdGlvbiBmcm9tIHRoZSBwcmV2aW91cyBkcmFnXG4gICAgICAgIGNvbnN0IHByZXZpb3VzU2VsZWN0aW9uID0gdGhpcy5fbGF5ZXJTZWxlY3RlZEl0ZW1zTWFwLmdldChsYXllcik7XG4gICAgICAgIFxuXG4gICAgICAgIGRhdHVtc0luSW50ZXJ2YWwuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgICAgICBpZiAoIXByZXZpb3VzU2VsZWN0aW9uLmhhcyhkYXR1bSkpIHtcbiAgICAgICAgICAgIHRvU2VsZWN0LmFkZChkYXR1bSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvVW5zZWxlY3QuYWRkKGRhdHVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGN1cnJlbnRTZWxlY3Rpb24uZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgICAgICBpZiAoIWRhdHVtc0luSW50ZXJ2YWwuaGFzKGRhdHVtKSAmJiAhcHJldmlvdXNTZWxlY3Rpb24uaGFzKGRhdHVtKSkge1xuICAgICAgICAgICAgdG9VbnNlbGVjdC5hZGQoZGF0dW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJldmlvdXNTZWxlY3Rpb24uZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgICAgICBpZiAoIWRhdHVtc0luSW50ZXJ2YWwuaGFzKGRhdHVtKSkge1xuICAgICAgICAgICAgdG9TZWxlY3QuYWRkKGRhdHVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICB9XG5cbiAgICAgIGxheWVyLnVuc2VsZWN0KHRvVW5zZWxlY3QpO1xuICAgICAgbGF5ZXIuc2VsZWN0KHRvU2VsZWN0KTtcblxuICAgICAgbGF5ZXIudXBkYXRlU2hhcGVzKGN1cnJlbnRTZWxlY3Rpb24pO1xuICAgICAgbGF5ZXIudXBkYXRlU2hhcGVzKGRhdHVtc0luSW50ZXJ2YWwpO1xuICAgIH0pO1xuICB9XG5cbiAgb25Nb3VzZVVwKGUpIHtcbiAgICB0aGlzLl9yZW1vdmVCcnVzaCh0aGlzLl9jdXJyZW50VHJhY2spO1xuICAgIHRoaXMubW91c2Vkb3duID0gZmFsc2U7XG4gICAgdGhpcy53YXNNb3ZpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIG9uQ2xpY2soZSkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdjbGljaycpO1xuICAgIGlmICghdGhpcy5fY3VycmVudFRyYWNrKSB7IHJldHVybjsgfVxuICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xuXG4gICAgdGhpcy5fY3VycmVudFRyYWNrLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuXG4gICAgICBjb25zdCBzaGFwZSA9IGUudGFyZ2V0LnNoYXBlO1xuICAgICAgY29uc3QgZGF0dW0gPSBsYXllci5nZXREYXR1bUZyb21TaGFwZShzaGFwZSk7XG4gICAgICB2YXIgdG9VcGRhdGUgPSBuZXcgU2V0KCk7XG5cbiAgICAgIC8vVE9ETzogY29ycmVjdCB0aGlzIGJlY2F1c2UgaXQgaXMgbm90IHdvcmtpbmcgYXMgSSBleHBlY3RlZCB0by4gIFxuICAgICAgaWYgKCFlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgdG9VcGRhdGUgPSBuZXcgU2V0KGxheWVyLnNlbGVjdGVkRGF0dW1zKTtcbiAgICAgICAgbGF5ZXIudW5zZWxlY3QobGF5ZXIuc2VsZWN0ZWREYXR1bXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0dW0pIHtcbiAgICAgICAgdG9VcGRhdGUuYWRkKGRhdHVtKTtcbiAgICAgICAgbGF5ZXIudG9nZ2xlU2VsZWN0aW9uKFtkYXR1bV0pO1xuICAgICAgfVxuXG4gICAgICBsYXllci51cGRhdGVTaGFwZXModG9VcGRhdGUpO1xuXG4gICAgfSk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlU3RhdGUgZnJvbSAnLi9iYXNlLXN0YXRlJztcbmltcG9ydCBLb252YSBmcm9tICdrb252YSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlbGVjdGlvblN0YXRlIGV4dGVuZHMgQmFzZVN0YXRlIHtcblxuICBjb25zdHJ1Y3Rvcih0aW1lbGluZSAvKiwgb3B0aW9ucyA9IHt9ICovKSB7XG4gICAgc3VwZXIodGltZWxpbmUgLyosIG9wdGlvbnMgKi8pO1xuXG4gICAgdGhpcy5jdXJyZW50TGF5ZXIgPSB1bmRlZmluZWQ7XG4gICAgLy8gbmVlZCBhIGNhY2hlZFxuICAgIHRoaXMuc2VsZWN0ZWREYXR1bXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tb3VzZURvd24gPSBmYWxzZTtcbiAgICB0aGlzLnNoaWZ0S2V5ID0gZmFsc2U7XG5cbiAgICB0aGlzLl9sYXllclNlbGVjdGVkSXRlbXNNYXAgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBlbnRlcigpIHtcblxuICB9XG5cbiAgZXhpdCgpIHtcbiAgICBjb25zdCBjb250YWluZXJzID0gdGhpcy50aW1lbGluZS5jb250YWluZXJzO1xuXG4gICAgZm9yIChsZXQgaWQgaW4gY29udGFpbmVycykge1xuICAgICAgdGhpcy5fcmVtb3ZlQnJ1c2goY29udGFpbmVyc1tpZF0pO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlRG93bihlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICB0aGlzLm9uTW91c2VNb3ZlKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgICB0aGlzLm9uTW91c2VVcChlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjbGljayc6XG4gICAgICAgIHRoaXMub25DbGljayhlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdrZXlkb3duJzpcbiAgICAgICAgdGhpcy5vbktleShlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdrZXl1cCc6XG4gICAgICAgIHRoaXMub25LZXkoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIF9hZGRCcnVzaCh0cmFjaykge1xuICAgIGlmICh0cmFjay4kYnJ1c2gpIHsgcmV0dXJuOyB9XG5cbiAgICBjb25zdCBicnVzaCA9IG5ldyBLb252YS5SZWN0KHt9KTtcbiAgICBicnVzaC5maWxsKCcjNjg2ODY4Jykub3BhY2l0eSgwLjUpO1xuXG4gICAgdHJhY2suJGludGVyYWN0aW9uc0xheWVyLmFkZChicnVzaCk7XG4gICAgdHJhY2suJGludGVyYWN0aW9uc0xheWVyLm1vdmVUb1RvcCgpO1xuXG4gICAgdHJhY2suJGJydXNoID0gYnJ1c2g7XG5cbiAgICB0cmFjay4kaW50ZXJhY3Rpb25zTGF5ZXIuYmF0Y2hEcmF3KCk7XG4gIH1cblxuICBfcmVtb3ZlQnJ1c2godHJhY2spIHtcbiAgICBpZiAodHJhY2suJGJydXNoID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLl9yZXNldEJydXNoKHRyYWNrKTtcblxuICAgIHRyYWNrLiRicnVzaC5kZXN0cm95KCk7XG5cbiAgICB0cmFjay4kaW50ZXJhY3Rpb25zTGF5ZXIuYmF0Y2hEcmF3KCk7XG5cbiAgICBkZWxldGUgdHJhY2suJGJydXNoO1xuICB9XG5cbiAgX3Jlc2V0QnJ1c2godHJhY2spIHtcbiAgICBjb25zdCAkYnJ1c2ggPSB0cmFjay4kYnJ1c2g7XG4gICAgLy8gcmVzZXQgYnJ1c2ggZWxlbWVudFxuICAgICRicnVzaC54KDApLnkoMCkud2lkdGgoMCkuaGVpZ2h0KDApO1xuICAgIHRyYWNrLiRpbnRlcmFjdGlvbnNMYXllci5iYXRjaERyYXcoKTtcbiAgfVxuXG4gIF91cGRhdGVCcnVzaChlLCB0cmFjaykge1xuICAgIGNvbnN0ICRicnVzaCA9IHRyYWNrLiRicnVzaDtcblxuICAgICRicnVzaC54KGUuYXJlYS5sZWZ0KS55KGUuYXJlYS50b3ApLndpZHRoKGUuYXJlYS53aWR0aCkuaGVpZ2h0KGUuYXJlYS5oZWlnaHQpO1xuICAgIHRyYWNrLiRpbnRlcmFjdGlvbnNMYXllci5iYXRjaERyYXcoKTtcbiAgfVxuXG4gIG9uS2V5KGUpIHtcbiAgICB0aGlzLnNoaWZ0S2V5ID0gZS5zaGlmdEtleTtcbiAgfVxuXG4gIG9uTW91c2VEb3duKGUpIHtcbiAgICB0aGlzLl9jdXJyZW50VHJhY2sgPSB0aGlzLnRpbWVsaW5lLmdldFRyYWNrRnJvbURPTUVsZW1lbnQoZS5jdXJyZW50VGFyZ2V0KTtcblxuICAgIGlmICghdGhpcy5fY3VycmVudFRyYWNrKSB7IHJldHVybjsgfVxuXG4gICAgdGhpcy5fYWRkQnJ1c2godGhpcy5fY3VycmVudFRyYWNrKTtcblxuICAgIC8vIHJlY3JlYXRlIHRoZSBtYXBcbiAgICB0aGlzLl9sYXllclNlbGVjdGVkSXRlbXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fY3VycmVudFRyYWNrLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgICAgY29uc3QgYXV4ID0gW107XG4gICAgICBsYXllci5zZWxlY3RlZERhdHVtcy5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICBhdXgucHVzaChkYXR1bSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2xheWVyU2VsZWN0ZWRJdGVtc01hcC5zZXQobGF5ZXIsIGF1eC5zbGljZSgwKSk7XG4gICAgfSk7XG4gIH1cblxuICBvbk1vdXNlTW92ZShlKSB7XG4gICAgY29uc29sZS5sb2coZS5hcmVhKTtcbiAgICBcbiAgICB0aGlzLl91cGRhdGVCcnVzaChlLCB0aGlzLl9jdXJyZW50VHJhY2spO1xuXG4gICAgdGhpcy5fY3VycmVudFRyYWNrLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IGxheWVyLnNlbGVjdGVkRGF0dW1zO1xuICAgICAgY29uc3QgY3VycmVudEl0ZW1zID0gbGF5ZXIuZ2V0RGF0dW1zSW5BcmVhKGUuYXJlYSk7XG5cbiAgICAgIC8vIGlmIGlzIG5vdCBwcmVzc2VkXG4gICAgICBpZiAoIWUub3JpZ2luYWxFdmVudC5zaGlmdEtleSkge1xuICAgICAgICBsYXllci51bnNlbGVjdChjdXJyZW50U2VsZWN0aW9uKTtcbiAgICAgICAgbGF5ZXIuc2VsZWN0KGN1cnJlbnRJdGVtcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0b1NlbGVjdCA9IFtdO1xuICAgICAgICBjb25zdCB0b1Vuc2VsZWN0ID0gW107XG4gICAgICAgIC8vIHVzZSB0aGUgc2VsZWN0aW9uIGZyb20gdGhlIHByZXZpb3VzIGRyYWdcbiAgICAgICAgY29uc3QgcHJldmlvdXNTZWxlY3Rpb24gPSB0aGlzLl9sYXllclNlbGVjdGVkSXRlbXNNYXAuZ2V0KGxheWVyKTtcbiAgICAgICAgLy8gdG9VbnNlbGVjdCA9IHRvVW5zZWxlY3QuY29uY2F0KHByZXZpb3VzU2VsZWN0ZWRJdGVtcyk7XG5cbiAgICAgICAgY3VycmVudEl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICBpZiAocHJldmlvdXNTZWxlY3Rpb24uaW5kZXhPZihpdGVtKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRvU2VsZWN0LnB1c2goaXRlbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvVW5zZWxlY3QucHVzaChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGN1cnJlbnRTZWxlY3Rpb24uZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGN1cnJlbnRJdGVtcy5pbmRleE9mKGl0ZW0pID09PSAtMSAmJlxuICAgICAgICAgICAgcHJldmlvdXNTZWxlY3Rpb24uaW5kZXhPZihpdGVtKSA9PT0gLTFcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRvVW5zZWxlY3QucHVzaChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxheWVyLnVuc2VsZWN0KHRvVW5zZWxlY3QpO1xuICAgICAgICBsYXllci5zZWxlY3QodG9TZWxlY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgb25Nb3VzZVVwKGUpIHtcbiAgICB0aGlzLl9yZW1vdmVCcnVzaCh0aGlzLl9jdXJyZW50VHJhY2spO1xuICB9XG5cbiAgb25DbGljayhlKSB7XG4gICAgaWYgKCF0aGlzLl9jdXJyZW50VHJhY2spIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLl9jdXJyZW50VHJhY2subGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiB7XG4gICAgICBjb25zdCBzaGFwZSA9IGUudGFyZ2V0LnNoYXBlO1xuICAgICAgY29uc3QgZGF0dW0gPSBsYXllci5nZXREYXR1bUZyb21TaGFwZShzaGFwZSk7XG5cbiAgICAgIGlmICghZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgIGxheWVyLnVuc2VsZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXR1bSkge1xuICAgICAgICBsYXllci50b2dnbGVTZWxlY3Rpb24oW2RhdHVtXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlU3RhdGUgZnJvbSAnLi9iYXNlLXN0YXRlJztcbmltcG9ydCBLb252YSBmcm9tICdrb252YSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYXBlSW5zZXJ0aW9uU3RhdGUgZXh0ZW5kcyBCYXNlU3RhdGUge1xuXG4gIGNvbnN0cnVjdG9yKHRpbWVsaW5lIC8qLCBvcHRpb25zID0ge30gKi8pIHtcbiAgICBzdXBlcih0aW1lbGluZSAvKiwgb3B0aW9ucyAqLyk7XG5cbiAgICB0aGlzLl9sYXllclNlbGVjdGVkSXRlbXNNYXAgPSBuZXcgTWFwKCk7XG5cbiAgICB0aGlzLnNoaWZ0S2V5ID0gZmFsc2U7XG5cbiAgICB0aGlzLndhc01vdmluZyA9IGZhbHNlO1xuICB9XG5cbiAgc2V0IHRhcmdldExheWVyKGxheWVyKSB7XG4gICAgdGhpcy5fbGF5ZXIgPSBsYXllcjtcbiAgfVxuXG4gIGdldCB0YXJnZXRMYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5fbGF5ZXI7XG4gIH1cblxuICBlbnRlcigpIHtcbiAgICAvLyBUT0RPXG4gIH1cblxuICBleGl0KCkge1xuICAgIC8vIFRPRE9cbiAgICBjb25zdCBjb250YWluZXJzID0gdGhpcy50aW1lbGluZS5jb250YWluZXJzO1xuXG4gICAgZm9yIChsZXQgaWQgaW4gY29udGFpbmVycykge1xuICAgICAgdGhpcy5fcmVtb3ZlQnJ1c2goY29udGFpbmVyc1tpZF0pO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlRG93bihlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICB0aGlzLm9uTW91c2VNb3ZlKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgICB0aGlzLm9uTW91c2VVcChlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjbGljayc6XG4gICAgICAgIHRoaXMub25DbGljayhlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdrZXlkb3duJzpcbiAgICAgICAgdGhpcy5vbktleShlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdrZXl1cCc6XG4gICAgICAgIHRoaXMub25LZXkoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIF9hZGRCcnVzaCh0cmFjaykge1xuICAgIGlmICh0cmFjay4kYnJ1c2gpIHsgcmV0dXJuOyB9XG5cbiAgICBjb25zdCBicnVzaCA9IG5ldyBLb252YS5SZWN0KHt9KTtcbiAgICBicnVzaC5maWxsKCcjNjg2ODY4Jykub3BhY2l0eSgwLjUpO1xuXG4gICAgdHJhY2suJGludGVyYWN0aW9uc0xheWVyLmFkZChicnVzaCk7XG4gICAgdHJhY2suJGludGVyYWN0aW9uc0xheWVyLm1vdmVUb1RvcCgpO1xuXG4gICAgdHJhY2suJGJydXNoID0gYnJ1c2g7XG5cbiAgICB0cmFjay4kaW50ZXJhY3Rpb25zTGF5ZXIuYmF0Y2hEcmF3KCk7XG4gIH1cblxuICBfcmVtb3ZlQnJ1c2godHJhY2spIHtcbiAgICBpZiAodHJhY2suJGJydXNoID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLl9yZXNldEJydXNoKHRyYWNrKTtcblxuICAgIHRyYWNrLiRicnVzaC5kZXN0cm95KCk7XG5cbiAgICB0cmFjay4kaW50ZXJhY3Rpb25zTGF5ZXIuYmF0Y2hEcmF3KCk7XG5cbiAgICBkZWxldGUgdHJhY2suJGJydXNoO1xuICB9XG5cbiAgX3Jlc2V0QnJ1c2godHJhY2spIHtcbiAgICBjb25zdCAkYnJ1c2ggPSB0cmFjay4kYnJ1c2g7XG4gICAgLy8gcmVzZXQgYnJ1c2ggZWxlbWVudFxuICAgICRicnVzaC54KDApLnkoMCkud2lkdGgoMCkuaGVpZ2h0KDApO1xuICAgIHRyYWNrLiRpbnRlcmFjdGlvbnNMYXllci5iYXRjaERyYXcoKTtcbiAgfVxuXG4gIF91cGRhdGVCcnVzaChlLCB0cmFjaykge1xuICAgIGNvbnN0ICRicnVzaCA9IHRyYWNrLiRicnVzaDtcblxuICAgICRicnVzaC54KGUuYXJlYS5sZWZ0KS55KDApLndpZHRoKGUuYXJlYS53aWR0aCkuaGVpZ2h0KHRyYWNrLmhlaWdodCk7XG4gICAgdHJhY2suJGludGVyYWN0aW9uc0xheWVyLmJhdGNoRHJhdygpO1xuICB9XG5cbiAgb25LZXkoZSkge1xuICAgIHRoaXMuc2hpZnRLZXkgPSBlLnNoaWZ0S2V5O1xuICB9XG5cbiAgb25Nb3VzZURvd24oZSkge1xuICAgIHRoaXMuX2N1cnJlbnRUcmFjayA9IHRoaXMudGltZWxpbmUuZ2V0VHJhY2tGcm9tRE9NRWxlbWVudChlLmN1cnJlbnRUYXJnZXQpO1xuXG4gICAgaWYgKCF0aGlzLl9jdXJyZW50VHJhY2spIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLl9hZGRCcnVzaCh0aGlzLl9jdXJyZW50VHJhY2spO1xuXG4gICAgLy8gcmVjcmVhdGUgdGhlIG1hcFxuICAgIHRoaXMuX2xheWVyU2VsZWN0ZWRJdGVtc01hcCA9IG5ldyBNYXAoKTtcbiAgICBcbiAgICB0aGlzLl9jdXJyZW50VHJhY2subGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiB7XG4gICAgICBcbiAgICAgIGlmICghZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgIGNvbnN0IGF1eCA9IG5ldyBTZXQobGF5ZXIuc2VsZWN0ZWREYXR1bXMpO1xuICAgICAgICBsYXllci51bnNlbGVjdChhdXgpO1xuICAgICAgICBsYXllci51cGRhdGVTaGFwZXMoYXV4KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbGF5ZXJTZWxlY3RlZEl0ZW1zTWFwLnNldChsYXllciwgbmV3IFNldChsYXllci5zZWxlY3RlZERhdHVtcykpO1xuICAgICAgXG4gICAgfSk7XG4gIH1cblxuICBvbk1vdXNlTW92ZShlKSB7XG5cbiAgICB0aGlzLndhc01vdmluZyA9IHRydWU7XG5cbiAgICBlLmFyZWEgPSB7bGVmdDogZS5hcmVhLmxlZnQsIHdpZHRoOmUuYXJlYS53aWR0aCwgdG9wOiAwLCBoZWlnaHQ6IHRoaXMuX2N1cnJlbnRUcmFjay5oZWlnaHQgfTtcbiAgICBcbiAgICB0aGlzLl91cGRhdGVCcnVzaChlLCB0aGlzLl9jdXJyZW50VHJhY2spO1xuXG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XG5cbiAgICB0aGlzLl9jdXJyZW50VHJhY2subGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50U2VsZWN0aW9uID0gbGF5ZXIuc2VsZWN0ZWREYXR1bXM7XG4gICAgICBjb25zdCBkYXR1bXNJbkFyZWEgPSBsYXllci5nZXREYXR1bXNJbkFyZWEoZS5hcmVhKTtcblxuICAgICAgdmFyIHRvU2VsZWN0O1xuICAgICAgdmFyIHRvVW5zZWxlY3Q7XG5cbiAgICAgIC8vIGlmIGlzIG5vdCBwcmVzc2VkXG4gICAgICBpZiAoIWUub3JpZ2luYWxFdmVudC5zaGlmdEtleSkgeyAgICAgICAgXG5cbiAgICAgICAgdG9VbnNlbGVjdCA9IG5ldyBTZXQoY3VycmVudFNlbGVjdGlvbik7XG4gICAgICAgIHRvU2VsZWN0ID0gbmV3IFNldChkYXR1bXNJbkFyZWEpO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHRvU2VsZWN0ID0gbmV3IFNldCgpO1xuICAgICAgICB0b1Vuc2VsZWN0ID0gbmV3IFNldCgpO1xuICAgICAgICAvLyB1c2UgdGhlIHNlbGVjdGlvbiBmcm9tIHRoZSBwcmV2aW91cyBkcmFnXG4gICAgICAgIGNvbnN0IHByZXZpb3VzU2VsZWN0aW9uID0gdGhpcy5fbGF5ZXJTZWxlY3RlZEl0ZW1zTWFwLmdldChsYXllcik7XG4gICAgICAgIFxuXG4gICAgICAgIGRhdHVtc0luQXJlYS5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICAgIGlmICghcHJldmlvdXNTZWxlY3Rpb24uaGFzKGRhdHVtKSkge1xuICAgICAgICAgICAgdG9TZWxlY3QuYWRkKGRhdHVtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9VbnNlbGVjdC5hZGQoZGF0dW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY3VycmVudFNlbGVjdGlvbi5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICAgIGlmICghZGF0dW1zSW5BcmVhLmhhcyhkYXR1bSkgJiYgIXByZXZpb3VzU2VsZWN0aW9uLmhhcyhkYXR1bSkpIHtcbiAgICAgICAgICAgIHRvVW5zZWxlY3QuYWRkKGRhdHVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByZXZpb3VzU2VsZWN0aW9uLmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICAgICAgaWYgKCFkYXR1bXNJbkFyZWEuaGFzKGRhdHVtKSkge1xuICAgICAgICAgICAgdG9TZWxlY3QuYWRkKGRhdHVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICB9XG5cbiAgICAgIGxheWVyLnVuc2VsZWN0KHRvVW5zZWxlY3QpO1xuICAgICAgbGF5ZXIuc2VsZWN0KHRvU2VsZWN0KTtcblxuICAgICAgbGF5ZXIudXBkYXRlU2hhcGVzKGN1cnJlbnRTZWxlY3Rpb24pO1xuICAgICAgbGF5ZXIudXBkYXRlU2hhcGVzKGRhdHVtc0luQXJlYSk7XG4gICAgfSk7XG4gIH1cblxuICBvbk1vdXNlVXAoZSkge1xuICAgIHRoaXMuX3JlbW92ZUJydXNoKHRoaXMuX2N1cnJlbnRUcmFjayk7XG4gICAgaWYgKHRoaXMud2FzTW92aW5nKSB7XG4gICAgICB0aGlzLndhc01vdmluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIG9uQ2xpY2soZSkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdjbGljaycpO1xuICAgIGlmICghdGhpcy5fY3VycmVudFRyYWNrKSB7IHJldHVybjsgfVxuICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xuXG4gICAgdGhpcy5fY3VycmVudFRyYWNrLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuXG4gICAgICBjb25zdCBzaGFwZSA9IGUudGFyZ2V0LnNoYXBlO1xuICAgICAgY29uc3QgZGF0dW0gPSBsYXllci5nZXREYXR1bUZyb21TaGFwZShzaGFwZSk7XG4gICAgICB2YXIgdG9VcGRhdGUgPSBuZXcgU2V0KCk7XG5cbiAgICAgIC8vVE9ETzogY29ycmVjdCB0aGlzIGJlY2F1c2UgaXQgaXMgbm90IHdvcmtpbmcgYXMgSSBleHBlY3RlZCB0by4gIFxuICAgICAgaWYgKCFlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgdG9VcGRhdGUgPSBuZXcgU2V0KGxheWVyLnNlbGVjdGVkRGF0dW1zKTtcbiAgICAgICAgbGF5ZXIudW5zZWxlY3QobGF5ZXIuc2VsZWN0ZWREYXR1bXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0dW0pIHtcbiAgICAgICAgdG9VcGRhdGUuYWRkKGRhdHVtKTtcbiAgICAgICAgbGF5ZXIudG9nZ2xlU2VsZWN0aW9uKFtkYXR1bV0pO1xuICAgICAgfVxuXG4gICAgICBsYXllci51cGRhdGVTaGFwZXModG9VcGRhdGUpO1xuXG4gICAgfSk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlU3RhdGUgZnJvbSAnLi9iYXNlLXN0YXRlJztcblxuXG4vKipcbiAqIEEgc3RhdGUgdG8gc2VsZWN0IGFuZCBlZGl0IHNoYXBlcyBpbiBhIHNpbXBsZSB3YXkuIChraW5kIG9mIHBsdWcgbiBwbGF5IHN0YXRlKVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaW1wbGVFZGl0aW9uU3RhdGUgZXh0ZW5kcyBCYXNlU3RhdGUge1xuICBjb25zdHJ1Y3Rvcih0aW1lbGluZSwgYXV0b1VwZGF0ZVNoYXBlcykge1xuICAgIHN1cGVyKHRpbWVsaW5lKTtcblxuICAgIHRoaXMuYXV0b1VwZGF0ZVNoYXBlcyA9IChhdXRvVXBkYXRlU2hhcGVzID09PSB1bmRlZmluZWQpPyB0cnVlIDogYXV0b1VwZGF0ZVNoYXBlcztcbiAgICB0aGlzLmN1cnJlbnRFZGl0ZWRMYXllciA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgfVxuXG4gIGVudGVyKCkge31cbiAgZXhpdCgpIHtcbiAgICB0aGlzLmN1cnJlbnRFZGl0ZWRMYXllciA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgfVxuXG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlRG93bihlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICB0aGlzLm9uTW91c2VNb3ZlKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgICB0aGlzLm9uTW91c2VVcChlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgb25Nb3VzZURvd24oZSkge1xuICAgIC8vIFRPRE86IGFsbG93IHNoYXBlcyBmcm9tIG11bHRpcGxlIGxheWVycyB0byBiZSBlZGl0ZWQgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAvLyBUT0RPOiBtb3ZlIHRhcmdldCBzaGFwZXMgdG8gdGhlIGRyYWcga29udmEgbGF5ZXIgb2YgZWFjaCBsYXllci5cblxuICAgIC8vIGtlZXAgdGFyZ2V0IGNvbnNpc3RlbnQgd2l0aCBtb3VzZSBkb3duXG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5jdXJyZW50VGFyZ2V0LnNoYXBlICYmIHRoaXMuY3VycmVudFRhcmdldC5zaGFwZS5pc0NvbnRleHRTaGFwZSkge1xuICAgICAgaWYgKCFlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkpIFxuICAgICAgICB0aGlzLnRpbWVsaW5lLmdldFRyYWNrRnJvbURPTUVsZW1lbnQoZS5jdXJyZW50VGFyZ2V0KS5sYXllcnMuZm9yRWFjaCgobGF5ZXIpID0+IHtcbiAgICAgICAgICBjb25zdCBhdXggPSBuZXcgU2V0KGxheWVyLnNlbGVjdGVkRGF0dW1zKTtcbiAgICAgICAgICBsYXllci51bnNlbGVjdChsYXllci5zZWxlY3RlZERhdHVtcyk7XG4gICAgICAgICAgaWYgKHRoYXQuYXV0b1VwZGF0ZVNoYXBlcykgXG4gICAgICAgICAgICBsYXllci51cGRhdGVTaGFwZXMoYXV4KTtcbiAgICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICghdGhpcy5jdXJyZW50VGFyZ2V0LnNoYXBlKSB7XG4gICAgICBpZiAoIWUub3JpZ2luYWxFdmVudC5zaGlmdEtleSkgXG4gICAgICAgIHRoaXMudGltZWxpbmUuZ2V0VHJhY2tGcm9tRE9NRWxlbWVudChlLmN1cnJlbnRUYXJnZXQpLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgICAgICAgIGNvbnN0IGF1eCA9IG5ldyBTZXQobGF5ZXIuc2VsZWN0ZWREYXR1bXMpO1xuICAgICAgICAgIGxheWVyLnVuc2VsZWN0KGxheWVyLnNlbGVjdGVkRGF0dW1zKTtcbiAgICAgICAgICBpZiAodGhhdC5hdXRvVXBkYXRlU2hhcGVzKVxuICAgICAgICAgICAgbGF5ZXIudXBkYXRlU2hhcGVzKGF1eCk7XG4gICAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5jdXJyZW50VGFyZ2V0LnNoYXBlLmxheWVyO1xuXG4gICAgY29uc3QgYSA9IG5ldyBTZXQobGF5ZXIuc2VsZWN0ZWREYXR1bXMpO1xuXG4gICAgaWYgKHRoaXMuY3VycmVudFRhcmdldC5zaGFwZS5sYXllcikge1xuICAgICAgaWYgKCFlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgdGhpcy50aW1lbGluZS5nZXRUcmFja0Zyb21ET01FbGVtZW50KGUuY3VycmVudFRhcmdldCkubGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiBsYXllci51bnNlbGVjdChsYXllci5zZWxlY3RlZERhdHVtcykpO1xuICAgICAgfVxuICAgICAgdGhpcy5jdXJyZW50RWRpdGVkTGF5ZXIgPSBsYXllcjtcbiAgICAgIGNvbnN0IGRhdHVtID0gbGF5ZXIuZ2V0RGF0dW1Gcm9tU2hhcGUodGhpcy5jdXJyZW50VGFyZ2V0LnNoYXBlKTtcbiAgICAgIGlmIChkYXR1bSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxheWVyLnNlbGVjdChbZGF0dW1dKTtcbiAgICAgICAgYS5hZGQoZGF0dW0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoYXQuYXV0b1VwZGF0ZVNoYXBlcylcbiAgICAgICAgbGF5ZXIudXBkYXRlU2hhcGVzKGEpO1xuICAgICAgdGhpcy5jdXJyZW50RWRpdGVkTGF5ZXIuc2VsZWN0ZWREYXR1bXMuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgICAgdGhhdC5jdXJyZW50RWRpdGVkTGF5ZXIuZ2V0U2hhcGVGcm9tRGF0dW0oZGF0dW0pLnN0YXJ0RHJhZygpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICBsYXllci51bnNlbGVjdChsYXllci5zZWxlY3RlZERhdHVtcyk7XG4gICAgICBpZiAodGhhdC5hdXRvVXBkYXRlU2hhcGVzKVxuICAgICAgICBsYXllci51cGRhdGVTaGFwZXMoYSk7XG4gICAgICB0aGlzLmN1cnJlbnRFZGl0ZWRMYXllci5zZWxlY3RlZERhdHVtcy5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICB0aGF0LmN1cnJlbnRFZGl0ZWRMYXllci5nZXRTaGFwZUZyb21EYXR1bShkYXR1bSkuc3RhcnREcmFnKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBvbk1vdXNlTW92ZShlKSB7XG4gICAgLy8gVE9ETzogYWxsb3cgc2hhcGVzIGZyb20gbXVsdGlwbGUgbGF5ZXJzIHRvIGJlIGVkaXRlZCBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIC8vIFRPRE86IG1vdmUgdGFyZ2V0IHNoYXBlcyB0byB0aGUgZHJhZyBrb252YSBsYXllciBvZiBlYWNoIGxheWVyLlxuXG4gICAgaWYgKCF0aGlzLmN1cnJlbnRFZGl0ZWRMYXllcikgeyByZXR1cm47IH1cblxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5jdXJyZW50RWRpdGVkTGF5ZXI7XG4gICAgY29uc3QgZGF0dW1zID0gbGF5ZXIuc2VsZWN0ZWREYXR1bXM7XG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XG5cbiAgICBsYXllci5lZGl0KGRhdHVtcywgZS5keCwgZS5keSwgdGhpcy5jdXJyZW50VGFyZ2V0KTtcbiAgICBpZiAodGhhdC5hdXRvVXBkYXRlU2hhcGVzKVxuICAgICAgbGF5ZXIudXBkYXRlU2hhcGVzKGRhdHVtcyk7XG4gIH1cblxuICBvbk1vdXNlVXAoZSkge1xuICAgIC8vIFRPRE86IGFsbG93IHNoYXBlcyBmcm9tIG11bHRpcGxlIGxheWVycyB0byBiZSBlZGl0ZWQgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAvLyBUT0RPOiB1c2UgTGF5ZXIuYWxsb2NhdGVTaGFwZXNUb0NvbnRlbnRMYXllcnMgdG8gbW92ZSB0aGUgdGFyZ2V0IHNoYXBlcyBmcm9tIHRoZSBkcmFnIGtvbnZhIGxheWVycyB0byBhIGNvbnRlbnQga29udmEgbGF5ZXIuXG5cbiAgICBjb25zdCB0aGF0ID0gdGhpcztcbiAgICBjb25zdCBsYXllciA9IHRoaXMuY3VycmVudEVkaXRlZExheWVyO1xuXG4gICAgaWYgKCFsYXllcikgcmV0dXJuO1xuXG4gICAgaWYgKHRoYXQuYXV0b1VwZGF0ZVNoYXBlcylcbiAgICAgIGxheWVyLnVwZGF0ZVNoYXBlcyhsYXllci5zZWxlY3RlZERhdHVtcyk7XG4gICAgbGF5ZXIuc2VsZWN0ZWREYXR1bXMuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgIGxheWVyLmdldFNoYXBlRnJvbURhdHVtKGRhdHVtKS5zdG9wRHJhZygpO1xuICAgIH0pO1xuICAgIHRoaXMuY3VycmVudEVkaXRlZExheWVyID0gbnVsbDtcbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQge1xuICBwYWRMZWZ0KGlucHV0LCBzaWduLCBsZW5ndGgpIHtcbiAgICBpbnB1dCArPSAnJztcbiAgICB3aGlsZSAoaW5wdXQubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICBpbnB1dCA9IHNpZ24gKyBpbnB1dDtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE9ydGhvZ29uYWxEYXRhIHRyYW5zZm9ybXMgYW4gb2JqZWN0IG9mIGFycmF5cyBge2ZvbzogWzEsIDJdLCBiYXI6IFszLCA0XX1gXG4gKiB0byBvciBmcm9tIGFuIGFycmF5IG9mIG9iamVjdHMgYFt7Zm9vOiAxLCBiYXI6IDN9LCB7Zm9vOiAyLCBiYXI6IDR9XWBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3J0aG9nb25hbERhdGEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9jb2xzID0gbnVsbDsgLy8gT2JqZWN0IG9mIGFycmF5c1xuICAgIHRoaXMuX3Jvd3MgPSBudWxsOyAvLyBBcnJheSBvZiBvYmplY3RzXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgdGhlIGNvbnNpc3RlbmN5IG9mIHRoZSBkYXRhLlxuICAgKi9cbiAgX2NoZWNrQ29uc2lzdGVuY3koKSB7XG4gICAgbGV0IHNpemUgPSBudWxsO1xuXG4gICAgZm9yIChsZXQga2V5IGluIHRoaXMuX2NvbHMpIHtcbiAgICAgIGNvbnN0IGNvbCA9IHRoaXMuX2NvbHNba2V5XTtcbiAgICAgIGNvbnN0IGNvbExlbmd0aCA9IGNvbC5sZW5ndGg7XG5cbiAgICAgIGlmIChzaXplICE9PSBudWxsICYmIHNpemUgIT09IGNvbExlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5wcm90b3R5cGUuY29uc3RydWN0b3IubmFtZX06IGluY29uc2lzdGVudCBkYXRhYCk7XG4gICAgICB9IGVsc2UgaWYgKHNpemUgPT09IG51bGwpIHtcbiAgICAgICAgc2l6ZSA9IGNvbExlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBhcnJheSBvZiBvYmplY3RzIGZyb20gb2JqZWN0IG9mIGFycmF5cy5cbiAgICovXG4gIHVwZGF0ZUZyb21Db2xzKCkge1xuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5fY29scyk7XG5cbiAgICBrZXlzLmZvckVhY2goKGtleSwgaSkgPT4ge1xuICAgICAgY29uc3QgY29sID0gdGhpcy5fY29sc1trZXldO1xuXG4gICAgICBjb2wuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9yb3dzW2luZGV4XSA9PT0gdW5kZWZpbmVkKSB0aGlzLl9yb3dzW2luZGV4XSA9IHt9O1xuICAgICAgICB0aGlzLl9yb3dzW2luZGV4XVtrZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2NoZWNrQ29uc2lzdGVuY3koKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIG9iamVjdCBvZiBhcnJheXMgZnJvbSBhcnJheSBvZiBvYmplY3RzLlxuICAgKi9cbiAgdXBkYXRlRnJvbVJvd3MoKSB7XG4gICAgdGhpcy5fcm93cy5mb3JFYWNoKChvYmosIGluZGV4KSA9PiB7XG4gICAgICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkgdGhpcy5fY29sc1trZXldID0gW107XG4gICAgICAgIHRoaXMuX2NvbHNba2V5XS5wdXNoKG9ialtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX2NoZWNrQ29uc2lzdGVuY3koKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIG9iamVjdCBvZiBhcnJheXMuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3Q8U3RyaW5nLCBBcnJheT59XG4gICAqL1xuICBzZXQgY29scyhvYmopIHtcbiAgICB0aGlzLl9jb2xzID0gb2JqO1xuICAgIHRoaXMuX3Jvd3MgPSBbXTtcblxuICAgIHRoaXMudXBkYXRlRnJvbUNvbHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCBvZiBhcnJheXMuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3Q8U3RyaW5nLCBBcnJheT59XG4gICAqL1xuICBnZXQgY29scygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29scztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxPYmplY3Q+fVxuICAgKi9cbiAgc2V0IHJvd3MoYXJyKSB7XG4gICAgdGhpcy5fcm93cyA9IGFycjtcbiAgICB0aGlzLl9jb2xzID0ge307XG5cbiAgICB0aGlzLnVwZGF0ZUZyb21Sb3dzKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzLlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8T2JqZWN0Pn1cbiAgICovXG4gIGdldCByb3dzKCkge1xuICAgIHJldHVybiB0aGlzLl9yb3dzO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbGluZWFyKCkge1xuICAgIGxldCBfZG9tYWluID0gWzAsIDFdO1xuICAgIGxldCBfcmFuZ2UgPSBbMCwgMV07XG5cbiAgICBsZXQgX3Nsb3BlID0gMTtcbiAgICBsZXQgX2ludGVyY2VwdCA9IDA7XG5cbiAgICBmdW5jdGlvbiBfdXBkYXRlQ29lZnMoKSB7XG4gICAgICBfc2xvcGUgPSAoX3JhbmdlWzFdIC0gX3JhbmdlWzBdKSAvIChfZG9tYWluWzFdIC0gX2RvbWFpblswXSk7XG4gICAgICBfaW50ZXJjZXB0ID0gX3JhbmdlWzBdIC0gKF9zbG9wZSAqIF9kb21haW5bMF0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYWxlICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIChfc2xvcGUgKiB2YWx1ZSkgKyBfaW50ZXJjZXB0O1xuICAgIH1cblxuICAgIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKHZhbHVlIC0gX2ludGVyY2VwdCkgLyBfc2xvcGU7XG4gICAgfTtcblxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKGFyciA9IG51bGwpIHtcbiAgICAgIGlmIChhcnIgPT09IG51bGwpIHsgcmV0dXJuIF9kb21haW47IH1cblxuICAgICAgX2RvbWFpbiA9IGFycjtcbiAgICAgIF91cGRhdGVDb2VmcygpO1xuXG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcblxuICAgIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oYXJyID0gbnVsbCkge1xuICAgICAgaWYgKGFyciA9PT0gbnVsbCkgeyByZXR1cm4gX3JhbmdlOyB9XG5cbiAgICAgIF9yYW5nZSA9IGFycjtcbiAgICAgIF91cGRhdGVDb2VmcygpO1xuXG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcblxuICAgIHJldHVybiBzY2FsZTtcbiAgfVxufTtcbiIsIi8vIGF4aXNcbmltcG9ydCBBeGlzTGF5ZXIgZnJvbSAnLi9heGlzL2F4aXMtbGF5ZXInO1xuaW1wb3J0IHRpbWVBeGlzR2VuZXJhdG9yIGZyb20gJy4vYXhpcy90aW1lLWF4aXMtZ2VuZXJhdG9yJztcbmltcG9ydCBncmlkQXhpc0dlbmVyYXRvciBmcm9tICcuL2F4aXMvZ3JpZC1heGlzLWdlbmVyYXRvcic7XG5cbi8vIGJlaGF2aW9yc1xuaW1wb3J0IEJhc2VCZWhhdmlvciBmcm9tICcuL2JlaGF2aW9ycy9iYXNlLWJlaGF2aW9yJztcbmltcG9ydCBTbmFwQmFzZUJlaGF2aW9yIGZyb20gJy4vYmVoYXZpb3JzL3NuYXAtYmFzZS1iZWhhdmlvcic7XG5pbXBvcnQgQmVhdEdyaWRTbmFwU2VnbWVudEJlaGF2aW9yIGZyb20gJy4vYmVoYXZpb3JzL2JlYXQtZ3JpZC1zbmFwLXNlZ21lbnQtYmVoYXZpb3InO1xuaW1wb3J0IEJyZWFrcG9pbnRCZWhhdmlvciBmcm9tICcuL2JlaGF2aW9ycy9icmVha3BvaW50LWJlaGF2aW9yJztcbmltcG9ydCBNYXJrZXJCZWhhdmlvciBmcm9tICcuL2JlaGF2aW9ycy9tYXJrZXItYmVoYXZpb3InO1xuaW1wb3J0IFNjcm9sbFNlZ21lbnRCZWhhdmlvciBmcm9tICcuL2JlaGF2aW9ycy9zY3JvbGwtc2VnbWVudC1iZWhhdmlvcic7XG5pbXBvcnQgU2VnbWVudEJlaGF2aW9yIGZyb20gJy4vYmVoYXZpb3JzL3NlZ21lbnQtYmVoYXZpb3InO1xuaW1wb3J0IFNpYmxpbmdMb2NrZWRTZWdtZW50QmVoYXZpb3IgZnJvbSAnLi9iZWhhdmlvcnMvc2libGluZy1sb2NrZWQtc2VnbWVudC1iZWhhdmlvcic7XG5pbXBvcnQgU2ltcGxlU25hcFNlZ21lbnRCZWhhdmlvciBmcm9tICcuL2JlaGF2aW9ycy9zaW1wbGUtc25hcC1zZWdtZW50LWJlaGF2aW9yJztcbmltcG9ydCBUaW1lQ29udGV4dEJlaGF2aW9yIGZyb20gJy4vYmVoYXZpb3JzL3RpbWUtY29udGV4dC1iZWhhdmlvcic7XG5pbXBvcnQgVHJhY2VCZWhhdmlvciBmcm9tICcuL2JlaGF2aW9ycy90cmFjZS1iZWhhdmlvcic7XG5pbXBvcnQgV2F2ZWZvcm1CZWhhdmlvciBmcm9tICcuL2JlaGF2aW9ycy93YXZlZm9ybS1iZWhhdmlvcic7XG5pbXBvcnQgTm9CZWhhdmlvciBmcm9tICcuL2JlaGF2aW9ycy9uby1iZWhhdmlvcic7XG5pbXBvcnQgTm9Ib3Jpem9udGFsT3ZlcmxhcHBpbmdTZWdtZW50c0JlaGF2aW9yIGZyb20gJy4vYmVoYXZpb3JzL25vLWhvcml6b250YWwtb3ZlcmxhcHBpbmctc2VnbWVudHMtYmVoYXZpb3InO1xuXG4vLyBjb3JlXG5pbXBvcnQgTGF5ZXJUaW1lQ29udGV4dCBmcm9tICcuL2NvcmUvbGF5ZXItdGltZS1jb250ZXh0JztcbmltcG9ydCBMYXllciBmcm9tICcuL2NvcmUvbGF5ZXInO1xuaW1wb3J0IFRpbWVsaW5lVGltZUNvbnRleHQgZnJvbSAnLi9jb3JlL3RpbWVsaW5lLXRpbWUtY29udGV4dCc7XG5pbXBvcnQgVGltZWxpbmUgZnJvbSAnLi9jb3JlL3RpbWVsaW5lJztcbmltcG9ydCBUcmFja0NvbGxlY3Rpb24gZnJvbSAnLi9jb3JlL3RyYWNrLWNvbGxlY3Rpb24nO1xuaW1wb3J0IFRyYWNrIGZyb20gJy4vY29yZS90cmFjayc7XG5cbi8vIGhlbHBlcnNcbmltcG9ydCBBbm5vdGF0ZWRNYXJrZXJMYXllciBmcm9tICcuL2hlbHBlcnMvYW5ub3RhdGVkLW1hcmtlci1sYXllcic7XG5pbXBvcnQgQW5ub3RhdGVkU2VnbWVudExheWVyIGZyb20gJy4vaGVscGVycy9hbm5vdGF0ZWQtc2VnbWVudC1sYXllcic7XG5pbXBvcnQgQnJlYWtwb2ludExheWVyIGZyb20gJy4vaGVscGVycy9icmVha3BvaW50LWxheWVyJztcbmltcG9ydCBDdXJzb3JMYXllciBmcm9tICcuL2hlbHBlcnMvY3Vyc29yLWxheWVyJztcbmltcG9ydCBHcmlkQXhpc0xheWVyIGZyb20gJy4vaGVscGVycy9ncmlkLWF4aXMtbGF5ZXInO1xuaW1wb3J0IE1hcmtlckxheWVyIGZyb20gJy4vaGVscGVycy9tYXJrZXItbGF5ZXInO1xuaW1wb3J0IFNlZ21lbnRMYXllciBmcm9tICcuL2hlbHBlcnMvc2VnbWVudC1sYXllcic7XG5pbXBvcnQgVGlja0xheWVyIGZyb20gJy4vaGVscGVycy90aWNrLWxheWVyJztcbmltcG9ydCBUaW1lQXhpc0xheWVyIGZyb20gJy4vaGVscGVycy90aW1lLWF4aXMtbGF5ZXInO1xuaW1wb3J0IFRyYWNlTGF5ZXIgZnJvbSAnLi9oZWxwZXJzL3RyYWNlLWxheWVyJztcbmltcG9ydCBXYXZlZm9ybUxheWVyIGZyb20gJy4vaGVscGVycy93YXZlZm9ybS1sYXllcic7XG5pbXBvcnQgQmVhdEdyaWRMYXllciBmcm9tICcuL2hlbHBlcnMvYmVhdC1ncmlkLWxheWVyJztcbmltcG9ydCBTY3JvbGxlciBmcm9tICcuL2hlbHBlcnMvc2Nyb2xsZXInO1xuaW1wb3J0IEJlYXRHcmlkQXhpc0xheWVyIGZyb20gJy4vaGVscGVycy9iZWF0LWdyaWQtYXhpcy1sYXllcic7XG5pbXBvcnQgQnJ1c2hDb250cm9sbGVyIGZyb20gJy4vaGVscGVycy9icnVzaC1jb250cm9sbGVyJztcblxuLy8gaW50ZXJhY3Rpb25zXG5pbXBvcnQgRXZlbnRTb3VyY2UgZnJvbSAnLi9pbnRlcmFjdGlvbnMvZXZlbnQtc291cmNlJztcbmltcG9ydCBLZXlib2FyZCBmcm9tICcuL2ludGVyYWN0aW9ucy9rZXlib2FyZCc7XG5pbXBvcnQgU3VyZmFjZSBmcm9tICcuL2ludGVyYWN0aW9ucy9rb252YS1zdXJmYWNlJztcbmltcG9ydCBLb252YVdhdmVFdmVudCBmcm9tICcuL2ludGVyYWN0aW9ucy9rb252YS13YXZlLWV2ZW50JztcbmltcG9ydCBXYXZlRXZlbnQgZnJvbSAnLi9pbnRlcmFjdGlvbnMvd2F2ZS1ldmVudCc7XG5cbi8vIHNoYXBlc1xuLy8gaW1wb3J0IEFubm90YXRlZE1hcmtlciBmcm9tICcuL3NoYXBlcy9hbm5vdGF0ZWQtbWFya2VyJztcbmltcG9ydCBBbm5vdGF0ZWRTZWdtZW50IGZyb20gJy4vc2hhcGVzL2Fubm90YXRlZC1zZWdtZW50JztcbmltcG9ydCBBbm5vdGF0ZWREb3QgZnJvbSAnLi9zaGFwZXMvYW5ub3RhdGVkLWRvdCc7XG5pbXBvcnQgQmFzZVNoYXBlIGZyb20gJy4vc2hhcGVzL2Jhc2Utc2hhcGUnO1xuaW1wb3J0IEN1cnNvciBmcm9tICcuL3NoYXBlcy9jdXJzb3InO1xuaW1wb3J0IERvdCBmcm9tICcuL3NoYXBlcy9kb3QnO1xuaW1wb3J0IExpbmUgZnJvbSAnLi9zaGFwZXMvbGluZSc7XG5pbXBvcnQgTWFya2VyIGZyb20gJy4vc2hhcGVzL21hcmtlcic7XG5pbXBvcnQgU2VnbWVudCBmcm9tICcuL3NoYXBlcy9zZWdtZW50JztcbmltcG9ydCBUaWNrcyBmcm9tICcuL3NoYXBlcy90aWNrcyc7XG5pbXBvcnQgVHJhY2VEb3RzIGZyb20gJy4vc2hhcGVzL3RyYWNlLWRvdHMnO1xuaW1wb3J0IFRyYWNlUGF0aCBmcm9tICcuL3NoYXBlcy90cmFjZS1wYXRoJztcbmltcG9ydCBXYXZlZm9ybSBmcm9tICcuL3NoYXBlcy93YXZlZm9ybSc7XG5cbi8vIHN0YXRlc1xuaW1wb3J0IEJhc2VTdGF0ZSBmcm9tICcuL3N0YXRlcy9iYXNlLXN0YXRlJztcbmltcG9ydCBCcmVha3BvaW50U3RhdGUgZnJvbSAnLi9zdGF0ZXMvYnJlYWtwb2ludC1zdGF0ZSc7XG5pbXBvcnQgQnJ1c2hab29tU3RhdGUgZnJvbSAnLi9zdGF0ZXMvYnJ1c2gtem9vbS1zdGF0ZSc7XG5pbXBvcnQgQ2VudGVyZWRab29tU3RhdGUgZnJvbSAnLi9zdGF0ZXMvY2VudGVyZWQtem9vbS1zdGF0ZSc7XG5pbXBvcnQgQ2VudGVyZWRTY3JvbGxTdGF0ZSBmcm9tICcuL3N0YXRlcy9jZW50ZXJlZC1zY3JvbGwtc3RhdGUnO1xuaW1wb3J0IENvbnRleHRFZGl0aW9uU3RhdGUgZnJvbSAnLi9zdGF0ZXMvY29udGV4dC1lZGl0aW9uLXN0YXRlJztcbmltcG9ydCBEcm9wQW5kQWRkU3RhdGUgZnJvbSAnLi9zdGF0ZXMvZHJvcC1hbmQtYWRkLXN0YXRlJztcbmltcG9ydCBFZGl0aW9uU3RhdGUgZnJvbSAnLi9zdGF0ZXMvZWRpdGlvbi1zdGF0ZSc7XG5pbXBvcnQgSG9yaXpvbnRhbFNlbGVjdGlvblN0YXRlIGZyb20gJy4vc3RhdGVzL2hvcml6b250YWwtc2VsZWN0aW9uLXN0YXRlJztcbmltcG9ydCBTZWxlY3Rpb25TdGF0ZSBmcm9tICcuL3N0YXRlcy9zZWxlY3Rpb24tc3RhdGUnO1xuaW1wb3J0IFNoYXBlSW5zZXJ0aW9uU3RhdGUgZnJvbSAnLi9zdGF0ZXMvc2hhcGUtaW5zZXJ0aW9uLXN0YXRlJztcbmltcG9ydCBTaW1wbGVFZGl0aW9uU3RhdGUgZnJvbSAnLi9zdGF0ZXMvc2ltcGxlLWVkaXRpb24tc3RhdGUnO1xuaW1wb3J0IERyYWdUb0NyZWF0ZUludGVydmFsU3RhdGUgZnJvbSAnLi9zdGF0ZXMvZHJhZy10by1jcmVhdGUtaW50ZXJ2YWwtc3RhdGUnO1xuLy8gaW1wb3J0IEJlYXRHcmlkRWRpdG9ySW50ZXJhY3Rpb25zU3RhdGUgZnJvbSAnLi9zdGF0ZXMvYmVhdC1ncmlkLWludGVyYWN0aW9ucy1zdGF0ZSc7XG5pbXBvcnQgRHJhZ0FuZERyb3BTdGF0ZSBmcm9tICcuL3N0YXRlcy9kcmFnLWFuZC1kcm9wLXN0YXRlJztcblxuXG5cbi8vIHV0aWxzXG5pbXBvcnQgZm9ybWF0IGZyb20gJy4vdXRpbHMvZm9ybWF0JztcbmltcG9ydCBPcnRob2dvbmFsRGF0YSBmcm9tICcuL3V0aWxzL29ydGhvZ29uYWwtZGF0YSc7XG5pbXBvcnQgc2NhbGVzIGZyb20gJy4vdXRpbHMvc2NhbGVzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBheGlzOiB7XG4gICAgQXhpc0xheWVyLCB0aW1lQXhpc0dlbmVyYXRvciwgZ3JpZEF4aXNHZW5lcmF0b3IsIFxuICB9LCBcblxuICBiZWhhdmlvcnM6IHtcbiAgICBCYXNlQmVoYXZpb3IsIFNuYXBCYXNlQmVoYXZpb3IsIEJlYXRHcmlkU25hcFNlZ21lbnRCZWhhdmlvciwgXG4gICAgQnJlYWtwb2ludEJlaGF2aW9yLCBNYXJrZXJCZWhhdmlvciwgXG4gICAgU2Nyb2xsU2VnbWVudEJlaGF2aW9yLCBTZWdtZW50QmVoYXZpb3IsIFxuICAgIFNpYmxpbmdMb2NrZWRTZWdtZW50QmVoYXZpb3IsIFNpbXBsZVNuYXBTZWdtZW50QmVoYXZpb3IsIFxuICAgIFRpbWVDb250ZXh0QmVoYXZpb3IsIFRyYWNlQmVoYXZpb3IsIFdhdmVmb3JtQmVoYXZpb3IsIFxuICAgIE5vQmVoYXZpb3IsIE5vSG9yaXpvbnRhbE92ZXJsYXBwaW5nU2VnbWVudHNCZWhhdmlvclxuICB9LCBcblxuICBjb3JlOiB7XG4gICAgTGF5ZXJUaW1lQ29udGV4dCwgTGF5ZXIsIFRpbWVsaW5lVGltZUNvbnRleHQsIFRpbWVsaW5lLCBcbiAgICBUcmFja0NvbGxlY3Rpb24sIFRyYWNrLCBcbiAgfSwgXG5cbiAgaGVscGVyczoge1xuICAgIEJlYXRHcmlkQXhpc0xheWVyLCBcbiAgICBBbm5vdGF0ZWRNYXJrZXJMYXllciwgXG4gICAgQW5ub3RhdGVkU2VnbWVudExheWVyLCBcbiAgICBCcmVha3BvaW50TGF5ZXIsIFxuICAgIEN1cnNvckxheWVyLCBcbiAgICBHcmlkQXhpc0xheWVyLCBcbiAgICBNYXJrZXJMYXllciwgXG4gICAgU2VnbWVudExheWVyLCBcbiAgICBUaWNrTGF5ZXIsIFxuICAgIFRpbWVBeGlzTGF5ZXIsIFxuICAgIFRyYWNlTGF5ZXIsIFxuICAgIFdhdmVmb3JtTGF5ZXIsIFxuICAgIEJlYXRHcmlkTGF5ZXIsIFxuICAgIFNjcm9sbGVyLCBcbiAgICBCcnVzaENvbnRyb2xsZXJcbiAgfSxcblxuICBpbnRlcmFjdGlvbnM6IHtcbiAgICBFdmVudFNvdXJjZSwgS2V5Ym9hcmQsIFxuICAgIFN1cmZhY2UsIEtvbnZhV2F2ZUV2ZW50LCBXYXZlRXZlbnQsIFxuICB9LFxuXG4gIHNoYXBlczoge1xuICAgIC8vIEFubm90YXRlZE1hcmtlciwgXG4gICAgQW5ub3RhdGVkU2VnbWVudCwgQW5ub3RhdGVkRG90LCBCYXNlU2hhcGUsIEN1cnNvciwgXG4gICAgRG90LCBMaW5lLCBNYXJrZXIsIFNlZ21lbnQsIFxuICAgIFRpY2tzLCBUcmFjZURvdHMsIFRyYWNlUGF0aCwgV2F2ZWZvcm0sIFxuICB9LFxuXG4gIHN0YXRlczoge1xuICAgIEJhc2VTdGF0ZSwgQnJlYWtwb2ludFN0YXRlLCBCcnVzaFpvb21TdGF0ZSwgQ2VudGVyZWRab29tU3RhdGUsIFxuICAgIENlbnRlcmVkU2Nyb2xsU3RhdGUsIENvbnRleHRFZGl0aW9uU3RhdGUsIERyb3BBbmRBZGRTdGF0ZSwgRWRpdGlvblN0YXRlLCBcbiAgICBTZWxlY3Rpb25TdGF0ZSwgSG9yaXpvbnRhbFNlbGVjdGlvblN0YXRlLCBTaGFwZUluc2VydGlvblN0YXRlLCBTaW1wbGVFZGl0aW9uU3RhdGUsIFxuICAgIERyYWdUb0NyZWF0ZUludGVydmFsU3RhdGUsIERyYWdBbmREcm9wU3RhdGVcbiAgfSxcblxuICB1dGlsczoge1xuICAgIGZvcm1hdCwgT3J0aG9nb25hbERhdGEsIHNjYWxlcyxcbiAgfSBcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL21hcFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2VcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc2V0XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9PYmplY3QkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIilbXCJkZWZhdWx0XCJdO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuXG4gICAgICBfT2JqZWN0JGRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KSgpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIilbXCJkZWZhdWx0XCJdO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHtcbiAgdmFyIF9hZ2FpbiA9IHRydWU7XG5cbiAgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7XG4gICAgdmFyIG9iamVjdCA9IF94LFxuICAgICAgICBwcm9wZXJ0eSA9IF94MixcbiAgICAgICAgcmVjZWl2ZXIgPSBfeDM7XG4gICAgX2FnYWluID0gZmFsc2U7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gICAgdmFyIGRlc2MgPSBfT2JqZWN0JGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIGlmIChkZXNjID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcblxuICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3ggPSBwYXJlbnQ7XG4gICAgICAgIF94MiA9IHByb3BlcnR5O1xuICAgICAgICBfeDMgPSByZWNlaXZlcjtcbiAgICAgICAgX2FnYWluID0gdHJ1ZTtcbiAgICAgICAgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29udGludWUgX2Z1bmN0aW9uO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHtcbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9PYmplY3QkY3JlYXRlID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIF9PYmplY3Qkc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpW1wiZGVmYXVsdFwiXTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gX09iamVjdCRjcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9PYmplY3Qkc2V0UHJvdG90eXBlT2YgPyBfT2JqZWN0JHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3InKTsiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubWFwJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5tYXAudG8tanNvbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzLyQuY29yZScpLk1hcDsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuT2JqZWN0LmFzc2lnbjsiLCJ2YXIgJCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCl7XG4gIHJldHVybiAkLmNyZWF0ZShQLCBEKTtcbn07IiwidmFyICQgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyl7XG4gIHJldHVybiAkLnNldERlc2MoaXQsIGtleSwgZGVzYyk7XG59OyIsInZhciAkID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy8kJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcbiAgcmV0dXJuICQuZ2V0RGVzYyhpdCwga2V5KTtcbn07IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmtleXMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy8kLmNvcmUnKS5PYmplY3Qua2V5czsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLk9iamVjdC5zZXRQcm90b3R5cGVPZjsiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzLyQuY29yZScpLlByb21pc2U7IiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnNldCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcuc2V0LnRvLWpzb24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy8kLmNvcmUnKS5TZXQ7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuU3ltYm9sOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC53a3MnKSgnaXRlcmF0b3InKTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH07IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59OyIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi8kLmNvZicpXG4gICwgVEFHID0gcmVxdWlyZSgnLi8kLndrcycpKCd0b1N0cmluZ1RhZycpXG4gIC8vIEVTMyB3cm9uZyBoZXJlXG4gICwgQVJHID0gY29mKGZ1bmN0aW9uKCl7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSAoTyA9IE9iamVjdChpdCkpW1RBR10pID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTsiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGhpZGUgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oaWRlJylcbiAgLCByZWRlZmluZUFsbCAgPSByZXF1aXJlKCcuLyQucmVkZWZpbmUtYWxsJylcbiAgLCBjdHggICAgICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBzdHJpY3ROZXcgICAgPSByZXF1aXJlKCcuLyQuc3RyaWN0LW5ldycpXG4gICwgZGVmaW5lZCAgICAgID0gcmVxdWlyZSgnLi8kLmRlZmluZWQnKVxuICAsIGZvck9mICAgICAgICA9IHJlcXVpcmUoJy4vJC5mb3Itb2YnKVxuICAsICRpdGVyRGVmaW5lICA9IHJlcXVpcmUoJy4vJC5pdGVyLWRlZmluZScpXG4gICwgc3RlcCAgICAgICAgID0gcmVxdWlyZSgnLi8kLml0ZXItc3RlcCcpXG4gICwgSUQgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpKCdpZCcpXG4gICwgJGhhcyAgICAgICAgID0gcmVxdWlyZSgnLi8kLmhhcycpXG4gICwgaXNPYmplY3QgICAgID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpXG4gICwgc2V0U3BlY2llcyAgID0gcmVxdWlyZSgnLi8kLnNldC1zcGVjaWVzJylcbiAgLCBERVNDUklQVE9SUyAgPSByZXF1aXJlKCcuLyQuZGVzY3JpcHRvcnMnKVxuICAsIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgaXNPYmplY3RcbiAgLCBTSVpFICAgICAgICAgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSdcbiAgLCBpZCAgICAgICAgICAgPSAwO1xuXG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYoISRoYXMoaXQsIElEKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IGlkIHRvIGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIGlkXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG9iamVjdCBpZFxuICAgIGhpZGUoaXQsIElELCArK2lkKTtcbiAgLy8gcmV0dXJuIG9iamVjdCBpZCB3aXRoIHByZWZpeFxuICB9IHJldHVybiAnTycgKyBpdFtJRF07XG59O1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbih0aGF0LCBrZXkpe1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpLCBlbnRyeTtcbiAgaWYoaW5kZXggIT09ICdGJylyZXR1cm4gdGhhdC5faVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICBpZihlbnRyeS5rID09IGtleSlyZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24od3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGl0ZXJhYmxlKXtcbiAgICAgIHN0cmljdE5ldyh0aGF0LCBDLCBOQU1FKTtcbiAgICAgIHRoYXQuX2kgPSAkLmNyZWF0ZShudWxsKTsgLy8gaW5kZXhcbiAgICAgIHRoYXQuX2YgPSB1bmRlZmluZWQ7ICAgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgICAvLyBzaXplXG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCl7XG4gICAgICAgIGZvcih2YXIgdGhhdCA9IHRoaXMsIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKGVudHJ5LnApZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgdmFyIHRoYXQgID0gdGhpc1xuICAgICAgICAgICwgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZihlbnRyeSl7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uXG4gICAgICAgICAgICAsIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKHByZXYpcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZihuZXh0KW5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYodGhhdC5fZiA9PSBlbnRyeSl0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZih0aGF0Ll9sID09IGVudHJ5KXRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpXG4gICAgICAgICAgLCBlbnRyeTtcbiAgICAgICAgd2hpbGUoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzLl9mKXtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpe1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmKERFU0NSSVBUT1JTKSQuc2V0RGVzYyhDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBkZWZpbmVkKHRoaXNbU0laRV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpe1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSlcbiAgICAgICwgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYoZW50cnkpe1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYoIXRoYXQuX2YpdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYocHJldilwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYoaW5kZXggIT09ICdGJyl0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbihDLCBOQU1FLCBJU19NQVApe1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gICAgICB0aGlzLl90ID0gaXRlcmF0ZWQ7ICAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7IC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24oKXtcbiAgICAgIHZhciB0aGF0ICA9IHRoaXNcbiAgICAgICAgLCBraW5kICA9IHRoYXQuX2tcbiAgICAgICAgLCBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpe1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJyAsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59OyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciBmb3JPZiAgID0gcmVxdWlyZSgnLi8kLmZvci1vZicpXG4gICwgY2xhc3NvZiA9IHJlcXVpcmUoJy4vJC5jbGFzc29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUpe1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCl7XG4gICAgaWYoY2xhc3NvZih0aGlzKSAhPSBOQU1FKXRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIGZvck9mKHRoaXMsIGZhbHNlLCBhcnIucHVzaCwgYXJyKTtcbiAgICByZXR1cm4gYXJyO1xuICB9O1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuLyQuZXhwb3J0JylcbiAgLCBmYWlscyAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5mYWlscycpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaGlkZScpXG4gICwgcmVkZWZpbmVBbGwgICAgPSByZXF1aXJlKCcuLyQucmVkZWZpbmUtYWxsJylcbiAgLCBmb3JPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5mb3Itb2YnKVxuICAsIHN0cmljdE5ldyAgICAgID0gcmVxdWlyZSgnLi8kLnN0cmljdC1uZXcnKVxuICAsIGlzT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLyQuc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi8kLmRlc2NyaXB0b3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSwgd3JhcHBlciwgbWV0aG9kcywgY29tbW9uLCBJU19NQVAsIElTX1dFQUspe1xuICB2YXIgQmFzZSAgPSBnbG9iYWxbTkFNRV1cbiAgICAsIEMgICAgID0gQmFzZVxuICAgICwgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnXG4gICAgLCBwcm90byA9IEMgJiYgQy5wcm90b3R5cGVcbiAgICAsIE8gICAgID0ge307XG4gIGlmKCFERVNDUklQVE9SUyB8fCB0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbigpe1xuICAgIG5ldyBDKCkuZW50cmllcygpLm5leHQoKTtcbiAgfSkpKXtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICB9IGVsc2Uge1xuICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgaXRlcmFibGUpe1xuICAgICAgc3RyaWN0TmV3KHRhcmdldCwgQywgTkFNRSk7XG4gICAgICB0YXJnZXQuX2MgPSBuZXcgQmFzZTtcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0YXJnZXRbQURERVJdLCB0YXJnZXQpO1xuICAgIH0pO1xuICAgICQuZWFjaC5jYWxsKCdhZGQsY2xlYXIsZGVsZXRlLGZvckVhY2gsZ2V0LGhhcyxzZXQsa2V5cyx2YWx1ZXMsZW50cmllcycuc3BsaXQoJywnKSxmdW5jdGlvbihLRVkpe1xuICAgICAgdmFyIElTX0FEREVSID0gS0VZID09ICdhZGQnIHx8IEtFWSA9PSAnc2V0JztcbiAgICAgIGlmKEtFWSBpbiBwcm90byAmJiAhKElTX1dFQUsgJiYgS0VZID09ICdjbGVhcicpKWhpZGUoQy5wcm90b3R5cGUsIEtFWSwgZnVuY3Rpb24oYSwgYil7XG4gICAgICAgIGlmKCFJU19BRERFUiAmJiBJU19XRUFLICYmICFpc09iamVjdChhKSlyZXR1cm4gS0VZID09ICdnZXQnID8gdW5kZWZpbmVkIDogZmFsc2U7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9jW0tFWV0oYSA9PT0gMCA/IDAgOiBhLCBiKTtcbiAgICAgICAgcmV0dXJuIElTX0FEREVSID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmKCdzaXplJyBpbiBwcm90bykkLnNldERlc2MoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5fYy5zaXplO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GLCBPKTtcblxuICBpZighSVNfV0VBSyljb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIEM7XG59OyIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzEuMi42J307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLyQuYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTsiLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07IiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi8kLmZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pOyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59OyIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgJCA9IHJlcXVpcmUoJy4vJCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBrZXlzICAgICAgID0gJC5nZXRLZXlzKGl0KVxuICAgICwgZ2V0U3ltYm9scyA9ICQuZ2V0U3ltYm9scztcbiAgaWYoZ2V0U3ltYm9scyl7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxuICAgICAgLCBpc0VudW0gID0gJC5pc0VudW1cbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07IiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIGNvcmUgICAgICA9IHJlcXVpcmUoJy4vJC5jb3JlJylcbiAgLCBjdHggICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cbiAgICAsIGtleSwgb3duLCBvdXQ7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYga2V5IGluIHRhcmdldDtcbiAgICBpZihvd24gJiYga2V5IGluIGV4cG9ydHMpY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbihDKXtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24ocGFyYW0pe1xuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIEMgPyBuZXcgQyhwYXJhbSkgOiBDKHBhcmFtKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgaWYoSVNfUFJPVE8pKGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pKVtrZXldID0gb3V0O1xuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7IC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAvLyB3cmFwXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07IiwidmFyIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgY2FsbCAgICAgICAgPSByZXF1aXJlKCcuLyQuaXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vJC5pcy1hcnJheS1pdGVyJylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi8kLnRvLWxlbmd0aCcpXG4gICwgZ2V0SXRlckZuICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQpe1xuICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKGl0ZXJhYmxlKVxuICAgICwgZiAgICAgID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yO1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZihpc0FycmF5SXRlcihpdGVyRm4pKWZvcihsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICB9IGVsc2UgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7ICl7XG4gICAgY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gIH1cbn07IiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vJC50by1pb2JqZWN0JylcbiAgLCBnZXROYW1lcyAgPSByZXF1aXJlKCcuLyQnKS5nZXROYW1lc1xuICAsIHRvU3RyaW5nICA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdldE5hbWVzKGl0KTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIGlmKHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nKXJldHVybiBnZXRXaW5kb3dOYW1lcyhpdCk7XG4gIHJldHVybiBnZXROYW1lcyh0b0lPYmplY3QoaXQpKTtcbn07IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59OyIsInZhciAkICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi8kLnByb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmRlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gJC5zZXREZXNjKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50OyIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgYXJncywgdGhhdCl7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTsiLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vJC5jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07IiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyAgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJylcbiAgLCBJVEVSQVRPUiAgID0gcmVxdWlyZSgnLi8kLndrcycpKCdpdGVyYXRvcicpXG4gICwgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59OyIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi8kLmNvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKGFyZyl7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07IiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoKGUpe1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYocmV0ICE9PSB1bmRlZmluZWQpYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgZGVzY3JpcHRvciAgICAgPSByZXF1aXJlKCcuLyQucHJvcGVydHktZGVzYycpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLyQuc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuLyQuaGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCl7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9ICQuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi8kLmxpYnJhcnknKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuLyQucmVkZWZpbmUnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmhpZGUnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmhhcycpXG4gICwgSXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJylcbiAgLCAkaXRlckNyZWF0ZSAgICA9IHJlcXVpcmUoJy4vJC5pdGVyLWNyZWF0ZScpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLyQuc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGdldFByb3RvICAgICAgID0gcmVxdWlyZSgnLi8kJykuZ2V0UHJvdG9cbiAgLCBJVEVSQVRPUiAgICAgICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcbiAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxuICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcbiAgICAsIG1ldGhvZHMsIGtleTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZigkbmF0aXZlKXtcbiAgICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90bygkZGVmYXVsdC5jYWxsKG5ldyBCYXNlKSk7XG4gICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgIC8vIEZGIGZpeFxuICAgIGlmKCFMSUJSQVJZICYmIGhhcyhwcm90bywgRkZfSVRFUkFUT1IpKWhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gICAgaWYoREVGX1ZBTFVFUyAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XG4gICAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gICAgfVxuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZigoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSl7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSAgPSByZXR1cm5UaGlzO1xuICBpZihERUZBVUxUKXtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiAgREVGX1ZBTFVFUyAgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICAgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKVxuICAgIH07XG4gICAgaWYoRk9SQ0VEKWZvcihrZXkgaW4gbWV0aG9kcyl7XG4gICAgICBpZighKGtleSBpbiBwcm90bykpcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTsiLCJ2YXIgSVRFUkFUT1IgICAgID0gcmVxdWlyZSgnLi8kLndrcycpKCdpdGVyYXRvcicpXG4gICwgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24oKXsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24oKXsgdGhyb3cgMjsgfSk7XG59IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYywgc2tpcENsb3Npbmcpe1xuICBpZighc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORylyZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciAgPSBbN11cbiAgICAgICwgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbigpeyBzYWZlID0gdHJ1ZTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvbmUsIHZhbHVlKXtcbiAgcmV0dXJuIHt2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZX07XG59OyIsIm1vZHVsZS5leHBvcnRzID0ge307IiwidmFyICRPYmplY3QgPSBPYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlOiAgICAgJE9iamVjdC5jcmVhdGUsXG4gIGdldFByb3RvOiAgICRPYmplY3QuZ2V0UHJvdG90eXBlT2YsXG4gIGlzRW51bTogICAgIHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICBnZXREZXNjOiAgICAkT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgc2V0RGVzYzogICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcbiAgc2V0RGVzY3M6ICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLFxuICBnZXRLZXlzOiAgICAkT2JqZWN0LmtleXMsXG4gIGdldE5hbWVzOiAgICRPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgZ2V0U3ltYm9sczogJE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gIGVhY2g6ICAgICAgIFtdLmZvckVhY2hcbn07IiwidmFyICQgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLWlvYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBlbCl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwga2V5cyAgID0gJC5nZXRLZXlzKE8pXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaW5kZXggID0gMFxuICAgICwga2V5O1xuICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7IiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vJC50YXNrJykuc2V0XG4gICwgT2JzZXJ2ZXIgID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXJcbiAgLCBwcm9jZXNzICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIFByb21pc2UgICA9IGdsb2JhbC5Qcm9taXNlXG4gICwgaXNOb2RlICAgID0gcmVxdWlyZSgnLi8kLmNvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJ1xuICAsIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxudmFyIGZsdXNoID0gZnVuY3Rpb24oKXtcbiAgdmFyIHBhcmVudCwgZG9tYWluLCBmbjtcbiAgaWYoaXNOb2RlICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpe1xuICAgIHByb2Nlc3MuZG9tYWluID0gbnVsbDtcbiAgICBwYXJlbnQuZXhpdCgpO1xuICB9XG4gIHdoaWxlKGhlYWQpe1xuICAgIGRvbWFpbiA9IGhlYWQuZG9tYWluO1xuICAgIGZuICAgICA9IGhlYWQuZm47XG4gICAgaWYoZG9tYWluKWRvbWFpbi5lbnRlcigpO1xuICAgIGZuKCk7IC8vIDwtIGN1cnJlbnRseSB3ZSB1c2UgaXQgb25seSBmb3IgUHJvbWlzZSAtIHRyeSAvIGNhdGNoIG5vdCByZXF1aXJlZFxuICAgIGlmKGRvbWFpbilkb21haW4uZXhpdCgpO1xuICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgaWYocGFyZW50KXBhcmVudC5lbnRlcigpO1xufTtcblxuLy8gTm9kZS5qc1xuaWYoaXNOb2RlKXtcbiAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgfTtcbi8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlclxufSBlbHNlIGlmKE9ic2VydmVyKXtcbiAgdmFyIHRvZ2dsZSA9IDFcbiAgICAsIG5vZGUgICA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gLXRvZ2dsZTtcbiAgfTtcbi8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG59IGVsc2UgaWYoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpe1xuICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZmx1c2gpO1xuICB9O1xuLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbi8vIC0gc2V0SW1tZWRpYXRlXG4vLyAtIE1lc3NhZ2VDaGFubmVsXG4vLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4vLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuLy8gLSBzZXRUaW1lb3V0XG59IGVsc2Uge1xuICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhc2FwKGZuKXtcbiAgdmFyIHRhc2sgPSB7Zm46IGZuLCBuZXh0OiB1bmRlZmluZWQsIGRvbWFpbjogaXNOb2RlICYmIHByb2Nlc3MuZG9tYWlufTtcbiAgaWYobGFzdClsYXN0Lm5leHQgPSB0YXNrO1xuICBpZighaGVhZCl7XG4gICAgaGVhZCA9IHRhc2s7XG4gICAgbm90aWZ5KCk7XG4gIH0gbGFzdCA9IHRhc2s7XG59OyIsIi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciAkICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuLyQudG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vJC5pb2JqZWN0Jyk7XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuZmFpbHMnKShmdW5jdGlvbigpe1xuICB2YXIgYSA9IE9iamVjdC5hc3NpZ25cbiAgICAsIEEgPSB7fVxuICAgICwgQiA9IHt9XG4gICAgLCBTID0gU3ltYm9sKClcbiAgICAsIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihrKXsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gYSh7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cyhhKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCAgICAgPSB0b09iamVjdCh0YXJnZXQpXG4gICAgLCAkJCAgICA9IGFyZ3VtZW50c1xuICAgICwgJCRsZW4gPSAkJC5sZW5ndGhcbiAgICAsIGluZGV4ID0gMVxuICAgICwgZ2V0S2V5cyAgICA9ICQuZ2V0S2V5c1xuICAgICwgZ2V0U3ltYm9scyA9ICQuZ2V0U3ltYm9sc1xuICAgICwgaXNFbnVtICAgICA9ICQuaXNFbnVtO1xuICB3aGlsZSgkJGxlbiA+IGluZGV4KXtcbiAgICB2YXIgUyAgICAgID0gSU9iamVjdCgkJFtpbmRleCsrXSlcbiAgICAgICwga2V5cyAgID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBqICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBqKWlmKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpVFtrZXldID0gU1trZXldO1xuICB9XG4gIHJldHVybiBUO1xufSA6IE9iamVjdC5hc3NpZ247IiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKVxuICAsIGNvcmUgICAgPSByZXF1aXJlKCcuLyQuY29yZScpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vJC5mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGV4ZWMpe1xuICB2YXIgZm4gID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldXG4gICAgLCBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGUgICAgOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlICAgICAgIDogdmFsdWVcbiAgfTtcbn07IiwidmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi8kLnJlZGVmaW5lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgc3JjKXtcbiAgZm9yKHZhciBrZXkgaW4gc3JjKXJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIHJldHVybiB0YXJnZXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmhpZGUnKTsiLCIvLyA3LjIuOSBTYW1lVmFsdWUoeCwgeSlcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uIGlzKHgsIHkpe1xuICByZXR1cm4geCA9PT0geSA/IHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5IDogeCAhPSB4ICYmIHkgIT0geTtcbn07IiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGdldERlc2MgID0gcmVxdWlyZSgnLi8kJykuZ2V0RGVzY1xuICAsIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbihPLCBwcm90byl7XG4gIGFuT2JqZWN0KE8pO1xuICBpZighaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKXRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uKHRlc3QsIGJ1Z2d5LCBzZXQpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi8kLmN0eCcpKEZ1bmN0aW9uLmNhbGwsIGdldERlc2MoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pe1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgY29yZSAgICAgICAgPSByZXF1aXJlKCcuLyQuY29yZScpXG4gICwgJCAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi8kLmRlc2NyaXB0b3JzJylcbiAgLCBTUEVDSUVTICAgICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSl7XG4gIHZhciBDID0gY29yZVtLRVldO1xuICBpZihERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKSQuc2V0RGVzYyhDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59OyIsInZhciBkZWYgPSByZXF1aXJlKCcuLyQnKS5zZXREZXNjXG4gICwgaGFzID0gcmVxdWlyZSgnLi8kLmhhcycpXG4gICwgVEFHID0gcmVxdWlyZSgnLi8kLndrcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuICBpZihpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKWRlZihpdCwgVEFHLCB7Y29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnfSk7XG59OyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylcbiAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xuICAsIHN0b3JlICA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59OyIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ICA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vJC5hLWZ1bmN0aW9uJylcbiAgLCBTUEVDSUVTICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywgRCl7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3IsIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgQ29uc3RydWN0b3IsIG5hbWUpe1xuICBpZighKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKXRocm93IFR5cGVFcnJvcihuYW1lICsgXCI6IHVzZSB0aGUgJ25ldycgb3BlcmF0b3IhXCIpO1xuICByZXR1cm4gaXQ7XG59OyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLyQudG8taW50ZWdlcicpXG4gICwgZGVmaW5lZCAgID0gcmVxdWlyZSgnLi8kLmRlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG4gIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxuICAgICAgLCBsID0gcy5sZW5ndGhcbiAgICAgICwgYSwgYjtcbiAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07IiwidmFyIGN0eCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5jdHgnKVxuICAsIGludm9rZSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5pbnZva2UnKVxuICAsIGh0bWwgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5odG1sJylcbiAgLCBjZWwgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuZG9tLWNyZWF0ZScpXG4gICwgZ2xvYmFsICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBzZXRUYXNrICAgICAgICAgICAgPSBnbG9iYWwuc2V0SW1tZWRpYXRlXG4gICwgY2xlYXJUYXNrICAgICAgICAgID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlXG4gICwgTWVzc2FnZUNoYW5uZWwgICAgID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsXG4gICwgY291bnRlciAgICAgICAgICAgID0gMFxuICAsIHF1ZXVlICAgICAgICAgICAgICA9IHt9XG4gICwgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSdcbiAgLCBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgaWQgPSArdGhpcztcbiAgaWYocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKXtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RuZXIgPSBmdW5jdGlvbihldmVudCl7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spe1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKXtcbiAgICB2YXIgYXJncyA9IFtdLCBpID0gMTtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbigpe1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKXtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYocmVxdWlyZSgnLi8kLmNvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYoTWVzc2FnZUNoYW5uZWwpe1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWw7XG4gICAgcG9ydCAgICA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0bmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdG5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZihPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbigpe1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogICBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59OyIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTsiLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmlvYmplY3QnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuLyQuZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07IiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi8kLnRvLWludGVnZXInKVxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59OyIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi8kLmRlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07IiwidmFyIGlkID0gMFxuICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07IiwidmFyIHN0b3JlICA9IHJlcXVpcmUoJy4vJC5zaGFyZWQnKSgnd2tzJylcbiAgLCB1aWQgICAgPSByZXF1aXJlKCcuLyQudWlkJylcbiAgLCBTeW1ib2wgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJykuU3ltYm9sO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgU3ltYm9sICYmIFN5bWJvbFtuYW1lXSB8fCAoU3ltYm9sIHx8IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTsiLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi8kLmNsYXNzb2YnKVxuICAsIElURVJBVE9SICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vJC5pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmNvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgIT0gdW5kZWZpbmVkKXJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07IiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpXG4gICwgZ2V0ICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuY29yZScpLmdldEl0ZXJhdG9yID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgaXRlckZuID0gZ2V0KGl0KTtcbiAgaWYodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICByZXR1cm4gYW5PYmplY3QoaXRlckZuLmNhbGwoaXQpKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuLyQuYWRkLXRvLXVuc2NvcGFibGVzJylcbiAgLCBzdGVwICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLml0ZXItc3RlcCcpXG4gICwgSXRlcmF0b3JzICAgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyYXRvcnMnKVxuICAsIHRvSU9iamVjdCAgICAgICAgPSByZXF1aXJlKCcuLyQudG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwga2luZCAgPSB0aGlzLl9rXG4gICAgLCBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpOyIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuLyQuY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gMjMuMSBNYXAgT2JqZWN0c1xucmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24nKSgnTWFwJywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMS4zLjYgTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpe1xuICAgIHZhciBlbnRyeSA9IHN0cm9uZy5nZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xuICB9LFxuICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKXtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZywgdHJ1ZSk7IiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHthc3NpZ246IHJlcXVpcmUoJy4vJC5vYmplY3QtYXNzaWduJyl9KTsiLCIvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLWlvYmplY3QnKTtcblxucmVxdWlyZSgnLi8kLm9iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJywgZnVuY3Rpb24oJGdldE93blByb3BlcnR5RGVzY3JpcHRvcil7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuLyQub2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24oJGtleXMpe1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCl7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTsiLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuLyQuZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi8kLnNldC1wcm90bycpLnNldH0pOyIsbnVsbCwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIExJQlJBUlkgICAgPSByZXF1aXJlKCcuLyQubGlicmFyeScpXG4gICwgZ2xvYmFsICAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIGN0eCAgICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBjbGFzc29mICAgID0gcmVxdWlyZSgnLi8kLmNsYXNzb2YnKVxuICAsICRleHBvcnQgICAgPSByZXF1aXJlKCcuLyQuZXhwb3J0JylcbiAgLCBpc09iamVjdCAgID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgICA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgPSByZXF1aXJlKCcuLyQuYS1mdW5jdGlvbicpXG4gICwgc3RyaWN0TmV3ICA9IHJlcXVpcmUoJy4vJC5zdHJpY3QtbmV3JylcbiAgLCBmb3JPZiAgICAgID0gcmVxdWlyZSgnLi8kLmZvci1vZicpXG4gICwgc2V0UHJvdG8gICA9IHJlcXVpcmUoJy4vJC5zZXQtcHJvdG8nKS5zZXRcbiAgLCBzYW1lICAgICAgID0gcmVxdWlyZSgnLi8kLnNhbWUtdmFsdWUnKVxuICAsIFNQRUNJRVMgICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ3NwZWNpZXMnKVxuICAsIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vJC5zcGVjaWVzLWNvbnN0cnVjdG9yJylcbiAgLCBhc2FwICAgICAgID0gcmVxdWlyZSgnLi8kLm1pY3JvdGFzaycpXG4gICwgUFJPTUlTRSAgICA9ICdQcm9taXNlJ1xuICAsIHByb2Nlc3MgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIGlzTm9kZSAgICAgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJ1xuICAsIFAgICAgICAgICAgPSBnbG9iYWxbUFJPTUlTRV1cbiAgLCBXcmFwcGVyO1xuXG52YXIgdGVzdFJlc29sdmUgPSBmdW5jdGlvbihzdWIpe1xuICB2YXIgdGVzdCA9IG5ldyBQKGZ1bmN0aW9uKCl7fSk7XG4gIGlmKHN1Yil0ZXN0LmNvbnN0cnVjdG9yID0gT2JqZWN0O1xuICByZXR1cm4gUC5yZXNvbHZlKHRlc3QpID09PSB0ZXN0O1xufTtcblxudmFyIFVTRV9OQVRJVkUgPSBmdW5jdGlvbigpe1xuICB2YXIgd29ya3MgPSBmYWxzZTtcbiAgZnVuY3Rpb24gUDIoeCl7XG4gICAgdmFyIHNlbGYgPSBuZXcgUCh4KTtcbiAgICBzZXRQcm90byhzZWxmLCBQMi5wcm90b3R5cGUpO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIHRyeSB7XG4gICAgd29ya3MgPSBQICYmIFAucmVzb2x2ZSAmJiB0ZXN0UmVzb2x2ZSgpO1xuICAgIHNldFByb3RvKFAyLCBQKTtcbiAgICBQMi5wcm90b3R5cGUgPSAkLmNyZWF0ZShQLnByb3RvdHlwZSwge2NvbnN0cnVjdG9yOiB7dmFsdWU6IFAyfX0pO1xuICAgIC8vIGFjdHVhbCBGaXJlZm94IGhhcyBicm9rZW4gc3ViY2xhc3Mgc3VwcG9ydCwgdGVzdCB0aGF0XG4gICAgaWYoIShQMi5yZXNvbHZlKDUpLnRoZW4oZnVuY3Rpb24oKXt9KSBpbnN0YW5jZW9mIFAyKSl7XG4gICAgICB3b3JrcyA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBhY3R1YWwgVjggYnVnLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDE2MlxuICAgIGlmKHdvcmtzICYmIHJlcXVpcmUoJy4vJC5kZXNjcmlwdG9ycycpKXtcbiAgICAgIHZhciB0aGVuYWJsZVRoZW5Hb3R0ZW4gPSBmYWxzZTtcbiAgICAgIFAucmVzb2x2ZSgkLnNldERlc2Moe30sICd0aGVuJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7IHRoZW5hYmxlVGhlbkdvdHRlbiA9IHRydWU7IH1cbiAgICAgIH0pKTtcbiAgICAgIHdvcmtzID0gdGhlbmFibGVUaGVuR290dGVuO1xuICAgIH1cbiAgfSBjYXRjaChlKXsgd29ya3MgPSBmYWxzZTsgfVxuICByZXR1cm4gd29ya3M7XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBzYW1lQ29uc3RydWN0b3IgPSBmdW5jdGlvbihhLCBiKXtcbiAgLy8gbGlicmFyeSB3cmFwcGVyIHNwZWNpYWwgY2FzZVxuICBpZihMSUJSQVJZICYmIGEgPT09IFAgJiYgYiA9PT0gV3JhcHBlcilyZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHNhbWUoYSwgYik7XG59O1xudmFyIGdldENvbnN0cnVjdG9yID0gZnVuY3Rpb24oQyl7XG4gIHZhciBTID0gYW5PYmplY3QoQylbU1BFQ0lFU107XG4gIHJldHVybiBTICE9IHVuZGVmaW5lZCA/IFMgOiBDO1xufTtcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcbnZhciBQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKEMpe1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbigkJHJlc29sdmUsICQkcmVqZWN0KXtcbiAgICBpZihyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ICA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpLFxuICB0aGlzLnJlamVjdCAgPSBhRnVuY3Rpb24ocmVqZWN0KVxufTtcbnZhciBwZXJmb3JtID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB7ZXJyb3I6IGV9O1xuICB9XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uKHJlY29yZCwgaXNSZWplY3Qpe1xuICBpZihyZWNvcmQubilyZXR1cm47XG4gIHJlY29yZC5uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcmVjb3JkLmM7XG4gIGFzYXAoZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSByZWNvcmQudlxuICAgICAgLCBvayAgICA9IHJlY29yZC5zID09IDFcbiAgICAgICwgaSAgICAgPSAwO1xuICAgIHZhciBydW4gPSBmdW5jdGlvbihyZWFjdGlvbil7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsXG4gICAgICAgICwgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmVcbiAgICAgICAgLCByZWplY3QgID0gcmVhY3Rpb24ucmVqZWN0XG4gICAgICAgICwgcmVzdWx0LCB0aGVuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYoaGFuZGxlcil7XG4gICAgICAgICAgaWYoIW9rKXJlY29yZC5oID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyID09PSB0cnVlID8gdmFsdWUgOiBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICBpZihyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2Upe1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSl7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSlydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgY2hhaW4ubGVuZ3RoID0gMDtcbiAgICByZWNvcmQubiA9IGZhbHNlO1xuICAgIGlmKGlzUmVqZWN0KXNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHZhciBwcm9taXNlID0gcmVjb3JkLnBcbiAgICAgICAgLCBoYW5kbGVyLCBjb25zb2xlO1xuICAgICAgaWYoaXNVbmhhbmRsZWQocHJvbWlzZSkpe1xuICAgICAgICBpZihpc05vZGUpe1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbil7XG4gICAgICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZX0pO1xuICAgICAgICB9IGVsc2UgaWYoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IHJlY29yZC5hID0gdW5kZWZpbmVkO1xuICAgIH0sIDEpO1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbihwcm9taXNlKXtcbiAgdmFyIHJlY29yZCA9IHByb21pc2UuX2RcbiAgICAsIGNoYWluICA9IHJlY29yZC5hIHx8IHJlY29yZC5jXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCByZWFjdGlvbjtcbiAgaWYocmVjb3JkLmgpcmV0dXJuIGZhbHNlO1xuICB3aGlsZShjaGFpbi5sZW5ndGggPiBpKXtcbiAgICByZWFjdGlvbiA9IGNoYWluW2krK107XG4gICAgaWYocmVhY3Rpb24uZmFpbCB8fCAhaXNVbmhhbmRsZWQocmVhY3Rpb24ucHJvbWlzZSkpcmV0dXJuIGZhbHNlO1xuICB9IHJldHVybiB0cnVlO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcmVjb3JkID0gdGhpcztcbiAgaWYocmVjb3JkLmQpcmV0dXJuO1xuICByZWNvcmQuZCA9IHRydWU7XG4gIHJlY29yZCA9IHJlY29yZC5yIHx8IHJlY29yZDsgLy8gdW53cmFwXG4gIHJlY29yZC52ID0gdmFsdWU7XG4gIHJlY29yZC5zID0gMjtcbiAgcmVjb3JkLmEgPSByZWNvcmQuYy5zbGljZSgpO1xuICBub3RpZnkocmVjb3JkLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciByZWNvcmQgPSB0aGlzXG4gICAgLCB0aGVuO1xuICBpZihyZWNvcmQuZClyZXR1cm47XG4gIHJlY29yZC5kID0gdHJ1ZTtcbiAgcmVjb3JkID0gcmVjb3JkLnIgfHwgcmVjb3JkOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZihyZWNvcmQucCA9PT0gdmFsdWUpdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKXtcbiAgICAgIGFzYXAoZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7cjogcmVjb3JkLCBkOiBmYWxzZX07IC8vIHdyYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eCgkcmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eCgkcmVqZWN0LCB3cmFwcGVyLCAxKSk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjb3JkLnYgPSB2YWx1ZTtcbiAgICAgIHJlY29yZC5zID0gMTtcbiAgICAgIG5vdGlmeShyZWNvcmQsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgJHJlamVjdC5jYWxsKHtyOiByZWNvcmQsIGQ6IGZhbHNlfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmKCFVU0VfTkFUSVZFKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgUCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgdmFyIHJlY29yZCA9IHRoaXMuX2QgPSB7XG4gICAgICBwOiBzdHJpY3ROZXcodGhpcywgUCwgUFJPTUlTRSksICAgICAgICAgLy8gPC0gcHJvbWlzZVxuICAgICAgYzogW10sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgICAgYTogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgICBzOiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICAgIGQ6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBkb25lXG4gICAgICB2OiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgIGg6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBoYW5kbGVkIHJlamVjdGlvblxuICAgICAgbjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgcmVjb3JkLCAxKSwgY3R4KCRyZWplY3QsIHJlY29yZCwgMSkpO1xuICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICRyZWplY3QuY2FsbChyZWNvcmQsIGVycik7XG4gICAgfVxuICB9O1xuICByZXF1aXJlKCcuLyQucmVkZWZpbmUtYWxsJykoUC5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpe1xuICAgICAgdmFyIHJlYWN0aW9uID0gbmV3IFByb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBQKSlcbiAgICAgICAgLCBwcm9taXNlICA9IHJlYWN0aW9uLnByb21pc2VcbiAgICAgICAgLCByZWNvcmQgICA9IHRoaXMuX2Q7XG4gICAgICByZWFjdGlvbi5vayAgID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVjb3JkLmMucHVzaChyZWFjdGlvbik7XG4gICAgICBpZihyZWNvcmQuYSlyZWNvcmQuYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmKHJlY29yZC5zKW5vdGlmeShyZWNvcmQsIGZhbHNlKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGVkKXtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7UHJvbWlzZTogUH0pO1xucmVxdWlyZSgnLi8kLnNldC10by1zdHJpbmctdGFnJykoUCwgUFJPTUlTRSk7XG5yZXF1aXJlKCcuLyQuc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcbldyYXBwZXIgPSByZXF1aXJlKCcuLyQuY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpe1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3IFByb21pc2VDYXBhYmlsaXR5KHRoaXMpXG4gICAgICAsICQkcmVqZWN0ICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAkJHJlamVjdChyKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8IHRlc3RSZXNvbHZlKHRydWUpKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KXtcbiAgICAvLyBpbnN0YW5jZW9mIGluc3RlYWQgb2YgaW50ZXJuYWwgc2xvdCBjaGVjayBiZWNhdXNlIHdlIHNob3VsZCBmaXggaXQgd2l0aG91dCByZXBsYWNlbWVudCBuYXRpdmUgUHJvbWlzZSBjb3JlXG4gICAgaWYoeCBpbnN0YW5jZW9mIFAgJiYgc2FtZUNvbnN0cnVjdG9yKHguY29uc3RydWN0b3IsIHRoaXMpKXJldHVybiB4O1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3IFByb21pc2VDYXBhYmlsaXR5KHRoaXMpXG4gICAgICAsICQkcmVzb2x2ZSAgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgJCRyZXNvbHZlKHgpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKFVTRV9OQVRJVkUgJiYgcmVxdWlyZSgnLi8kLml0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7XG4gIFAuYWxsKGl0ZXIpWydjYXRjaCddKGZ1bmN0aW9uKCl7fSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IGdldENvbnN0cnVjdG9yKHRoaXMpXG4gICAgICAsIGNhcGFiaWxpdHkgPSBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVzb2x2ZSAgICA9IGNhcGFiaWxpdHkucmVzb2x2ZVxuICAgICAgLCByZWplY3QgICAgID0gY2FwYWJpbGl0eS5yZWplY3RcbiAgICAgICwgdmFsdWVzICAgICA9IFtdO1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIHZhbHVlcy5wdXNoLCB2YWx1ZXMpO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHZhbHVlcy5sZW5ndGhcbiAgICAgICAgLCByZXN1bHRzICAgPSBBcnJheShyZW1haW5pbmcpO1xuICAgICAgaWYocmVtYWluaW5nKSQuZWFjaC5jYWxsKHZhbHVlcywgZnVuY3Rpb24ocHJvbWlzZSwgaW5kZXgpe1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgaWYoYWxyZWFkeUNhbGxlZClyZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICBlbHNlIHJlc29sdmUocmVzdWx0cyk7XG4gICAgfSk7XG4gICAgaWYoYWJydXB0KXJlamVjdChhYnJ1cHQuZXJyb3IpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH0sXG4gIC8vIDI1LjQuNC40IFByb21pc2UucmFjZShpdGVyYWJsZSlcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSl7XG4gICAgdmFyIEMgICAgICAgICAgPSBnZXRDb25zdHJ1Y3Rvcih0aGlzKVxuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlamVjdCAgICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbihwcm9taXNlKXtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYoYWJydXB0KXJlamVjdChhYnJ1cHQuZXJyb3IpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuLyQuY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gMjMuMiBTZXQgT2JqZWN0c1xucmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24nKSgnU2V0JywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKXtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih0aGlzLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZyk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCAgPSByZXF1aXJlKCcuLyQuc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vJC5pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwgaW5kZXggPSB0aGlzLl9pXG4gICAgLCBwb2ludDtcbiAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHt2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlfTtcbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciAkICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oYXMnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi8kLmRlc2NyaXB0b3JzJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi8kLnJlZGVmaW5lJylcbiAgLCAkZmFpbHMgICAgICAgICA9IHJlcXVpcmUoJy4vJC5mYWlscycpXG4gICwgc2hhcmVkICAgICAgICAgPSByZXF1aXJlKCcuLyQuc2hhcmVkJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vJC5zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgdWlkICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQudWlkJylcbiAgLCB3a3MgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC53a3MnKVxuICAsIGtleU9mICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmtleW9mJylcbiAgLCAkbmFtZXMgICAgICAgICA9IHJlcXVpcmUoJy4vJC5nZXQtbmFtZXMnKVxuICAsIGVudW1LZXlzICAgICAgID0gcmVxdWlyZSgnLi8kLmVudW0ta2V5cycpXG4gICwgaXNBcnJheSAgICAgICAgPSByZXF1aXJlKCcuLyQuaXMtYXJyYXknKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuLyQudG8taW9iamVjdCcpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuLyQucHJvcGVydHktZGVzYycpXG4gICwgZ2V0RGVzYyAgICAgICAgPSAkLmdldERlc2NcbiAgLCBzZXREZXNjICAgICAgICA9ICQuc2V0RGVzY1xuICAsIF9jcmVhdGUgICAgICAgID0gJC5jcmVhdGVcbiAgLCBnZXROYW1lcyAgICAgICA9ICRuYW1lcy5nZXRcbiAgLCAkU3ltYm9sICAgICAgICA9IGdsb2JhbC5TeW1ib2xcbiAgLCAkSlNPTiAgICAgICAgICA9IGdsb2JhbC5KU09OXG4gICwgX3N0cmluZ2lmeSAgICAgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnlcbiAgLCBzZXR0ZXIgICAgICAgICA9IGZhbHNlXG4gICwgSElEREVOICAgICAgICAgPSB3a3MoJ19oaWRkZW4nKVxuICAsIGlzRW51bSAgICAgICAgID0gJC5pc0VudW1cbiAgLCBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5JylcbiAgLCBBbGxTeW1ib2xzICAgICA9IHNoYXJlZCgnc3ltYm9scycpXG4gICwgdXNlTmF0aXZlICAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXG4gICwgT2JqZWN0UHJvdG8gICAgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBfY3JlYXRlKHNldERlc2Moe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHNldERlc2ModGhpcywgJ2EnLCB7dmFsdWU6IDd9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uKGl0LCBrZXksIEQpe1xuICB2YXIgcHJvdG9EZXNjID0gZ2V0RGVzYyhPYmplY3RQcm90bywga2V5KTtcbiAgaWYocHJvdG9EZXNjKWRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBzZXREZXNjKGl0LCBrZXksIEQpO1xuICBpZihwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKXNldERlc2MoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBzZXREZXNjO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uKHRhZyl7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2wucHJvdG90eXBlKTtcbiAgc3ltLl9rID0gdGFnO1xuICBERVNDUklQVE9SUyAmJiBzZXR0ZXIgJiYgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpe1xuICAgICAgaWYoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSl0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpe1xuICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcbiAgICBpZighRC5lbnVtZXJhYmxlKXtcbiAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpc2V0RGVzYyhpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKWl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwge2VudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gc2V0RGVzYyhpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKXtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpXG4gICAgLCBpICAgID0gMFxuICAgICwgbCA9IGtleXMubGVuZ3RoXG4gICAgLCBrZXk7XG4gIHdoaWxlKGwgPiBpKSRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApe1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSl7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5KTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XVxuICAgID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIHZhciBEID0gZ2V0RGVzYyhpdCA9IHRvSU9iamVjdChpdCksIGtleSk7XG4gIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSlELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgdmFyIG5hbWVzICA9IGdldE5hbWVzKHRvSU9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTilyZXN1bHQucHVzaChrZXkpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KXtcbiAgdmFyIG5hbWVzICA9IGdldE5hbWVzKHRvSU9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSlyZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXtcbiAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gIHZhciBhcmdzID0gW2l0XVxuICAgICwgaSAgICA9IDFcbiAgICAsICQkICAgPSBhcmd1bWVudHNcbiAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gIHdoaWxlKCQkLmxlbmd0aCA+IGkpYXJncy5wdXNoKCQkW2krK10pO1xuICByZXBsYWNlciA9IGFyZ3NbMV07XG4gIGlmKHR5cGVvZiByZXBsYWNlciA9PSAnZnVuY3Rpb24nKSRyZXBsYWNlciA9IHJlcGxhY2VyO1xuICBpZigkcmVwbGFjZXIgfHwgIWlzQXJyYXkocmVwbGFjZXIpKXJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG4gICAgaWYoJHJlcGxhY2VyKXZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgaWYoIWlzU3ltYm9sKHZhbHVlKSlyZXR1cm4gdmFsdWU7XG4gIH07XG4gIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xufTtcbnZhciBidWdneUpTT04gPSAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoe2E6IFN9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSk7XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYoIXVzZU5hdGl2ZSl7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKXtcbiAgICBpZihpc1N5bWJvbCh0aGlzKSl0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xuICAgIHJldHVybiB3cmFwKHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCkpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sLnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgaXNTeW1ib2wgPSBmdW5jdGlvbihpdCl7XG4gICAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbiAgfTtcblxuICAkLmNyZWF0ZSAgICAgPSAkY3JlYXRlO1xuICAkLmlzRW51bSAgICAgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gICQuZ2V0RGVzYyAgICA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICQuc2V0RGVzYyAgICA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgJC5zZXREZXNjcyAgID0gJGRlZmluZVByb3BlcnRpZXM7XG4gICQuZ2V0TmFtZXMgICA9ICRuYW1lcy5nZXQgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgJC5nZXRTeW1ib2xzID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZihERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi8kLmxpYnJhcnknKSl7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cbn1cblxudmFyIHN5bWJvbFN0YXRpY3MgPSB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24oa2V5KXtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKGtleSl7XG4gICAgcmV0dXJuIGtleU9mKFN5bWJvbFJlZ2lzdHJ5LCBrZXkpO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uKCl7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24oKXsgc2V0dGVyID0gZmFsc2U7IH1cbn07XG4vLyAxOS40LjIuMiBTeW1ib2wuaGFzSW5zdGFuY2Vcbi8vIDE5LjQuMi4zIFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGVcbi8vIDE5LjQuMi40IFN5bWJvbC5pdGVyYXRvclxuLy8gMTkuNC4yLjYgU3ltYm9sLm1hdGNoXG4vLyAxOS40LjIuOCBTeW1ib2wucmVwbGFjZVxuLy8gMTkuNC4yLjkgU3ltYm9sLnNlYXJjaFxuLy8gMTkuNC4yLjEwIFN5bWJvbC5zcGVjaWVzXG4vLyAxOS40LjIuMTEgU3ltYm9sLnNwbGl0XG4vLyAxOS40LjIuMTIgU3ltYm9sLnRvUHJpbWl0aXZlXG4vLyAxOS40LjIuMTMgU3ltYm9sLnRvU3RyaW5nVGFnXG4vLyAxOS40LjIuMTQgU3ltYm9sLnVuc2NvcGFibGVzXG4kLmVhY2guY2FsbCgoXG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsJyArXG4gICdzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBmdW5jdGlvbihpdCl7XG4gIHZhciBzeW0gPSB3a3MoaXQpO1xuICBzeW1ib2xTdGF0aWNzW2l0XSA9IHVzZU5hdGl2ZSA/IHN5bSA6IHdyYXAoc3ltKTtcbn0pO1xuXG5zZXR0ZXIgPSB0cnVlO1xuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVywge1N5bWJvbDogJFN5bWJvbH0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1N5bWJvbCcsIHN5bWJvbFN0YXRpY3MpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICF1c2VOYXRpdmUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCF1c2VOYXRpdmUgfHwgYnVnZ3lKU09OKSwgJ0pTT04nLCB7c3RyaW5naWZ5OiAkc3RyaW5naWZ5fSk7XG5cbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ01hcCcsIHt0b0pTT046IHJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uLXRvLWpzb24nKSgnTWFwJyl9KTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuLyQuZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU2V0Jywge3RvSlNPTjogcmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24tdG8tanNvbicpKCdTZXQnKX0pOyIsInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi8kLml0ZXJhdG9ycycpO1xuSXRlcmF0b3JzLk5vZGVMaXN0ID0gSXRlcmF0b3JzLkhUTUxDb2xsZWN0aW9uID0gSXRlcmF0b3JzLkFycmF5OyIsIi8vIFRoaXMgbWV0aG9kIG9mIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBuZWVkcyB0byBiZVxuLy8ga2VwdCBpZGVudGljYWwgdG8gdGhlIHdheSBpdCBpcyBvYnRhaW5lZCBpbiBydW50aW1lLmpzXG52YXIgZyA9XG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpcztcblxuLy8gVXNlIGBnZXRPd25Qcm9wZXJ0eU5hbWVzYCBiZWNhdXNlIG5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCBjYWxsaW5nXG4vLyBgaGFzT3duUHJvcGVydHlgIG9uIHRoZSBnbG9iYWwgYHNlbGZgIG9iamVjdCBpbiBhIHdvcmtlci4gU2VlICMxODMuXG52YXIgaGFkUnVudGltZSA9IGcucmVnZW5lcmF0b3JSdW50aW1lICYmXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGcpLmluZGV4T2YoXCJyZWdlbmVyYXRvclJ1bnRpbWVcIikgPj0gMDtcblxuLy8gU2F2ZSB0aGUgb2xkIHJlZ2VuZXJhdG9yUnVudGltZSBpbiBjYXNlIGl0IG5lZWRzIHRvIGJlIHJlc3RvcmVkIGxhdGVyLlxudmFyIG9sZFJ1bnRpbWUgPSBoYWRSdW50aW1lICYmIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuXG4vLyBGb3JjZSByZWV2YWx1dGF0aW9uIG9mIHJ1bnRpbWUuanMuXG5nLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9ydW50aW1lXCIpO1xuXG5pZiAoaGFkUnVudGltZSkge1xuICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBydW50aW1lLlxuICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IG9sZFJ1bnRpbWU7XG59IGVsc2Uge1xuICAvLyBSZW1vdmUgdGhlIGdsb2JhbCBwcm9wZXJ0eSBhZGRlZCBieSBydW50aW1lLmpzLlxuICB0cnkge1xuICAgIGRlbGV0ZSBnLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBtb2R1bGUuZXhwb3J0cywgX19lc01vZHVsZTogdHJ1ZSB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfU3ltYm9sID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2xcIilbXCJkZWZhdWx0XCJdO1xuXG52YXIgX09iamVjdCRjcmVhdGUgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGVcIilbXCJkZWZhdWx0XCJdO1xuXG52YXIgX09iamVjdCRzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIilbXCJkZWZhdWx0XCJdO1xuXG52YXIgX1Byb21pc2UgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2VcIilbXCJkZWZhdWx0XCJdO1xuXG4hKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBfU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBfU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgZ2VuZXJhdG9yID0gX09iamVjdCRjcmVhdGUoKG91dGVyRm4gfHwgR2VuZXJhdG9yKS5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9IEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvciA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgaWYgKF9PYmplY3Qkc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIF9PYmplY3Qkc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IF9PYmplY3QkY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgdmFsdWUgaW5zdGFuY2VvZiBBd2FpdEFyZ3VtZW50YCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC4gU29tZSBtYXkgY29uc2lkZXIgdGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgdG9vXG4gIC8vIGN1dGVzeSwgYnV0IHRoZXkgYXJlIGN1cm11ZGdlb25zLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiBuZXcgQXdhaXRBcmd1bWVudChhcmcpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEF3YWl0QXJndW1lbnQoYXJnKSB7XG4gICAgdGhpcy5hcmcgPSBhcmc7XG4gIH1cblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gX1Byb21pc2UucmVzb2x2ZSh2YWx1ZS5hcmcpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MuZG9tYWluKSB7XG4gICAgICBpbnZva2UgPSBwcm9jZXNzLmRvbWFpbi5iaW5kKGludm9rZSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIgfHwgbWV0aG9kID09PSBcInRocm93XCIgJiYgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBBIHJldHVybiBvciB0aHJvdyAod2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIHRocm93XG4gICAgICAgICAgICAvLyBtZXRob2QpIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgICB2YXIgcmV0dXJuTWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl07XG4gICAgICAgICAgICBpZiAocmV0dXJuTWV0aG9kKSB7XG4gICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChyZXR1cm5NZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBhcmcpO1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXR1cm4gbWV0aG9kIHRocmV3IGFuIGV4Y2VwdGlvbiwgbGV0IHRoYXRcbiAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gcHJldmFpbCBvdmVyIHRoZSBvcmlnaW5hbCByZXR1cm4gb3IgdGhyb3cuXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBvdXRlciByZXR1cm4sIG5vdyB0aGF0IHRoZSBkZWxlZ2F0ZVxuICAgICAgICAgICAgICAvLyBpdGVyYXRvciBoYXMgYmVlbiB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSwgZGVsZWdhdGUuaXRlcmF0b3IsIGFyZyk7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIExpa2UgcmV0dXJuaW5nIGdlbmVyYXRvci50aHJvdyh1bmNhdWdodCksIGJ1dCB3aXRob3V0IHRoZVxuICAgICAgICAgICAgLy8gb3ZlcmhlYWQgb2YgYW4gZXh0cmEgZnVuY3Rpb24gY2FsbC5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZWxlZ2F0ZSBnZW5lcmF0b3IgcmFuIGFuZCBoYW5kbGVkIGl0cyBvd24gZXhjZXB0aW9ucyBzb1xuICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUgbWV0aG9kIHdhcywgd2UgY29udGludWUgYXMgaWYgaXQgaXNcbiAgICAgICAgICAvLyBcIm5leHRcIiB3aXRoIGFuIHVuZGVmaW5lZCBhcmcuXG4gICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuICAgICAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCkge1xuICAgICAgICAgICAgY29udGV4dC5zZW50ID0gYXJnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LnNlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IEdlblN0YXRlQ29tcGxldGVkIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmRlbGVnYXRlICYmIG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsXG4gICAgICAgICAgICBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldChza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIHRoaXMuc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIGRpc3BhdGNoRXhjZXB0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24gYWJydXB0KHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmICh0eXBlID09PSBcImJyZWFrXCIgfHwgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fCByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaChmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uIF9jYXRjaCh0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuLy8gQW1vbmcgdGhlIHZhcmlvdXMgdHJpY2tzIGZvciBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbFxuLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4vLyB1c2UgaW5kaXJlY3QgZXZhbCAod2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kpLlxudHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6IHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB1bmRlZmluZWQpOyIsIlxuLypcbiAqIEtvbnZhIEphdmFTY3JpcHQgRnJhbWV3b3JrIHYwLjExLjFcbiAqIGh0dHA6Ly9rb252YWpzLmdpdGh1Yi5pby9cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cbiAqIERhdGU6IFNhdCBKYW4gMTYgMjAxNlxuICpcbiAqIE9yaWdpbmFsIHdvcmsgQ29weXJpZ2h0IChDKSAyMDExIC0gMjAxMyBieSBFcmljIFJvd2VsbCAoS2luZXRpY0pTKVxuICogTW9kaWZpZWQgd29yayBDb3B5cmlnaHQgKEMpIDIwMTQgLSAyMDE1IGJ5IEFudG9uIExhdnJlbm92IChLb252YSlcbiAqXG4gKiBAbGljZW5zZVxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vLyBydW50aW1lIGNoZWNrIGZvciBhbHJlYWR5IGluY2x1ZGVkIEtvbnZhXG4oZnVuY3Rpb24oKXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZSBLb252YVxuICAgICAqL1xuXG4gICAgdmFyIFBJX09WRVJfMTgwID0gTWF0aC5QSSAvIDE4MDtcblxuICAgIHZhciBLb252YSA9IHtcbiAgICAgICAgLy8gcHVibGljXG4gICAgICAgIHZlcnNpb246ICcwLjExLjEnLFxuXG4gICAgICAgIC8vIHByaXZhdGVcbiAgICAgICAgc3RhZ2VzOiBbXSxcbiAgICAgICAgaWRDb3VudGVyOiAwLFxuICAgICAgICBpZHM6IHt9LFxuICAgICAgICBuYW1lczoge30sXG4gICAgICAgIHNoYXBlczoge30sXG4gICAgICAgIGxpc3RlbkNsaWNrVGFwOiBmYWxzZSxcbiAgICAgICAgaW5EYmxDbGlja1dpbmRvdzogZmFsc2UsXG5cbiAgICAgICAgLy8gY29uZmlndXJhdGlvbnNcbiAgICAgICAgZW5hYmxlVHJhY2U6IGZhbHNlLFxuICAgICAgICB0cmFjZUFyck1heDogMTAwLFxuICAgICAgICBkYmxDbGlja1dpbmRvdzogNDAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogR2xvYmFsIHBpeGVsIHJhdGlvIGNvbmZpZ3VyYXRpb24uIEtvbnZhSlMgYXV0b21hdGljYWxseSBkZXRlY3QgcGl4ZWwgcmF0aW8gb2YgY3VycmVudCBkZXZpY2UuXG4gICAgICAgICAqIEJ1dCB5b3UgbWF5IG92ZXJyaWRlIHN1Y2ggcHJvcGVydHksIGlmIHlvdSB3YW50IHRvIHVzZSB5b3VyIHZhbHVlLlxuICAgICAgICAgKiBAcHJvcGVydHkgcGl4ZWxSYXRpb1xuICAgICAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIEtvbnZhLnBpeGVsUmF0aW8gPSAxO1xuICAgICAgICAgKi9cbiAgICAgICAgcGl4ZWxSYXRpbzogdW5kZWZpbmVkLFxuICAgICAgICAvKipcbiAgICAgICAgICogRHJhZyBkaXN0YW5jZSBwcm9wZXJ0eS4gSWYgeW91IHN0YXJ0IHRvIGRyYWcgYSBub2RlIHlvdSBtYXkgd2FudCB0byB3YWl0IHVudGlsIHBvaW50ZXIgaXMgbW92ZWQgdG8gc29tZSBkaXN0YW5jZSBmcm9tIHN0YXJ0IHBvaW50LFxuICAgICAgICAgKiBvbmx5IHRoZW4gc3RhcnQgZHJhZ2dpbmcuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnRGlzdGFuY2VcbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogS29udmEuZHJhZ0Rpc3RhbmNlID0gMTA7XG4gICAgICAgICAqL1xuICAgICAgICBkcmFnRGlzdGFuY2U6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgZGVncmVlIHZhbHVlcyBmb3IgYW5nbGUgcHJvcGVydGllcy4gWW91IG1heSBzZXQgdGhpcyBwcm9wZXJ0eSB0byBmYWxzZSBpZiB5b3Ugd2FudCB0byB1c2UgcmFkaWFudCB2YWx1ZXMuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBhbmdsZURlZ1xuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBub2RlLnJvdGF0aW9uKDQ1KTsgLy8gNDUgZGVncmVlc1xuICAgICAgICAgKiBLb252YS5hbmdsZURlZyA9IGZhbHNlO1xuICAgICAgICAgKiBub2RlLnJvdGF0aW9uKE1hdGguUEkgLyAyKTsgLy8gUEkvMiByYWRpYW5cbiAgICAgICAgICovXG4gICAgICAgIGFuZ2xlRGVnOiB0cnVlLFxuICAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgZGlmZmVyZW50IHdhcm5pbmdzIGFib3V0IGVycm9ycyBvciB3cm9uZyBBUEkgdXNhZ2VcbiAgICAgICAgICogQHByb3BlcnR5IHNob3dXYXJuaW5nc1xuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBLb252YS5zaG93V2FybmluZ3MgPSBmYWxzZTtcbiAgICAgICAgICovXG4gICAgICAgIHNob3dXYXJuaW5nczogdHJ1ZSxcblxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lc3BhY2UgRmlsdGVyc1xuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgICAgICovXG4gICAgICAgIEZpbHRlcnM6IHt9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXR1cm5zIHdoZXRoZXIgb3Igbm90IGRyYWcgYW5kIGRyb3AgaXMgY3VycmVudGx5IGFjdGl2ZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAgICAgKi9cbiAgICAgICAgaXNEcmFnZ2luZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZGQgPSBLb252YS5ERDtcblxuICAgICAgICAgICAgLy8gaWYgREQgaXMgbm90IGluY2x1ZGVkIHdpdGggdGhlIGJ1aWxkLCB0aGVuXG4gICAgICAgICAgICAvLyBkcmFnIGFuZCBkcm9wIGlzIG5vdCBldmVuIHBvc3NpYmxlXG4gICAgICAgICAgICBpZiAoZGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGQuaXNEcmFnZ2luZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogcmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhIGRyYWcgYW5kIGRyb3Agb3BlcmF0aW9uIGlzIHJlYWR5LCBidXQgbWF5XG4gICAgICAgICogIG5vdCBuZWNlc3NhcmlseSBoYXZlIHN0YXJ0ZWRcbiAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICAgICovXG4gICAgICAgIGlzRHJhZ1JlYWR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkZCA9IEtvbnZhLkREO1xuXG4gICAgICAgICAgICAvLyBpZiBERCBpcyBub3QgaW5jbHVkZWQgd2l0aCB0aGUgYnVpbGQsIHRoZW5cbiAgICAgICAgICAgIC8vIGRyYWcgYW5kIGRyb3AgaXMgbm90IGV2ZW4gcG9zc2libGVcbiAgICAgICAgICAgIGlmIChkZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIWRkLm5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIF9hZGRJZDogZnVuY3Rpb24obm9kZSwgaWQpIHtcbiAgICAgICAgICAgIGlmKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlkc1tpZF0gPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfcmVtb3ZlSWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICBpZihpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaWRzW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2FkZE5hbWU6IGZ1bmN0aW9uKG5vZGUsIG5hbWUpIHtcbiAgICAgICAgICAgIGlmKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZighdGhpcy5uYW1lc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWVzW25hbWVdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubmFtZXNbbmFtZV0ucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX3JlbW92ZU5hbWU6IGZ1bmN0aW9uKG5hbWUsIF9pZCkge1xuICAgICAgICAgICAgaWYoIW5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5hbWVzW25hbWVdO1xuICAgICAgICAgICAgaWYoIW5vZGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vID0gbm9kZXNbbl07XG4gICAgICAgICAgICAgICAgaWYobm8uX2lkID09PSBfaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKG4sIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5hbWVzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRBbmdsZTogZnVuY3Rpb24oYW5nbGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuZ2xlRGVnID8gYW5nbGUgKiBQSV9PVkVSXzE4MCA6IGFuZ2xlO1xuICAgICAgICB9LFxuICAgICAgICBfcGFyc2VVQTogZnVuY3Rpb24odXNlckFnZW50KSB7XG4gICAgICAgICAgICB2YXIgdWEgPSB1c2VyQWdlbnQudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAvLyBqUXVlcnkgVUEgcmVnZXhcbiAgICAgICAgICAgICAgICBtYXRjaCA9IC8oY2hyb21lKVsgXFwvXShbXFx3Ll0rKS8uZXhlYyggdWEgKSB8fFxuICAgICAgICAgICAgICAgIC8od2Via2l0KVsgXFwvXShbXFx3Ll0rKS8uZXhlYyggdWEgKSB8fFxuICAgICAgICAgICAgICAgIC8ob3BlcmEpKD86Lip2ZXJzaW9ufClbIFxcL10oW1xcdy5dKykvLmV4ZWMoIHVhICkgfHxcbiAgICAgICAgICAgICAgICAvKG1zaWUpIChbXFx3Ll0rKS8uZXhlYyggdWEgKSB8fFxuICAgICAgICAgICAgICAgIHVhLmluZGV4T2YoJ2NvbXBhdGlibGUnKSA8IDAgJiYgLyhtb3ppbGxhKSg/Oi4qPyBydjooW1xcdy5dKyl8KS8uZXhlYyggdWEgKSB8fFxuICAgICAgICAgICAgICAgIFtdLFxuXG4gICAgICAgICAgICAgICAgLy8gYWRkaW5nIG1vYmlsZSBmbGFnIGFzIHdlbGxcbiAgICAgICAgICAgICAgICBtb2JpbGUgPSAhISh1c2VyQWdlbnQubWF0Y2goL0FuZHJvaWR8QmxhY2tCZXJyeXxpUGhvbmV8aVBhZHxpUG9kfE9wZXJhIE1pbml8SUVNb2JpbGUvaSkpLFxuICAgICAgICAgICAgICAgIGllTW9iaWxlID0gISEodXNlckFnZW50Lm1hdGNoKC9JRU1vYmlsZS9pKSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYnJvd3NlcjogbWF0Y2hbIDEgXSB8fCAnJyxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBtYXRjaFsgMiBdIHx8ICcwJyxcblxuICAgICAgICAgICAgICAgIC8vIGFkZGluZyBtb2JpbGUgZmxhYlxuICAgICAgICAgICAgICAgIG1vYmlsZTogbW9iaWxlLFxuICAgICAgICAgICAgICAgIGllTW9iaWxlOiBpZU1vYmlsZSAgLy8gSWYgdGhpcyBpcyB0cnVlIChpLmUuLCBXUDgpLCB0aGVuIEtvbnZhIHRvdWNoIGV2ZW50cyBhcmUgZXhlY3V0ZWQgaW5zdGVhZCBvZiBlcXVpdmFsZW50IEtvbnZhIG1vdXNlIGV2ZW50c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gdXNlciBhZ2VudFxuICAgICAgICBVQTogdW5kZWZpbmVkXG4gICAgfTtcblxuICAgIHZhciBnbG9iYWwgPVxuICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6XG4gICAgICAgIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDpcbiAgICAgICAgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuXG4gICAgS29udmEuVUEgPSBLb252YS5fcGFyc2VVQSgoZ2xvYmFsLm5hdmlnYXRvciAmJiBnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgJycpO1xuXG4gICAgaWYgKGdsb2JhbC5Lb252YSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0tvbnZhIGluc3RhbmNlIGlzIGFscmVhZHkgZXhpc3QgaW4gY3VycmVudCBldmlyb21lbnQuICcgK1xuICAgICAgICAgICAgJ1BsZWFzZSB1c2Ugb25seSBvbmUgaW5zdGFuY2UuJ1xuICAgICAgICApO1xuICAgIH1cbiAgICBnbG9iYWwuS29udmEgPSBLb252YTtcbiAgICBLb252YS5nbG9iYWwgPSBnbG9iYWw7XG5cblxuICAgIGlmKCB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gcnVudGltZS1jaGVjayBmb3IgYnJvd3NlcmlmeSBhbmQgbncuanMgKG5vZGUtd2Via2l0KVxuICAgICAgICBpZihnbG9iYWwud2luZG93ICYmIGdsb2JhbC53aW5kb3cuZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIEtvbnZhLmRvY3VtZW50ID0gZ2xvYmFsLndpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgICAgIEtvbnZhLndpbmRvdyA9IGdsb2JhbC53aW5kb3c7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcbiAgICAgICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAgICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICAgICAgICB2YXIgQ2FudmFzID0gcmVxdWlyZSgnY2FudmFzJyk7XG4gICAgICAgICAgICB2YXIganNkb20gPSByZXF1aXJlKCdqc2RvbScpLmpzZG9tO1xuXG4gICAgICAgICAgICBLb252YS5kb2N1bWVudCA9IGpzZG9tKCc8IURPQ1RZUEUgaHRtbD48aHRtbD48aGVhZD48L2hlYWQ+PGJvZHk+PC9ib2R5PjwvaHRtbD4nKTtcbiAgICAgICAgICAgIEtvbnZhLndpbmRvdyA9IEtvbnZhLmRvY3VtZW50LnBhcmVudFdpbmRvdztcbiAgICAgICAgICAgIEtvbnZhLndpbmRvdy5JbWFnZSA9IENhbnZhcy5JbWFnZTtcbiAgICAgICAgICAgIEtvbnZhLl9ub2RlQ2FudmFzID0gQ2FudmFzO1xuICAgICAgICB9XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gS29udmE7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIEtvbnZhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgS29udmEuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICBLb252YS53aW5kb3cgPSB3aW5kb3c7XG59KSgpO1xuXG4vKmVzbGludC1kaXNhYmxlICBlcWVxZXEsIG5vLWNvbmQtYXNzaWduLCBuby1lbXB0eSovXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qKlxuICAgICAqIENvbGxlY3Rpb24gY29uc3RydWN0b3IuICBDb2xsZWN0aW9uIGV4dGVuZHNcbiAgICAgKiAgQXJyYXkuICBUaGlzIGNsYXNzIGlzIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB7QGxpbmsgS29udmEuQ29udGFpbmVyI2dldH1cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKi9cbiAgICBLb252YS5Db2xsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLCBsZW5ndGggPSBhcmdzLmxlbmd0aCwgaSA9IDA7XG5cbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIGZvcig7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpc1tpXSA9IGFyZ3NbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBLb252YS5Db2xsZWN0aW9uLnByb3RvdHlwZSA9IFtdO1xuICAgIC8qKlxuICAgICAqIGl0ZXJhdGUgdGhyb3VnaCBub2RlIGFycmF5IGFuZCBydW4gYSBmdW5jdGlvbiBmb3IgZWFjaCBub2RlLlxuICAgICAqICBUaGUgbm9kZSBhbmQgaW5kZXggaXMgcGFzc2VkIGludG8gdGhlIGZ1bmN0aW9uXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db2xsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBhbGwgbm9kZXMgd2l0aCBuYW1lIGZvbyBpbnNpZGUgbGF5ZXIsIGFuZCBzZXQgeCB0byAxMCBmb3IgZWFjaFxuICAgICAqIGxheWVyLmdldCgnLmZvbycpLmVhY2goZnVuY3Rpb24oc2hhcGUsIG4pIHtcbiAgICAgKiAgIHNoYXBlLnNldFgoMTApO1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIEtvbnZhLkNvbGxlY3Rpb24ucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgIGZvcih2YXIgbiA9IDA7IG4gPCB0aGlzLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICBmdW5jKHRoaXNbbl0sIG4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IGNvbGxlY3Rpb24gaW50byBhbiBhcnJheVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29sbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBLb252YS5Db2xsZWN0aW9uLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcnIgPSBbXSxcbiAgICAgICAgICAgIGxlbiA9IHRoaXMubGVuZ3RoLFxuICAgICAgICAgICAgbjtcblxuICAgICAgICBmb3IobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgYXJyLnB1c2godGhpc1tuXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGNvbnZlcnQgYXJyYXkgaW50byBhIGNvbGxlY3Rpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKi9cbiAgICBLb252YS5Db2xsZWN0aW9uLnRvQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKGFycikge1xuICAgICAgICB2YXIgY29sbGVjdGlvbiA9IG5ldyBLb252YS5Db2xsZWN0aW9uKCksXG4gICAgICAgICAgICBsZW4gPSBhcnIubGVuZ3RoLFxuICAgICAgICAgICAgbjtcblxuICAgICAgICBmb3IobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgY29sbGVjdGlvbi5wdXNoKGFycltuXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfTtcblxuICAgIC8vIG1hcCBvbmUgbWV0aG9kIGJ5IGl0J3MgbmFtZVxuICAgIEtvbnZhLkNvbGxlY3Rpb24uX21hcE1ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgS29udmEuQ29sbGVjdGlvbi5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tpXVttZXRob2ROYW1lXS5hcHBseSh0aGlzW2ldLCBhcmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyA9IGZ1bmN0aW9uKGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHZhciBwcm90ID0gY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgICAgICBmb3IodmFyIG1ldGhvZE5hbWUgaW4gcHJvdCkge1xuICAgICAgICAgICAgS29udmEuQ29sbGVjdGlvbi5fbWFwTWV0aG9kKG1ldGhvZE5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgKiBMYXN0IHVwZGF0ZWQgTm92ZW1iZXIgMjAxMVxuICAgICogQnkgU2ltb24gU2FycmlzXG4gICAgKiB3d3cuc2ltb25zYXJyaXMuY29tXG4gICAgKiBzYXJyaXNAYWNtLm9yZ1xuICAgICpcbiAgICAqIEZyZWUgdG8gdXNlIGFuZCBkaXN0cmlidXRlIGF0IHdpbGxcbiAgICAqIFNvIGxvbmcgYXMgeW91IGFyZSBuaWNlIHRvIHBlb3BsZSwgZXRjXG4gICAgKi9cblxuICAgIC8qXG4gICAgKiBUaGUgdXNhZ2Ugb2YgdGhpcyBjbGFzcyB3YXMgaW5zcGlyZWQgYnkgc29tZSBvZiB0aGUgd29yayBkb25lIGJ5IGEgZm9ya2VkXG4gICAgKiBwcm9qZWN0LCBLaW5ldGljSlMtRXh0IGJ5IFdhcHB3b3Jrcywgd2hpY2ggaXMgYmFzZWQgb24gU2ltb24ncyBUcmFuc2Zvcm1cbiAgICAqIGNsYXNzLiAgTW9kaWZpZWQgYnkgRXJpYyBSb3dlbGxcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW21dIE9wdGlvbmFsIHNpeC1lbGVtZW50IG1hdHJpeFxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqL1xuICAgIEtvbnZhLlRyYW5zZm9ybSA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgdGhpcy5tID0gKG0gJiYgbS5zbGljZSgpKSB8fCBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgfTtcblxuICAgIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGUgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3B5IEtvbnZhLlRyYW5zZm9ybSBvYmplY3RcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuVHJhbnNmb3JtfVxuICAgICAgICAgKi9cbiAgICAgICAgY29weTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEtvbnZhLlRyYW5zZm9ybSh0aGlzLm0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJhbnNmb3JtIHBvaW50XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50IDJEIHBvaW50KHgsIHkpXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IDJEIHBvaW50KHgsIHkpXG4gICAgICAgICAqL1xuICAgICAgICBwb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhpcy5tO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBtWzBdICogcG9pbnQueCArIG1bMl0gKiBwb2ludC55ICsgbVs0XSxcbiAgICAgICAgICAgICAgICB5OiBtWzFdICogcG9pbnQueCArIG1bM10gKiBwb2ludC55ICsgbVs1XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGx5IHRyYW5zbGF0aW9uXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgdGhpcy5tWzRdICs9IHRoaXMubVswXSAqIHggKyB0aGlzLm1bMl0gKiB5O1xuICAgICAgICAgICAgdGhpcy5tWzVdICs9IHRoaXMubVsxXSAqIHggKyB0aGlzLm1bM10gKiB5O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBseSBzY2FsZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzeFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3lcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cbiAgICAgICAgICovXG4gICAgICAgIHNjYWxlOiBmdW5jdGlvbihzeCwgc3kpIHtcbiAgICAgICAgICAgIHRoaXMubVswXSAqPSBzeDtcbiAgICAgICAgICAgIHRoaXMubVsxXSAqPSBzeDtcbiAgICAgICAgICAgIHRoaXMubVsyXSAqPSBzeTtcbiAgICAgICAgICAgIHRoaXMubVszXSAqPSBzeTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbHkgcm90YXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkICBBbmdsZSBpbiByYWRpYW5zXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICAgICAqL1xuICAgICAgICByb3RhdGU6IGZ1bmN0aW9uKHJhZCkge1xuICAgICAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgICAgICAgICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICAgICAgICAgICAgdmFyIG0xMSA9IHRoaXMubVswXSAqIGMgKyB0aGlzLm1bMl0gKiBzO1xuICAgICAgICAgICAgdmFyIG0xMiA9IHRoaXMubVsxXSAqIGMgKyB0aGlzLm1bM10gKiBzO1xuICAgICAgICAgICAgdmFyIG0yMSA9IHRoaXMubVswXSAqIC1zICsgdGhpcy5tWzJdICogYztcbiAgICAgICAgICAgIHZhciBtMjIgPSB0aGlzLm1bMV0gKiAtcyArIHRoaXMubVszXSAqIGM7XG4gICAgICAgICAgICB0aGlzLm1bMF0gPSBtMTE7XG4gICAgICAgICAgICB0aGlzLm1bMV0gPSBtMTI7XG4gICAgICAgICAgICB0aGlzLm1bMl0gPSBtMjE7XG4gICAgICAgICAgICB0aGlzLm1bM10gPSBtMjI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gMkQgcG9pbnQoeCwgeSlcbiAgICAgICAgICovXG4gICAgICAgIGdldFRyYW5zbGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogdGhpcy5tWzRdLFxuICAgICAgICAgICAgICAgIHk6IHRoaXMubVs1XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGx5IHNrZXdcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3hcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHN5XG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICAgICAqL1xuICAgICAgICBza2V3OiBmdW5jdGlvbihzeCwgc3kpIHtcbiAgICAgICAgICAgIHZhciBtMTEgPSB0aGlzLm1bMF0gKyB0aGlzLm1bMl0gKiBzeTtcbiAgICAgICAgICAgIHZhciBtMTIgPSB0aGlzLm1bMV0gKyB0aGlzLm1bM10gKiBzeTtcbiAgICAgICAgICAgIHZhciBtMjEgPSB0aGlzLm1bMl0gKyB0aGlzLm1bMF0gKiBzeDtcbiAgICAgICAgICAgIHZhciBtMjIgPSB0aGlzLm1bM10gKyB0aGlzLm1bMV0gKiBzeDtcbiAgICAgICAgICAgIHRoaXMubVswXSA9IG0xMTtcbiAgICAgICAgICAgIHRoaXMubVsxXSA9IG0xMjtcbiAgICAgICAgICAgIHRoaXMubVsyXSA9IG0yMTtcbiAgICAgICAgICAgIHRoaXMubVszXSA9IG0yMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYW5zZm9ybSBtdWx0aXBsaWNhdGlvblxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7S29udmEuVHJhbnNmb3JtfSBtYXRyaXhcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5OiBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICAgICAgICAgIHZhciBtMTEgPSB0aGlzLm1bMF0gKiBtYXRyaXgubVswXSArIHRoaXMubVsyXSAqIG1hdHJpeC5tWzFdO1xuICAgICAgICAgICAgdmFyIG0xMiA9IHRoaXMubVsxXSAqIG1hdHJpeC5tWzBdICsgdGhpcy5tWzNdICogbWF0cml4Lm1bMV07XG5cbiAgICAgICAgICAgIHZhciBtMjEgPSB0aGlzLm1bMF0gKiBtYXRyaXgubVsyXSArIHRoaXMubVsyXSAqIG1hdHJpeC5tWzNdO1xuICAgICAgICAgICAgdmFyIG0yMiA9IHRoaXMubVsxXSAqIG1hdHJpeC5tWzJdICsgdGhpcy5tWzNdICogbWF0cml4Lm1bM107XG5cbiAgICAgICAgICAgIHZhciBkeCA9IHRoaXMubVswXSAqIG1hdHJpeC5tWzRdICsgdGhpcy5tWzJdICogbWF0cml4Lm1bNV0gKyB0aGlzLm1bNF07XG4gICAgICAgICAgICB2YXIgZHkgPSB0aGlzLm1bMV0gKiBtYXRyaXgubVs0XSArIHRoaXMubVszXSAqIG1hdHJpeC5tWzVdICsgdGhpcy5tWzVdO1xuXG4gICAgICAgICAgICB0aGlzLm1bMF0gPSBtMTE7XG4gICAgICAgICAgICB0aGlzLm1bMV0gPSBtMTI7XG4gICAgICAgICAgICB0aGlzLm1bMl0gPSBtMjE7XG4gICAgICAgICAgICB0aGlzLm1bM10gPSBtMjI7XG4gICAgICAgICAgICB0aGlzLm1bNF0gPSBkeDtcbiAgICAgICAgICAgIHRoaXMubVs1XSA9IGR5O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnZlcnQgdGhlIG1hdHJpeFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICAgICAqL1xuICAgICAgICBpbnZlcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGQgPSAxIC8gKHRoaXMubVswXSAqIHRoaXMubVszXSAtIHRoaXMubVsxXSAqIHRoaXMubVsyXSk7XG4gICAgICAgICAgICB2YXIgbTAgPSB0aGlzLm1bM10gKiBkO1xuICAgICAgICAgICAgdmFyIG0xID0gLXRoaXMubVsxXSAqIGQ7XG4gICAgICAgICAgICB2YXIgbTIgPSAtdGhpcy5tWzJdICogZDtcbiAgICAgICAgICAgIHZhciBtMyA9IHRoaXMubVswXSAqIGQ7XG4gICAgICAgICAgICB2YXIgbTQgPSBkICogKHRoaXMubVsyXSAqIHRoaXMubVs1XSAtIHRoaXMubVszXSAqIHRoaXMubVs0XSk7XG4gICAgICAgICAgICB2YXIgbTUgPSBkICogKHRoaXMubVsxXSAqIHRoaXMubVs0XSAtIHRoaXMubVswXSAqIHRoaXMubVs1XSk7XG4gICAgICAgICAgICB0aGlzLm1bMF0gPSBtMDtcbiAgICAgICAgICAgIHRoaXMubVsxXSA9IG0xO1xuICAgICAgICAgICAgdGhpcy5tWzJdID0gbTI7XG4gICAgICAgICAgICB0aGlzLm1bM10gPSBtMztcbiAgICAgICAgICAgIHRoaXMubVs0XSA9IG00O1xuICAgICAgICAgICAgdGhpcy5tWzVdID0gbTU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJldHVybiBtYXRyaXhcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgdG8gYWJzb2x1dGUgcG9zaXRpb24gdmlhIHRyYW5zbGF0aW9uXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cbiAgICAgICAgICogQGF1dGhvciBlcmljZHJvd2VsbFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0QWJzb2x1dGVQb3NpdGlvbjogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgdmFyIG0wID0gdGhpcy5tWzBdLFxuICAgICAgICAgICAgICAgIG0xID0gdGhpcy5tWzFdLFxuICAgICAgICAgICAgICAgIG0yID0gdGhpcy5tWzJdLFxuICAgICAgICAgICAgICAgIG0zID0gdGhpcy5tWzNdLFxuICAgICAgICAgICAgICAgIG00ID0gdGhpcy5tWzRdLFxuICAgICAgICAgICAgICAgIG01ID0gdGhpcy5tWzVdLFxuICAgICAgICAgICAgICAgIHl0ID0gKChtMCAqICh5IC0gbTUpKSAtIChtMSAqICh4IC0gbTQpKSkgLyAoKG0wICogbTMpIC0gKG0xICogbTIpKSxcbiAgICAgICAgICAgICAgICB4dCA9ICh4IC0gbTQgLSAobTIgKiB5dCkpIC8gbTA7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZSh4dCwgeXQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIENPTlNUQU5UU1xuICAgIHZhciBDT05URVhUXzJEID0gJzJkJyxcbiAgICAgICAgT0JKRUNUX0FSUkFZID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgICAgT0JKRUNUX05VTUJFUiA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgICAgICBPQkpFQ1RfU1RSSU5HID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgICAgIFBJX09WRVJfREVHMTgwID0gTWF0aC5QSSAvIDE4MCxcbiAgICAgICAgREVHMTgwX09WRVJfUEkgPSAxODAgLyBNYXRoLlBJLFxuICAgICAgICBIQVNIID0gJyMnLFxuICAgICAgICBFTVBUWV9TVFJJTkcgPSAnJyxcbiAgICAgICAgWkVSTyA9ICcwJyxcbiAgICAgICAgS09OVkFfV0FSTklORyA9ICdLb252YSB3YXJuaW5nOiAnLFxuICAgICAgICBLT05WQV9FUlJPUiA9ICdLb252YSBlcnJvcjogJyxcbiAgICAgICAgUkdCX1BBUkVOID0gJ3JnYignLFxuICAgICAgICBDT0xPUlMgPSB7XG4gICAgICAgICAgICBhbGljZWJsdWU6IFsyNDAsIDI0OCwgMjU1XSxcbiAgICAgICAgICAgIGFudGlxdWV3aGl0ZTogWzI1MCwgMjM1LCAyMTVdLFxuICAgICAgICAgICAgYXF1YTogWzAsIDI1NSwgMjU1XSxcbiAgICAgICAgICAgIGFxdWFtYXJpbmU6IFsxMjcsIDI1NSwgMjEyXSxcbiAgICAgICAgICAgIGF6dXJlOiBbMjQwLCAyNTUsIDI1NV0sXG4gICAgICAgICAgICBiZWlnZTogWzI0NSwgMjQ1LCAyMjBdLFxuICAgICAgICAgICAgYmlzcXVlOiBbMjU1LCAyMjgsIDE5Nl0sXG4gICAgICAgICAgICBibGFjazogWzAsIDAsIDBdLFxuICAgICAgICAgICAgYmxhbmNoZWRhbG1vbmQ6IFsyNTUsIDIzNSwgMjA1XSxcbiAgICAgICAgICAgIGJsdWU6IFswLCAwLCAyNTVdLFxuICAgICAgICAgICAgYmx1ZXZpb2xldDogWzEzOCwgNDMsIDIyNl0sXG4gICAgICAgICAgICBicm93bjogWzE2NSwgNDIsIDQyXSxcbiAgICAgICAgICAgIGJ1cmx5d29vZDogWzIyMiwgMTg0LCAxMzVdLFxuICAgICAgICAgICAgY2FkZXRibHVlOiBbOTUsIDE1OCwgMTYwXSxcbiAgICAgICAgICAgIGNoYXJ0cmV1c2U6IFsxMjcsIDI1NSwgMF0sXG4gICAgICAgICAgICBjaG9jb2xhdGU6IFsyMTAsIDEwNSwgMzBdLFxuICAgICAgICAgICAgY29yYWw6IFsyNTUsIDEyNywgODBdLFxuICAgICAgICAgICAgY29ybmZsb3dlcmJsdWU6IFsxMDAsIDE0OSwgMjM3XSxcbiAgICAgICAgICAgIGNvcm5zaWxrOiBbMjU1LCAyNDgsIDIyMF0sXG4gICAgICAgICAgICBjcmltc29uOiBbMjIwLCAyMCwgNjBdLFxuICAgICAgICAgICAgY3lhbjogWzAsIDI1NSwgMjU1XSxcbiAgICAgICAgICAgIGRhcmtibHVlOiBbMCwgMCwgMTM5XSxcbiAgICAgICAgICAgIGRhcmtjeWFuOiBbMCwgMTM5LCAxMzldLFxuICAgICAgICAgICAgZGFya2dvbGRlbnJvZDogWzE4NCwgMTMyLCAxMV0sXG4gICAgICAgICAgICBkYXJrZ3JheTogWzE2OSwgMTY5LCAxNjldLFxuICAgICAgICAgICAgZGFya2dyZWVuOiBbMCwgMTAwLCAwXSxcbiAgICAgICAgICAgIGRhcmtncmV5OiBbMTY5LCAxNjksIDE2OV0sXG4gICAgICAgICAgICBkYXJra2hha2k6IFsxODksIDE4MywgMTA3XSxcbiAgICAgICAgICAgIGRhcmttYWdlbnRhOiBbMTM5LCAwLCAxMzldLFxuICAgICAgICAgICAgZGFya29saXZlZ3JlZW46IFs4NSwgMTA3LCA0N10sXG4gICAgICAgICAgICBkYXJrb3JhbmdlOiBbMjU1LCAxNDAsIDBdLFxuICAgICAgICAgICAgZGFya29yY2hpZDogWzE1MywgNTAsIDIwNF0sXG4gICAgICAgICAgICBkYXJrcmVkOiBbMTM5LCAwLCAwXSxcbiAgICAgICAgICAgIGRhcmtzYWxtb246IFsyMzMsIDE1MCwgMTIyXSxcbiAgICAgICAgICAgIGRhcmtzZWFncmVlbjogWzE0MywgMTg4LCAxNDNdLFxuICAgICAgICAgICAgZGFya3NsYXRlYmx1ZTogWzcyLCA2MSwgMTM5XSxcbiAgICAgICAgICAgIGRhcmtzbGF0ZWdyYXk6IFs0NywgNzksIDc5XSxcbiAgICAgICAgICAgIGRhcmtzbGF0ZWdyZXk6IFs0NywgNzksIDc5XSxcbiAgICAgICAgICAgIGRhcmt0dXJxdW9pc2U6IFswLCAyMDYsIDIwOV0sXG4gICAgICAgICAgICBkYXJrdmlvbGV0OiBbMTQ4LCAwLCAyMTFdLFxuICAgICAgICAgICAgZGVlcHBpbms6IFsyNTUsIDIwLCAxNDddLFxuICAgICAgICAgICAgZGVlcHNreWJsdWU6IFswLCAxOTEsIDI1NV0sXG4gICAgICAgICAgICBkaW1ncmF5OiBbMTA1LCAxMDUsIDEwNV0sXG4gICAgICAgICAgICBkaW1ncmV5OiBbMTA1LCAxMDUsIDEwNV0sXG4gICAgICAgICAgICBkb2RnZXJibHVlOiBbMzAsIDE0NCwgMjU1XSxcbiAgICAgICAgICAgIGZpcmVicmljazogWzE3OCwgMzQsIDM0XSxcbiAgICAgICAgICAgIGZsb3JhbHdoaXRlOiBbMjU1LCAyNTUsIDI0MF0sXG4gICAgICAgICAgICBmb3Jlc3RncmVlbjogWzM0LCAxMzksIDM0XSxcbiAgICAgICAgICAgIGZ1Y2hzaWE6IFsyNTUsIDAsIDI1NV0sXG4gICAgICAgICAgICBnYWluc2Jvcm86IFsyMjAsIDIyMCwgMjIwXSxcbiAgICAgICAgICAgIGdob3N0d2hpdGU6IFsyNDgsIDI0OCwgMjU1XSxcbiAgICAgICAgICAgIGdvbGQ6IFsyNTUsIDIxNSwgMF0sXG4gICAgICAgICAgICBnb2xkZW5yb2Q6IFsyMTgsIDE2NSwgMzJdLFxuICAgICAgICAgICAgZ3JheTogWzEyOCwgMTI4LCAxMjhdLFxuICAgICAgICAgICAgZ3JlZW46IFswLCAxMjgsIDBdLFxuICAgICAgICAgICAgZ3JlZW55ZWxsb3c6IFsxNzMsIDI1NSwgNDddLFxuICAgICAgICAgICAgZ3JleTogWzEyOCwgMTI4LCAxMjhdLFxuICAgICAgICAgICAgaG9uZXlkZXc6IFsyNDAsIDI1NSwgMjQwXSxcbiAgICAgICAgICAgIGhvdHBpbms6IFsyNTUsIDEwNSwgMTgwXSxcbiAgICAgICAgICAgIGluZGlhbnJlZDogWzIwNSwgOTIsIDkyXSxcbiAgICAgICAgICAgIGluZGlnbzogWzc1LCAwLCAxMzBdLFxuICAgICAgICAgICAgaXZvcnk6IFsyNTUsIDI1NSwgMjQwXSxcbiAgICAgICAgICAgIGtoYWtpOiBbMjQwLCAyMzAsIDE0MF0sXG4gICAgICAgICAgICBsYXZlbmRlcjogWzIzMCwgMjMwLCAyNTBdLFxuICAgICAgICAgICAgbGF2ZW5kZXJibHVzaDogWzI1NSwgMjQwLCAyNDVdLFxuICAgICAgICAgICAgbGF3bmdyZWVuOiBbMTI0LCAyNTIsIDBdLFxuICAgICAgICAgICAgbGVtb25jaGlmZm9uOiBbMjU1LCAyNTAsIDIwNV0sXG4gICAgICAgICAgICBsaWdodGJsdWU6IFsxNzMsIDIxNiwgMjMwXSxcbiAgICAgICAgICAgIGxpZ2h0Y29yYWw6IFsyNDAsIDEyOCwgMTI4XSxcbiAgICAgICAgICAgIGxpZ2h0Y3lhbjogWzIyNCwgMjU1LCAyNTVdLFxuICAgICAgICAgICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsyNTAsIDI1MCwgMjEwXSxcbiAgICAgICAgICAgIGxpZ2h0Z3JheTogWzIxMSwgMjExLCAyMTFdLFxuICAgICAgICAgICAgbGlnaHRncmVlbjogWzE0NCwgMjM4LCAxNDRdLFxuICAgICAgICAgICAgbGlnaHRncmV5OiBbMjExLCAyMTEsIDIxMV0sXG4gICAgICAgICAgICBsaWdodHBpbms6IFsyNTUsIDE4MiwgMTkzXSxcbiAgICAgICAgICAgIGxpZ2h0c2FsbW9uOiBbMjU1LCAxNjAsIDEyMl0sXG4gICAgICAgICAgICBsaWdodHNlYWdyZWVuOiBbMzIsIDE3OCwgMTcwXSxcbiAgICAgICAgICAgIGxpZ2h0c2t5Ymx1ZTogWzEzNSwgMjA2LCAyNTBdLFxuICAgICAgICAgICAgbGlnaHRzbGF0ZWdyYXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgICAgICAgICAgIGxpZ2h0c2xhdGVncmV5OiBbMTE5LCAxMzYsIDE1M10sXG4gICAgICAgICAgICBsaWdodHN0ZWVsYmx1ZTogWzE3NiwgMTk2LCAyMjJdLFxuICAgICAgICAgICAgbGlnaHR5ZWxsb3c6IFsyNTUsIDI1NSwgMjI0XSxcbiAgICAgICAgICAgIGxpbWU6IFswLCAyNTUsIDBdLFxuICAgICAgICAgICAgbGltZWdyZWVuOiBbNTAsIDIwNSwgNTBdLFxuICAgICAgICAgICAgbGluZW46IFsyNTAsIDI0MCwgMjMwXSxcbiAgICAgICAgICAgIG1hZ2VudGE6IFsyNTUsIDAsIDI1NV0sXG4gICAgICAgICAgICBtYXJvb246IFsxMjgsIDAsIDBdLFxuICAgICAgICAgICAgbWVkaXVtYXF1YW1hcmluZTogWzEwMiwgMjA1LCAxNzBdLFxuICAgICAgICAgICAgbWVkaXVtYmx1ZTogWzAsIDAsIDIwNV0sXG4gICAgICAgICAgICBtZWRpdW1vcmNoaWQ6IFsxODYsIDg1LCAyMTFdLFxuICAgICAgICAgICAgbWVkaXVtcHVycGxlOiBbMTQ3LCAxMTIsIDIxOV0sXG4gICAgICAgICAgICBtZWRpdW1zZWFncmVlbjogWzYwLCAxNzksIDExM10sXG4gICAgICAgICAgICBtZWRpdW1zbGF0ZWJsdWU6IFsxMjMsIDEwNCwgMjM4XSxcbiAgICAgICAgICAgIG1lZGl1bXNwcmluZ2dyZWVuOiBbMCwgMjUwLCAxNTRdLFxuICAgICAgICAgICAgbWVkaXVtdHVycXVvaXNlOiBbNzIsIDIwOSwgMjA0XSxcbiAgICAgICAgICAgIG1lZGl1bXZpb2xldHJlZDogWzE5OSwgMjEsIDEzM10sXG4gICAgICAgICAgICBtaWRuaWdodGJsdWU6IFsyNSwgMjUsIDExMl0sXG4gICAgICAgICAgICBtaW50Y3JlYW06IFsyNDUsIDI1NSwgMjUwXSxcbiAgICAgICAgICAgIG1pc3R5cm9zZTogWzI1NSwgMjI4LCAyMjVdLFxuICAgICAgICAgICAgbW9jY2FzaW46IFsyNTUsIDIyOCwgMTgxXSxcbiAgICAgICAgICAgIG5hdmFqb3doaXRlOiBbMjU1LCAyMjIsIDE3M10sXG4gICAgICAgICAgICBuYXZ5OiBbMCwgMCwgMTI4XSxcbiAgICAgICAgICAgIG9sZGxhY2U6IFsyNTMsIDI0NSwgMjMwXSxcbiAgICAgICAgICAgIG9saXZlOiBbMTI4LCAxMjgsIDBdLFxuICAgICAgICAgICAgb2xpdmVkcmFiOiBbMTA3LCAxNDIsIDM1XSxcbiAgICAgICAgICAgIG9yYW5nZTogWzI1NSwgMTY1LCAwXSxcbiAgICAgICAgICAgIG9yYW5nZXJlZDogWzI1NSwgNjksIDBdLFxuICAgICAgICAgICAgb3JjaGlkOiBbMjE4LCAxMTIsIDIxNF0sXG4gICAgICAgICAgICBwYWxlZ29sZGVucm9kOiBbMjM4LCAyMzIsIDE3MF0sXG4gICAgICAgICAgICBwYWxlZ3JlZW46IFsxNTIsIDI1MSwgMTUyXSxcbiAgICAgICAgICAgIHBhbGV0dXJxdW9pc2U6IFsxNzUsIDIzOCwgMjM4XSxcbiAgICAgICAgICAgIHBhbGV2aW9sZXRyZWQ6IFsyMTksIDExMiwgMTQ3XSxcbiAgICAgICAgICAgIHBhcGF5YXdoaXA6IFsyNTUsIDIzOSwgMjEzXSxcbiAgICAgICAgICAgIHBlYWNocHVmZjogWzI1NSwgMjE4LCAxODVdLFxuICAgICAgICAgICAgcGVydTogWzIwNSwgMTMzLCA2M10sXG4gICAgICAgICAgICBwaW5rOiBbMjU1LCAxOTIsIDIwM10sXG4gICAgICAgICAgICBwbHVtOiBbMjIxLCAxNjAsIDIwM10sXG4gICAgICAgICAgICBwb3dkZXJibHVlOiBbMTc2LCAyMjQsIDIzMF0sXG4gICAgICAgICAgICBwdXJwbGU6IFsxMjgsIDAsIDEyOF0sXG4gICAgICAgICAgICByZWJlY2NhcHVycGxlOiBbMTAyLCA1MSwgMTUzXSxcbiAgICAgICAgICAgIHJlZDogWzI1NSwgMCwgMF0sXG4gICAgICAgICAgICByb3N5YnJvd246IFsxODgsIDE0MywgMTQzXSxcbiAgICAgICAgICAgIHJveWFsYmx1ZTogWzY1LCAxMDUsIDIyNV0sXG4gICAgICAgICAgICBzYWRkbGVicm93bjogWzEzOSwgNjksIDE5XSxcbiAgICAgICAgICAgIHNhbG1vbjogWzI1MCwgMTI4LCAxMTRdLFxuICAgICAgICAgICAgc2FuZHlicm93bjogWzI0NCwgMTY0LCA5Nl0sXG4gICAgICAgICAgICBzZWFncmVlbjogWzQ2LCAxMzksIDg3XSxcbiAgICAgICAgICAgIHNlYXNoZWxsOiBbMjU1LCAyNDUsIDIzOF0sXG4gICAgICAgICAgICBzaWVubmE6IFsxNjAsIDgyLCA0NV0sXG4gICAgICAgICAgICBzaWx2ZXI6IFsxOTIsIDE5MiwgMTkyXSxcbiAgICAgICAgICAgIHNreWJsdWU6IFsxMzUsIDIwNiwgMjM1XSxcbiAgICAgICAgICAgIHNsYXRlYmx1ZTogWzEwNiwgOTAsIDIwNV0sXG4gICAgICAgICAgICBzbGF0ZWdyYXk6IFsxMTksIDEyOCwgMTQ0XSxcbiAgICAgICAgICAgIHNsYXRlZ3JleTogWzExOSwgMTI4LCAxNDRdLFxuICAgICAgICAgICAgc25vdzogWzI1NSwgMjU1LCAyNTBdLFxuICAgICAgICAgICAgc3ByaW5nZ3JlZW46IFswLCAyNTUsIDEyN10sXG4gICAgICAgICAgICBzdGVlbGJsdWU6IFs3MCwgMTMwLCAxODBdLFxuICAgICAgICAgICAgdGFuOiBbMjEwLCAxODAsIDE0MF0sXG4gICAgICAgICAgICB0ZWFsOiBbMCwgMTI4LCAxMjhdLFxuICAgICAgICAgICAgdGhpc3RsZTogWzIxNiwgMTkxLCAyMTZdLFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IFsyNTUsIDI1NSwgMjU1LCAwXSxcbiAgICAgICAgICAgIHRvbWF0bzogWzI1NSwgOTksIDcxXSxcbiAgICAgICAgICAgIHR1cnF1b2lzZTogWzY0LCAyMjQsIDIwOF0sXG4gICAgICAgICAgICB2aW9sZXQ6IFsyMzgsIDEzMCwgMjM4XSxcbiAgICAgICAgICAgIHdoZWF0OiBbMjQ1LCAyMjIsIDE3OV0sXG4gICAgICAgICAgICB3aGl0ZTogWzI1NSwgMjU1LCAyNTVdLFxuICAgICAgICAgICAgd2hpdGVzbW9rZTogWzI0NSwgMjQ1LCAyNDVdLFxuICAgICAgICAgICAgeWVsbG93OiBbMjU1LCAyNTUsIDBdLFxuICAgICAgICAgICAgeWVsbG93Z3JlZW46IFsxNTQsIDIwNSwgNV1cbiAgICAgICAgfSxcblxuICAgICAgICBSR0JfUkVHRVggPSAvcmdiXFwoKFxcZHsxLDN9KSwoXFxkezEsM30pLChcXGR7MSwzfSlcXCkvO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZSBVdGlsXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICovXG4gICAgS29udmEuVXRpbCA9IHtcbiAgICAgICAgLypcbiAgICAgICAgICogY2hlcnJ5LXBpY2tlZCB1dGlsaXRpZXMgZnJvbSB1bmRlcnNjb3JlLmpzXG4gICAgICAgICAqL1xuICAgICAgICBfaXNFbGVtZW50OiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09IDEpO1xuICAgICAgICB9LFxuICAgICAgICBfaXNGdW5jdGlvbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gISEob2JqICYmIG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY2FsbCAmJiBvYmouYXBwbHkpO1xuICAgICAgICB9LFxuICAgICAgICBfaXNPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuICghIW9iaiAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9pc0FycmF5OiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gT0JKRUNUX0FSUkFZO1xuICAgICAgICB9LFxuICAgICAgICBfaXNOdW1iZXI6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBPQkpFQ1RfTlVNQkVSO1xuICAgICAgICB9LFxuICAgICAgICBfaXNTdHJpbmc6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBPQkpFQ1RfU1RSSU5HO1xuICAgICAgICB9LFxuICAgICAgICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgICAgICAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gICAgICAgIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgICAgICAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgICAgICAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gICAgICAgIF90aHJvdHRsZTogZnVuY3Rpb24oZnVuYywgd2FpdCwgb3B0cykge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge307XG4gICAgICAgICAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmcgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKlxuICAgICAgICAgKiBvdGhlciB1dGlsc1xuICAgICAgICAgKi9cbiAgICAgICAgX2hhc01ldGhvZHM6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgdmFyIG5hbWVzID0gW10sXG4gICAgICAgICAgICAgICAga2V5O1xuXG4gICAgICAgICAgICBmb3Ioa2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX2lzRnVuY3Rpb24ob2JqW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmFtZXMubGVuZ3RoID4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgaXNWYWxpZFNlbGVjdG9yOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZmlyc3RDaGFyID0gc2VsZWN0b3JbMF07XG4gICAgICAgICAgICByZXR1cm4gZmlyc3RDaGFyID09PSAnIycgfHwgZmlyc3RDaGFyID09PSAnLicgfHwgZmlyc3RDaGFyID09PSBmaXJzdENoYXIudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlQ2FudmFzRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gS29udmEuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAvLyBvbiBzb21lIGVudmlyb25tZW50cyBjYW52YXMuc3R5bGUgaXMgcmVhZG9ubHlcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlID0gY2FudmFzLnN0eWxlIHx8IHt9O1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICAgICAgfSxcbiAgICAgICAgaXNCcm93c2VyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIGV4cG9ydHMgIT09ICdvYmplY3QnKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2lzSW5Eb2N1bWVudDogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIHdoaWxlKGVsID0gZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmKGVsID09IEtvbnZhLmRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NpbXBsaWZ5QXJyYXk6IGZ1bmN0aW9uKGFycikge1xuICAgICAgICAgICAgdmFyIHJldEFyciA9IFtdLFxuICAgICAgICAgICAgICAgIGxlbiA9IGFyci5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdXRpbCA9IEtvbnZhLlV0aWwsXG4gICAgICAgICAgICAgICAgbiwgdmFsO1xuXG4gICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBhcnJbbl07XG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuX2lzTnVtYmVyKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gTWF0aC5yb3VuZCh2YWwgKiAxMDAwKSAvIDEwMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF1dGlsLl9pc1N0cmluZyh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKHZhbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgIH0sXG4gICAgICAgIC8qXG4gICAgICAgICAqIGFyZyBjYW4gYmUgYW4gaW1hZ2Ugb2JqZWN0IG9yIGltYWdlIGRhdGFcbiAgICAgICAgICovXG4gICAgICAgIF9nZXRJbWFnZTogZnVuY3Rpb24oYXJnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGltYWdlT2JqLCBjYW52YXM7XG5cbiAgICAgICAgICAgIC8vIGlmIGFyZyBpcyBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgaWYoIWFyZykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBhcmcgaXMgYWxyZWFkeSBhbiBpbWFnZSBvYmplY3RcbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5faXNFbGVtZW50KGFyZykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhhcmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBhcmcgaXMgYSBzdHJpbmcsIHRoZW4gaXQncyBhIGRhdGEgdXJsXG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMuX2lzU3RyaW5nKGFyZykpIHtcbiAgICAgICAgICAgICAgICBpbWFnZU9iaiA9IG5ldyBLb252YS53aW5kb3cuSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICBpbWFnZU9iai5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soaW1hZ2VPYmopO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaW1hZ2VPYmouc3JjID0gYXJnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2lmIGFyZyBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgZGF0YSBwcm9wZXJ0eSwgaXQncyBhbiBpbWFnZSBvYmplY3RcbiAgICAgICAgICAgIGVsc2UgaWYoYXJnLmRhdGEpIHtcbiAgICAgICAgICAgICAgICBjYW52YXMgPSBLb252YS5VdGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBhcmcud2lkdGg7XG4gICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGFyZy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIF9jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoQ09OVEVYVF8yRCk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucHV0SW1hZ2VEYXRhKGFyZywgMCwgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0SW1hZ2UoY2FudmFzLnRvRGF0YVVSTCgpLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2dldFJHQkFTdHJpbmc6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgdmFyIHJlZCA9IG9iai5yZWQgfHwgMCxcbiAgICAgICAgICAgICAgICBncmVlbiA9IG9iai5ncmVlbiB8fCAwLFxuICAgICAgICAgICAgICAgIGJsdWUgPSBvYmouYmx1ZSB8fCAwLFxuICAgICAgICAgICAgICAgIGFscGhhID0gb2JqLmFscGhhIHx8IDE7XG5cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgJ3JnYmEoJyxcbiAgICAgICAgICAgICAgICByZWQsXG4gICAgICAgICAgICAgICAgJywnLFxuICAgICAgICAgICAgICAgIGdyZWVuLFxuICAgICAgICAgICAgICAgICcsJyxcbiAgICAgICAgICAgICAgICBibHVlLFxuICAgICAgICAgICAgICAgICcsJyxcbiAgICAgICAgICAgICAgICBhbHBoYSxcbiAgICAgICAgICAgICAgICAnKSdcbiAgICAgICAgICAgIF0uam9pbihFTVBUWV9TVFJJTkcpO1xuICAgICAgICB9LFxuICAgICAgICBfcmdiVG9IZXg6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiAoKDEgPDwgMjQpICsgKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9oZXhUb1JnYjogZnVuY3Rpb24oaGV4KSB7XG4gICAgICAgICAgICBoZXggPSBoZXgucmVwbGFjZShIQVNILCBFTVBUWV9TVFJJTkcpO1xuICAgICAgICAgICAgdmFyIGJpZ2ludCA9IHBhcnNlSW50KGhleCwgMTYpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByOiAoYmlnaW50ID4+IDE2KSAmIDI1NSxcbiAgICAgICAgICAgICAgICBnOiAoYmlnaW50ID4+IDgpICYgMjU1LFxuICAgICAgICAgICAgICAgIGI6IGJpZ2ludCAmIDI1NVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJldHVybiByYW5kb20gaGV4IGNvbG9yXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlV0aWwucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRSYW5kb21Db2xvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmFuZENvbG9yID0gKE1hdGgucmFuZG9tKCkgKiAweEZGRkZGRiA8PCAwKS50b1N0cmluZygxNik7XG4gICAgICAgICAgICB3aGlsZSAocmFuZENvbG9yLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgICAgICAgICByYW5kQ29sb3IgPSBaRVJPICsgcmFuZENvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEhBU0ggKyByYW5kQ29sb3I7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXR1cm4gdmFsdWUgd2l0aCBkZWZhdWx0IGZhbGxiYWNrXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlV0aWwucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKHZhbCwgZGVmKSB7XG4gICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBSR0IgY29tcG9uZW50cyBvZiBhIGNvbG9yXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlV0aWwucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBlYWNoIG9mIHRoZSBmb2xsb3dpbmcgZXhhbXBsZXMgcmV0dXJuIHtyOjAsIGc6MCwgYjoyNTV9XG4gICAgICAgICAqIHZhciByZ2IgPSBLb252YS5VdGlsLmdldFJHQignYmx1ZScpO1xuICAgICAgICAgKiB2YXIgcmdiID0gS29udmEuVXRpbC5nZXRSR0IoJyMwMDAwZmYnKTtcbiAgICAgICAgICogdmFyIHJnYiA9IEtvbnZhLlV0aWwuZ2V0UkdCKCdyZ2IoMCwwLDI1NSknKTtcbiAgICAgICAgICovXG4gICAgICAgIGdldFJHQjogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHZhciByZ2I7XG4gICAgICAgICAgICAvLyBjb2xvciBzdHJpbmdcbiAgICAgICAgICAgIGlmIChjb2xvciBpbiBDT0xPUlMpIHtcbiAgICAgICAgICAgICAgICByZ2IgPSBDT0xPUlNbY29sb3JdO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHI6IHJnYlswXSxcbiAgICAgICAgICAgICAgICAgICAgZzogcmdiWzFdLFxuICAgICAgICAgICAgICAgICAgICBiOiByZ2JbMl1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGV4XG4gICAgICAgICAgICBlbHNlIGlmIChjb2xvclswXSA9PT0gSEFTSCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZXhUb1JnYihjb2xvci5zdWJzdHJpbmcoMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmdiIHN0cmluZ1xuICAgICAgICAgICAgZWxzZSBpZiAoY29sb3Iuc3Vic3RyKDAsIDQpID09PSBSR0JfUEFSRU4pIHtcbiAgICAgICAgICAgICAgICByZ2IgPSBSR0JfUkVHRVguZXhlYyhjb2xvci5yZXBsYWNlKC8gL2csICcnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcjogcGFyc2VJbnQocmdiWzFdLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIGc6IHBhcnNlSW50KHJnYlsyXSwgMTApLFxuICAgICAgICAgICAgICAgICAgICBiOiBwYXJzZUludChyZ2JbM10sIDEwKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZWZhdWx0XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByOiAwLFxuICAgICAgICAgICAgICAgICAgICBnOiAwLFxuICAgICAgICAgICAgICAgICAgICBiOiAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gY29udmVydCBhbnkgY29sb3Igc3RyaW5nIHRvIFJHQkEgb2JqZWN0XG4gICAgICAgIC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2NvbXBvbmVudC9jb2xvci1wYXJzZXJcbiAgICAgICAgY29sb3JUb1JHQkE6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgc3RyID0gc3RyIHx8ICdibGFjayc7XG4gICAgICAgICAgICByZXR1cm4gS29udmEuVXRpbC5fbmFtZWRDb2xvclRvUkJBKHN0cilcbiAgICAgICAgICAgICAgICB8fCBLb252YS5VdGlsLl9oZXgzQ29sb3JUb1JHQkEoc3RyKVxuICAgICAgICAgICAgICAgIHx8IEtvbnZhLlV0aWwuX2hleDZDb2xvclRvUkdCQShzdHIpXG4gICAgICAgICAgICAgICAgfHwgS29udmEuVXRpbC5fcmdiQ29sb3JUb1JHQkEoc3RyKVxuICAgICAgICAgICAgICAgIHx8IEtvbnZhLlV0aWwuX3JnYmFDb2xvclRvUkdCQShzdHIpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBQYXJzZSBuYW1lZCBjc3MgY29sb3IuIExpa2UgXCJncmVlblwiXG4gICAgICAgIF9uYW1lZENvbG9yVG9SQkE6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgdmFyIGMgPSBDT0xPUlNbc3RyLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgaWYgKCFjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHI6IGNbMF0sXG4gICAgICAgICAgICAgICAgZzogY1sxXSxcbiAgICAgICAgICAgICAgICBiOiBjWzJdLFxuICAgICAgICAgICAgICAgIGE6IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFBhcnNlIHJnYihuLCBuLCBuKVxuICAgICAgICBfcmdiQ29sb3JUb1JHQkE6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgaWYgKHN0ci5pbmRleE9mKCdyZ2IoJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIubWF0Y2goL3JnYlxcKChbXildKylcXCkvKVsxXTtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoLyAqLCAqLykubWFwKE51bWJlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcjogcGFydHNbMF0sXG4gICAgICAgICAgICAgICAgICAgIGc6IHBhcnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICBiOiBwYXJ0c1syXSxcbiAgICAgICAgICAgICAgICAgICAgYTogMVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFBhcnNlIHJnYmEobiwgbiwgbiwgbilcbiAgICAgICAgX3JnYmFDb2xvclRvUkdCQTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICBpZiAoc3RyLmluZGV4T2YoJ3JnYmEoJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIubWF0Y2goL3JnYmFcXCgoW14pXSspXFwpLylbMV07XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KC8gKiwgKi8pLm1hcChOdW1iZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHI6IHBhcnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICBnOiBwYXJ0c1sxXSxcbiAgICAgICAgICAgICAgICAgICAgYjogcGFydHNbMl0sXG4gICAgICAgICAgICAgICAgICAgIGE6IHBhcnRzWzNdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuICAgICAgICAvLyBQYXJzZSAjbm5ubm5uXG4gICAgICAgIF9oZXg2Q29sb3JUb1JHQkE6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgaWYgKChzdHJbMF0gPT09ICcjJykgJiYgKHN0ci5sZW5ndGggPT09IDcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcjogcGFyc2VJbnQoc3RyLnNsaWNlKDEsIDMpLCAxNiksXG4gICAgICAgICAgICAgICAgICAgIGc6IHBhcnNlSW50KHN0ci5zbGljZSgzLCA1KSwgMTYpLFxuICAgICAgICAgICAgICAgICAgICBiOiBwYXJzZUludChzdHIuc2xpY2UoNSwgNyksIDE2KSxcbiAgICAgICAgICAgICAgICAgICAgYTogMVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFBhcnNlICNubm5cbiAgICAgICAgX2hleDNDb2xvclRvUkdCQTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICBpZiAoKHN0clswXSA9PT0gJyMnKSAmJiAoc3RyLmxlbmd0aCA9PT0gNCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByOiBwYXJzZUludChzdHJbMV0gKyBzdHJbMV0sIDE2KSxcbiAgICAgICAgICAgICAgICAgICAgZzogcGFyc2VJbnQoc3RyWzJdICsgc3RyWzJdLCAxNiksXG4gICAgICAgICAgICAgICAgICAgIGI6IHBhcnNlSW50KHN0clszXSArIHN0clszXSwgMTYpLFxuICAgICAgICAgICAgICAgICAgICBhOiAxXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gbzEgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIG8yXG4gICAgICAgIF9tZXJnZTogZnVuY3Rpb24obzEsIG8yKSB7XG4gICAgICAgICAgICB2YXIgcmV0T2JqID0gdGhpcy5fY2xvbmUobzIpO1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gbzEpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9pc09iamVjdChvMVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXRPYmpba2V5XSA9IHRoaXMuX21lcmdlKG8xW2tleV0sIHJldE9ialtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldE9ialtrZXldID0gbzFba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0T2JqO1xuICAgICAgICB9LFxuICAgICAgICBjbG9uZU9iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICB2YXIgcmV0T2JqID0ge307XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9pc09iamVjdChvYmpba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0T2JqW2tleV0gPSB0aGlzLmNsb25lT2JqZWN0KG9ialtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faXNBcnJheShvYmpba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0T2JqW2tleV0gPSB0aGlzLmNsb25lQXJyYXkob2JqW2tleV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldE9ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldE9iajtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvbmVBcnJheTogZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyLnNsaWNlKDApO1xuICAgICAgICB9LFxuICAgICAgICBfZGVnVG9SYWQ6IGZ1bmN0aW9uKGRlZykge1xuICAgICAgICAgICAgcmV0dXJuIGRlZyAqIFBJX09WRVJfREVHMTgwO1xuICAgICAgICB9LFxuICAgICAgICBfcmFkVG9EZWc6IGZ1bmN0aW9uKHJhZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJhZCAqIERFRzE4MF9PVkVSX1BJO1xuICAgICAgICB9LFxuICAgICAgICBfY2FwaXRhbGl6ZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xuICAgICAgICB9LFxuICAgICAgICB0aHJvdzogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoS09OVkFfRVJST1IgKyBzdHIpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihLT05WQV9FUlJPUiArIHN0cik7XG4gICAgICAgIH0sXG4gICAgICAgIHdhcm46IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIElFOSBvbiBXaW5kb3dzNyA2NGJpdCB3aWxsIHRocm93IGEgSlMgZXJyb3JcbiAgICAgICAgICAgICAqIGlmIHdlIGRvbid0IHVzZSB3aW5kb3cuY29uc29sZSBpbiB0aGUgY29uZGl0aW9uYWxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYoS29udmEuZ2xvYmFsLmNvbnNvbGUgJiYgY29uc29sZS53YXJuICYmIEtvbnZhLnNob3dXYXJuaW5ncykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihLT05WQV9XQVJOSU5HICsgc3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBDdG9yKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICAgICAgICAgIHZhciBvbGRQcm90byA9IGNoaWxkLnByb3RvdHlwZTtcbiAgICAgICAgICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBDdG9yKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2xkUHJvdG8pIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkUHJvdG8uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5wcm90b3R5cGVba2V5XSA9IG9sZFByb3RvW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSByZWZlcmVuY2UgdG8gcGFyZW50XG4gICAgICAgICAgICBjaGlsZC5zdXBlciA9IHBhcmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFkZHMgbWV0aG9kcyB0byBhIGNvbnN0cnVjdG9yIHByb3RvdHlwZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5VdGlsLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbWV0aG9kc1xuICAgICAgICAgKi9cbiAgICAgICAgYWRkTWV0aG9kczogZnVuY3Rpb24oY29uc3RydWN0b3IsIG1ldGhvZHMpIHtcbiAgICAgICAgICAgIHZhciBrZXk7XG5cbiAgICAgICAgICAgIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGVba2V5XSA9IG1ldGhvZHNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2dldENvbnRyb2xQb2ludHM6IGZ1bmN0aW9uKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHQpIHtcbiAgICAgICAgICAgIHZhciBkMDEgPSBNYXRoLnNxcnQoTWF0aC5wb3coeDEgLSB4MCwgMikgKyBNYXRoLnBvdyh5MSAtIHkwLCAyKSksXG4gICAgICAgICAgICAgICAgZDEyID0gTWF0aC5zcXJ0KE1hdGgucG93KHgyIC0geDEsIDIpICsgTWF0aC5wb3coeTIgLSB5MSwgMikpLFxuICAgICAgICAgICAgICAgIGZhID0gdCAqIGQwMSAvIChkMDEgKyBkMTIpLFxuICAgICAgICAgICAgICAgIGZiID0gdCAqIGQxMiAvIChkMDEgKyBkMTIpLFxuICAgICAgICAgICAgICAgIHAxeCA9IHgxIC0gZmEgKiAoeDIgLSB4MCksXG4gICAgICAgICAgICAgICAgcDF5ID0geTEgLSBmYSAqICh5MiAtIHkwKSxcbiAgICAgICAgICAgICAgICBwMnggPSB4MSArIGZiICogKHgyIC0geDApLFxuICAgICAgICAgICAgICAgIHAyeSA9IHkxICsgZmIgKiAoeTIgLSB5MCk7XG5cbiAgICAgICAgICAgIHJldHVybiBbcDF4LCBwMXksIHAyeCwgcDJ5XTtcbiAgICAgICAgfSxcbiAgICAgICAgX2V4cGFuZFBvaW50czogZnVuY3Rpb24ocCwgdGVuc2lvbikge1xuICAgICAgICAgICAgdmFyIGxlbiA9IHAubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGFsbFBvaW50cyA9IFtdLFxuICAgICAgICAgICAgICAgIG4sIGNwO1xuXG4gICAgICAgICAgICBmb3IgKG4gPSAyOyBuIDwgbGVuIC0gMjsgbiArPSAyKSB7XG4gICAgICAgICAgICAgICAgY3AgPSBLb252YS5VdGlsLl9nZXRDb250cm9sUG9pbnRzKHBbbiAtIDJdLCBwW24gLSAxXSwgcFtuXSwgcFtuICsgMV0sIHBbbiArIDJdLCBwW24gKyAzXSwgdGVuc2lvbik7XG4gICAgICAgICAgICAgICAgYWxsUG9pbnRzLnB1c2goY3BbMF0pO1xuICAgICAgICAgICAgICAgIGFsbFBvaW50cy5wdXNoKGNwWzFdKTtcbiAgICAgICAgICAgICAgICBhbGxQb2ludHMucHVzaChwW25dKTtcbiAgICAgICAgICAgICAgICBhbGxQb2ludHMucHVzaChwW24gKyAxXSk7XG4gICAgICAgICAgICAgICAgYWxsUG9pbnRzLnB1c2goY3BbMl0pO1xuICAgICAgICAgICAgICAgIGFsbFBvaW50cy5wdXNoKGNwWzNdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFsbFBvaW50cztcbiAgICAgICAgfSxcbiAgICAgICAgX3JlbW92ZUxhc3RMZXR0ZXI6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpO1xuICAgICAgICB9LFxuICAgICAgICBlYWNoOiBmdW5jdGlvbihvYmosIGZ1bmMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBmdW5jKGtleSwgb2JqW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfZ2V0UHJvamVjdGlvblRvU2VnbWVudDogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgICAgICAgdmFyIHgsIHksIGRpc3Q7XG5cbiAgICAgICAgICAgIHZhciBwZDIgPSAoeDEgLSB4MikgKiAoeDEgLSB4MikgKyAoeTEgLSB5MikgKiAoeTEgLSB5Mik7XG4gICAgICAgICAgICBpZihwZDIgPT0gMCkge1xuICAgICAgICAgICAgICAgIHggPSB4MTtcbiAgICAgICAgICAgICAgICB5ID0geTE7XG4gICAgICAgICAgICAgICAgZGlzdCA9ICh4MyAtIHgyKSAqICh4MyAtIHgyKSArICh5MyAtIHkyKSAqICh5MyAtIHkyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHUgPSAoKHgzIC0geDEpICogKHgyIC0geDEpICsgKHkzIC0geTEpICogKHkyIC0geTEpKSAvIHBkMjtcbiAgICAgICAgICAgICAgICBpZih1IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB4ID0geDE7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB5MTtcbiAgICAgICAgICAgICAgICAgICAgZGlzdCA9ICh4MSAtIHgzKSAqICh4MSAtIHgzKSArICh5MSAtIHkzKSAqICh5MSAtIHkzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHUgPiAxLjApIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHgyO1xuICAgICAgICAgICAgICAgICAgICB5ID0geTI7XG4gICAgICAgICAgICAgICAgICAgIGRpc3QgPSAoeDIgLSB4MykgKiAoeDIgLSB4MykgKyAoeTIgLSB5MykgKiAoeTIgLSB5Myk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHgxICsgdSAqICh4MiAtIHgxKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHkxICsgdSAqICh5MiAtIHkxKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzdCA9ICh4IC0geDMpICogKHggLSB4MykgKyAoeSAtIHkzKSAqICh5IC0geTMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbeCwgeSwgZGlzdF07XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGxpbmUgYXMgYXJyYXkgb2YgcG9pbnRzLlxuICAgICAgICAvLyBsaW5lIG1pZ2h0IGJlIGNsb3NlZFxuICAgICAgICBfZ2V0UHJvamVjdGlvblRvTGluZTogZnVuY3Rpb24ocHQsIGxpbmUsIGlzQ2xvc2VkKSB7XG4gICAgICAgICAgICB2YXIgcGMgPSBLb252YS5VdGlsLmNsb25lT2JqZWN0KHB0KTtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIGxpbmUuZm9yRWFjaChmdW5jdGlvbihwMSwgaSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNDbG9zZWQgJiYgaSA9PT0gbGluZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHAyID0gbGluZVsoaSArIDEpICUgbGluZS5sZW5ndGhdO1xuICAgICAgICAgICAgICAgIHZhciBwcm9qID0gS29udmEuVXRpbC5fZ2V0UHJvamVjdGlvblRvU2VnbWVudChwMS54LCBwMS55LCBwMi54LCBwMi55LCBwdC54LCBwdC55KTtcbiAgICAgICAgICAgICAgICB2YXIgcHggPSBwcm9qWzBdLCBweSA9IHByb2pbMV0sIHBkaXN0ID0gcHJvalsyXTtcbiAgICAgICAgICAgICAgICBpZiAocGRpc3QgPCBkaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBjLnggPSBweDtcbiAgICAgICAgICAgICAgICAgICAgcGMueSA9IHB5O1xuICAgICAgICAgICAgICAgICAgICBkaXN0ID0gcGRpc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGM7XG4gICAgICAgIH0sXG4gICAgICAgIF9wcmVwYXJlQXJyYXlGb3JUd2VlbjogZnVuY3Rpb24oc3RhcnRBcnJheSwgZW5kQXJyYXksIGlzQ2xvc2VkKSB7XG4gICAgICAgICAgICB2YXIgbiwgc3RhcnQgPSBbXSwgZW5kID0gW107XG4gICAgICAgICAgICBpZiAoc3RhcnRBcnJheS5sZW5ndGggPiBlbmRBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IGVuZEFycmF5O1xuICAgICAgICAgICAgICAgIGVuZEFycmF5ID0gc3RhcnRBcnJheTtcbiAgICAgICAgICAgICAgICBzdGFydEFycmF5ID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBzdGFydEFycmF5Lmxlbmd0aDsgbiArPSAyKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IHN0YXJ0QXJyYXlbbl0sXG4gICAgICAgICAgICAgICAgICAgIHk6IHN0YXJ0QXJyYXlbbiArIDFdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgZW5kQXJyYXkubGVuZ3RoOyBuICs9IDIpIHtcbiAgICAgICAgICAgICAgICBlbmQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IGVuZEFycmF5W25dLFxuICAgICAgICAgICAgICAgICAgICB5OiBlbmRBcnJheVtuICsgMV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB2YXIgbmV3U3RhcnQgPSBbXTtcbiAgICAgICAgICAgIGVuZC5mb3JFYWNoKGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHByID0gS29udmEuVXRpbC5fZ2V0UHJvamVjdGlvblRvTGluZShwb2ludCwgc3RhcnQsIGlzQ2xvc2VkKTtcbiAgICAgICAgICAgICAgICBuZXdTdGFydC5wdXNoKHByLngpO1xuICAgICAgICAgICAgICAgIG5ld1N0YXJ0LnB1c2gocHIueSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXdTdGFydDtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIGNhbGN1bGF0ZSBwaXhlbCByYXRpb1xuICAgIHZhciBjYW52YXMgPSBLb252YS5VdGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSxcbiAgICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICBfcGl4ZWxSYXRpbyA9IChmdW5jdGlvbigpe1xuICAgICAgICAgICAgdmFyIGRldmljZVBpeGVsUmF0aW8gPSBLb252YS53aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxuICAgICAgICAgICAgYmFja2luZ1N0b3JlUmF0aW8gPSBjb250ZXh0LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW9cbiAgICAgICAgICAgICAgICB8fCBjb250ZXh0Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW9cbiAgICAgICAgICAgICAgICB8fCBjb250ZXh0Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpb1xuICAgICAgICAgICAgICAgIHx8IGNvbnRleHQub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW9cbiAgICAgICAgICAgICAgICB8fCBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW9cbiAgICAgICAgICAgICAgICB8fCAxO1xuICAgICAgICAgICAgcmV0dXJuIGRldmljZVBpeGVsUmF0aW8gLyBiYWNraW5nU3RvcmVSYXRpbztcbiAgICAgICAgfSkoKTtcblxuICAgIC8qKlxuICAgICAqIENhbnZhcyBSZW5kZXJlciBjb25zdHJ1Y3RvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLndpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5oZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnBpeGVsUmF0aW8gS29udmFKUyBhdXRvbWF0aWNhbGx5IGhhbmRsZXMgcGl4ZWwgcmF0aW8gYWRqdXN0bWVudHMgaW4gb3JkZXIgdG8gcmVuZGVyIGNyaXNwIGRyYXdpbmdzXG4gICAgICogIG9uIGFsbCBkZXZpY2VzLiBNb3N0IGRlc2t0b3BzLCBsb3cgZW5kIHRhYmxldHMsIGFuZCBsb3cgZW5kIHBob25lcywgaGF2ZSBkZXZpY2UgcGl4ZWwgcmF0aW9zXG4gICAgICogIG9mIDEuICBTb21lIGhpZ2ggZW5kIHRhYmxldHMgYW5kIHBob25lcywgbGlrZSBpUGhvbmVzIGFuZCBpUGFkcyAobm90IHRoZSBtaW5pKSBoYXZlIGEgZGV2aWNlIHBpeGVsIHJhdGlvXG4gICAgICogIG9mIDIuICBTb21lIE1hY2Jvb2sgUHJvcywgYW5kIGlNYWNzIGFsc28gaGF2ZSBhIGRldmljZSBwaXhlbCByYXRpbyBvZiAyLiAgU29tZSBoaWdoIGVuZCBBbmRyb2lkIGRldmljZXMgaGF2ZSBwaXhlbFxuICAgICAqICByYXRpb3Mgb2YgMiBvciAzLiAgU29tZSBicm93c2VycyBsaWtlIEZpcmVmb3ggYWxsb3cgeW91IHRvIGNvbmZpZ3VyZSB0aGUgcGl4ZWwgcmF0aW8gb2YgdGhlIHZpZXdwb3J0LiAgVW5sZXNzIG90aGVyd2lzZVxuICAgICAqICBzcGVjaWZpZWQsIHRoZSBwaXhlbCByYXRpbyB3aWxsIGJlIGRlZmF1bHRlZCB0byB0aGUgYWN0dWFsIGRldmljZSBwaXhlbCByYXRpby4gIFlvdSBjYW4gb3ZlcnJpZGUgdGhlIGRldmljZSBwaXhlbFxuICAgICAqICByYXRpbyBmb3Igc3BlY2lhbCBzaXR1YXRpb25zLCBvciwgaWYgeW91IGRvbid0IHdhbnQgdGhlIHBpeGVsIHJhdGlvIHRvIGJlIHRha2VuIGludG8gYWNjb3VudCwgeW91IGNhbiBzZXQgaXQgdG8gMS5cbiAgICAgKi9cbiAgICBLb252YS5DYW52YXMgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLkNhbnZhcy5wcm90b3R5cGUgPSB7XG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgdmFyIGNvbmYgPSBjb25maWcgfHwge307XG5cbiAgICAgICAgICAgIHZhciBwaXhlbFJhdGlvID0gY29uZi5waXhlbFJhdGlvIHx8IEtvbnZhLnBpeGVsUmF0aW8gfHwgX3BpeGVsUmF0aW87XG5cbiAgICAgICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMgPSBLb252YS5VdGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcblxuICAgICAgICAgICAgLy8gc2V0IGlubGluZSBzdHlsZXNcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5wYWRkaW5nID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5tYXJnaW4gPSAwO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmJvcmRlciA9IDA7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLnRvcCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUubGVmdCA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgY2FudmFzIGNvbnRleHRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ2FudmFzLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7Q2FudmFzQ29udGV4dH0gY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29udGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IHBpeGVsIHJhdGlvXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn0gcGl4ZWwgcmF0aW9cbiAgICAgICAgICovXG4gICAgICAgIGdldFBpeGVsUmF0aW86IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGl4ZWxSYXRpbztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBwaXhlbCByYXRpb1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwaXhlbFJhdGlvIEtvbnZhSlMgYXV0b21hdGljYWxseSBoYW5kbGVzIHBpeGVsIHJhdGlvIGFkdXN0bWVudHMgaW4gb3JkZXIgdG8gcmVuZGVyIGNyaXNwIGRyYXdpbmdzXG4gICAgICAgICAqICBvbiBhbGwgZGV2aWNlcy4gTW9zdCBkZXNrdG9wcywgbG93IGVuZCB0YWJsZXRzLCBhbmQgbG93IGVuZCBwaG9uZXMsIGhhdmUgZGV2aWNlIHBpeGVsIHJhdGlvc1xuICAgICAgICAgKiAgb2YgMS4gIFNvbWUgaGlnaCBlbmQgdGFibGV0cyBhbmQgcGhvbmVzLCBsaWtlIGlQaG9uZXMgYW5kIGlQYWRzIGhhdmUgYSBkZXZpY2UgcGl4ZWwgcmF0aW9cbiAgICAgICAgICogIG9mIDIuICBTb21lIE1hY2Jvb2sgUHJvcywgYW5kIGlNYWNzIGFsc28gaGF2ZSBhIGRldmljZSBwaXhlbCByYXRpbyBvZiAyLiAgU29tZSBoaWdoIGVuZCBBbmRyb2lkIGRldmljZXMgaGF2ZSBwaXhlbFxuICAgICAgICAgKiAgcmF0aW9zIG9mIDIgb3IgMy4gIFNvbWUgYnJvd3NlcnMgbGlrZSBGaXJlZm94IGFsbG93IHlvdSB0byBjb25maWd1cmUgdGhlIHBpeGVsIHJhdGlvIG9mIHRoZSB2aWV3cG9ydC4gIFVubGVzcyBvdGhlcndpc2VcbiAgICAgICAgICogIHNwZWNpZmljZWQsIHRoZSBwaXhlbCByYXRpbyB3aWxsIGJlIGRlZmF1bHRlZCB0byB0aGUgYWN0dWFsIGRldmljZSBwaXhlbCByYXRpby4gIFlvdSBjYW4gb3ZlcnJpZGUgdGhlIGRldmljZSBwaXhlbFxuICAgICAgICAgKiAgcmF0aW8gZm9yIHNwZWNpYWwgc2l0dWF0aW9ucywgb3IsIGlmIHlvdSBkb24ndCB3YW50IHRoZSBwaXhlbCByYXRpbyB0byBiZSB0YWtlbiBpbnRvIGFjY291bnQsIHlvdSBjYW4gc2V0IGl0IHRvIDEuXG4gICAgICAgICAqL1xuICAgICAgICBzZXRQaXhlbFJhdGlvOiBmdW5jdGlvbihwaXhlbFJhdGlvKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbztcbiAgICAgICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgICAgICAgICB0aGlzLnNldFNpemUodGhpcy5nZXRXaWR0aCgpIC8gcHJldmlvdXNSYXRpbywgdGhpcy5nZXRIZWlnaHQoKSAvIHByZXZpb3VzUmF0aW8pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IHdpZHRoXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICAgICAqL1xuICAgICAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgICAgIC8vIHRha2UgaW50byBhY2NvdW50IHBpeGVsIHJhdGlvXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5fY2FudmFzLndpZHRoID0gd2lkdGggKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cbiAgICAgICAgICAgIHZhciBwaXhlbFJhdGlvID0gdGhpcy5waXhlbFJhdGlvLFxuICAgICAgICAgICAgICAgIF9jb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KCkuX2NvbnRleHQ7XG4gICAgICAgICAgICBfY29udGV4dC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCBoZWlnaHRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ2FudmFzLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICAgICAqL1xuICAgICAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICAgICAgLy8gdGFrZSBpbnRvIGFjY291bnQgcGl4ZWwgcmF0aW9cbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5fY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbztcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSB0aGlzLnBpeGVsUmF0aW8sXG4gICAgICAgICAgICAgICAgX2NvbnRleHQgPSB0aGlzLmdldENvbnRleHQoKS5fY29udGV4dDtcbiAgICAgICAgICAgIF9jb250ZXh0LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IHdpZHRoXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn0gd2lkdGhcbiAgICAgICAgICovXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGhlaWdodFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IGhlaWdodFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCBzaXplXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIHNldFNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0V2lkdGgod2lkdGgpO1xuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQoaGVpZ2h0KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRvIGRhdGEgdXJsXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1pbWVUeXBlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBxdWFsaXR5IGJldHdlZW4gMCBhbmQgMSBmb3IganBnIG1pbWUgdHlwZXNcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gZGF0YSB1cmwgc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0b0RhdGFVUkw6IGZ1bmN0aW9uKG1pbWVUeXBlLCBxdWFsaXR5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgY2FsbCBmYWlscyAoZHVlIHRvIGJyb3dzZXIgYnVnLCBsaWtlIGluIEZpcmVmb3ggMy42KSxcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHJldmVydCB0byBwcmV2aW91cyBuby1wYXJhbWV0ZXIgaW1hZ2UvcG5nIGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhcy50b0RhdGFVUkwobWltZVR5cGUsIHF1YWxpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYW52YXMudG9EYXRhVVJMKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoKGVycikge1xuICAgICAgICAgICAgICAgICAgICBLb252YS5VdGlsLndhcm4oJ1VuYWJsZSB0byBnZXQgZGF0YSBVUkwuICcgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS29udmEuU2NlbmVDYW52YXMgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdmFyIGNvbmYgPSBjb25maWcgfHwge307XG4gICAgICAgIHZhciB3aWR0aCA9IGNvbmYud2lkdGggfHwgMCxcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbmYuaGVpZ2h0IHx8IDA7XG5cbiAgICAgICAgS29udmEuQ2FudmFzLmNhbGwodGhpcywgY29uZik7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IG5ldyBLb252YS5TY2VuZUNvbnRleHQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9O1xuXG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuU2NlbmVDYW52YXMsIEtvbnZhLkNhbnZhcyk7XG5cbiAgICBLb252YS5IaXRDYW52YXMgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdmFyIGNvbmYgPSBjb25maWcgfHwge307XG4gICAgICAgIHZhciB3aWR0aCA9IGNvbmYud2lkdGggfHwgMCxcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbmYuaGVpZ2h0IHx8IDA7XG5cbiAgICAgICAgS29udmEuQ2FudmFzLmNhbGwodGhpcywgY29uZik7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IG5ldyBLb252YS5IaXRDb250ZXh0KHRoaXMpO1xuICAgICAgICB0aGlzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGl0Q2FudmFzID0gdHJ1ZTtcbiAgICB9O1xuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkhpdENhbnZhcywgS29udmEuQ2FudmFzKTtcblxufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgQ09NTUEgPSAnLCcsXG4gICAgICAgIE9QRU5fUEFSRU4gPSAnKCcsXG4gICAgICAgIENMT1NFX1BBUkVOID0gJyknLFxuICAgICAgICBPUEVOX1BBUkVOX0JSQUNLRVQgPSAnKFsnLFxuICAgICAgICBDTE9TRV9CUkFDS0VUX1BBUkVOID0gJ10pJyxcbiAgICAgICAgU0VNSUNPTE9OID0gJzsnLFxuICAgICAgICBET1VCTEVfUEFSRU4gPSAnKCknLFxuICAgICAgICAvLyBFTVBUWV9TVFJJTkcgPSAnJyxcbiAgICAgICAgRVFVQUxTID0gJz0nLFxuICAgICAgICAvLyBTRVQgPSAnc2V0JyxcbiAgICAgICAgQ09OVEVYVF9NRVRIT0RTID0gW1xuICAgICAgICAgICAgJ2FyYycsXG4gICAgICAgICAgICAnYXJjVG8nLFxuICAgICAgICAgICAgJ2JlZ2luUGF0aCcsXG4gICAgICAgICAgICAnYmV6aWVyQ3VydmVUbycsXG4gICAgICAgICAgICAnY2xlYXJSZWN0JyxcbiAgICAgICAgICAgICdjbGlwJyxcbiAgICAgICAgICAgICdjbG9zZVBhdGgnLFxuICAgICAgICAgICAgJ2NyZWF0ZUxpbmVhckdyYWRpZW50JyxcbiAgICAgICAgICAgICdjcmVhdGVQYXR0ZXJuJyxcbiAgICAgICAgICAgICdjcmVhdGVSYWRpYWxHcmFkaWVudCcsXG4gICAgICAgICAgICAnZHJhd0ltYWdlJyxcbiAgICAgICAgICAgICdmaWxsJyxcbiAgICAgICAgICAgICdmaWxsVGV4dCcsXG4gICAgICAgICAgICAnZ2V0SW1hZ2VEYXRhJyxcbiAgICAgICAgICAgICdjcmVhdGVJbWFnZURhdGEnLFxuICAgICAgICAgICAgJ2xpbmVUbycsXG4gICAgICAgICAgICAnbW92ZVRvJyxcbiAgICAgICAgICAgICdwdXRJbWFnZURhdGEnLFxuICAgICAgICAgICAgJ3F1YWRyYXRpY0N1cnZlVG8nLFxuICAgICAgICAgICAgJ3JlY3QnLFxuICAgICAgICAgICAgJ3Jlc3RvcmUnLFxuICAgICAgICAgICAgJ3JvdGF0ZScsXG4gICAgICAgICAgICAnc2F2ZScsXG4gICAgICAgICAgICAnc2NhbGUnLFxuICAgICAgICAgICAgJ3NldExpbmVEYXNoJyxcbiAgICAgICAgICAgICdzZXRUcmFuc2Zvcm0nLFxuICAgICAgICAgICAgJ3N0cm9rZScsXG4gICAgICAgICAgICAnc3Ryb2tlVGV4dCcsXG4gICAgICAgICAgICAndHJhbnNmb3JtJyxcbiAgICAgICAgICAgICd0cmFuc2xhdGUnXG4gICAgICAgIF07XG5cbiAgICB2YXIgQ09OVEVYVF9QUk9QRVJUSUVTID0gWydmaWxsU3R5bGUnLCAnc3Ryb2tlU3R5bGUnLCAnc2hhZG93Q29sb3InLCAnc2hhZG93Qmx1cicsICdzaGFkb3dPZmZzZXRYJyxcbiAgICAgICAgJ3NoYWRvd09mZnNldFknLCAnbGluZUNhcCcsICdsaW5lSm9pbicsICdsaW5lV2lkdGgnLCAnbWl0ZXJMaW1pdCcsICdmb250JywgJ3RleHRBbGlnbicsICd0ZXh0QmFzZWxpbmUnLFxuICAgICAgICAnZ2xvYmFsQWxwaGEnLCAnZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uJ107XG5cbiAgICAvKipcbiAgICAgKiBDYW52YXMgQ29udGV4dCBjb25zdHJ1Y3RvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqL1xuICAgIEtvbnZhLkNvbnRleHQgPSBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgICAgdGhpcy5pbml0KGNhbnZhcyk7XG4gICAgfTtcblxuICAgIEtvbnZhLkNvbnRleHQucHJvdG90eXBlID0ge1xuICAgICAgICBpbml0OiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dCA9IGNhbnZhcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIGlmIChLb252YS5lbmFibGVUcmFjZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2VBcnIgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmFibGVUcmFjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZmlsbCBzaGFwZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0tvbnZhLlNoYXBlfSBzaGFwZVxuICAgICAgICAgKi9cbiAgICAgICAgZmlsbFNoYXBlOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgICAgICAgaWYoc2hhcGUuZ2V0RmlsbEVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGwoc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogc3Ryb2tlIHNoYXBlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRleHQucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7S29udmEuU2hhcGV9IHNoYXBlXG4gICAgICAgICAqL1xuICAgICAgICBzdHJva2VTaGFwZTogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgICAgIGlmKHNoYXBlLmdldFN0cm9rZUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0cm9rZShzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmaWxsIHRoZW4gc3Ryb2tlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRleHQucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7S29udmEuU2hhcGV9IHNoYXBlXG4gICAgICAgICAqL1xuICAgICAgICBmaWxsU3Ryb2tlU2hhcGU6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgZmlsbEVuYWJsZWQgPSBzaGFwZS5nZXRGaWxsRW5hYmxlZCgpO1xuICAgICAgICAgICAgaWYoZmlsbEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxsKHNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHNoYXBlLmdldFN0cm9rZUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0cm9rZShzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgY29udGV4dCB0cmFjZSBpZiB0cmFjZSBpcyBlbmFibGVkXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRleHQucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVsYXhlZCBpZiBmYWxzZSwgcmV0dXJuIHN0cmljdCBjb250ZXh0IHRyYWNlLCB3aGljaCBpbmNsdWRlcyBtZXRob2QgbmFtZXMsIG1ldGhvZCBwYXJhbWV0ZXJzXG4gICAgICAgICAqICBwcm9wZXJ0aWVzLCBhbmQgcHJvcGVydHkgdmFsdWVzLiAgSWYgdHJ1ZSwgcmV0dXJuIHJlbGF4ZWQgY29udGV4dCB0cmFjZSwgd2hpY2ggb25seSByZXR1cm5zIG1ldGhvZCBuYW1lcyBhbmRcbiAgICAgICAgICogIHByb3Blcml0ZXMuXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUcmFjZTogZnVuY3Rpb24ocmVsYXhlZCkge1xuICAgICAgICAgICAgdmFyIHRyYWNlQXJyID0gdGhpcy50cmFjZUFycixcbiAgICAgICAgICAgICAgICBsZW4gPSB0cmFjZUFyci5sZW5ndGgsXG4gICAgICAgICAgICAgICAgc3RyID0gJycsXG4gICAgICAgICAgICAgICAgbiwgdHJhY2UsIG1ldGhvZCwgYXJncztcblxuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgdHJhY2UgPSB0cmFjZUFycltuXTtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSB0cmFjZS5tZXRob2Q7XG5cbiAgICAgICAgICAgICAgICAvLyBtZXRob2RzXG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gdHJhY2UuYXJncztcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9IG1ldGhvZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbGF4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBET1VCTEVfUEFSRU47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoS29udmEuVXRpbC5faXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBPUEVOX1BBUkVOX0JSQUNLRVQgKyBhcmdzLmpvaW4oQ09NTUEpICsgQ0xPU0VfQlJBQ0tFVF9QQVJFTjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBPUEVOX1BBUkVOICsgYXJncy5qb2luKENPTU1BKSArIENMT1NFX1BBUkVOO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9IHRyYWNlLnByb3BlcnR5O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlbGF4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBFUVVBTFMgKyB0cmFjZS52YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdHIgKz0gU0VNSUNPTE9OO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogY2xlYXIgdHJhY2UgaWYgdHJhY2UgaXMgZW5hYmxlZFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXJUcmFjZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlQXJyID0gW107XG4gICAgICAgIH0sXG4gICAgICAgIF90cmFjZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2VBcnIgPSB0aGlzLnRyYWNlQXJyLFxuICAgICAgICAgICAgICAgIGxlbjtcblxuICAgICAgICAgICAgdHJhY2VBcnIucHVzaChzdHIpO1xuICAgICAgICAgICAgbGVuID0gdHJhY2VBcnIubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAobGVuID49IEtvbnZhLnRyYWNlQXJyTWF4KSB7XG4gICAgICAgICAgICAgICAgdHJhY2VBcnIuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlc2V0IGNhbnZhcyBjb250ZXh0IHRyYW5zZm9ybVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSB0aGlzLmdldENhbnZhcygpLmdldFBpeGVsUmF0aW8oKTtcbiAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKDEgKiBwaXhlbFJhdGlvLCAwLCAwLCAxICogcGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgY2FudmFzXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRleHQucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5DYW52YXN9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogY2xlYXIgY2FudmFzXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRleHQucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbYm91bmRzXVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy54XVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy55XVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy53aWR0aF1cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMuaGVpZ2h0XVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uKGJvdW5kcykge1xuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XG5cbiAgICAgICAgICAgIGlmIChib3VuZHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyUmVjdChib3VuZHMueCB8fCAwLCBib3VuZHMueSB8fCAwLCBib3VuZHMud2lkdGggfHwgMCwgYm91bmRzLmhlaWdodCB8fCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy5nZXRXaWR0aCgpIC8gY2FudmFzLnBpeGVsUmF0aW8sIGNhbnZhcy5nZXRIZWlnaHQoKSAvIGNhbnZhcy5waXhlbFJhdGlvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2FwcGx5TGluZUNhcDogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciBsaW5lQ2FwID0gc2hhcGUuZ2V0TGluZUNhcCgpO1xuICAgICAgICAgICAgaWYobGluZUNhcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cignbGluZUNhcCcsIGxpbmVDYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfYXBwbHlPcGFjaXR5OiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgICAgICAgdmFyIGFic09wYWNpdHkgPSBzaGFwZS5nZXRBYnNvbHV0ZU9wYWNpdHkoKTtcbiAgICAgICAgICAgIGlmKGFic09wYWNpdHkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHIoJ2dsb2JhbEFscGhhJywgYWJzT3BhY2l0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9hcHBseUxpbmVKb2luOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgICAgICAgdmFyIGxpbmVKb2luID0gc2hhcGUuZ2V0TGluZUpvaW4oKTtcbiAgICAgICAgICAgIGlmKGxpbmVKb2luKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdsaW5lSm9pbicsIGxpbmVKb2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0QXR0cjogZnVuY3Rpb24oYXR0ciwgdmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0W2F0dHJdID0gdmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGNvbnRleHQgcGFzcyB0aHJvdWdoIG1ldGhvZHNcbiAgICAgICAgYXJjOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5hcmMoYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSk7XG4gICAgICAgIH0sXG4gICAgICAgIGJlZ2luUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICB9LFxuICAgICAgICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0pO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhclJlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmNsZWFyUmVjdChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xpcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmNsaXAoKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2VQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZUltYWdlRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIGlmKGEubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKGFbMF0sIGFbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmNyZWF0ZUltYWdlRGF0YShhWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlTGluZWFyR3JhZGllbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlUGF0dGVybjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmNyZWF0ZVBhdHRlcm4oYVswXSwgYVsxXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZVJhZGlhbEdyYWRpZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY3JlYXRlUmFkaWFsR3JhZGllbnQoYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYXdJbWFnZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICBfY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG5cbiAgICAgICAgICAgIGlmKGEubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQuZHJhd0ltYWdlKGFbMF0sIGFbMV0sIGFbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihhLmxlbmd0aCA9PT0gNSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LmRyYXdJbWFnZShhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoYS5sZW5ndGggPT09IDkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5kcmF3SW1hZ2UoYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSwgYVs2XSwgYVs3XSwgYVs4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlzUG9pbnRJblBhdGg6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmlzUG9pbnRJblBhdGgoeCwgeSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5maWxsKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGxSZWN0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9LFxuICAgICAgICBzdHJva2VSZWN0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnN0cm9rZVJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGxUZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5maWxsVGV4dChhWzBdLCBhWzFdLCBhWzJdKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVhc3VyZVRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJbWFnZURhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5nZXRJbWFnZURhdGEoYVswXSwgYVsxXSwgYVsyXSwgYVszXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVUbzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKGFbMF0sIGFbMV0pO1xuICAgICAgICB9LFxuICAgICAgICBtb3ZlVG86IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyhhWzBdLCBhWzFdKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQucmVjdChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHV0SW1hZ2VEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5wdXRJbWFnZURhdGEoYVswXSwgYVsxXSwgYVsyXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oYVswXSwgYVsxXSwgYVsyXSwgYVszXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3RvcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJvdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQucm90YXRlKGFbMF0pO1xuICAgICAgICB9LFxuICAgICAgICBzYXZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2F2ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBzY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2NhbGUoYVswXSwgYVsxXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldExpbmVEYXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgIF9jb250ZXh0ID0gdGhpcy5fY29udGV4dDtcblxuICAgICAgICAgICAgLy8gd29ya3MgZm9yIENocm9tZSBhbmQgSUUxMVxuICAgICAgICAgICAgaWYodGhpcy5fY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LnNldExpbmVEYXNoKGFbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdmVyaWZpZWQgdGhhdCB0aGlzIHdvcmtzIGluIGZpcmVmb3hcbiAgICAgICAgICAgIGVsc2UgaWYoJ21vekRhc2gnIGluIF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubW96RGFzaCA9IGFbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb2VzIG5vdCBjdXJyZW50bHkgd29yayBmb3IgU2FmYXJpXG4gICAgICAgICAgICBlbHNlIGlmKCd3ZWJraXRMaW5lRGFzaCcgaW4gX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC53ZWJraXRMaW5lRGFzaCA9IGFbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vIHN1cHBvcnQgZm9yIElFOSBhbmQgSUUxMFxuICAgICAgICB9LFxuICAgICAgICBnZXRMaW5lRGFzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5nZXRMaW5lRGFzaCgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNldFRyYW5zZm9ybShhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZVRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnN0cm9rZVRleHQoYVswXSwgYVsxXSwgYVsyXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQudHJhbnNmb3JtKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0pO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnRyYW5zbGF0ZShhWzBdLCBhWzFdKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2VuYWJsZVRyYWNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBsZW4gPSBDT05URVhUX01FVEhPRFMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIF9zaW1wbGlmeUFycmF5ID0gS29udmEuVXRpbC5fc2ltcGxpZnlBcnJheSxcbiAgICAgICAgICAgICAgICBvcmlnU2V0dGVyID0gdGhpcy5zZXRBdHRyLFxuICAgICAgICAgICAgICAgIG4sIGFyZ3M7XG5cbiAgICAgICAgICAgIC8vIHRvIHByZXZlbnQgY3JlYXRpbmcgc2NvcGUgZnVuY3Rpb24gYXQgZWFjaCBsb29wXG4gICAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdNZXRob2QgPSB0aGF0W21ldGhvZE5hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0O1xuXG4gICAgICAgICAgICAgICAgICAgIHRoYXRbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBfc2ltcGxpZnlBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IG9yaWdNZXRob2QuYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdjbGVhclJlY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1syXSA9IGFyZ3NbMl0gLyB0aGF0LmNhbnZhcy5nZXRQaXhlbFJhdGlvKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1szXSA9IGFyZ3NbM10gLyB0aGF0LmNhbnZhcy5nZXRQaXhlbFJhdGlvKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll90cmFjZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIG1ldGhvZHNcbiAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgIGZ1bmMoQ09OVEVYVF9NRVRIT0RTW25dKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYXR0cnNcbiAgICAgICAgICAgIHRoYXQuc2V0QXR0ciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG9yaWdTZXR0ZXIuYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGF0Ll90cmFjZSh7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHZhbDogYXJndW1lbnRzWzFdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIENPTlRFWFRfUFJPUEVSVElFUy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEtvbnZhLkNvbnRleHQucHJvdG90eXBlLCBwcm9wLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dFtwcm9wXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0W3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIEtvbnZhLlNjZW5lQ29udGV4dCA9IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgICBLb252YS5Db250ZXh0LmNhbGwodGhpcywgY2FudmFzKTtcbiAgICB9O1xuXG4gICAgS29udmEuU2NlbmVDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICAgICAgX2ZpbGxDb2xvcjogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciBmaWxsID0gc2hhcGUuZmlsbCgpO1xuXG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ2ZpbGxTdHlsZScsIGZpbGwpO1xuICAgICAgICAgICAgc2hhcGUuX2ZpbGxGdW5jKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBfZmlsbFBhdHRlcm46IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgZmlsbFBhdHRlcm5YID0gc2hhcGUuZ2V0RmlsbFBhdHRlcm5YKCksXG4gICAgICAgICAgICAgICAgZmlsbFBhdHRlcm5ZID0gc2hhcGUuZ2V0RmlsbFBhdHRlcm5ZKCksXG4gICAgICAgICAgICAgICAgZmlsbFBhdHRlcm5TY2FsZSA9IHNoYXBlLmdldEZpbGxQYXR0ZXJuU2NhbGUoKSxcbiAgICAgICAgICAgICAgICBmaWxsUGF0dGVyblJvdGF0aW9uID0gS29udmEuZ2V0QW5nbGUoc2hhcGUuZ2V0RmlsbFBhdHRlcm5Sb3RhdGlvbigpKSxcbiAgICAgICAgICAgICAgICBmaWxsUGF0dGVybk9mZnNldCA9IHNoYXBlLmdldEZpbGxQYXR0ZXJuT2Zmc2V0KCk7XG5cbiAgICAgICAgICAgIGlmKGZpbGxQYXR0ZXJuWCB8fCBmaWxsUGF0dGVyblkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZShmaWxsUGF0dGVyblggfHwgMCwgZmlsbFBhdHRlcm5ZIHx8IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZmlsbFBhdHRlcm5Sb3RhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucm90YXRlKGZpbGxQYXR0ZXJuUm90YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZmlsbFBhdHRlcm5TY2FsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGUoZmlsbFBhdHRlcm5TY2FsZS54LCBmaWxsUGF0dGVyblNjYWxlLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZmlsbFBhdHRlcm5PZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZSgtMSAqIGZpbGxQYXR0ZXJuT2Zmc2V0LngsIC0xICogZmlsbFBhdHRlcm5PZmZzZXQueSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignZmlsbFN0eWxlJywgdGhpcy5jcmVhdGVQYXR0ZXJuKHNoYXBlLmdldEZpbGxQYXR0ZXJuSW1hZ2UoKSwgc2hhcGUuZ2V0RmlsbFBhdHRlcm5SZXBlYXQoKSB8fCAncmVwZWF0JykpO1xuICAgICAgICAgICAgdGhpcy5maWxsKCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9maWxsTGluZWFyR3JhZGllbnQ6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBzaGFwZS5nZXRGaWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50KCksXG4gICAgICAgICAgICAgICAgZW5kID0gc2hhcGUuZ2V0RmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnQoKSxcbiAgICAgICAgICAgICAgICBjb2xvclN0b3BzID0gc2hhcGUuZ2V0RmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wcygpLFxuICAgICAgICAgICAgICAgIGdyZCA9IHRoaXMuY3JlYXRlTGluZWFyR3JhZGllbnQoc3RhcnQueCwgc3RhcnQueSwgZW5kLngsIGVuZC55KTtcblxuICAgICAgICAgICAgaWYgKGNvbG9yU3RvcHMpIHtcbiAgICAgICAgICAgICAgICAvLyBidWlsZCBjb2xvciBzdG9wc1xuICAgICAgICAgICAgICAgIGZvcih2YXIgbiA9IDA7IG4gPCBjb2xvclN0b3BzLmxlbmd0aDsgbiArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyZC5hZGRDb2xvclN0b3AoY29sb3JTdG9wc1tuXSwgY29sb3JTdG9wc1tuICsgMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHIoJ2ZpbGxTdHlsZScsIGdyZCk7XG4gICAgICAgICAgICAgICAgc2hhcGUuX2ZpbGxGdW5jKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfZmlsbFJhZGlhbEdyYWRpZW50OiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gc2hhcGUuZ2V0RmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludCgpLFxuICAgICAgICAgICAgICAgIGVuZCA9IHNoYXBlLmdldEZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50KCksXG4gICAgICAgICAgICAgICAgc3RhcnRSYWRpdXMgPSBzaGFwZS5nZXRGaWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1cygpLFxuICAgICAgICAgICAgICAgIGVuZFJhZGl1cyA9IHNoYXBlLmdldEZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1cygpLFxuICAgICAgICAgICAgICAgIGNvbG9yU3RvcHMgPSBzaGFwZS5nZXRGaWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzKCksXG4gICAgICAgICAgICAgICAgZ3JkID0gdGhpcy5jcmVhdGVSYWRpYWxHcmFkaWVudChzdGFydC54LCBzdGFydC55LCBzdGFydFJhZGl1cywgZW5kLngsIGVuZC55LCBlbmRSYWRpdXMpO1xuXG4gICAgICAgICAgICAvLyBidWlsZCBjb2xvciBzdG9wc1xuICAgICAgICAgICAgZm9yKHZhciBuID0gMDsgbiA8IGNvbG9yU3RvcHMubGVuZ3RoOyBuICs9IDIpIHtcbiAgICAgICAgICAgICAgICBncmQuYWRkQ29sb3JTdG9wKGNvbG9yU3RvcHNbbl0sIGNvbG9yU3RvcHNbbiArIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignZmlsbFN0eWxlJywgZ3JkKTtcbiAgICAgICAgICAgIHRoaXMuZmlsbCgpO1xuICAgICAgICB9LFxuICAgICAgICBfZmlsbDogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciBoYXNDb2xvciA9IHNoYXBlLmZpbGwoKSxcbiAgICAgICAgICAgICAgICBoYXNQYXR0ZXJuID0gc2hhcGUuZ2V0RmlsbFBhdHRlcm5JbWFnZSgpLFxuICAgICAgICAgICAgICAgIGhhc0xpbmVhckdyYWRpZW50ID0gc2hhcGUuZ2V0RmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wcygpLFxuICAgICAgICAgICAgICAgIGhhc1JhZGlhbEdyYWRpZW50ID0gc2hhcGUuZ2V0RmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wcygpLFxuICAgICAgICAgICAgICAgIGZpbGxQcmlvcml0eSA9IHNoYXBlLmdldEZpbGxQcmlvcml0eSgpO1xuXG4gICAgICAgICAgICAvLyBwcmlvcml0eSBmaWxsc1xuICAgICAgICAgICAgaWYoaGFzQ29sb3IgJiYgZmlsbFByaW9yaXR5ID09PSAnY29sb3InKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsbENvbG9yKHNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoaGFzUGF0dGVybiAmJiBmaWxsUHJpb3JpdHkgPT09ICdwYXR0ZXJuJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGxQYXR0ZXJuKHNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoaGFzTGluZWFyR3JhZGllbnQgJiYgZmlsbFByaW9yaXR5ID09PSAnbGluZWFyLWdyYWRpZW50Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGxMaW5lYXJHcmFkaWVudChzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGhhc1JhZGlhbEdyYWRpZW50ICYmIGZpbGxQcmlvcml0eSA9PT0gJ3JhZGlhbC1ncmFkaWVudCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxsUmFkaWFsR3JhZGllbnQoc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm93IGp1c3QgdHJ5IGFuZCBmaWxsIHdpdGggd2hhdGV2ZXIgaXMgYXZhaWxhYmxlXG4gICAgICAgICAgICBlbHNlIGlmKGhhc0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsbENvbG9yKHNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoaGFzUGF0dGVybikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGxQYXR0ZXJuKHNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoaGFzTGluZWFyR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxsTGluZWFyR3JhZGllbnQoc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihoYXNSYWRpYWxHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGxSYWRpYWxHcmFkaWVudChzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9zdHJva2U6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgZGFzaCA9IHNoYXBlLmRhc2goKSxcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgc3Ryb2tlU2NhbGVFbmFibGVkIGZvciBUZXh0XG4gICAgICAgICAgICAgICAgc3Ryb2tlU2NhbGVFbmFibGVkID0gKHNoYXBlLmdldFN0cm9rZVNjYWxlRW5hYmxlZCgpIHx8IChzaGFwZSBpbnN0YW5jZW9mIEtvbnZhLlRleHQpKTtcblxuICAgICAgICAgICAgaWYoc2hhcGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0cm9rZVNjYWxlRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlMaW5lQ2FwKHNoYXBlKTtcbiAgICAgICAgICAgICAgICBpZihkYXNoICYmIHNoYXBlLmRhc2hFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRMaW5lRGFzaChkYXNoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHIoJ2xpbmVXaWR0aCcsIHNoYXBlLnN0cm9rZVdpZHRoKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cignc3Ryb2tlU3R5bGUnLCBzaGFwZS5zdHJva2UoKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNoYXBlLmdldFNoYWRvd0ZvclN0cm9rZUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3NoYWRvd0NvbG9yJywgJ3JnYmEoMCwwLDAsMCknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2hhcGUuX3N0cm9rZUZ1bmModGhpcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXN0cm9rZVNjYWxlRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9hcHBseVNoYWRvdzogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB1dGlsID0gS29udmEuVXRpbCxcbiAgICAgICAgICAgICAgICBjb2xvciA9IHV0aWwuZ2V0KHNoYXBlLmdldFNoYWRvd1JHQkEoKSwgJ2JsYWNrJyksXG4gICAgICAgICAgICAgICAgYmx1ciA9IHV0aWwuZ2V0KHNoYXBlLmdldFNoYWRvd0JsdXIoKSwgNSksXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdXRpbC5nZXQoc2hhcGUuZ2V0U2hhZG93T2Zmc2V0KCksIHtcbiAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG0gPSBzaGFwZS5nZXRBYnNvbHV0ZVRyYW5zZm9ybSgpLm0sXG4gICAgICAgICAgICAgICAgc2NhbGVYID0gbVswXSxcbiAgICAgICAgICAgICAgICBzY2FsZVkgPSBtWzNdO1xuXG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3NoYWRvd0NvbG9yJywgY29sb3IpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdzaGFkb3dCbHVyJywgYmx1cik7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3NoYWRvd09mZnNldFgnLCBvZmZzZXQueCAqIHNjYWxlWCk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3NoYWRvd09mZnNldFknLCBvZmZzZXQueSAqIHNjYWxlWSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlNjZW5lQ29udGV4dCwgS29udmEuQ29udGV4dCk7XG5cbiAgICBLb252YS5IaXRDb250ZXh0ID0gZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICAgIEtvbnZhLkNvbnRleHQuY2FsbCh0aGlzLCBjYW52YXMpO1xuICAgIH07XG5cbiAgICBLb252YS5IaXRDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICAgICAgX2ZpbGw6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignZmlsbFN0eWxlJywgc2hhcGUuY29sb3JLZXkpO1xuICAgICAgICAgICAgc2hhcGUuX2ZpbGxGdW5jSGl0KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zdHJva2U6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgICAgICBpZihzaGFwZS5oYXNTdHJva2UoKSAmJiBzaGFwZS5zdHJva2VIaXRFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgc3Ryb2tlU2NhbGVFbmFibGVkIGZvciBUZXh0XG4gICAgICAgICAgICAgICAgdmFyIHN0cm9rZVNjYWxlRW5hYmxlZCA9IChzaGFwZS5nZXRTdHJva2VTY2FsZUVuYWJsZWQoKSB8fCAoc2hhcGUgaW5zdGFuY2VvZiBLb252YS5UZXh0KSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdHJva2VTY2FsZUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUxpbmVDYXAoc2hhcGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cignbGluZVdpZHRoJywgc2hhcGUuc3Ryb2tlV2lkdGgoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdzdHJva2VTdHlsZScsIHNoYXBlLmNvbG9yS2V5KTtcbiAgICAgICAgICAgICAgICBzaGFwZS5fc3Ryb2tlRnVuY0hpdCh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0cm9rZVNjYWxlRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkhpdENvbnRleHQsIEtvbnZhLkNvbnRleHQpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBDT05TVEFOVFNcbiAgICB2YXIgR0VUID0gJ2dldCcsXG4gICAgICAgIFNFVCA9ICdzZXQnO1xuXG4gICAgS29udmEuRmFjdG9yeSA9IHtcbiAgICAgICAgYWRkR2V0dGVyU2V0dGVyOiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgYXR0ciwgZGVmLCB2YWxpZGF0b3IsIGFmdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEdldHRlcihjb25zdHJ1Y3RvciwgYXR0ciwgZGVmKTtcbiAgICAgICAgICAgIHRoaXMuYWRkU2V0dGVyKGNvbnN0cnVjdG9yLCBhdHRyLCB2YWxpZGF0b3IsIGFmdGVyKTtcbiAgICAgICAgICAgIHRoaXMuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihjb25zdHJ1Y3RvciwgYXR0cik7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZEdldHRlcjogZnVuY3Rpb24oY29uc3RydWN0b3IsIGF0dHIsIGRlZikge1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IEdFVCArIEtvbnZhLlV0aWwuX2NhcGl0YWxpemUoYXR0cik7XG5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMuYXR0cnNbYXR0cl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkID8gZGVmIDogdmFsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkU2V0dGVyOiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgYXR0ciwgdmFsaWRhdG9yLCBhZnRlcikge1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IFNFVCArIEtvbnZhLlV0aWwuX2NhcGl0YWxpemUoYXR0cik7XG5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWxpZGF0b3IuY2FsbCh0aGlzLCB2YWwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3NldEF0dHIoYXR0ciwgdmFsKTtcblxuICAgICAgICAgICAgICAgIGlmIChhZnRlcikge1xuICAgICAgICAgICAgICAgICAgICBhZnRlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkQ29tcG9uZW50c0dldHRlclNldHRlcjogZnVuY3Rpb24oY29uc3RydWN0b3IsIGF0dHIsIGNvbXBvbmVudHMsIHZhbGlkYXRvciwgYWZ0ZXIpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBjb21wb25lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjYXBpdGFsaXplID0gS29udmEuVXRpbC5fY2FwaXRhbGl6ZSxcbiAgICAgICAgICAgICAgICBnZXR0ZXIgPSBHRVQgKyBjYXBpdGFsaXplKGF0dHIpLFxuICAgICAgICAgICAgICAgIHNldHRlciA9IFNFVCArIGNhcGl0YWxpemUoYXR0ciksXG4gICAgICAgICAgICAgICAgbiwgY29tcG9uZW50O1xuXG4gICAgICAgICAgICAvLyBnZXR0ZXJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVtnZXR0ZXJdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHt9O1xuXG4gICAgICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbbl07XG4gICAgICAgICAgICAgICAgICAgIHJldFtjb21wb25lbnRdID0gdGhpcy5nZXRBdHRyKGF0dHIgKyBjYXBpdGFsaXplKGNvbXBvbmVudCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBzZXR0ZXJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVtzZXR0ZXJdID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhbCA9IHRoaXMuYXR0cnNbYXR0cl0sXG4gICAgICAgICAgICAgICAgICAgIGtleTtcblxuICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsaWRhdG9yLmNhbGwodGhpcywgdmFsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWwuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0QXR0cihhdHRyICsgY2FwaXRhbGl6ZShrZXkpLCB2YWxba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyZUNoYW5nZUV2ZW50KGF0dHIsIG9sZFZhbCwgdmFsKTtcblxuICAgICAgICAgICAgICAgIGlmIChhZnRlcikge1xuICAgICAgICAgICAgICAgICAgICBhZnRlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKGNvbnN0cnVjdG9yLCBhdHRyKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcjogZnVuY3Rpb24oY29uc3RydWN0b3IsIGF0dHIpIHtcbiAgICAgICAgICAgIHZhciBjYXBpdGFsaXplZEF0dHIgPSBLb252YS5VdGlsLl9jYXBpdGFsaXplKGF0dHIpLFxuICAgICAgICAgICAgICAgIHNldHRlciA9IFNFVCArIGNhcGl0YWxpemVkQXR0cixcbiAgICAgICAgICAgICAgICBnZXR0ZXIgPSBHRVQgKyBjYXBpdGFsaXplZEF0dHI7XG5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVthdHRyXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIHNldHRpbmdcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW3NldHRlcl0oYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGdldHRpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tnZXR0ZXJdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBhZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyOiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgYXR0ciwgZGVmLCB2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBHRVQgKyBLb252YS5VdGlsLl9jYXBpdGFsaXplKGF0dHIpO1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBhdHRyICsgJyBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgc29vbi4gTG9vayBhdCBLb252YSBjaGFuZ2UgbG9nIGZvciBtb3JlIGluZm9ybWF0aW9uLic7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMuYXR0cnNbYXR0cl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkID8gZGVmIDogdmFsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuYWRkU2V0dGVyKGNvbnN0cnVjdG9yLCBhdHRyLCB2YWxpZGF0b3IsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBLb252YS5VdGlsLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoY29uc3RydWN0b3IsIGF0dHIpO1xuICAgICAgICB9LFxuICAgICAgICBiYWNrQ29tcGF0OiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgbWV0aG9kcykge1xuICAgICAgICAgICAgS29udmEuVXRpbC5lYWNoKG1ldGhvZHMsIGZ1bmN0aW9uKG9sZE1ldGhvZE5hbWUsIG5ld01ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gY29uc3RydWN0b3IucHJvdG90eXBlW25ld01ldGhvZE5hbWVdO1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVtvbGRNZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBLb252YS5VdGlsLmVycm9yKG9sZE1ldGhvZE5hbWUgKyAnIG1ldGhvZCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgc29vbi4gVXNlICcgKyBuZXdNZXRob2ROYW1lICsgJyBpbnN0ZWFkJyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhZnRlclNldEZpbHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtvbnZhLlZhbGlkYXRvcnMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBSR0JDb21wb25lbnQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgaWYgKHZhbCA+IDI1NSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAyNTU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFscGhhQ29tcG9uZW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIGlmICh2YWwgPiAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaHJvbWUgZG9lcyBub3QgaG9ub3IgYWxwaGEgdmFsdWVzIG9mIDBcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA8IDAuMDAwMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjAwMDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxuKGZ1bmN0aW9uKEtvbnZhKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIENPTlNUQU5UU1xuICAgIHZhciBBQlNPTFVURV9PUEFDSVRZID0gJ2Fic29sdXRlT3BhY2l0eScsXG4gICAgICAgIEFCU09MVVRFX1RSQU5TRk9STSA9ICdhYnNvbHV0ZVRyYW5zZm9ybScsXG4gICAgICAgIENIQU5HRSA9ICdDaGFuZ2UnLFxuICAgICAgICBDSElMRFJFTiA9ICdjaGlsZHJlbicsXG4gICAgICAgIERPVCA9ICcuJyxcbiAgICAgICAgRU1QVFlfU1RSSU5HID0gJycsXG4gICAgICAgIEdFVCA9ICdnZXQnLFxuICAgICAgICBJRCA9ICdpZCcsXG4gICAgICAgIEtPTlZBID0gJ2tvbnZhJyxcbiAgICAgICAgTElTVEVOSU5HID0gJ2xpc3RlbmluZycsXG4gICAgICAgIE1PVVNFRU5URVIgPSAnbW91c2VlbnRlcicsXG4gICAgICAgIE1PVVNFTEVBVkUgPSAnbW91c2VsZWF2ZScsXG4gICAgICAgIE5BTUUgPSAnbmFtZScsXG4gICAgICAgIFNFVCA9ICdzZXQnLFxuICAgICAgICBTSEFQRSA9ICdTaGFwZScsXG4gICAgICAgIFNQQUNFID0gJyAnLFxuICAgICAgICBTVEFHRSA9ICdzdGFnZScsXG4gICAgICAgIFRSQU5TRk9STSA9ICd0cmFuc2Zvcm0nLFxuICAgICAgICBVUFBFUl9TVEFHRSA9ICdTdGFnZScsXG4gICAgICAgIFZJU0lCTEUgPSAndmlzaWJsZScsXG4gICAgICAgIENMT05FX0JMQUNLX0xJU1QgPSBbJ2lkJ10sXG5cbiAgICAgICAgVFJBTlNGT1JNX0NIQU5HRV9TVFIgPSBbXG4gICAgICAgICAgICAneENoYW5nZS5rb252YScsXG4gICAgICAgICAgICAneUNoYW5nZS5rb252YScsXG4gICAgICAgICAgICAnc2NhbGVYQ2hhbmdlLmtvbnZhJyxcbiAgICAgICAgICAgICdzY2FsZVlDaGFuZ2Uua29udmEnLFxuICAgICAgICAgICAgJ3NrZXdYQ2hhbmdlLmtvbnZhJyxcbiAgICAgICAgICAgICdza2V3WUNoYW5nZS5rb252YScsXG4gICAgICAgICAgICAncm90YXRpb25DaGFuZ2Uua29udmEnLFxuICAgICAgICAgICAgJ29mZnNldFhDaGFuZ2Uua29udmEnLFxuICAgICAgICAgICAgJ29mZnNldFlDaGFuZ2Uua29udmEnLFxuICAgICAgICAgICAgJ3RyYW5zZm9ybXNFbmFibGVkQ2hhbmdlLmtvbnZhJ1xuICAgICAgICBdLmpvaW4oU1BBQ0UpO1xuXG4gICAgLyoqXG4gICAgICogTm9kZSBjb25zdHJ1Y3Rvci4gTm9kZXMgYXJlIGVudGl0aWVzIHRoYXQgY2FuIGJlIHRyYW5zZm9ybWVkLCBsYXllcmVkLFxuICAgICAqIGFuZCBoYXZlIGJvdW5kIGV2ZW50cy4gVGhlIHN0YWdlLCBsYXllcnMsIGdyb3VwcywgYW5kIHNoYXBlcyBhbGwgZXh0ZW5kIE5vZGUuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICovXG4gICAgS29udmEuTm9kZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLlV0aWwuYWRkTWV0aG9kcyhLb252YS5Ob2RlLCB7XG4gICAgICAgIF9pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX2lkID0gS29udmEuaWRDb3VudGVyKys7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0ge307XG4gICAgICAgICAgICB0aGlzLmF0dHJzID0ge307XG4gICAgICAgICAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cnMoY29uZmlnKTtcblxuICAgICAgICAgICAgLy8gZXZlbnQgYmluZGluZ3MgZm9yIGNhY2hlIGhhbmRsaW5nXG4gICAgICAgICAgICB0aGlzLm9uKFRSQU5TRk9STV9DSEFOR0VfU1RSLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhckNhY2hlKFRSQU5TRk9STSk7XG4gICAgICAgICAgICAgICAgdGhhdC5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKEFCU09MVVRFX1RSQU5TRk9STSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMub24oJ3Zpc2libGVDaGFuZ2Uua29udmEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoVklTSUJMRSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMub24oJ2xpc3RlbmluZ0NoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShMSVNURU5JTkcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm9uKCdvcGFjaXR5Q2hhbmdlLmtvbnZhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKEFCU09MVVRFX09QQUNJVFkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9jbGVhckNhY2hlOiBmdW5jdGlvbihhdHRyKXtcbiAgICAgICAgICAgIGlmIChhdHRyKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NhY2hlW2F0dHJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2dldENhY2hlOiBmdW5jdGlvbihhdHRyLCBwcml2YXRlR2V0dGVyKXtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IHRoaXMuX2NhY2hlW2F0dHJdO1xuXG4gICAgICAgICAgICAvLyBpZiBub3QgY2FjaGVkLCB3ZSBuZWVkIHRvIHNldCBpdCB1c2luZyB0aGUgcHJpdmF0ZSBnZXR0ZXIgbWV0aG9kLlxuICAgICAgICAgICAgaWYgKGNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZVthdHRyXSA9IHByaXZhdGVHZXR0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlW2F0dHJdO1xuICAgICAgICB9LFxuICAgICAgICAvKlxuICAgICAgICAgKiB3aGVuIHRoZSBsb2dpYyBmb3IgYSBjYWNoZWQgcmVzdWx0IGRlcGVuZHMgb24gYW5jZXN0b3IgcHJvcGFnYXRpb24sIHVzZSB0aGlzXG4gICAgICAgICAqIG1ldGhvZCB0byBjbGVhciBzZWxmIGFuZCBjaGlsZHJlbiBjYWNoZVxuICAgICAgICAgKi9cbiAgICAgICAgX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZTogZnVuY3Rpb24oYXR0cikge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJDYWNoZShhdHRyKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldENoaWxkcmVuKCkuZWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShhdHRyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogY2xlYXIgY2FjaGVkIGNhbnZhc1xuICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAqIG5vZGUuY2xlYXJDYWNoZSgpO1xuICAgICAgICAqL1xuICAgICAgICBjbGVhckNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jYWNoZS5jYW52YXM7XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqICBjYWNoZSBub2RlIHRvIGltcHJvdmUgZHJhd2luZyBwZXJmb3JtYW5jZSwgYXBwbHkgZmlsdGVycywgb3IgY3JlYXRlIG1vcmUgYWNjdXJhdGVcbiAgICAgICAgKiAgaGl0IHJlZ2lvbnMuIEZvciBhbGwgYmFzaWMgc2hhcGVzIHNpemUgb2YgY2FjaGUgY2FudmFzIHdpbGwgYmUgYXV0b21hdGljYWxseSBkZXRlY3RlZC5cbiAgICAgICAgKiAgSWYgeW91IG5lZWQgdG8gY2FjaGUgeW91ciBjdXN0b20gYEtvbnZhLlNoYXBlYCBpbnN0YW5jZSB5b3UgaGF2ZSB0byBwYXNzIHNoYXBlJ3MgYm91bmRpbmcgYm94XG4gICAgICAgICogIHByb3BlcnRpZXMuIExvb2sgYXQgW2xpbmsgdG8gZGVtbyBwYWdlXShsaW5rIHRvIGRlbW8gcGFnZSkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICAgICogQG1ldGhvZFxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXVxuICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0XSAgaW5jcmVhc2UgY2FudmFzIHNpemUgYnkgYG9mZnNldGAgcGl4ZWwgaW4gYWxsIGRpcmVjdGlvbnMuXG4gICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYXdCb3JkZXJdIHdoZW4gc2V0IHRvIHRydWUsIGEgcmVkIGJvcmRlciB3aWxsIGJlIGRyYXduIGFyb3VuZCB0aGUgY2FjaGVkXG4gICAgICAgICogIHJlZ2lvbiBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXG4gICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgKiAvLyBjYWNoZSBhIHNoYXBlIHdpdGggdGhlIHgseSBwb3NpdGlvbiBvZiB0aGUgYm91bmRpbmcgYm94IGF0IHRoZSBjZW50ZXIgYW5kXG4gICAgICAgICogLy8gdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIGJveCBlcXVhbCB0byB0aGUgd2lkdGggYW5kIGhlaWdodCBvZlxuICAgICAgICAqIC8vIHRoZSBzaGFwZSBvYnRhaW5lZCBmcm9tIHNoYXBlLndpZHRoKCkgYW5kIHNoYXBlLmhlaWdodCgpXG4gICAgICAgICogaW1hZ2UuY2FjaGUoKTtcbiAgICAgICAgKlxuICAgICAgICAqIC8vIGNhY2hlIGEgbm9kZSBhbmQgZGVmaW5lIHRoZSBib3VuZGluZyBib3ggcG9zaXRpb24gYW5kIHNpemVcbiAgICAgICAgKiBub2RlLmNhY2hlKHtcbiAgICAgICAgKiAgIHg6IC0zMCxcbiAgICAgICAgKiAgIHk6IC0zMCxcbiAgICAgICAgKiAgIHdpZHRoOiAxMDAsXG4gICAgICAgICogICBoZWlnaHQ6IDIwMFxuICAgICAgICAqIH0pO1xuICAgICAgICAqXG4gICAgICAgICogLy8gY2FjaGUgYSBub2RlIGFuZCBkcmF3IGEgcmVkIGJvcmRlciBhcm91bmQgdGhlIGJvdW5kaW5nIGJveFxuICAgICAgICAqIC8vIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXNcbiAgICAgICAgKiBub2RlLmNhY2hlKHtcbiAgICAgICAgKiAgIHg6IC0zMCxcbiAgICAgICAgKiAgIHk6IC0zMCxcbiAgICAgICAgKiAgIHdpZHRoOiAxMDAsXG4gICAgICAgICogICBoZWlnaHQ6IDIwMCxcbiAgICAgICAgKiAgIG9mZnNldCA6IDEwLFxuICAgICAgICAqICAgZHJhd0JvcmRlcjogdHJ1ZVxuICAgICAgICAqIH0pO1xuICAgICAgICAqL1xuICAgICAgICBjYWNoZTogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICB2YXIgY29uZiA9IGNvbmZpZyB8fCB7fSxcbiAgICAgICAgICAgICAgICByZWN0ID0gdGhpcy5nZXRDbGllbnRSZWN0KHRydWUpLFxuICAgICAgICAgICAgICAgIHdpZHRoID0gY29uZi53aWR0aCB8fCByZWN0LndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCA9IGNvbmYuaGVpZ2h0IHx8IHJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHggPSBjb25mLnggfHwgcmVjdC54LFxuICAgICAgICAgICAgICAgIHkgPSBjb25mLnkgfHwgcmVjdC55LFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGNvbmYub2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICAgICAgZHJhd0JvcmRlciA9IGNvbmYuZHJhd0JvcmRlciB8fCBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaWR0aCBvciBoZWlnaHQgb2YgY2FjaGluZyBjb25maWd1cmF0aW9uIGVxdWFscyAwLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aWR0aCArPSBvZmZzZXQgKiAyO1xuICAgICAgICAgICAgaGVpZ2h0ICs9IG9mZnNldCAqIDI7XG5cbiAgICAgICAgICAgIHggLT0gb2Zmc2V0O1xuICAgICAgICAgICAgeSAtPSBvZmZzZXQ7XG5cblxuICAgICAgICAgICAgdmFyIGNhY2hlZFNjZW5lQ2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgY2FjaGVkRmlsdGVyQ2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgY2FjaGVkSGl0Q2FudmFzID0gbmV3IEtvbnZhLkhpdENhbnZhcyh7XG4gICAgICAgICAgICAgICAgcGl4ZWxSYXRpbzogMSxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc2NlbmVDb250ZXh0ID0gY2FjaGVkU2NlbmVDYW52YXMuZ2V0Q29udGV4dCgpLFxuICAgICAgICAgICAgaGl0Q29udGV4dCA9IGNhY2hlZEhpdENhbnZhcy5nZXRDb250ZXh0KCk7XG5cbiAgICAgICAgICAgIGNhY2hlZEhpdENhbnZhcy5pc0NhY2hlID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5jbGVhckNhY2hlKCk7XG5cbiAgICAgICAgICAgIHNjZW5lQ29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICBoaXRDb250ZXh0LnNhdmUoKTtcblxuICAgICAgICAgICAgc2NlbmVDb250ZXh0LnRyYW5zbGF0ZSgteCwgLXkpO1xuICAgICAgICAgICAgaGl0Q29udGV4dC50cmFuc2xhdGUoLXgsIC15KTtcblxuICAgICAgICAgICAgdGhpcy5kcmF3U2NlbmUoY2FjaGVkU2NlbmVDYW52YXMsIHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5kcmF3SGl0KGNhY2hlZEhpdENhbnZhcywgdGhpcywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHNjZW5lQ29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICBoaXRDb250ZXh0LnJlc3RvcmUoKTtcblxuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGRyYXcgYSByZWQgYm9yZGVyIGFyb3VuZCB0aGUgY2FjaGVkIGJveCBmb3JcbiAgICAgICAgICAgIC8vIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICAgICAgICAgICAgaWYgKGRyYXdCb3JkZXIpIHtcbiAgICAgICAgICAgICAgICBzY2VuZUNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgIHNjZW5lQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBzY2VuZUNvbnRleHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBzY2VuZUNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgc2NlbmVDb250ZXh0LnNldEF0dHIoJ3N0cm9rZVN0eWxlJywgJ3JlZCcpO1xuICAgICAgICAgICAgICAgIHNjZW5lQ29udGV4dC5zZXRBdHRyKCdsaW5lV2lkdGgnLCA1KTtcbiAgICAgICAgICAgICAgICBzY2VuZUNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgc2NlbmVDb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY2FjaGUuY2FudmFzID0ge1xuICAgICAgICAgICAgICAgIHNjZW5lOiBjYWNoZWRTY2VuZUNhbnZhcyxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IGNhY2hlZEZpbHRlckNhbnZhcyxcbiAgICAgICAgICAgICAgICBoaXQ6IGNhY2hlZEhpdENhbnZhcyxcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIGNsaWVudCByZWN0YW5nbGUge3gsIHksIHdpZHRoLCBoZWlnaHR9IG9mIG5vZGUuIFRoaXMgcmVjdGFuZ2xlIGFsc28gaW5jbHVkZSBhbGwgc3R5bGluZyAoc3Ryb2tlcywgc2hhZG93cywgZXRjKS5cbiAgICAgICAgICogVGhlIHJlY3RhbmdsZSBwb3NpdGlvbiBpcyByZWxhdGl2ZSB0byBwYXJlbnQgY29udGFpbmVyLlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwVHJhbnNmb3JtXSBmbGFnIHNob3VsZCB3ZSBza2lwIHRyYW5zZm9ybWF0aW9uIHRvIHJlY3RhbmdsZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSByZWN0IHdpdGgge3gsIHksIHdpZHRoLCBoZWlnaHR9IHByb3BlcnRpZXNcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogdmFyIHJlY3QgPSBuZXcgS29udmEuUmVjdCh7XG4gICAgICAgICAqICAgICAgd2lkdGggOiAxMDAsXG4gICAgICAgICAqICAgICAgaGVpZ2h0IDogMTAwLFxuICAgICAgICAgKiAgICAgIHggOiA1MCxcbiAgICAgICAgICogICAgICB5IDogNTAsXG4gICAgICAgICAqICAgICAgc3Ryb2tlV2lkdGggOiA0LFxuICAgICAgICAgKiAgICAgIHN0cm9rZSA6ICdibGFjaycsXG4gICAgICAgICAqICAgICAgb2Zmc2V0WCA6IDUwLFxuICAgICAgICAgKiAgICAgIHNjYWxlWSA6IDJcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGdldCBjbGllbnQgcmVjdCB3aXRob3V0IHRoaW5rIG9mZiB0cmFuc2Zvcm1hdGlvbnMgKHBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGUsIG9mZnNldCwgZXRjKVxuICAgICAgICAgKiByZWN0LmdldENsaWVudFJlY3QodHJ1ZSk7XG4gICAgICAgICAqIC8vIHJldHVybnMge1xuICAgICAgICAgKiAvLyAgICAgeCA6IC0yLCAgIC8vIHR3byBwaXhlbHMgZm9yIHN0cm9rZSAvIDJcbiAgICAgICAgICogLy8gICAgIHkgOiAtMixcbiAgICAgICAgICogLy8gICAgIHdpZHRoIDogMTA0LCAvLyBpbmNyZWFzZWQgYnkgNCBmb3Igc3Ryb2tlXG4gICAgICAgICAqIC8vICAgICBoZWlnaHQgOiAxMDRcbiAgICAgICAgICogLy99XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGdldCBjbGllbnQgcmVjdCB3aXRoIHRyYW5zZm9ybWF0aW9uIGFwcGxpZWRcbiAgICAgICAgICogcmVjdC5nZXRDbGllbnRSZWN0KCk7XG4gICAgICAgICAqIC8vIHJldHVybnMgT2JqZWN0IHt4OiAtMiwgeTogNDYsIHdpZHRoOiAxMDQsIGhlaWdodDogMjA4fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q2xpZW50UmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBhYnN0cmFjdCBtZXRob2RcbiAgICAgICAgICAgIC8vIHJlZGVmaW5lIGluIENvbnRhaW5lciBhbmQgU2hhcGVcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWJzdHJhY3QgXCJnZXRDbGllbnRSZWN0XCIgbWV0aG9kIGNhbGwnKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3RyYW5zZm9ybWVkUmVjdDogZnVuY3Rpb24ocmVjdCkge1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtcbiAgICAgICAgICAgICAgICB7eDogcmVjdC54LCB5OiByZWN0Lnl9LFxuICAgICAgICAgICAgICAgIHt4OiByZWN0LnggKyByZWN0LndpZHRoLCB5OiByZWN0Lnl9LFxuICAgICAgICAgICAgICAgIHt4OiByZWN0LnggKyByZWN0LndpZHRoLCB5OiByZWN0LnkgKyByZWN0LmhlaWdodH0sXG4gICAgICAgICAgICAgICAge3g6IHJlY3QueCwgeTogcmVjdC55ICsgcmVjdC5oZWlnaHR9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFk7XG4gICAgICAgICAgICB2YXIgdHJhbnMgPSB0aGlzLmdldFRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgcG9pbnRzLmZvckVhY2goZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWQgPSB0cmFucy5wb2ludChwb2ludCk7XG4gICAgICAgICAgICAgICAgaWYgKG1pblggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBtaW5YID0gbWF4WCA9IHRyYW5zZm9ybWVkLng7XG4gICAgICAgICAgICAgICAgICAgIG1pblkgPSBtYXhZID0gdHJhbnNmb3JtZWQueTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHRyYW5zZm9ybWVkLngpO1xuICAgICAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB0cmFuc2Zvcm1lZC55KTtcbiAgICAgICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgdHJhbnNmb3JtZWQueCk7XG4gICAgICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHRyYW5zZm9ybWVkLnkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IE1hdGgucm91bmQobWluWCksXG4gICAgICAgICAgICAgICAgeTogTWF0aC5yb3VuZChtaW5ZKSxcbiAgICAgICAgICAgICAgICB3aWR0aDogTWF0aC5yb3VuZChtYXhYIC0gbWluWCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKG1heFkgLSBtaW5ZKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgX2RyYXdDYWNoZWRTY2VuZUNhbnZhczogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICBjb250ZXh0Ll9hcHBseU9wYWNpdHkodGhpcyk7XG4gICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jYW52YXMueCxcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jYW52YXMueVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdmFyIGNhY2hlQ2FudmFzID0gdGhpcy5fZ2V0Q2FjaGVkU2NlbmVDYW52YXMoKTtcbiAgICAgICAgICAgIHZhciByYXRpbyA9IGNhY2hlQ2FudmFzLnBpeGVsUmF0aW87XG5cbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGNhY2hlQ2FudmFzLl9jYW52YXMsIDAsIDAsIGNhY2hlQ2FudmFzLndpZHRoIC8gcmF0aW8sIGNhY2hlQ2FudmFzLmhlaWdodCAvIHJhdGlvKTtcbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9LFxuICAgICAgICBfZHJhd0NhY2hlZEhpdENhbnZhczogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGNhY2hlZENhbnZhcyA9IHRoaXMuX2NhY2hlLmNhbnZhcyxcbiAgICAgICAgICAgICAgICBoaXRDYW52YXMgPSBjYWNoZWRDYW52YXMuaGl0O1xuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jYW52YXMueCxcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jYW52YXMueVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGhpdENhbnZhcy5fY2FudmFzLCAwLCAwKTtcbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0Q2FjaGVkU2NlbmVDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGZpbHRlcnMgPSB0aGlzLmZpbHRlcnMoKSxcbiAgICAgICAgICAgICAgICBjYWNoZWRDYW52YXMgPSB0aGlzLl9jYWNoZS5jYW52YXMsXG4gICAgICAgICAgICAgICAgc2NlbmVDYW52YXMgPSBjYWNoZWRDYW52YXMuc2NlbmUsXG4gICAgICAgICAgICAgICAgZmlsdGVyQ2FudmFzID0gY2FjaGVkQ2FudmFzLmZpbHRlcixcbiAgICAgICAgICAgICAgICBmaWx0ZXJDb250ZXh0ID0gZmlsdGVyQ2FudmFzLmdldENvbnRleHQoKSxcbiAgICAgICAgICAgICAgICBsZW4sIGltYWdlRGF0YSwgbiwgZmlsdGVyO1xuXG4gICAgICAgICAgICBpZiAoZmlsdGVycykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZmlsdGVyVXBUb0RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhdGlvID0gc2NlbmVDYW52YXMucGl4ZWxSYXRpbztcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gZmlsdGVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJDb250ZXh0LmNsZWFyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgY2FjaGVkIGNhbnZhcyBvbnRvIGZpbHRlciBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJDb250ZXh0LmRyYXdJbWFnZShzY2VuZUNhbnZhcy5fY2FudmFzLCAwLCAwLCBzY2VuZUNhbnZhcy5nZXRXaWR0aCgpIC8gcmF0aW8sIHNjZW5lQ2FudmFzLmdldEhlaWdodCgpIC8gcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhID0gZmlsdGVyQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgZmlsdGVyQ2FudmFzLmdldFdpZHRoKCksIGZpbHRlckNhbnZhcy5nZXRIZWlnaHQoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFwcGx5IGZpbHRlcnMgdG8gZmlsdGVyIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IGZpbHRlcnNbbl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyLmNhbGwodGhpcywgaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJDb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwud2FybignVW5hYmxlIHRvIGFwcGx5IGZpbHRlci4gJyArIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlckNhbnZhcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzY2VuZUNhbnZhcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGJpbmQgZXZlbnRzIHRvIHRoZSBub2RlLiBLb252YUpTIHN1cHBvcnRzIG1vdXNlb3ZlciwgbW91c2Vtb3ZlLFxuICAgICAgICAgKiAgbW91c2VvdXQsIG1vdXNlZW50ZXIsIG1vdXNlbGVhdmUsIG1vdXNlZG93biwgbW91c2V1cCwgbW91c2V3aGVlbCwgY2xpY2ssIGRibGNsaWNrLCB0b3VjaHN0YXJ0LCB0b3VjaG1vdmUsXG4gICAgICAgICAqICB0b3VjaGVuZCwgdGFwLCBkYmx0YXAsIGRyYWdzdGFydCwgZHJhZ21vdmUsIGFuZCBkcmFnZW5kIGV2ZW50cy4gVGhlIEtvbnZhIFN0YWdlIHN1cHBvcnRzXG4gICAgICAgICAqICBjb250ZW50TW91c2VvdmVyLCBjb250ZW50TW91c2Vtb3ZlLCBjb250ZW50TW91c2VvdXQsIGNvbnRlbnRNb3VzZWRvd24sIGNvbnRlbnRNb3VzZXVwLFxuICAgICAgICAgKiAgY29udGVudENsaWNrLCBjb250ZW50RGJsY2xpY2ssIGNvbnRlbnRUb3VjaHN0YXJ0LCBjb250ZW50VG91Y2htb3ZlLCBjb250ZW50VG91Y2hlbmQsIGNvbnRlbnRUYXAsXG4gICAgICAgICAqICBhbmQgY29udGVudERibFRhcC4gIFBhc3MgaW4gYSBzdHJpbmcgb2YgZXZlbnRzIGRlbGltbWl0ZWQgYnkgYSBzcGFjZSB0byBiaW5kIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gICAgICAgICAqICBzdWNoIGFzICdtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUnLiBJbmNsdWRlIGEgbmFtZXNwYWNlIHRvIGJpbmQgYW5cbiAgICAgICAgICogIGV2ZW50IGJ5IG5hbWUgc3VjaCBhcyAnY2xpY2suZm9vYmFyJy5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2dFN0ciBlLmcuICdjbGljaycsICdtb3VzZWRvd24gdG91Y2hzdGFydCcsICdtb3VzZWRvd24uZm9vIHRvdWNoc3RhcnQuZm9vJ1xuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBoYW5kbGVyIGZ1bmN0aW9uIGlzIHBhc3NlZCBhbiBldmVudCBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIGFkZCBjbGljayBsaXN0ZW5lclxuICAgICAgICAgKiBub2RlLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKCd5b3UgY2xpY2tlZCBtZSEnKTtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGdldCB0aGUgdGFyZ2V0IG5vZGVcbiAgICAgICAgICogbm9kZS5vbignY2xpY2snLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhldnQudGFyZ2V0KTtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIHN0b3AgZXZlbnQgcHJvcGFnYXRpb25cbiAgICAgICAgICogbm9kZS5vbignY2xpY2snLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICogICBldnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGJpbmQgbXVsdGlwbGUgbGlzdGVuZXJzXG4gICAgICAgICAqIG5vZGUub24oJ2NsaWNrIHRvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZygneW91IGNsaWNrZWQvdG91Y2hlZCBtZSEnKTtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIG5hbWVzcGFjZSBsaXN0ZW5lclxuICAgICAgICAgKiBub2RlLm9uKCdjbGljay5mb28nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZygneW91IGNsaWNrZWQvdG91Y2hlZCBtZSEnKTtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGdldCB0aGUgZXZlbnQgdHlwZVxuICAgICAgICAgKiBub2RlLm9uKCdjbGljayB0YXAnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICogICB2YXIgZXZlbnRUeXBlID0gZXZ0LnR5cGU7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBnZXQgbmF0aXZlIGV2ZW50IG9iamVjdFxuICAgICAgICAgKiBub2RlLm9uKCdjbGljayB0YXAnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICogICB2YXIgbmF0aXZlRXZlbnQgPSBldnQuZXZ0O1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gZm9yIGNoYW5nZSBldmVudHMsIGdldCB0aGUgb2xkIGFuZCBuZXcgdmFsXG4gICAgICAgICAqIG5vZGUub24oJ3hDaGFuZ2UnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICogICB2YXIgb2xkVmFsID0gZXZ0Lm9sZFZhbDtcbiAgICAgICAgICogICB2YXIgbmV3VmFsID0gZXZ0Lm5ld1ZhbDtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGdldCBldmVudCB0YXJnZXRzXG4gICAgICAgICAqIC8vIHdpdGggZXZlbnQgZGVsZWdhdGlvbnNcbiAgICAgICAgICogbGF5ZXIub24oJ2NsaWNrJywgJ0dyb3VwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAqICAgdmFyIHNoYXBlID0gZXZ0LnRhcmdldDtcbiAgICAgICAgICogICB2YXIgZ3JvdXAgPSBldnRuLmN1cnJlbnRUYXJnZXI7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgb246IGZ1bmN0aW9uKGV2dFN0ciwgaGFuZGxlcikge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBldmVudHMgPSBldnRTdHIuc3BsaXQoU1BBQ0UpLFxuICAgICAgICAgICAgICAgIGxlbiA9IGV2ZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbiwgZXZlbnQsIHBhcnRzLCBiYXNlRXZlbnQsIG5hbWU7XG5cbiAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogbG9vcCB0aHJvdWdoIHR5cGVzIGFuZCBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzIHRvXG4gICAgICAgICAgICAgKiBlYWNoIG9uZS4gIGVnLiAnY2xpY2sgbW91c2VvdmVyLm5hbWVzcGFjZSBtb3VzZW91dCdcbiAgICAgICAgICAgICAqIHdpbGwgY3JlYXRlIHRocmVlIGV2ZW50IGJpbmRpbmdzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvcihuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBldmVudHNbbl07XG4gICAgICAgICAgICAgICAgcGFydHMgPSBldmVudC5zcGxpdChET1QpO1xuICAgICAgICAgICAgICAgIGJhc2VFdmVudCA9IHBhcnRzWzBdO1xuICAgICAgICAgICAgICAgIG5hbWUgPSBwYXJ0c1sxXSB8fCBFTVBUWV9TVFJJTkc7XG5cbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgZXZlbnRzIGFycmF5IGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgICAgICBpZighdGhpcy5ldmVudExpc3RlbmVyc1tiYXNlRXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnNbYmFzZUV2ZW50XSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnNbYmFzZUV2ZW50XS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlbW92ZSBldmVudCBiaW5kaW5ncyBmcm9tIHRoZSBub2RlLiBQYXNzIGluIGEgc3RyaW5nIG9mXG4gICAgICAgICAqICBldmVudCB0eXBlcyBkZWxpbW1pdGVkIGJ5IGEgc3BhY2UgdG8gcmVtb3ZlIG11bHRpcGxlIGV2ZW50XG4gICAgICAgICAqICBiaW5kaW5ncyBhdCBvbmNlIHN1Y2ggYXMgJ21vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZScuXG4gICAgICAgICAqICBpbmNsdWRlIGEgbmFtZXNwYWNlIHRvIHJlbW92ZSBhbiBldmVudCBiaW5kaW5nIGJ5IG5hbWVcbiAgICAgICAgICogIHN1Y2ggYXMgJ2NsaWNrLmZvb2JhcicuIElmIHlvdSBvbmx5IGdpdmUgYSBuYW1lIGxpa2UgJy5mb29iYXInLFxuICAgICAgICAgKiAgYWxsIGV2ZW50cyBpbiB0aGF0IG5hbWVzcGFjZSB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldnRTdHIgZS5nLiAnY2xpY2snLCAnbW91c2Vkb3duIHRvdWNoc3RhcnQnLCAnLmZvb2JhcidcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIHJlbW92ZSBsaXN0ZW5lclxuICAgICAgICAgKiBub2RlLm9mZignY2xpY2snKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gcmVtb3ZlIG11bHRpcGxlIGxpc3RlbmVyc1xuICAgICAgICAgKiBub2RlLm9mZignY2xpY2sgdG91Y2hzdGFydCcpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyByZW1vdmUgbGlzdGVuZXIgYnkgbmFtZVxuICAgICAgICAgKiBub2RlLm9mZignY2xpY2suZm9vJyk7XG4gICAgICAgICAqL1xuICAgICAgICBvZmY6IGZ1bmN0aW9uKGV2dFN0cikge1xuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IChldnRTdHIgfHwgJycpLnNwbGl0KFNQQUNFKSxcbiAgICAgICAgICAgICAgICBsZW4gPSBldmVudHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG4sIHQsIGV2ZW50LCBwYXJ0cywgYmFzZUV2ZW50LCBuYW1lO1xuXG4gICAgICAgICAgICBpZiAoIWV2dFN0cikge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwgZXZlbnRzXG4gICAgICAgICAgICAgICAgZm9yKHQgaW4gdGhpcy5ldmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZmYodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IGV2ZW50c1tuXTtcbiAgICAgICAgICAgICAgICBwYXJ0cyA9IGV2ZW50LnNwbGl0KERPVCk7XG4gICAgICAgICAgICAgICAgYmFzZUV2ZW50ID0gcGFydHNbMF07XG4gICAgICAgICAgICAgICAgbmFtZSA9IHBhcnRzWzFdO1xuXG4gICAgICAgICAgICAgICAgaWYoYmFzZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZXZlbnRMaXN0ZW5lcnNbYmFzZUV2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2ZmKGJhc2VFdmVudCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcih0IGluIHRoaXMuZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZih0LCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBzb21lIGV2ZW50IGFsaWFzZXMgZm9yIHRoaXJkIHBhcnR5IGludGVncmF0aW9uIGxpa2UgSGFtbWVySlNcbiAgICAgICAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICB0eXBlOiBldnQudHlwZSxcbiAgICAgICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmZpcmUoZXZ0LnR5cGUsIGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gcGFzcyBuYXRpdmUgZXZlbnQgdG8gaGFuZGxlclxuICAgICAgICAgICAgdGhpcy5vbih0eXBlLCBmdW5jdGlvbihldnQpe1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBldnQuZXZ0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMub2ZmKHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGxpa2Ugbm9kZS5vblxuICAgICAgICBfZGVsZWdhdGU6IGZ1bmN0aW9uKGV2ZW50LCBzZWxlY3RvciwgaGFuZGxlcikge1xuICAgICAgICAgICAgdmFyIHN0b3BOb2RlID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMub24oZXZlbnQsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRzID0gZXZ0LnRhcmdldC5maW5kQW5jZXN0b3JzKHNlbGVjdG9yLCB0cnVlLCBzdG9wTm9kZSk7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0ID0gS29udmEuVXRpbC5jbG9uZU9iamVjdChldnQpO1xuICAgICAgICAgICAgICAgICAgICBldnQuY3VycmVudFRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbCh0YXJnZXRzW2ldLCBldnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnQsIGJ1dCBkb24ndCBkZXN0cm95XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuXG4gICAgICAgICAgICBpZihwYXJlbnQgJiYgcGFyZW50LmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuX3NldENoaWxkcmVuSW5kaWNlcygpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZXZlcnkgY2FjaGVkIGF0dHIgdGhhdCBpcyBjYWxjdWxhdGVkIHZpYSBub2RlIHRyZWVcbiAgICAgICAgICAgIC8vIHRyYXZlcnNhbCBtdXN0IGJlIGNsZWFyZWQgd2hlbiByZW1vdmluZyBhIG5vZGVcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShTVEFHRSk7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoQUJTT0xVVEVfVFJBTlNGT1JNKTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShWSVNJQkxFKTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShMSVNURU5JTkcpO1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKEFCU09MVVRFX09QQUNJVFkpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlbW92ZSBhbmQgZGVzdHJveSBzZWxmXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIG5vZGUuZGVzdHJveSgpO1xuICAgICAgICAgKi9cbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZnJvbSBpZHMgYW5kIG5hbWVzIGhhc2hlc1xuICAgICAgICAgICAgS29udmEuX3JlbW92ZUlkKHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgICAgICBLb252YS5fcmVtb3ZlTmFtZSh0aGlzLmdldE5hbWUoKSwgdGhpcy5faWQpO1xuXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgYXR0clxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0clxuICAgICAgICAgKiBAcmV0dXJucyB7SW50ZWdlcnxTdHJpbmd8T2JqZWN0fEFycmF5fVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiB2YXIgeCA9IG5vZGUuZ2V0QXR0cigneCcpO1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXR0cjogZnVuY3Rpb24oYXR0cikge1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IEdFVCArIEtvbnZhLlV0aWwuX2NhcGl0YWxpemUoYXR0cik7XG4gICAgICAgICAgICBpZihLb252YS5VdGlsLl9pc0Z1bmN0aW9uKHRoaXNbbWV0aG9kXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1ttZXRob2RdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgZ2V0IGRpcmVjdGx5XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyc1thdHRyXTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogZ2V0IGFuY2VzdG9yc1xuICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgKiBAcmV0dXJucyB7S29udmEuQ29sbGVjdGlvbn1cbiAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAqIHNoYXBlLmdldEFuY2VzdG9ycygpLmVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAqICAgY29uc29sZS5sb2cobm9kZS5nZXRJZCgpKTtcbiAgICAgICAgKiB9KVxuICAgICAgICAqL1xuICAgICAgICBnZXRBbmNlc3RvcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCksXG4gICAgICAgICAgICAgICAgYW5jZXN0b3JzID0gbmV3IEtvbnZhLkNvbGxlY3Rpb24oKTtcblxuICAgICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGFuY2VzdG9ycy5wdXNoKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYW5jZXN0b3JzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGF0dHJzIG9iamVjdCBsaXRlcmFsXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRycyB8fCB7fTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCBtdWx0aXBsZSBhdHRycyBhdCBvbmNlIHVzaW5nIGFuIG9iamVjdCBsaXRlcmFsXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgb2JqZWN0IGNvbnRhaW5pbmcga2V5IHZhbHVlIHBhaXJzXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBub2RlLnNldEF0dHJzKHtcbiAgICAgICAgICogICB4OiA1LFxuICAgICAgICAgKiAgIGZpbGw6ICdyZWQnXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgc2V0QXR0cnM6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgdmFyIGtleSwgbWV0aG9kO1xuXG4gICAgICAgICAgICBpZighY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3Ioa2V5IGluIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXRob2QgPSBTRVQgKyBLb252YS5VdGlsLl9jYXBpdGFsaXplKGtleSk7XG4gICAgICAgICAgICAgICAgLy8gdXNlIHNldHRlciBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICBpZihLb252YS5VdGlsLl9pc0Z1bmN0aW9uKHRoaXNbbWV0aG9kXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1ttZXRob2RdKGNvbmZpZ1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHNldCBkaXJlY3RseVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRBdHRyKGtleSwgY29uZmlnW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZGV0ZXJtaW5lIGlmIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHMgYnkgdGFraW5nIGludG8gYWNjb3VudCBhbmNlc3RvcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhcmVudCAgICB8IFNlbGYgICAgICB8IGlzTGlzdGVuaW5nXG4gICAgICAgICAqIGxpc3RlbmluZyB8IGxpc3RlbmluZyB8XG4gICAgICAgICAqIC0tLS0tLS0tLS0rLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tXG4gICAgICAgICAqIFQgICAgICAgICB8IFQgICAgICAgICB8IFRcbiAgICAgICAgICogVCAgICAgICAgIHwgRiAgICAgICAgIHwgRlxuICAgICAgICAgKiBGICAgICAgICAgfCBUICAgICAgICAgfCBUXG4gICAgICAgICAqIEYgICAgICAgICB8IEYgICAgICAgICB8IEZcbiAgICAgICAgICogLS0tLS0tLS0tLSstLS0tLS0tLS0tLSstLS0tLS0tLS0tLS1cbiAgICAgICAgICogVCAgICAgICAgIHwgSSAgICAgICAgIHwgVFxuICAgICAgICAgKiBGICAgICAgICAgfCBJICAgICAgICAgfCBGXG4gICAgICAgICAqIEkgICAgICAgICB8IEkgICAgICAgICB8IFRcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpc0xpc3RlbmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoTElTVEVOSU5HLCB0aGlzLl9pc0xpc3RlbmluZyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9pc0xpc3RlbmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuaW5nID0gdGhpcy5nZXRMaXN0ZW5pbmcoKSxcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuXG4gICAgICAgICAgICAvLyB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIGEgc2ltcGxpZmljYXRpb24gb2YgdGhlIHRydXRoIHRhYmxlIGFib3ZlLlxuICAgICAgICAgICAgLy8gcGxlYXNlIG1vZGlmeSBjYXJlZnVsbHlcbiAgICAgICAgICAgIGlmIChsaXN0ZW5pbmcgPT09ICdpbmhlcml0Jykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5pc0xpc3RlbmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRldGVybWluZSBpZiBub2RlIGlzIHZpc2libGUgYnkgdGFraW5nIGludG8gYWNjb3VudCBhbmNlc3RvcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhcmVudCAgICB8IFNlbGYgICAgICB8IGlzVmlzaWJsZVxuICAgICAgICAgKiB2aXNpYmxlICAgfCB2aXNpYmxlICAgfFxuICAgICAgICAgKiAtLS0tLS0tLS0tKy0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLVxuICAgICAgICAgKiBUICAgICAgICAgfCBUICAgICAgICAgfCBUXG4gICAgICAgICAqIFQgICAgICAgICB8IEYgICAgICAgICB8IEZcbiAgICAgICAgICogRiAgICAgICAgIHwgVCAgICAgICAgIHwgVFxuICAgICAgICAgKiBGICAgICAgICAgfCBGICAgICAgICAgfCBGXG4gICAgICAgICAqIC0tLS0tLS0tLS0rLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tXG4gICAgICAgICAqIFQgICAgICAgICB8IEkgICAgICAgICB8IFRcbiAgICAgICAgICogRiAgICAgICAgIHwgSSAgICAgICAgIHwgRlxuICAgICAgICAgKiBJICAgICAgICAgfCBJICAgICAgICAgfCBUXG5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKFZJU0lCTEUsIHRoaXMuX2lzVmlzaWJsZSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9pc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHZpc2libGUgPSB0aGlzLmdldFZpc2libGUoKSxcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuXG4gICAgICAgICAgICAvLyB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIGEgc2ltcGxpZmljYXRpb24gb2YgdGhlIHRydXRoIHRhYmxlIGFib3ZlLlxuICAgICAgICAgICAgLy8gcGxlYXNlIG1vZGlmeSBjYXJlZnVsbHlcbiAgICAgICAgICAgIGlmICh2aXNpYmxlID09PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQuaXNWaXNpYmxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRldGVybWluZSBpZiBsaXN0ZW5pbmcgaXMgZW5hYmxlZCBieSB0YWtpbmcgaW50byBhY2NvdW50IGRlc2NlbmRhbnRzLiAgSWYgc2VsZiBvciBhbnkgY2hpbGRyZW5cbiAgICAgICAgICogaGF2ZSBfaXNMaXN0ZW5pbmdFbmFibGVkIHNldCB0byB0cnVlLCB0aGVuIHNlbGYgYWxzbyBoYXMgbGlzdGVuaW5nIGVuYWJsZWQuXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvdWxkRHJhd0hpdDogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgICAgICAgICByZXR1cm4gKGNhbnZhcyAmJiBjYW52YXMuaXNDYWNoZSkgfHwgKGxheWVyICYmIGxheWVyLmhpdEdyYXBoRW5hYmxlZCgpKVxuICAgICAgICAgICAgICAgICYmIHRoaXMuaXNMaXN0ZW5pbmcoKSAmJiB0aGlzLmlzVmlzaWJsZSgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogc2hvdyBub2RlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZpc2libGUodHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGhpZGUgbm9kZS4gIEhpZGRlbiBub2RlcyBhcmUgbm8gbG9uZ2VyIGRldGVjdGFibGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqL1xuICAgICAgICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCB6SW5kZXggcmVsYXRpdmUgdG8gdGhlIG5vZGUncyBzaWJsaW5ncyB3aG8gc2hhcmUgdGhlIHNhbWUgcGFyZW50XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0WkluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4IHx8IDA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgYWJzb2x1dGUgei1pbmRleCB3aGljaCB0YWtlcyBpbnRvIGFjY291bnQgc2libGluZ1xuICAgICAgICAgKiAgYW5kIGFuY2VzdG9yIGluZGljZXNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRBYnNvbHV0ZVpJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZGVwdGggPSB0aGlzLmdldERlcHRoKCksXG4gICAgICAgICAgICAgICAgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIG5vZGVzLCBsZW4sIG4sIGNoaWxkO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRDaGlsZHJlbihjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIG5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgbGVuID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvcihuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5bbl07XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoY2hpbGQubm9kZVR5cGUgIT09IFNIQVBFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChjaGlsZC5nZXRDaGlsZHJlbigpLnRvQXJyYXkoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihjaGlsZC5faWQgPT09IHRoYXQuX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gbGVuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYobm9kZXMubGVuZ3RoID4gMCAmJiBub2Rlc1swXS5nZXREZXB0aCgpIDw9IGRlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZENoaWxkcmVuKG5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGF0Lm5vZGVUeXBlICE9PSBVUFBFUl9TVEFHRSkge1xuICAgICAgICAgICAgICAgIGFkZENoaWxkcmVuKHRoYXQuZ2V0U3RhZ2UoKS5nZXRDaGlsZHJlbigpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IG5vZGUgZGVwdGggaW4gbm9kZSB0cmVlLiAgUmV0dXJucyBhbiBpbnRlZ2VyLlxuICAgICAgICAgKiAgZS5nLiBTdGFnZSBkZXB0aCB3aWxsIGFsd2F5cyBiZSAwLiAgTGF5ZXJzIHdpbGwgYWx3YXlzIGJlIDEuICBHcm91cHMgYW5kIFNoYXBlcyB3aWxsIGFsd2F5c1xuICAgICAgICAgKiAgYmUgPj0gMlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldERlcHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkZXB0aCA9IDAsXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cbiAgICAgICAgICAgIHdoaWxlKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZXB0aDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICAgICAgdGhpcy5zZXRYKHBvcy54KTtcbiAgICAgICAgICAgIHRoaXMuc2V0WShwb3MueSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLmdldFgoKSxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLmdldFkoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBhYnNvbHV0ZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBzdGFnZSBjb250YWluZXIgZGl2XG4gICAgICAgICAqIG9yIHJlbGF0aXZlIHRvIHBhc3NlZCBub2RlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFt0b3BdIG9wdGlvbmFsIHBhcmVudCBub2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QWJzb2x1dGVQb3NpdGlvbjogZnVuY3Rpb24odG9wKSB7XG4gICAgICAgICAgICB2YXIgYWJzb2x1dGVNYXRyaXggPSB0aGlzLmdldEFic29sdXRlVHJhbnNmb3JtKHRvcCkuZ2V0TWF0cml4KCksXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVUcmFuc2Zvcm0gPSBuZXcgS29udmEuVHJhbnNmb3JtKCksXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblxuICAgICAgICAgICAgLy8gY2xvbmUgdGhlIG1hdHJpeCBhcnJheVxuICAgICAgICAgICAgYWJzb2x1dGVUcmFuc2Zvcm0ubSA9IGFic29sdXRlTWF0cml4LnNsaWNlKCk7XG4gICAgICAgICAgICBhYnNvbHV0ZVRyYW5zZm9ybS50cmFuc2xhdGUob2Zmc2V0LngsIG9mZnNldC55KTtcblxuICAgICAgICAgICAgcmV0dXJuIGFic29sdXRlVHJhbnNmb3JtLmdldFRyYW5zbGF0aW9uKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgYWJzb2x1dGUgcG9zaXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBvc1xuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zLnhcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy55XG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0QWJzb2x1dGVQb3NpdGlvbjogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ1RyYW5zID0gdGhpcy5fY2xlYXJUcmFuc2Zvcm0oKSxcbiAgICAgICAgICAgICAgICBpdDtcblxuICAgICAgICAgICAgLy8gZG9uJ3QgY2xlYXIgdHJhbnNsYXRpb25cbiAgICAgICAgICAgIHRoaXMuYXR0cnMueCA9IG9yaWdUcmFucy54O1xuICAgICAgICAgICAgdGhpcy5hdHRycy55ID0gb3JpZ1RyYW5zLnk7XG4gICAgICAgICAgICBkZWxldGUgb3JpZ1RyYW5zLng7XG4gICAgICAgICAgICBkZWxldGUgb3JpZ1RyYW5zLnk7XG5cbiAgICAgICAgICAgIC8vIHVucmF2ZWwgdHJhbnNmb3JtXG4gICAgICAgICAgICBpdCA9IHRoaXMuZ2V0QWJzb2x1dGVUcmFuc2Zvcm0oKTtcblxuICAgICAgICAgICAgaXQuaW52ZXJ0KCk7XG4gICAgICAgICAgICBpdC50cmFuc2xhdGUocG9zLngsIHBvcy55KTtcbiAgICAgICAgICAgIHBvcyA9IHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLmF0dHJzLnggKyBpdC5nZXRUcmFuc2xhdGlvbigpLngsXG4gICAgICAgICAgICAgICAgeTogdGhpcy5hdHRycy55ICsgaXQuZ2V0VHJhbnNsYXRpb24oKS55XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHt4OiBwb3MueCwgeTogcG9zLnl9KTtcbiAgICAgICAgICAgIHRoaXMuX3NldFRyYW5zZm9ybShvcmlnVHJhbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgX3NldFRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnMpIHtcbiAgICAgICAgICAgIHZhciBrZXk7XG5cbiAgICAgICAgICAgIGZvcihrZXkgaW4gdHJhbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJzW2tleV0gPSB0cmFuc1trZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9jbGVhckNhY2hlKFRSQU5TRk9STSk7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoQUJTT0xVVEVfVFJBTlNGT1JNKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2NsZWFyVHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0cmFucyA9IHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLmdldFgoKSxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLmdldFkoKSxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogdGhpcy5nZXRSb3RhdGlvbigpLFxuICAgICAgICAgICAgICAgIHNjYWxlWDogdGhpcy5nZXRTY2FsZVgoKSxcbiAgICAgICAgICAgICAgICBzY2FsZVk6IHRoaXMuZ2V0U2NhbGVZKCksXG4gICAgICAgICAgICAgICAgb2Zmc2V0WDogdGhpcy5nZXRPZmZzZXRYKCksXG4gICAgICAgICAgICAgICAgb2Zmc2V0WTogdGhpcy5nZXRPZmZzZXRZKCksXG4gICAgICAgICAgICAgICAgc2tld1g6IHRoaXMuZ2V0U2tld1goKSxcbiAgICAgICAgICAgICAgICBza2V3WTogdGhpcy5nZXRTa2V3WSgpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmF0dHJzLnggPSAwO1xuICAgICAgICAgICAgdGhpcy5hdHRycy55ID0gMDtcbiAgICAgICAgICAgIHRoaXMuYXR0cnMucm90YXRpb24gPSAwO1xuICAgICAgICAgICAgdGhpcy5hdHRycy5zY2FsZVggPSAxO1xuICAgICAgICAgICAgdGhpcy5hdHRycy5zY2FsZVkgPSAxO1xuICAgICAgICAgICAgdGhpcy5hdHRycy5vZmZzZXRYID0gMDtcbiAgICAgICAgICAgIHRoaXMuYXR0cnMub2Zmc2V0WSA9IDA7XG4gICAgICAgICAgICB0aGlzLmF0dHJzLnNrZXdYID0gMDtcbiAgICAgICAgICAgIHRoaXMuYXR0cnMuc2tld1kgPSAwO1xuXG4gICAgICAgICAgICB0aGlzLl9jbGVhckNhY2hlKFRSQU5TRk9STSk7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoQUJTT0xVVEVfVFJBTlNGT1JNKTtcblxuICAgICAgICAgICAgLy8gcmV0dXJuIG9yaWdpbmFsIHRyYW5zZm9ybVxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogbW92ZSBub2RlIGJ5IGFuIGFtb3VudCByZWxhdGl2ZSB0byBpdHMgY3VycmVudCBwb3NpdGlvblxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hhbmdlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFuZ2UueFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhbmdlLnlcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIG1vdmUgbm9kZSBpbiB4IGRpcmVjdGlvbiBieSAxcHggYW5kIHkgZGlyZWN0aW9uIGJ5IDJweFxuICAgICAgICAgKiBub2RlLm1vdmUoe1xuICAgICAgICAgKiAgIHg6IDEsXG4gICAgICAgICAqICAgeTogMilcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlOiBmdW5jdGlvbihjaGFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VYID0gY2hhbmdlLngsXG4gICAgICAgICAgICAgICAgY2hhbmdlWSA9IGNoYW5nZS55LFxuICAgICAgICAgICAgICAgIHggPSB0aGlzLmdldFgoKSxcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5nZXRZKCk7XG5cbiAgICAgICAgICAgIGlmKGNoYW5nZVggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHggKz0gY2hhbmdlWDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoY2hhbmdlWSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgeSArPSBjaGFuZ2VZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHt4OiB4LCB5OiB5fSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgX2VhY2hBbmNlc3RvclJldmVyc2U6IGZ1bmN0aW9uKGZ1bmMsIHRvcCkge1xuICAgICAgICAgICAgdmFyIGZhbWlseSA9IFtdLFxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCksXG4gICAgICAgICAgICAgICAgbGVuLCBuO1xuXG4gICAgICAgICAgICAvLyBpZiB0b3Agbm9kZSBpcyBkZWZpbmVkLCBhbmQgdGhpcyBub2RlIGlzIHRvcCBub2RlLFxuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBuZWVkIHRvIGJ1aWxkIGEgZmFtaWx5IHRyZWUuICBqdXN0IGV4ZWN1dGVcbiAgICAgICAgICAgIC8vIGZ1bmMgd2l0aCB0aGlzIGJlY2F1c2UgaXQgd2lsbCBiZSB0aGUgb25seSBub2RlXG4gICAgICAgICAgICBpZiAodG9wICYmIHRvcC5faWQgPT09IHRoaXMuX2lkKSB7XG4gICAgICAgICAgICAgICAgZnVuYyh0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmFtaWx5LnVuc2hpZnQodGhpcyk7XG5cbiAgICAgICAgICAgIHdoaWxlKHBhcmVudCAmJiAoIXRvcCB8fCBwYXJlbnQuX2lkICE9PSB0b3AuX2lkKSkge1xuICAgICAgICAgICAgICAgIGZhbWlseS51bnNoaWZ0KHBhcmVudCk7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGVuID0gZmFtaWx5Lmxlbmd0aDtcbiAgICAgICAgICAgIGZvcihuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgZnVuYyhmYW1pbHlbbl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogcm90YXRlIG5vZGUgYnkgYW4gYW1vdW50IGluIGRlZ3JlZXMgcmVsYXRpdmUgdG8gaXRzIGN1cnJlbnQgcm90YXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHRoZXRhXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRlOiBmdW5jdGlvbih0aGV0YSkge1xuICAgICAgICAgICAgdGhpcy5zZXRSb3RhdGlvbih0aGlzLmdldFJvdGF0aW9uKCkgKyB0aGV0YSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1vdmUgbm9kZSB0byB0aGUgdG9wIG9mIGl0cyBzaWJsaW5nc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIG1vdmVUb1RvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdOb2RlIGhhcyBubyBwYXJlbnQuIG1vdmVUb1RvcCBmdW5jdGlvbiBpcyBpZ25vcmVkLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Ll9zZXRDaGlsZHJlbkluZGljZXMoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogbW92ZSBub2RlIHVwXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBmbGFnIGlzIG1vdmVkIG9yIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZVVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBLb252YS5VdGlsLndhcm4oJ05vZGUgaGFzIG5vIHBhcmVudC4gbW92ZVVwIGZ1bmN0aW9uIGlzIGlnbm9yZWQuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCxcbiAgICAgICAgICAgICAgICBsZW4gPSB0aGlzLnBhcmVudC5nZXRDaGlsZHJlbigpLmxlbmd0aDtcbiAgICAgICAgICAgIGlmKGluZGV4IDwgbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4ICsgMSwgMCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuX3NldENoaWxkcmVuSW5kaWNlcygpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogbW92ZSBub2RlIGRvd25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlRG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdOb2RlIGhhcyBubyBwYXJlbnQuIG1vdmVEb3duIGZ1bmN0aW9uIGlzIGlnbm9yZWQuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgIGlmKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4IC0gMSwgMCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuX3NldENoaWxkcmVuSW5kaWNlcygpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogbW92ZSBub2RlIHRvIHRoZSBib3R0b20gb2YgaXRzIHNpYmxpbmdzXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZVRvQm90dG9tOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBLb252YS5VdGlsLndhcm4oJ05vZGUgaGFzIG5vIHBhcmVudC4gbW92ZVRvQm90dG9tIGZ1bmN0aW9uIGlzIGlnbm9yZWQuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgIGlmKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4udW5zaGlmdCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5fc2V0Q2hpbGRyZW5JbmRpY2VzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgekluZGV4IHJlbGF0aXZlIHRvIHNpYmxpbmdzXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gekluZGV4XG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0WkluZGV4OiBmdW5jdGlvbih6SW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBLb252YS5VdGlsLndhcm4oJ05vZGUgaGFzIG5vIHBhcmVudC4gekluZGV4IHBhcmFtZXRlciBpcyBpZ25vcmVkLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKHpJbmRleCwgMCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5fc2V0Q2hpbGRyZW5JbmRpY2VzKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBhYnNvbHV0ZSBvcGFjaXR5XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRBYnNvbHV0ZU9wYWNpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKEFCU09MVVRFX09QQUNJVFksIHRoaXMuX2dldEFic29sdXRlT3BhY2l0eSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRBYnNvbHV0ZU9wYWNpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFic09wYWNpdHkgPSB0aGlzLmdldE9wYWNpdHkoKTtcbiAgICAgICAgICAgIGlmKHRoaXMuZ2V0UGFyZW50KCkpIHtcbiAgICAgICAgICAgICAgICBhYnNPcGFjaXR5ICo9IHRoaXMuZ2V0UGFyZW50KCkuZ2V0QWJzb2x1dGVPcGFjaXR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWJzT3BhY2l0eTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1vdmUgbm9kZSB0byBhbm90aGVyIGNvbnRhaW5lclxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0NvbnRhaW5lcn0gbmV3Q29udGFpbmVyXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBtb3ZlIG5vZGUgZnJvbSBjdXJyZW50IGxheWVyIGludG8gbGF5ZXIyXG4gICAgICAgICAqIG5vZGUubW92ZVRvKGxheWVyMik7XG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlVG86IGZ1bmN0aW9uKG5ld0NvbnRhaW5lcikge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZyBpZiBuZXcgY29udGFpbmVyIGlzIGFscmVhZHkgcGFyZW50XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRQYXJlbnQoKSAhPT0gbmV3Q29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBuZXdDb250YWluZXIuYWRkKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjb252ZXJ0IE5vZGUgaW50byBhbiBvYmplY3QgZm9yIHNlcmlhbGl6YXRpb24uICBSZXR1cm5zIGFuIG9iamVjdC5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSB7fSxcbiAgICAgICAgICAgICAgICBhdHRycyA9IHRoaXMuZ2V0QXR0cnMoKSxcbiAgICAgICAgICAgICAgICBrZXksIHZhbCwgZ2V0dGVyLCBkZWZhdWx0VmFsdWU7XG5cbiAgICAgICAgICAgIG9iai5hdHRycyA9IHt9O1xuXG4gICAgICAgICAgICBmb3Ioa2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgICAgICAvLyBzZXJpYWxpemUgb25seSBhdHRyaWJ1dGVzIHRoYXQgYXJlIG5vdCBmdW5jdGlvbiwgaW1hZ2UsIERPTSwgb3Igb2JqZWN0cyB3aXRoIG1ldGhvZHNcbiAgICAgICAgICAgICAgICBpZiAoS29udmEuVXRpbC5faXNGdW5jdGlvbih2YWwpIHx8IEtvbnZhLlV0aWwuX2lzRWxlbWVudCh2YWwpIHx8XG4gICAgICAgICAgICAgICAgICAgIChLb252YS5VdGlsLl9pc09iamVjdCh2YWwpIHx8IEtvbnZhLlV0aWwuX2hhc01ldGhvZHModmFsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdldHRlciA9IHRoaXNba2V5XTtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgYXR0ciB2YWx1ZSBzbyB0aGF0IHdlIGNhbiBleHRyYWN0IHRoZSBkZWZhdWx0IHZhbHVlIGZyb20gdGhlIGdldHRlclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyc1trZXldO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKHRoaXMpIDogbnVsbDtcbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIGF0dHIgdmFsdWVcbiAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsO1xuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0VmFsdWUgIT09IHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBvYmouYXR0cnNba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iai5jbGFzc05hbWUgPSB0aGlzLmdldENsYXNzTmFtZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbnZlcnQgTm9kZSBpbnRvIGEgSlNPTiBzdHJpbmcuICBSZXR1cm5zIGEgSlNPTiBzdHJpbmcuXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9fVxuICAgICAgICAgKi9cbiAgICAgICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvT2JqZWN0KCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IHBhcmVudCBjb250YWluZXJcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGFsbCBhbmNlc3Ryb3MgKHBhcmVudCB0aGVuIHBhcmVudCBvZiB0aGUgcGFyZW50LCBldGMpIG9mIHRoZSBub2RlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0b3JdIHNlbGVjdG9yIGZvciBzZWFyY2hcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbaW5jbHVkZVNlbGZdIHNob3cgd2UgdGhpbmsgdGhhdCBub2RlIGlzIGFuY2VzdHJvIGl0c2VsZj9cbiAgICAgICAgICogQHBhcmFtIHtLb252YS5Ob2RlfSBbc3RvcE5vZGVdIG9wdGlvbmFsIG5vZGUgd2hlcmUgd2UgbmVlZCB0byBzdG9wIHNlYXJjaGluZyAob25lIG9mIGFuY2VzdG9ycylcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fSBbYW5jZXN0b3JzXVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBnZXQgb25lIG9mIHRoZSBwYXJlbnQgZ3JvdXBcbiAgICAgICAgICogdmFyIHBhcmVudEdyb3VwcyA9IG5vZGUuZmluZEFuY2VzdG9ycygnR3JvdXAnKTtcbiAgICAgICAgICovXG4gICAgICAgIGZpbmRBbmNlc3RvcnM6IGZ1bmN0aW9uKHNlbGVjdG9yLCBpbmNsdWRlU2VsZiwgc3RvcE5vZGUpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBbXTtcblxuICAgICAgICAgICAgaWYgKGluY2x1ZGVTZWxmICYmIHRoaXMuX2lzTWF0Y2goc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2godGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIHdoaWxlKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuY2VzdG9yID09PSBzdG9wTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYW5jZXN0b3IuX2lzTWF0Y2goc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGFuY2VzdG9yIChwYXJlbnQgb3IgcGFyZW50IG9mIHRoZSBwYXJlbnQsIGV0Yykgb2YgdGhlIG5vZGUgdGhhdCBtYXRjaCBwYXNzZWQgc2VsZWN0b3JcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtzZWxlY3Rvcl0gc2VsZWN0b3IgZm9yIHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbmNsdWRlU2VsZl0gc2hvdyB3ZSB0aGluayB0aGF0IG5vZGUgaXMgYW5jZXN0cm8gaXRzZWxmP1xuICAgICAgICAgKiBAcGFyYW0ge0tvbnZhLk5vZGV9IFtzdG9wTm9kZV0gb3B0aW9uYWwgbm9kZSB3aGVyZSB3ZSBuZWVkIHRvIHN0b3Agc2VhcmNoaW5nIChvbmUgb2YgYW5jZXN0b3JzKVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX0gYW5jZXN0b3JcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gZ2V0IG9uZSBvZiB0aGUgcGFyZW50IGdyb3VwXG4gICAgICAgICAqIHZhciBncm91cCA9IG5vZGUuZmluZEFuY2VzdG9ycygnLm15Z3JvdXAnKTtcbiAgICAgICAgICovXG4gICAgICAgIGZpbmRBbmNlc3RvcjogZnVuY3Rpb24oc2VsZWN0b3IsIGluY2x1ZGVTZWxmLCBzdG9wTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZEFuY2VzdG9ycyhzZWxlY3RvciwgaW5jbHVkZVNlbGYsIHN0b3BOb2RlKVswXTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaXMgY3VycmVudCBub2RlIG1hdGNoIHBhc3NlZCBzZWxlY3Rvcj9cbiAgICAgICAgX2lzTWF0Y2g6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNlbGVjdG9yQXJyID0gc2VsZWN0b3IucmVwbGFjZSgvIC9nLCAnJykuc3BsaXQoJywnKSxcbiAgICAgICAgICAgICAgICBsZW4gPSBzZWxlY3RvckFyci5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbiwgc2VsO1xuXG4gICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICBzZWwgPSBzZWxlY3RvckFycltuXTtcbiAgICAgICAgICAgICAgICBpZiAoIUtvbnZhLlV0aWwuaXNWYWxpZFNlbGVjdG9yKHNlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdTZWxlY3RvciBcIicgKyBzZWwgKyAnXCIgaXMgaW52YWxpZC4gQWxsb3dlZCBzZWxlY3RvcnMgZXhhbXBsZXMgYXJlIFwiI2Zvb1wiLCBcIi5iYXJcIiBvciBcIkdyb3VwXCIuJyk7XG4gICAgICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwud2FybignSWYgeW91IGhhdmUgYSBjdXN0b20gc2hhcGUgd2l0aCBzdWNoIGNsYXNzTmFtZSwgcGxlYXNlIGNoYW5nZSBpdCB0byBzdGFydCB3aXRoIHVwcGVyIGxldHRlciBsaWtlIFwiVHJpYW5nbGVcIi4nKTtcbiAgICAgICAgICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdLb252YSBpcyBhd2Vzb21lLCByaWdodD8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWQgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICBpZihzZWwuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaWQoKSA9PT0gc2VsLnNsaWNlKDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBuYW1lIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgZWxzZSBpZihzZWwuY2hhckF0KDApID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzTmFtZShzZWwuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZ2V0KHNlbCkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBsYXllciBhbmNlc3RvclxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTGF5ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYXllcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQgPyBwYXJlbnQuZ2V0TGF5ZXIoKSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgc3RhZ2UgYW5jZXN0b3JcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlN0YWdlfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U3RhZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKFNUQUdFLCB0aGlzLl9nZXRTdGFnZSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRTdGFnZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICAgICAgICAgIGlmKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQuZ2V0U3RhZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmaXJlIGV2ZW50XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgZXZlbnQgdHlwZS4gIGNhbiBiZSBhIHJlZ3VsYXIgZXZlbnQsIGxpa2UgY2xpY2ssIG1vdXNlb3Zlciwgb3IgbW91c2VvdXQsIG9yIGl0IGNhbiBiZSBhIGN1c3RvbSBldmVudCwgbGlrZSBteUN1c3RvbUV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IFtldnRdIGV2ZW50IG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtidWJibGVdIHNldHRpbmcgdGhlIHZhbHVlIHRvIGZhbHNlLCBvciBsZWF2aW5nIGl0IHVuZGVmaW5lZCwgd2lsbCByZXN1bHQgaW4gdGhlIGV2ZW50XG4gICAgICAgICAqICBub3QgYnViYmxpbmcuICBTZXR0aW5nIHRoZSB2YWx1ZSB0byB0cnVlIHdpbGwgcmVzdWx0IGluIHRoZSBldmVudCBidWJibGluZy5cbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIG1hbnVhbGx5IGZpcmUgY2xpY2sgZXZlbnRcbiAgICAgICAgICogbm9kZS5maXJlKCdjbGljaycpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBmaXJlIGN1c3RvbSBldmVudFxuICAgICAgICAgKiBub2RlLmZpcmUoJ2ZvbycpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBmaXJlIGN1c3RvbSBldmVudCB3aXRoIGN1c3RvbSBldmVudCBvYmplY3RcbiAgICAgICAgICogbm9kZS5maXJlKCdmb28nLCB7XG4gICAgICAgICAqICAgYmFyOiAxMFxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gZmlyZSBjbGljayBldmVudCB0aGF0IGJ1YmJsZXNcbiAgICAgICAgICogbm9kZS5maXJlKCdjbGljaycsIG51bGwsIHRydWUpO1xuICAgICAgICAgKi9cbiAgICAgICAgZmlyZTogZnVuY3Rpb24oZXZlbnRUeXBlLCBldnQsIGJ1YmJsZSkge1xuICAgICAgICAgICAgZXZ0ID0gZXZ0IHx8IHt9O1xuICAgICAgICAgICAgZXZ0LnRhcmdldCA9IGV2dC50YXJnZXQgfHwgdGhpcztcbiAgICAgICAgICAgIC8vIGJ1YmJsZVxuICAgICAgICAgICAgaWYgKGJ1YmJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmVBbmRCdWJibGUoZXZlbnRUeXBlLCBldnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm8gYnViYmxlXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlKGV2ZW50VHlwZSwgZXZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGFic29sdXRlIHRyYW5zZm9ybSBvZiB0aGUgbm9kZSB3aGljaCB0YWtlcyBpbnRvXG4gICAgICAgICAqICBhY2NvdW50IGl0cyBhbmNlc3RvciB0cmFuc2Zvcm1zXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICAgICAqL1xuICAgICAgICBnZXRBYnNvbHV0ZVRyYW5zZm9ybTogZnVuY3Rpb24odG9wKSB7XG4gICAgICAgICAgICAvLyBpZiB1c2luZyBhbiBhcmd1bWVudCwgd2UgY2FuJ3QgY2FjaGUgdGhlIHJlc3VsdC5cbiAgICAgICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QWJzb2x1dGVUcmFuc2Zvcm0odG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIG5vIGFyZ3VtZW50LCB3ZSBjYW4gY2FjaGUgdGhlIHJlc3VsdFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKEFCU09MVVRFX1RSQU5TRk9STSwgdGhpcy5fZ2V0QWJzb2x1dGVUcmFuc2Zvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfZ2V0QWJzb2x1dGVUcmFuc2Zvcm06IGZ1bmN0aW9uKHRvcCkge1xuICAgICAgICAgICAgdmFyIGF0ID0gbmV3IEtvbnZhLlRyYW5zZm9ybSgpLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybXNFbmFibGVkLCB0cmFucztcblxuICAgICAgICAgICAgLy8gc3RhcnQgd2l0aCBzdGFnZSBhbmQgdHJhdmVyc2UgZG93bndhcmRzIHRvIHNlbGZcbiAgICAgICAgICAgIHRoaXMuX2VhY2hBbmNlc3RvclJldmVyc2UoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybXNFbmFibGVkID0gbm9kZS50cmFuc2Zvcm1zRW5hYmxlZCgpO1xuICAgICAgICAgICAgICAgIHRyYW5zID0gbm9kZS5nZXRUcmFuc2Zvcm0oKTtcblxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1zRW5hYmxlZCA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXQubXVsdGlwbHkodHJhbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0cmFuc2Zvcm1zRW5hYmxlZCA9PT0gJ3Bvc2l0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBhdC50cmFuc2xhdGUobm9kZS54KCksIG5vZGUueSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0b3ApO1xuICAgICAgICAgICAgcmV0dXJuIGF0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IHRyYW5zZm9ybSBvZiB0aGUgbm9kZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuVHJhbnNmb3JtfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZShUUkFOU0ZPUk0sIHRoaXMuX2dldFRyYW5zZm9ybSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRUcmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG0gPSBuZXcgS29udmEuVHJhbnNmb3JtKCksXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMuZ2V0WCgpLFxuICAgICAgICAgICAgICAgIHkgPSB0aGlzLmdldFkoKSxcbiAgICAgICAgICAgICAgICByb3RhdGlvbiA9IEtvbnZhLmdldEFuZ2xlKHRoaXMuZ2V0Um90YXRpb24oKSksXG4gICAgICAgICAgICAgICAgc2NhbGVYID0gdGhpcy5nZXRTY2FsZVgoKSxcbiAgICAgICAgICAgICAgICBzY2FsZVkgPSB0aGlzLmdldFNjYWxlWSgpLFxuICAgICAgICAgICAgICAgIHNrZXdYID0gdGhpcy5nZXRTa2V3WCgpLFxuICAgICAgICAgICAgICAgIHNrZXdZID0gdGhpcy5nZXRTa2V3WSgpLFxuICAgICAgICAgICAgICAgIG9mZnNldFggPSB0aGlzLmdldE9mZnNldFgoKSxcbiAgICAgICAgICAgICAgICBvZmZzZXRZID0gdGhpcy5nZXRPZmZzZXRZKCk7XG5cbiAgICAgICAgICAgIGlmKHggIT09IDAgfHwgeSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIG0udHJhbnNsYXRlKHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYocm90YXRpb24gIT09IDApIHtcbiAgICAgICAgICAgICAgICBtLnJvdGF0ZShyb3RhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihza2V3WCAhPT0gMCB8fCBza2V3WSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIG0uc2tldyhza2V3WCwgc2tld1kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIG0uc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYob2Zmc2V0WCAhPT0gMCB8fCBvZmZzZXRZICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgbS50cmFuc2xhdGUoLTEgKiBvZmZzZXRYLCAtMSAqIG9mZnNldFkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNsb25lIG5vZGUuICBSZXR1cm5zIGEgbmV3IE5vZGUgaW5zdGFuY2Ugd2l0aCBpZGVudGljYWwgYXR0cmlidXRlcy4gIFlvdSBjYW4gYWxzbyBvdmVycmlkZVxuICAgICAgICAgKiAgdGhlIG5vZGUgcHJvcGVydGllcyB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLCBlbmFibGluZyB5b3UgdG8gdXNlIGFuIGV4aXN0aW5nIG5vZGUgYXMgYSB0ZW1wbGF0ZVxuICAgICAgICAgKiAgZm9yIGFub3RoZXIgbm9kZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIG92ZXJyaWRlIGF0dHJzXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBzaW1wbGUgY2xvbmVcbiAgICAgICAgICogdmFyIGNsb25lID0gbm9kZS5jbG9uZSgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBjbG9uZSBhIG5vZGUgYW5kIG92ZXJyaWRlIHRoZSB4IHBvc2l0aW9uXG4gICAgICAgICAqIHZhciBjbG9uZSA9IHJlY3QuY2xvbmUoe1xuICAgICAgICAgKiAgIHg6IDVcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICBjbG9uZTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAvLyBpbnN0YW50aWF0ZSBuZXcgbm9kZVxuICAgICAgICAgICAgdmFyIGF0dHJzID0gS29udmEuVXRpbC5jbG9uZU9iamVjdCh0aGlzLmF0dHJzKSxcbiAgICAgICAgICAgICAgICBrZXksIGFsbExpc3RlbmVycywgbGVuLCBuLCBsaXN0ZW5lcjtcbiAgICAgICAgICAgIC8vIGZpbHRlciBibGFjayBhdHRyc1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBDTE9ORV9CTEFDS19MSVNUKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrQXR0ciA9IENMT05FX0JMQUNLX0xJU1RbaV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJzW2Jsb2NrQXR0cl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhcHBseSBhdHRyIG92ZXJyaWRlc1xuICAgICAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGF0dHJzKTtcbiAgICAgICAgICAgIC8vIGNvcHkgb3ZlciBsaXN0ZW5lcnNcbiAgICAgICAgICAgIGZvcihrZXkgaW4gdGhpcy5ldmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGFsbExpc3RlbmVycyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnNba2V5XTtcbiAgICAgICAgICAgICAgICBsZW4gPSBhbGxMaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvcihuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gYWxsTGlzdGVuZXJzW25dO1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiBkb24ndCBpbmNsdWRlIGtvbnZhIG5hbWVzcGFjZWQgbGlzdGVuZXJzIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgICogIHRoZXNlIGFyZSBnZW5lcmF0ZWQgYnkgdGhlIGNvbnN0cnVjdG9yc1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYobGlzdGVuZXIubmFtZS5pbmRleE9mKEtPTlZBKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGxpc3RlbmVycyBhcnJheSBkb2Vzbid0IGV4aXN0LCB0aGVuIGNyZWF0ZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW5vZGUuZXZlbnRMaXN0ZW5lcnNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZXZlbnRMaXN0ZW5lcnNba2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ldmVudExpc3RlbmVyc1trZXldLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgY29tcG9zaXRlIGRhdGEgVVJMLiBJZiBNSU1FIHR5cGUgaXMgbm90XG4gICAgICAgICAqIHNwZWNpZmllZCwgdGhlbiBcImltYWdlL3BuZ1wiIHdpbGwgcmVzdWx0LiBGb3IgXCJpbWFnZS9qcGVnXCIsIHNwZWNpZnkgYSBxdWFsaXR5XG4gICAgICAgICAqIGxldmVsIGFzIHF1YWxpdHkgKHJhbmdlIDAuMCAtIDEuMClcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5taW1lVHlwZV0gY2FuIGJlIFwiaW1hZ2UvcG5nXCIgb3IgXCJpbWFnZS9qcGVnXCIuXG4gICAgICAgICAqICBcImltYWdlL3BuZ1wiIGlzIHRoZSBkZWZhdWx0XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdIHggcG9zaXRpb24gb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV0geSBwb3NpdGlvbiBvZiBjYW52YXMgc2VjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF0gd2lkdGggb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XSBoZWlnaHQgb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucXVhbGl0eV0ganBlZyBxdWFsaXR5LiAgSWYgdXNpbmcgYW4gXCJpbWFnZS9qcGVnXCIgbWltZVR5cGUsXG4gICAgICAgICAqICB5b3UgY2FuIHNwZWNpZnkgdGhlIHF1YWxpdHkgZnJvbSAwIHRvIDEsIHdoZXJlIDAgaXMgdmVyeSBwb29yIHF1YWxpdHkgYW5kIDFcbiAgICAgICAgICogIGlzIHZlcnkgaGlnaCBxdWFsaXR5XG4gICAgICAgICAqIEBwYXJlbXQge051bWJlcn0gW2NvbmZpZy5waXhlbFJhdGlvXSBwaXhlbFJhdGlvIG9mIG91cHV0IGltYWdlIHVybC4gRGVmYXVsdCBpcyAxXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0b0RhdGFVUkw6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gICAgICAgICAgICB2YXIgbWltZVR5cGUgPSBjb25maWcubWltZVR5cGUgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBxdWFsaXR5ID0gY29uZmlnLnF1YWxpdHkgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKSxcbiAgICAgICAgICAgICAgICB4ID0gY29uZmlnLnggfHwgMCxcbiAgICAgICAgICAgICAgICB5ID0gY29uZmlnLnkgfHwgMCxcbiAgICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gY29uZmlnLnBpeGVsUmF0aW8gfHwgMSxcbiAgICAgICAgICAgICAgICBjYW52YXMgPSBuZXcgS29udmEuU2NlbmVDYW52YXMoe1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogY29uZmlnLndpZHRoIHx8IHRoaXMuZ2V0V2lkdGgoKSB8fCAoc3RhZ2UgPyBzdGFnZS5nZXRXaWR0aCgpIDogMCksXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogY29uZmlnLmhlaWdodCB8fCB0aGlzLmdldEhlaWdodCgpIHx8IChzdGFnZSA/IHN0YWdlLmdldEhlaWdodCgpIDogMCksXG4gICAgICAgICAgICAgICAgICAgIHBpeGVsUmF0aW86IHBpeGVsUmF0aW9cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoKTtcblxuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICAgICAgICAgIGlmKHggfHwgeSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKC0xICogeCwgLTEgKiB5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kcmF3U2NlbmUoY2FudmFzKTtcbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTChtaW1lVHlwZSwgcXVhbGl0eSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjb252ZXJ0cyBub2RlIGludG8gYW4gaW1hZ2UuICBTaW5jZSB0aGUgdG9JbWFnZVxuICAgICAgICAgKiAgbWV0aG9kIGlzIGFzeW5jaHJvbm91cywgYSBjYWxsYmFjayBpcyByZXF1aXJlZC4gIHRvSW1hZ2UgaXMgbW9zdCBjb21tb25seSB1c2VkXG4gICAgICAgICAqICB0byBjYWNoZSBjb21wbGV4IGRyYXdpbmdzIGFzIGFuIGltYWdlIHNvIHRoYXQgdGhleSBkb24ndCBoYXZlIHRvIGNvbnN0YW50bHkgYmUgcmVkcmF3blxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmZpZy5jYWxsYmFjayBmdW5jdGlvbiBleGVjdXRlZCB3aGVuIHRoZSBjb21wb3NpdGUgaGFzIGNvbXBsZXRlZFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5taW1lVHlwZV0gY2FuIGJlIFwiaW1hZ2UvcG5nXCIgb3IgXCJpbWFnZS9qcGVnXCIuXG4gICAgICAgICAqICBcImltYWdlL3BuZ1wiIGlzIHRoZSBkZWZhdWx0XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdIHggcG9zaXRpb24gb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV0geSBwb3NpdGlvbiBvZiBjYW52YXMgc2VjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF0gd2lkdGggb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XSBoZWlnaHQgb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucXVhbGl0eV0ganBlZyBxdWFsaXR5LiAgSWYgdXNpbmcgYW4gXCJpbWFnZS9qcGVnXCIgbWltZVR5cGUsXG4gICAgICAgICAqICB5b3UgY2FuIHNwZWNpZnkgdGhlIHF1YWxpdHkgZnJvbSAwIHRvIDEsIHdoZXJlIDAgaXMgdmVyeSBwb29yIHF1YWxpdHkgYW5kIDFcbiAgICAgICAgICogIGlzIHZlcnkgaGlnaCBxdWFsaXR5XG4gICAgICAgICAqIEBwYXJlbXQge051bWJlcn0gW2NvbmZpZy5waXhlbFJhdGlvXSBwaXhlbFJhdGlvIG9mIG91cHV0IGltYWdlLiAgRGVmYXVsdCBpcyAxLlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiB2YXIgaW1hZ2UgPSBub2RlLnRvSW1hZ2Uoe1xuICAgICAgICAgKiAgIGNhbGxiYWNrOiBmdW5jdGlvbihpbWcpIHtcbiAgICAgICAgICogICAgIC8vIGRvIHN0dWZmIHdpdGggaW1nXG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHRvSW1hZ2U6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKCFjb25maWcgfHwgIWNvbmZpZy5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRocm93ICdjYWxsYmFjayByZXF1aXJlZCBmb3IgdG9JbWFnZSBtZXRob2QgY29uZmlnIGFyZ3VtZW50JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEtvbnZhLlV0aWwuX2dldEltYWdlKHRoaXMudG9EYXRhVVJMKGNvbmZpZyksIGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFjayhpbWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFNpemU6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0V2lkdGgoc2l6ZS53aWR0aCk7XG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChzaXplLmhlaWdodCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLmdldFdpZHRoKCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmdldEhlaWdodCgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRycy53aWR0aCB8fCAwO1xuICAgICAgICB9LFxuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cnMuaGVpZ2h0IHx8IDA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgY2xhc3MgbmFtZSwgd2hpY2ggbWF5IHJldHVybiBTdGFnZSwgTGF5ZXIsIEdyb3VwLCBvciBzaGFwZSBjbGFzcyBuYW1lcyBsaWtlIFJlY3QsIENpcmNsZSwgVGV4dCwgZXRjLlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsYXNzTmFtZSB8fCB0aGlzLm5vZGVUeXBlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IHRoZSBub2RlIHR5cGUsIHdoaWNoIG1heSByZXR1cm4gU3RhZ2UsIExheWVyLCBHcm91cCwgb3IgTm9kZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlVHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0RHJhZ0Rpc3RhbmNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGNvbXBhcmUgd2l0aCB1bmRlZmluZWQgYmVjYXVzZSB3ZSBuZWVkIHRvIHRyYWNrIDAgdmFsdWVcbiAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzLmRyYWdEaXN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cnMuZHJhZ0Rpc3RhbmNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXREcmFnRGlzdGFuY2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEtvbnZhLmRyYWdEaXN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2dldDogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsYXNzTmFtZSA9PT0gc2VsZWN0b3IgfHwgdGhpcy5ub2RlVHlwZSA9PT0gc2VsZWN0b3IgPyBbdGhpc10gOiBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgX29mZjogZnVuY3Rpb24odHlwZSwgbmFtZSkge1xuICAgICAgICAgICAgdmFyIGV2dExpc3RlbmVycyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnNbdHlwZV0sXG4gICAgICAgICAgICAgICAgaSwgZXZ0TmFtZTtcblxuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgZXZ0TGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZXZ0TmFtZSA9IGV2dExpc3RlbmVyc1tpXS5uYW1lO1xuICAgICAgICAgICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgdHdvIGNvbmRpdGlvbnMgbXVzdCBiZSB0cnVlIGluIG9yZGVyIHRvIHJlbW92ZSBhIGhhbmRsZXI6XG4gICAgICAgICAgICAgICAgLy8gMSkgdGhlIGN1cnJlbnQgZXZlbnQgbmFtZSBjYW5ub3QgYmUga29udmEgdW5sZXNzIHRoZSBldmVudCBuYW1lIGlzIGtvbnZhXG4gICAgICAgICAgICAgICAgLy8gICAgdGhpcyBlbmFibGVzIGRldmVsb3BlcnMgdG8gZm9yY2UgcmVtb3ZlIGEga29udmEgc3BlY2lmaWMgbGlzdGVuZXIgZm9yIHdoYXRldmVyIHJlYXNvblxuICAgICAgICAgICAgICAgIC8vIDIpIGFuIGV2ZW50IG5hbWUgaXMgbm90IHNwZWNpZmllZCwgb3IgaWYgb25lIGlzIHNwZWNpZmllZCwgaXQgbWF0Y2hlcyB0aGUgY3VycmVudCBldmVudCBuYW1lXG4gICAgICAgICAgICAgICAgaWYoKGV2dE5hbWUgIT09ICdrb252YScgfHwgbmFtZSA9PT0gJ2tvbnZhJykgJiYgKCFuYW1lIHx8IGV2dE5hbWUgPT09IG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2dExpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGV2dExpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50TGlzdGVuZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2ZpcmVDaGFuZ2VFdmVudDogZnVuY3Rpb24oYXR0ciwgb2xkVmFsLCBuZXdWYWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoYXR0ciArIENIQU5HRSwge1xuICAgICAgICAgICAgICAgIG9sZFZhbDogb2xkVmFsLFxuICAgICAgICAgICAgICAgIG5ld1ZhbDogbmV3VmFsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0SWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICB2YXIgb2xkSWQgPSB0aGlzLmdldElkKCk7XG5cbiAgICAgICAgICAgIEtvbnZhLl9yZW1vdmVJZChvbGRJZCk7XG4gICAgICAgICAgICBLb252YS5fYWRkSWQodGhpcywgaWQpO1xuICAgICAgICAgICAgdGhpcy5fc2V0QXR0cihJRCwgaWQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldE5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBvbGROYW1lcyA9ICh0aGlzLmdldE5hbWUoKSB8fCAnJykuc3BsaXQoL1xccy9nKTtcbiAgICAgICAgICAgIHZhciBuZXdOYW1lcyA9IChuYW1lIHx8ICcnKS5zcGxpdCgvXFxzL2cpO1xuICAgICAgICAgICAgdmFyIHN1Ym5hbWUsIGk7XG4gICAgICAgICAgICAvLyByZW1vdmUgYWxsIHN1Ym5hbWVzXG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBvbGROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHN1Ym5hbWUgPSBvbGROYW1lc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoKG5ld05hbWVzLmluZGV4T2Yoc3VibmFtZSkpID09PSAtMSAmJiBzdWJuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIEtvbnZhLl9yZW1vdmVOYW1lKHN1Ym5hbWUsIHRoaXMuX2lkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFkZCBuZXcgbmFtZXNcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IG5ld05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3VibmFtZSA9IG5ld05hbWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICgob2xkTmFtZXMuaW5kZXhPZihzdWJuYW1lKSA9PT0gLTEpICYmIHN1Ym5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgS29udmEuX2FkZE5hbWUodGhpcywgc3VibmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9zZXRBdHRyKE5BTUUsIG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIG5hbWluZyBtZXRob2RzXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhZGQgbmFtZSB0byBub2RlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBub2RlLm5hbWUoJ3JlZCcpO1xuICAgICAgICAgKiBub2RlLmFkZE5hbWUoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAqIG5vZGUubmFtZSgpOyAvLyByZXR1cm4gJ3JlZCBzZWxlY3RlZCdcbiAgICAgICAgICovXG4gICAgICAgIGFkZE5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNOYW1lKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZE5hbWUgPSB0aGlzLm5hbWUoKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3TmFtZSA9IG9sZE5hbWUgPyAob2xkTmFtZSArICcgJyArIG5hbWUpIDogbmFtZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE5hbWUobmV3TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoZWNrIGlzIG5vZGUgaGFzIG5hbWVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIG5vZGUubmFtZSgncmVkJyk7XG4gICAgICAgICAqIG5vZGUuaGFzTmFtZSgncmVkJyk7ICAgLy8gcmV0dXJuIHRydWVcbiAgICAgICAgICogbm9kZS5oYXNOYW1lKCdzZWxlY3RlZCcpOyAvLyByZXR1cm4gZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGhhc05hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBuYW1lcyA9ICh0aGlzLm5hbWUoKSB8fCAnJykuc3BsaXQoL1xccy9nKTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lcy5pbmRleE9mKG5hbWUpICE9PSAtMTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlbW92ZSBuYW1lIGZyb20gbm9kZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogbm9kZS5uYW1lKCdyZWQgc2VsZWN0ZWQnKTtcbiAgICAgICAgICogbm9kZS5yZW1vdmVOYW1lKCdzZWxlY3RlZCcpO1xuICAgICAgICAgKiBub2RlLmhhc05hbWUoJ3NlbGVjdGVkJyk7IC8vIHJldHVybiBmYWxzZVxuICAgICAgICAgKiBub2RlLm5hbWUoKTsgLy8gcmV0dXJuICdyZWQnXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVOYW1lOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICB2YXIgbmFtZXMgPSAodGhpcy5uYW1lKCkgfHwgJycpLnNwbGl0KC9cXHMvZyk7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBuYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIG5hbWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXROYW1lKG5hbWVzLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCBhdHRyXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBub2RlLnNldEF0dHIoJ3gnLCA1KTtcbiAgICAgICAgICovXG4gICAgICAgIHNldEF0dHI6IGZ1bmN0aW9uKGF0dHIsIHZhbCkge1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IFNFVCArIEtvbnZhLlV0aWwuX2NhcGl0YWxpemUoYXR0ciksXG4gICAgICAgICAgICAgICAgZnVuYyA9IHRoaXNbbWV0aG9kXTtcblxuICAgICAgICAgICAgaWYoS29udmEuVXRpbC5faXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICAgICAgICAgIGZ1bmMuY2FsbCh0aGlzLCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHNldCBkaXJlY3RseVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0QXR0cihhdHRyLCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIF9zZXRBdHRyOiBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgICAgICAgICAgdmFyIG9sZFZhbDtcbiAgICAgICAgICAgIGlmKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb2xkVmFsID0gdGhpcy5hdHRyc1trZXldO1xuICAgICAgICAgICAgICAgIGlmIChvbGRWYWwgPT09IHZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYXR0cnNba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlQ2hhbmdlRXZlbnQoa2V5LCBvbGRWYWwsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9zZXRDb21wb25lbnRBdHRyOiBmdW5jdGlvbihrZXksIGNvbXBvbmVudCwgdmFsKSB7XG4gICAgICAgICAgICB2YXIgb2xkVmFsO1xuICAgICAgICAgICAgaWYodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvbGRWYWwgPSB0aGlzLmF0dHJzW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoIW9sZFZhbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgdmFsdWUgdG8gZGVmYXVsdCB2YWx1ZSB1c2luZyBnZXRBdHRyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cnNba2V5XSA9IHRoaXMuZ2V0QXR0cihrZXkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuYXR0cnNba2V5XVtjb21wb25lbnRdID0gdmFsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmVDaGFuZ2VFdmVudChrZXksIG9sZFZhbCwgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2ZpcmVBbmRCdWJibGU6IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZXZ0LCBjb21wYXJlU2hhcGUpIHtcbiAgICAgICAgICAgIHZhciBva2F5VG9SdW4gPSB0cnVlO1xuXG4gICAgICAgICAgICBpZihldnQgJiYgdGhpcy5ub2RlVHlwZSA9PT0gU0hBUEUpIHtcbiAgICAgICAgICAgICAgICBldnQudGFyZ2V0ID0gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZXZlbnRUeXBlID09PSBNT1VTRUVOVEVSICYmIGNvbXBhcmVTaGFwZSAmJiAodGhpcy5faWQgPT09IGNvbXBhcmVTaGFwZS5faWQgfHwgKHRoaXMuaXNBbmNlc3Rvck9mICYmIHRoaXMuaXNBbmNlc3Rvck9mKGNvbXBhcmVTaGFwZSkpKSkge1xuICAgICAgICAgICAgICAgIG9rYXlUb1J1biA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihldmVudFR5cGUgPT09IE1PVVNFTEVBVkUgJiYgY29tcGFyZVNoYXBlICYmICh0aGlzLl9pZCA9PT0gY29tcGFyZVNoYXBlLl9pZCB8fCAodGhpcy5pc0FuY2VzdG9yT2YgJiYgdGhpcy5pc0FuY2VzdG9yT2YoY29tcGFyZVNoYXBlKSkpKSB7XG4gICAgICAgICAgICAgICAgb2theVRvUnVuID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihva2F5VG9SdW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlKGV2ZW50VHlwZSwgZXZ0KTtcblxuICAgICAgICAgICAgICAgIC8vIHNpbXVsYXRlIGV2ZW50IGJ1YmJsaW5nXG4gICAgICAgICAgICAgICAgdmFyIHN0b3BCdWJibGUgPSAoZXZlbnRUeXBlID09PSBNT1VTRUVOVEVSIHx8IGV2ZW50VHlwZSA9PT0gTU9VU0VMRUFWRSkgJiYgKChjb21wYXJlU2hhcGUgJiYgY29tcGFyZVNoYXBlLmlzQW5jZXN0b3JPZiAmJiBjb21wYXJlU2hhcGUuaXNBbmNlc3Rvck9mKHRoaXMpKSB8fCAhIShjb21wYXJlU2hhcGUgJiYgY29tcGFyZVNoYXBlLmlzQW5jZXN0b3JPZikpO1xuICAgICAgICAgICAgICAgIGlmKChldnQgJiYgIWV2dC5jYW5jZWxCdWJibGUgfHwgIWV2dCkgJiYgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaXNMaXN0ZW5pbmcoKSAmJiAoIXN0b3BCdWJibGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGNvbXBhcmVTaGFwZSAmJiBjb21wYXJlU2hhcGUucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9maXJlQW5kQnViYmxlLmNhbGwodGhpcy5wYXJlbnQsIGV2ZW50VHlwZSwgZXZ0LCBjb21wYXJlU2hhcGUucGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmVBbmRCdWJibGUuY2FsbCh0aGlzLnBhcmVudCwgZXZlbnRUeXBlLCBldnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfZmlyZTogZnVuY3Rpb24oZXZlbnRUeXBlLCBldnQpIHtcbiAgICAgICAgICAgIHZhciBldmVudHMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50VHlwZV0sXG4gICAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgICAgZXZ0ID0gS29udmEuVXRpbC5jbG9uZU9iamVjdChldnQgfHwge30pO1xuICAgICAgICAgICAgZXZ0LmN1cnJlbnRUYXJnZXQgPSB0aGlzO1xuICAgICAgICAgICAgZXZ0LnR5cGUgPSBldmVudFR5cGU7XG5cbiAgICAgICAgICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzW2ldLmhhbmRsZXIuY2FsbCh0aGlzLCBldnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRyYXcgYm90aCBzY2VuZSBhbmQgaGl0IGdyYXBocy4gIElmIHRoZSBub2RlIGJlaW5nIGRyYXduIGlzIHRoZSBzdGFnZSwgYWxsIG9mIHRoZSBsYXllcnMgd2lsbCBiZSBjbGVhcmVkIGFuZCByZWRyYXduXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdTY2VuZSgpO1xuICAgICAgICAgICAgdGhpcy5kcmF3SGl0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIG5vZGUgd2l0aCBKU09OIHN0cmluZyBvciBhbiBPYmplY3QuICBEZS1zZXJpYWxpenRpb24gZG9lcyBub3QgZ2VuZXJhdGUgY3VzdG9tXG4gICAgICogIHNoYXBlIGRyYXdpbmcgZnVuY3Rpb25zLCBpbWFnZXMsIG9yIGV2ZW50IGhhbmRsZXJzICh0aGlzIHdvdWxkIG1ha2UgdGhlXG4gICAgICogIHNlcmlhbGl6ZWQgb2JqZWN0IGh1Z2UpLiAgSWYgeW91ciBhcHAgdXNlcyBjdXN0b20gc2hhcGVzLCBpbWFnZXMsIGFuZFxuICAgICAqICBldmVudCBoYW5kbGVycyAoaXQgcHJvYmFibHkgZG9lcyksIHRoZW4geW91IG5lZWQgdG8gc2VsZWN0IHRoZSBhcHByb3ByaWF0ZVxuICAgICAqICBzaGFwZXMgYWZ0ZXIgbG9hZGluZyB0aGUgc3RhZ2UgYW5kIHNldCB0aGVzZSBwcm9wZXJ0aWVzIHZpYSBvbigpLCBzZXREcmF3RnVuYygpLFxuICAgICAqICBhbmQgc2V0SW1hZ2UoKSBtZXRob2RzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBqc29uIHN0cmluZyBvciBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IFtjb250YWluZXJdIG9wdGlvbmFsIGNvbnRhaW5lciBkb20gZWxlbWVudCB1c2VkIG9ubHkgaWYgeW91J3JlXG4gICAgICogIGNyZWF0aW5nIGEgc3RhZ2Ugbm9kZVxuICAgICAqL1xuICAgIEtvbnZhLk5vZGUuY3JlYXRlID0gZnVuY3Rpb24oZGF0YSwgY29udGFpbmVyKSB7XG4gICAgICAgIGlmIChLb252YS5VdGlsLl9pc1N0cmluZyhkYXRhKSkge1xuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZU5vZGUoZGF0YSwgY29udGFpbmVyKTtcbiAgICB9O1xuICAgIEtvbnZhLk5vZGUuX2NyZWF0ZU5vZGUgPSBmdW5jdGlvbihvYmosIGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gS29udmEuTm9kZS5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lLmNhbGwob2JqKSxcbiAgICAgICAgICAgIGNoaWxkcmVuID0gb2JqLmNoaWxkcmVuLFxuICAgICAgICAgICAgbm8sIGxlbiwgbjtcblxuICAgICAgICAvLyBpZiBjb250YWluZXIgd2FzIHBhc3NlZCBpbiwgYWRkIGl0IHRvIGF0dHJzXG4gICAgICAgIGlmKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgb2JqLmF0dHJzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vID0gbmV3IEtvbnZhW2NsYXNzTmFtZV0ob2JqLmF0dHJzKTtcbiAgICAgICAgaWYoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGZvcihuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgbm8uYWRkKHRoaXMuX2NyZWF0ZU5vZGUoY2hpbGRyZW5bbl0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBubztcbiAgICB9O1xuXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT0gYWRkIGdldHRlcnMgc2V0dGVycyA9PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAncG9zaXRpb24nKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IG5vZGUgcG9zaXRpb24gcmVsYXRpdmUgdG8gcGFyZW50XG4gICAgICogQG5hbWUgcG9zaXRpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgcG9zaXRpb25cbiAgICAgKiB2YXIgcG9zaXRpb24gPSBub2RlLnBvc2l0aW9uKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgcG9zaXRpb25cbiAgICAgKiBub2RlLnBvc2l0aW9uKHtcbiAgICAgKiAgIHg6IDVcbiAgICAgKiAgIHk6IDEwXG4gICAgICogfSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAneCcsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCB4IHBvc2l0aW9uXG4gICAgICogQG5hbWUgeFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgeFxuICAgICAqIHZhciB4ID0gbm9kZS54KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgeFxuICAgICAqIG5vZGUueCg1KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICd5JywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHkgcG9zaXRpb25cbiAgICAgKiBAbmFtZSB5XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgeVxuICAgICAqIHZhciB5ID0gbm9kZS55KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgeVxuICAgICAqIG5vZGUueSg1KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdvcGFjaXR5JywgMSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IG9wYWNpdHkuICBPcGFjaXR5IHZhbHVlcyByYW5nZSBmcm9tIDAgdG8gMS5cbiAgICAgKiAgQSBub2RlIHdpdGggYW4gb3BhY2l0eSBvZiAwIGlzIGZ1bGx5IHRyYW5zcGFyZW50LCBhbmQgYSBub2RlXG4gICAgICogIHdpdGggYW4gb3BhY2l0eSBvZiAxIGlzIGZ1bGx5IG9wYXF1ZVxuICAgICAqIEBuYW1lIG9wYWNpdHlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wYWNpdHlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IG9wYWNpdHlcbiAgICAgKiB2YXIgb3BhY2l0eSA9IG5vZGUub3BhY2l0eSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IG9wYWNpdHlcbiAgICAgKiBub2RlLm9wYWNpdHkoMC41KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyKEtvbnZhLk5vZGUsICduYW1lJyk7XG4gICAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICduYW1lJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IG5hbWVcbiAgICAgKiBAbmFtZSBuYW1lXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBuYW1lXG4gICAgICogdmFyIG5hbWUgPSBub2RlLm5hbWUoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBuYW1lXG4gICAgICogbm9kZS5uYW1lKCdmb28nKTtcbiAgICAgKlxuICAgICAqIC8vIGFsc28gbm9kZSBtYXkgaGF2ZSBtdWx0aXBsZSBuYW1lcyAoYXMgY3NzIGNsYXNzZXMpXG4gICAgICogbm9kZS5uYW1lKCdmb28gYmFyJyk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlcihLb252YS5Ob2RlLCAnaWQnKTtcbiAgICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2lkJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGlkLiBJZCBpcyBnbG9iYWwgZm9yIHdob2xlIHBhZ2UuXG4gICAgICogQG5hbWUgaWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBpZFxuICAgICAqIHZhciBuYW1lID0gbm9kZS5pZCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGlkXG4gICAgICogbm9kZS5pZCgnZm9vJyk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAncm90YXRpb24nLCAwKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBuYW1lIHJvdGF0aW9uXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByb3RhdGlvblxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIHZhciByb3RhdGlvbiA9IG5vZGUucm90YXRpb24oKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogbm9kZS5yb3RhdGlvbig0NSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3NjYWxlJywgWyd4JywgJ3knXSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHNjYWxlXG4gICAgICogQG5hbWUgc2NhbGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUueFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZS55XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc2NhbGVcbiAgICAgKiB2YXIgc2NhbGUgPSBub2RlLnNjYWxlKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc2NhbGVcbiAgICAgKiBzaGFwZS5zY2FsZSh7XG4gICAgICogICB4OiAyXG4gICAgICogICB5OiAzXG4gICAgICogfSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnc2NhbGVYJywgMSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHNjYWxlIHhcbiAgICAgKiBAbmFtZSBzY2FsZVhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHNjYWxlIHhcbiAgICAgKiB2YXIgc2NhbGVYID0gbm9kZS5zY2FsZVgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzY2FsZSB4XG4gICAgICogbm9kZS5zY2FsZVgoMik7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnc2NhbGVZJywgMSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHNjYWxlIHlcbiAgICAgKiBAbmFtZSBzY2FsZVlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHNjYWxlIHlcbiAgICAgKiB2YXIgc2NhbGVZID0gbm9kZS5zY2FsZVkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzY2FsZSB5XG4gICAgICogbm9kZS5zY2FsZVkoMik7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3NrZXcnLCBbJ3gnLCAneSddKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgc2tld1xuICAgICAqIEBuYW1lIHNrZXdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2tld1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBza2V3LnhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2tldy55XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc2tld1xuICAgICAqIHZhciBza2V3ID0gbm9kZS5za2V3KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc2tld1xuICAgICAqIG5vZGUuc2tldyh7XG4gICAgICogICB4OiAyMFxuICAgICAqICAgeTogMTBcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdza2V3WCcsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBza2V3IHhcbiAgICAgKiBAbmFtZSBza2V3WFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc2tldyB4XG4gICAgICogdmFyIHNrZXdYID0gbm9kZS5za2V3WCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNrZXcgeFxuICAgICAqIG5vZGUuc2tld1goMyk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnc2tld1knLCAwKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgc2tldyB5XG4gICAgICogQG5hbWUgc2tld1lcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHNrZXcgeVxuICAgICAqIHZhciBza2V3WSA9IG5vZGUuc2tld1koKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBza2V3IHlcbiAgICAgKiBub2RlLnNrZXdZKDMpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdvZmZzZXQnLCBbJ3gnLCAneSddKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgb2Zmc2V0LiAgT2Zmc2V0cyB0aGUgZGVmYXVsdCBwb3NpdGlvbiBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9mZnNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQueFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQueVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgb2Zmc2V0XG4gICAgICogdmFyIG9mZnNldCA9IG5vZGUub2Zmc2V0KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgb2Zmc2V0XG4gICAgICogbm9kZS5vZmZzZXQoe1xuICAgICAqICAgeDogMjBcbiAgICAgKiAgIHk6IDEwXG4gICAgICogfSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnb2Zmc2V0WCcsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBvZmZzZXQgeFxuICAgICAqIEBuYW1lIG9mZnNldFhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IG9mZnNldCB4XG4gICAgICogdmFyIG9mZnNldFggPSBub2RlLm9mZnNldFgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBvZmZzZXQgeFxuICAgICAqIG5vZGUub2Zmc2V0WCgzKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdvZmZzZXRZJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IG9mZnNldCB5XG4gICAgICogQG5hbWUgb2Zmc2V0WVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgb2Zmc2V0IHlcbiAgICAgKiB2YXIgb2Zmc2V0WSA9IG5vZGUub2Zmc2V0WSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IG9mZnNldCB5XG4gICAgICogbm9kZS5vZmZzZXRZKDMpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRTZXR0ZXIoS29udmEuTm9kZSwgJ2RyYWdEaXN0YW5jZScpO1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZHJhZ0Rpc3RhbmNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGRyYWcgZGlzdGFuY2VcbiAgICAgKiBAbmFtZSBkcmFnRGlzdGFuY2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBkcmFnIGRpc3RhbmNlXG4gICAgICogdmFyIGRyYWdEaXN0YW5jZSA9IG5vZGUuZHJhZ0Rpc3RhbmNlKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZGlzdGFuY2VcbiAgICAgKiAvLyBub2RlIHN0YXJ0cyBkcmFnZ2luZyBvbmx5IGlmIHBvaW50ZXIgbW92ZWQgbW9yZSB0aGVuIDMgcGl4ZWxzXG4gICAgICogbm9kZS5kcmFnRGlzdGFuY2UoMyk7XG4gICAgICogLy8gb3Igc2V0IGdsb2JhbGx5XG4gICAgICogS29udmEuZHJhZ0Rpc3RhbmNlID0gMztcbiAgICAgKi9cblxuXG4gICAgS29udmEuRmFjdG9yeS5hZGRTZXR0ZXIoS29udmEuTm9kZSwgJ3dpZHRoJywgMCk7XG4gICAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICd3aWR0aCcpO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgd2lkdGhcbiAgICAgKiBAbmFtZSB3aWR0aFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHdpZHRoXG4gICAgICogdmFyIHdpZHRoID0gbm9kZS53aWR0aCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHdpZHRoXG4gICAgICogbm9kZS53aWR0aCgxMDApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRTZXR0ZXIoS29udmEuTm9kZSwgJ2hlaWdodCcsIDApO1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnaGVpZ2h0Jyk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBoZWlnaHRcbiAgICAgKiBAbmFtZSBoZWlnaHRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgaGVpZ2h0XG4gICAgICogdmFyIGhlaWdodCA9IG5vZGUuaGVpZ2h0KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgaGVpZ2h0XG4gICAgICogbm9kZS5oZWlnaHQoMTAwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdsaXN0ZW5pbmcnLCAnaW5oZXJpdCcpO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgbGlzdGVuaWcgYXR0ci4gIElmIHlvdSBuZWVkIHRvIGRldGVybWluZSBpZiBhIG5vZGUgaXMgbGlzdGVuaW5nIG9yIG5vdFxuICAgICAqICAgYnkgdGFraW5nIGludG8gYWNjb3VudCBpdHMgcGFyZW50cywgdXNlIHRoZSBpc0xpc3RlbmluZygpIG1ldGhvZFxuICAgICAqIEBuYW1lIGxpc3RlbmluZ1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBsaXN0ZW5pbmcgQ2FuIGJlIFwiaW5oZXJpdFwiLCB0cnVlLCBvciBmYWxzZS4gIFRoZSBkZWZhdWx0IGlzIFwiaW5oZXJpdFwiLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufFN0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBsaXN0ZW5pbmcgYXR0clxuICAgICAqIHZhciBsaXN0ZW5pbmcgPSBub2RlLmxpc3RlbmluZygpO1xuICAgICAqXG4gICAgICogLy8gc3RvcCBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIG5vZGUubGlzdGVuaW5nKGZhbHNlKTtcbiAgICAgKlxuICAgICAqIC8vIGxpc3RlbiBmb3IgZXZlbnRzXG4gICAgICogbm9kZS5saXN0ZW5pbmcodHJ1ZSk7XG4gICAgICpcbiAgICAgKiAvLyBsaXN0ZW4gdG8gZXZlbnRzIGFjY29yZGluZyB0byB0aGUgcGFyZW50XG4gICAgICogbm9kZS5saXN0ZW5pbmcoJ2luaGVyaXQnKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdmaWx0ZXJzJywgdW5kZWZpbmVkLCBmdW5jdGlvbih2YWwpIHt0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlOyByZXR1cm4gdmFsOyB9KTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbHRlcnMuICBGaWx0ZXJzIGFyZSBhcHBsaWVkIHRvIGNhY2hlZCBjYW52YXNlc1xuICAgICAqIEBuYW1lIGZpbHRlcnNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZmlsdGVycyBhcnJheSBvZiBmaWx0ZXJzXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbHRlcnNcbiAgICAgKiB2YXIgZmlsdGVycyA9IG5vZGUuZmlsdGVycygpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGEgc2luZ2xlIGZpbHRlclxuICAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuQmx1cl0pO1xuICAgICAqXG4gICAgICogLy8gc2V0IG11bHRpcGxlIGZpbHRlcnNcbiAgICAgKiBub2RlLmNhY2hlKCk7XG4gICAgICogbm9kZS5maWx0ZXJzKFtcbiAgICAgKiAgIEtvbnZhLkZpbHRlcnMuQmx1cixcbiAgICAgKiAgIEtvbnZhLkZpbHRlcnMuU2VwaWEsXG4gICAgICogICBLb252YS5GaWx0ZXJzLkludmVydFxuICAgICAqIF0pO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3Zpc2libGUnLCAnaW5oZXJpdCcpO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgdmlzaWJsZSBhdHRyLiAgQ2FuIGJlIFwiaW5oZXJpdFwiLCB0cnVlLCBvciBmYWxzZS4gIFRoZSBkZWZhdWx0IGlzIFwiaW5oZXJpdFwiLlxuICAgICAqICAgSWYgeW91IG5lZWQgdG8gZGV0ZXJtaW5lIGlmIGEgbm9kZSBpcyB2aXNpYmxlIG9yIG5vdFxuICAgICAqICAgYnkgdGFraW5nIGludG8gYWNjb3VudCBpdHMgcGFyZW50cywgdXNlIHRoZSBpc1Zpc2libGUoKSBtZXRob2RcbiAgICAgKiBAbmFtZSB2aXNpYmxlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IHZpc2libGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgdmlzaWJsZSBhdHRyXG4gICAgICogdmFyIHZpc2libGUgPSBub2RlLnZpc2libGUoKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgaW52aXNpYmxlXG4gICAgICogbm9kZS52aXNpYmxlKGZhbHNlKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgdmlzaWJsZVxuICAgICAqIG5vZGUudmlzaWJsZSh0cnVlKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgdmlzaWJsZSBhY2NvcmRpbmcgdG8gdGhlIHBhcmVudFxuICAgICAqIG5vZGUudmlzaWJsZSgnaW5oZXJpdCcpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3RyYW5zZm9ybXNFbmFibGVkJywgJ2FsbCcpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCB0cmFuc2Zvcm1zIHRoYXQgYXJlIGVuYWJsZWQuICBDYW4gYmUgXCJhbGxcIiwgXCJub25lXCIsIG9yIFwicG9zaXRpb25cIi4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIFwiYWxsXCJcbiAgICAgKiBAbmFtZSB0cmFuc2Zvcm1zRW5hYmxlZFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZW5hYmxlZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBlbmFibGUgcG9zaXRpb24gdHJhbnNmb3JtIG9ubHkgdG8gaW1wcm92ZSBkcmF3IHBlcmZvcm1hbmNlXG4gICAgICogbm9kZS50cmFuc2Zvcm1zRW5hYmxlZCgncG9zaXRpb24nKTtcbiAgICAgKlxuICAgICAqIC8vIGVuYWJsZSBhbGwgdHJhbnNmb3Jtc1xuICAgICAqIG5vZGUudHJhbnNmb3Jtc0VuYWJsZWQoJ2FsbCcpO1xuICAgICAqL1xuXG5cblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgbm9kZSBzaXplXG4gICAgICogQG5hbWUgc2l6ZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2l6ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplLndpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUuaGVpZ2h0XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBub2RlIHNpemVcbiAgICAgKiB2YXIgc2l6ZSA9IG5vZGUuc2l6ZSgpO1xuICAgICAqIHZhciB4ID0gc2l6ZS54O1xuICAgICAqIHZhciB5ID0gc2l6ZS55O1xuICAgICAqXG4gICAgICogLy8gc2V0IHNpemVcbiAgICAgKiBub2RlLnNpemUoe1xuICAgICAqICAgd2lkdGg6IDEwMCxcbiAgICAgKiAgIGhlaWdodDogMjAwXG4gICAgICogfSk7XG4gICAgICovXG4gICAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdzaXplJyk7XG5cbiAgICBLb252YS5GYWN0b3J5LmJhY2tDb21wYXQoS29udmEuTm9kZSwge1xuICAgICAgICByb3RhdGVEZWc6ICdyb3RhdGUnLFxuICAgICAgICBzZXRSb3RhdGlvbkRlZzogJ3NldFJvdGF0aW9uJyxcbiAgICAgICAgZ2V0Um90YXRpb25EZWc6ICdnZXRSb3RhdGlvbidcbiAgICB9KTtcblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5Ob2RlKTtcbn0pKEtvbnZhKTtcblxuKGZ1bmN0aW9uKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgLyoqXHJcbiAgICAqIEdyYXlzY2FsZSBGaWx0ZXJcclxuICAgICogQGZ1bmN0aW9uXHJcbiAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXHJcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcclxuICAgICogQGV4YW1wbGVcclxuICAgICogbm9kZS5jYWNoZSgpO1xyXG4gICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuR3JheXNjYWxlXSk7XHJcbiAgICAqL1xyXG4gICAgS29udmEuRmlsdGVycy5HcmF5c2NhbGUgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxyXG4gICAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aCxcclxuICAgICAgICAgICAgaSwgYnJpZ2h0bmVzcztcclxuXHJcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcclxuICAgICAgICAgICAgYnJpZ2h0bmVzcyA9IDAuMzQgKiBkYXRhW2ldICsgMC41ICogZGF0YVtpICsgMV0gKyAwLjE2ICogZGF0YVtpICsgMl07XHJcbiAgICAgICAgICAgIC8vIHJlZFxyXG4gICAgICAgICAgICBkYXRhW2ldID0gYnJpZ2h0bmVzcztcclxuICAgICAgICAgICAgLy8gZ3JlZW5cclxuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBicmlnaHRuZXNzO1xyXG4gICAgICAgICAgICAvLyBibHVlXHJcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gYnJpZ2h0bmVzcztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59KSgpO1xyXG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogQnJpZ2h0ZW4gRmlsdGVyLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgICAqIEBleGFtcGxlXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5CcmlnaHRlbl0pO1xuICAgICAqIG5vZGUuYnJpZ2h0bmVzcygwLjgpO1xuICAgICAqL1xuICAgIEtvbnZhLkZpbHRlcnMuQnJpZ2h0ZW4gPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICAgICAgdmFyIGJyaWdodG5lc3MgPSB0aGlzLmJyaWdodG5lc3MoKSAqIDI1NSxcbiAgICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICAgICAgLy8gcmVkXG4gICAgICAgICAgICBkYXRhW2ldICs9IGJyaWdodG5lc3M7XG4gICAgICAgICAgICAvLyBncmVlblxuICAgICAgICAgICAgZGF0YVtpICsgMV0gKz0gYnJpZ2h0bmVzcztcbiAgICAgICAgICAgIC8vIGJsdWVcbiAgICAgICAgICAgIGRhdGFbaSArIDJdICs9IGJyaWdodG5lc3M7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2JyaWdodG5lc3MnLCAwLCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcbiAgICAvKipcbiAgICAqIGdldC9zZXQgZmlsdGVyIGJyaWdodG5lc3MuICBUaGUgYnJpZ2h0bmVzcyBpcyBhIG51bWJlciBiZXR3ZWVuIC0xIGFuZCAxLiZuYnNwOyBQb3NpdGl2ZSB2YWx1ZXNcbiAgICAqICBicmlnaHRlbiB0aGUgcGl4ZWxzIGFuZCBuZWdhdGl2ZSB2YWx1ZXMgZGFya2VuIHRoZW0uIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkJyaWdodGVufSBmaWx0ZXIuXG4gICAgKiBAbmFtZSBicmlnaHRuZXNzXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBicmlnaHRuZXNzIHZhbHVlIGJldHdlZW4gLTEgYW5kIDFcbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgKi9cblxufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgLyoqXHJcbiAgICAqIEludmVydCBGaWx0ZXJcclxuICAgICogQGZ1bmN0aW9uXHJcbiAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXHJcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcclxuICAgICogQGV4YW1wbGVcclxuICAgICogbm9kZS5jYWNoZSgpO1xyXG4gICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuSW52ZXJ0XSk7XHJcbiAgICAqL1xyXG4gICAgS29udmEuRmlsdGVycy5JbnZlcnQgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxyXG4gICAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aCxcclxuICAgICAgICAgICAgaTtcclxuXHJcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcclxuICAgICAgICAgICAgLy8gcmVkXHJcbiAgICAgICAgICAgIGRhdGFbaV0gPSAyNTUgLSBkYXRhW2ldO1xyXG4gICAgICAgICAgICAvLyBncmVlblxyXG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IDI1NSAtIGRhdGFbaSArIDFdO1xyXG4gICAgICAgICAgICAvLyBibHVlXHJcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gMjU1IC0gZGF0YVtpICsgMl07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSkoKTtcclxuXG4vKlxuIHRoZSBHYXVzcyBmaWx0ZXJcbiBtYXN0ZXIgcmVwbzogaHR0cHM6Ly9naXRodWIuY29tL3BhdmVscG93ZXIva2luZXRpY2pzR2F1c3NGaWx0ZXJcbiovXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qXG5cbiAgICAgU3RhY2tCbHVyIC0gYSBmYXN0IGFsbW9zdCBHYXVzc2lhbiBCbHVyIEZvciBDYW52YXNcblxuICAgICBWZXJzaW9uOiAgIDAuNVxuICAgICBBdXRob3I6ICAgIE1hcmlvIEtsaW5nZW1hbm5cbiAgICAgQ29udGFjdDogICBtYXJpb0BxdWFzaW1vbmRvLmNvbVxuICAgICBXZWJzaXRlOiAgIGh0dHA6Ly93d3cucXVhc2ltb25kby5jb20vU3RhY2tCbHVyRm9yQ2FudmFzXG4gICAgIFR3aXR0ZXI6ICAgQHF1YXNpbW9uZG9cblxuICAgICBJbiBjYXNlIHlvdSBmaW5kIHRoaXMgY2xhc3MgdXNlZnVsIC0gZXNwZWNpYWxseSBpbiBjb21tZXJjaWFsIHByb2plY3RzIC1cbiAgICAgSSBhbSBub3QgdG90YWxseSB1bmhhcHB5IGZvciBhIHNtYWxsIGRvbmF0aW9uIHRvIG15IFBheVBhbCBhY2NvdW50XG4gICAgIG1hcmlvQHF1YXNpbW9uZG8uZGVcblxuICAgICBPciBzdXBwb3J0IG1lIG9uIGZsYXR0cjpcbiAgICAgaHR0cHM6Ly9mbGF0dHIuY29tL3RoaW5nLzcyNzkxL1N0YWNrQmx1ci1hLWZhc3QtYWxtb3N0LUdhdXNzaWFuLUJsdXItRWZmZWN0LWZvci1DYW52YXNKYXZhc2NyaXB0XG5cbiAgICAgQ29weXJpZ2h0IChjKSAyMDEwIE1hcmlvIEtsaW5nZW1hbm5cblxuICAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICAgICBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAgICAgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gICAgIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICAgICBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICAgICBjb25kaXRpb25zOlxuXG4gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gICAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICAgICBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICAgICBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAgICAgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gICAgIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAgICAgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQmx1clN0YWNrKCkge1xuICAgICAgICB0aGlzLnIgPSAwO1xuICAgICAgICB0aGlzLmcgPSAwO1xuICAgICAgICB0aGlzLmIgPSAwO1xuICAgICAgICB0aGlzLmEgPSAwO1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBtdWxfdGFibGUgPSBbXG4gICAgICAgIDUxMiwgNTEyLCA0NTYsIDUxMiwgMzI4LCA0NTYsIDMzNSwgNTEyLCA0MDUsIDMyOCwgMjcxLCA0NTYsIDM4OCwgMzM1LCAyOTIsIDUxMixcbiAgICAgICAgNDU0LCA0MDUsIDM2NCwgMzI4LCAyOTgsIDI3MSwgNDk2LCA0NTYsIDQyMCwgMzg4LCAzNjAsIDMzNSwgMzEyLCAyOTIsIDI3MywgNTEyLFxuICAgICAgICA0ODIsIDQ1NCwgNDI4LCA0MDUsIDM4MywgMzY0LCAzNDUsIDMyOCwgMzEyLCAyOTgsIDI4NCwgMjcxLCAyNTksIDQ5NiwgNDc1LCA0NTYsXG4gICAgICAgIDQzNywgNDIwLCA0MDQsIDM4OCwgMzc0LCAzNjAsIDM0NywgMzM1LCAzMjMsIDMxMiwgMzAyLCAyOTIsIDI4MiwgMjczLCAyNjUsIDUxMixcbiAgICAgICAgNDk3LCA0ODIsIDQ2OCwgNDU0LCA0NDEsIDQyOCwgNDE3LCA0MDUsIDM5NCwgMzgzLCAzNzMsIDM2NCwgMzU0LCAzNDUsIDMzNywgMzI4LFxuICAgICAgICAzMjAsIDMxMiwgMzA1LCAyOTgsIDI5MSwgMjg0LCAyNzgsIDI3MSwgMjY1LCAyNTksIDUwNywgNDk2LCA0ODUsIDQ3NSwgNDY1LCA0NTYsXG4gICAgICAgIDQ0NiwgNDM3LCA0MjgsIDQyMCwgNDEyLCA0MDQsIDM5NiwgMzg4LCAzODEsIDM3NCwgMzY3LCAzNjAsIDM1NCwgMzQ3LCAzNDEsIDMzNSxcbiAgICAgICAgMzI5LCAzMjMsIDMxOCwgMzEyLCAzMDcsIDMwMiwgMjk3LCAyOTIsIDI4NywgMjgyLCAyNzgsIDI3MywgMjY5LCAyNjUsIDI2MSwgNTEyLFxuICAgICAgICA1MDUsIDQ5NywgNDg5LCA0ODIsIDQ3NSwgNDY4LCA0NjEsIDQ1NCwgNDQ3LCA0NDEsIDQzNSwgNDI4LCA0MjIsIDQxNywgNDExLCA0MDUsXG4gICAgICAgIDM5OSwgMzk0LCAzODksIDM4MywgMzc4LCAzNzMsIDM2OCwgMzY0LCAzNTksIDM1NCwgMzUwLCAzNDUsIDM0MSwgMzM3LCAzMzIsIDMyOCxcbiAgICAgICAgMzI0LCAzMjAsIDMxNiwgMzEyLCAzMDksIDMwNSwgMzAxLCAyOTgsIDI5NCwgMjkxLCAyODcsIDI4NCwgMjgxLCAyNzgsIDI3NCwgMjcxLFxuICAgICAgICAyNjgsIDI2NSwgMjYyLCAyNTksIDI1NywgNTA3LCA1MDEsIDQ5NiwgNDkxLCA0ODUsIDQ4MCwgNDc1LCA0NzAsIDQ2NSwgNDYwLCA0NTYsXG4gICAgICAgIDQ1MSwgNDQ2LCA0NDIsIDQzNywgNDMzLCA0MjgsIDQyNCwgNDIwLCA0MTYsIDQxMiwgNDA4LCA0MDQsIDQwMCwgMzk2LCAzOTIsIDM4OCxcbiAgICAgICAgMzg1LCAzODEsIDM3NywgMzc0LCAzNzAsIDM2NywgMzYzLCAzNjAsIDM1NywgMzU0LCAzNTAsIDM0NywgMzQ0LCAzNDEsIDMzOCwgMzM1LFxuICAgICAgICAzMzIsIDMyOSwgMzI2LCAzMjMsIDMyMCwgMzE4LCAzMTUsIDMxMiwgMzEwLCAzMDcsIDMwNCwgMzAyLCAyOTksIDI5NywgMjk0LCAyOTIsXG4gICAgICAgIDI4OSwgMjg3LCAyODUsIDI4MiwgMjgwLCAyNzgsIDI3NSwgMjczLCAyNzEsIDI2OSwgMjY3LCAyNjUsIDI2MywgMjYxLCAyNTlcbiAgICBdO1xuXG4gICAgdmFyIHNoZ190YWJsZSA9IFtcbiAgICAgICAgOSwgMTEsIDEyLCAxMywgMTMsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE2LCAxNiwgMTYsIDE2LCAxNyxcbiAgICAgICAgMTcsIDE3LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTksXG4gICAgICAgIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLFxuICAgICAgICAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMSxcbiAgICAgICAgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsXG4gICAgICAgIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLFxuICAgICAgICAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMixcbiAgICAgICAgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjMsXG4gICAgICAgIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLFxuICAgICAgICAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMyxcbiAgICAgICAgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsXG4gICAgICAgIDIzLCAyMywgMjMsIDIzLCAyMywgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxuICAgICAgICAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcbiAgICAgICAgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsXG4gICAgICAgIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxuICAgICAgICAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0XG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIGZpbHRlckdhdXNzQmx1clJHQkEoIGltYWdlRGF0YSwgcmFkaXVzKSB7XG5cbiAgICAgICAgdmFyIHBpeGVscyA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgICAgd2lkdGggPSBpbWFnZURhdGEud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0O1xuXG4gICAgICAgIHZhciB4LCB5LCBpLCBwLCB5cCwgeWksIHl3LCByX3N1bSwgZ19zdW0sIGJfc3VtLCBhX3N1bSxcbiAgICAgICAgICAgIHJfb3V0X3N1bSwgZ19vdXRfc3VtLCBiX291dF9zdW0sIGFfb3V0X3N1bSxcbiAgICAgICAgICAgIHJfaW5fc3VtLCBnX2luX3N1bSwgYl9pbl9zdW0sIGFfaW5fc3VtLFxuICAgICAgICAgICAgcHIsIHBnLCBwYiwgcGEsIHJicztcblxuICAgICAgICB2YXIgZGl2ID0gcmFkaXVzICsgcmFkaXVzICsgMSxcbiAgICAgICAgICAgIHdpZHRoTWludXMxID0gd2lkdGggLSAxLFxuICAgICAgICAgICAgaGVpZ2h0TWludXMxID0gaGVpZ2h0IC0gMSxcbiAgICAgICAgICAgIHJhZGl1c1BsdXMxID0gcmFkaXVzICsgMSxcbiAgICAgICAgICAgIHN1bUZhY3RvciA9IHJhZGl1c1BsdXMxICogKCByYWRpdXNQbHVzMSArIDEgKSAvIDIsXG4gICAgICAgICAgICBzdGFja1N0YXJ0ID0gbmV3IEJsdXJTdGFjaygpLFxuICAgICAgICAgICAgc3RhY2tFbmQgPSBudWxsLFxuICAgICAgICAgICAgc3RhY2sgPSBzdGFja1N0YXJ0LFxuICAgICAgICAgICAgc3RhY2tJbiA9IG51bGwsXG4gICAgICAgICAgICBzdGFja091dCA9IG51bGwsXG4gICAgICAgICAgICBtdWxfc3VtID0gbXVsX3RhYmxlW3JhZGl1c10sXG4gICAgICAgICAgICBzaGdfc3VtID0gc2hnX3RhYmxlW3JhZGl1c107XG5cbiAgICAgICAgZm9yICggaSA9IDE7IGkgPCBkaXY7IGkrKyApIHtcbiAgICAgICAgICAgIHN0YWNrID0gc3RhY2submV4dCA9IG5ldyBCbHVyU3RhY2soKTtcbiAgICAgICAgICAgIGlmICggaSA9PT0gcmFkaXVzUGx1czEgKXtcbiAgICAgICAgICAgICAgICBzdGFja0VuZCA9IHN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhY2submV4dCA9IHN0YWNrU3RhcnQ7XG5cbiAgICAgICAgeXcgPSB5aSA9IDA7XG5cbiAgICAgICAgZm9yICggeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKyApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJfaW5fc3VtID0gZ19pbl9zdW0gPSBiX2luX3N1bSA9IGFfaW5fc3VtID0gcl9zdW0gPSBnX3N1bSA9IGJfc3VtID0gYV9zdW0gPSAwO1xuXG4gICAgICAgICAgICByX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcHIgPSBwaXhlbHNbeWldICk7XG4gICAgICAgICAgICBnX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGcgPSBwaXhlbHNbeWkgKyAxXSApO1xuICAgICAgICAgICAgYl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHBiID0gcGl4ZWxzW3lpICsgMl0gKTtcbiAgICAgICAgICAgIGFfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwYSA9IHBpeGVsc1t5aSArIDNdICk7XG5cbiAgICAgICAgICAgIHJfc3VtICs9IHN1bUZhY3RvciAqIHByO1xuICAgICAgICAgICAgZ19zdW0gKz0gc3VtRmFjdG9yICogcGc7XG4gICAgICAgICAgICBiX3N1bSArPSBzdW1GYWN0b3IgKiBwYjtcbiAgICAgICAgICAgIGFfc3VtICs9IHN1bUZhY3RvciAqIHBhO1xuXG4gICAgICAgICAgICBzdGFjayA9IHN0YWNrU3RhcnQ7XG5cbiAgICAgICAgICAgIGZvciggaSA9IDA7IGkgPCByYWRpdXNQbHVzMTsgaSsrIClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGFjay5yID0gcHI7XG4gICAgICAgICAgICAgICAgc3RhY2suZyA9IHBnO1xuICAgICAgICAgICAgICAgIHN0YWNrLmIgPSBwYjtcbiAgICAgICAgICAgICAgICBzdGFjay5hID0gcGE7XG4gICAgICAgICAgICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IoIGkgPSAxOyBpIDwgcmFkaXVzUGx1czE7IGkrKyApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcCA9IHlpICsgKCggd2lkdGhNaW51czEgPCBpID8gd2lkdGhNaW51czEgOiBpICkgPDwgMiApO1xuICAgICAgICAgICAgICAgIHJfc3VtICs9ICggc3RhY2suciA9ICggcHIgPSBwaXhlbHNbcF0pKSAqICggcmJzID0gcmFkaXVzUGx1czEgLSBpICk7XG4gICAgICAgICAgICAgICAgZ19zdW0gKz0gKCBzdGFjay5nID0gKCBwZyA9IHBpeGVsc1twICsgMV0pKSAqIHJicztcbiAgICAgICAgICAgICAgICBiX3N1bSArPSAoIHN0YWNrLmIgPSAoIHBiID0gcGl4ZWxzW3AgKyAyXSkpICogcmJzO1xuICAgICAgICAgICAgICAgIGFfc3VtICs9ICggc3RhY2suYSA9ICggcGEgPSBwaXhlbHNbcCArIDNdKSkgKiByYnM7XG5cbiAgICAgICAgICAgICAgICByX2luX3N1bSArPSBwcjtcbiAgICAgICAgICAgICAgICBnX2luX3N1bSArPSBwZztcbiAgICAgICAgICAgICAgICBiX2luX3N1bSArPSBwYjtcbiAgICAgICAgICAgICAgICBhX2luX3N1bSArPSBwYTtcblxuICAgICAgICAgICAgICAgIHN0YWNrID0gc3RhY2submV4dDtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBzdGFja0luID0gc3RhY2tTdGFydDtcbiAgICAgICAgICAgIHN0YWNrT3V0ID0gc3RhY2tFbmQ7XG4gICAgICAgICAgICBmb3IgKCB4ID0gMDsgeCA8IHdpZHRoOyB4KysgKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBpeGVsc1t5aSArIDNdID0gcGEgPSAoYV9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtO1xuICAgICAgICAgICAgICAgIGlmICggcGEgIT09IDAgKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGEgPSAyNTUgLyBwYTtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW3lpXSA9ICgocl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtKSAqIHBhO1xuICAgICAgICAgICAgICAgICAgICBwaXhlbHNbeWkgKyAxXSA9ICgoZ19zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtKSAqIHBhO1xuICAgICAgICAgICAgICAgICAgICBwaXhlbHNbeWkgKyAyXSA9ICgoYl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtKSAqIHBhO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsc1t5aV0gPSBwaXhlbHNbeWkgKyAxXSA9IHBpeGVsc1t5aSArIDJdID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByX3N1bSAtPSByX291dF9zdW07XG4gICAgICAgICAgICAgICAgZ19zdW0gLT0gZ19vdXRfc3VtO1xuICAgICAgICAgICAgICAgIGJfc3VtIC09IGJfb3V0X3N1bTtcbiAgICAgICAgICAgICAgICBhX3N1bSAtPSBhX291dF9zdW07XG5cbiAgICAgICAgICAgICAgICByX291dF9zdW0gLT0gc3RhY2tJbi5yO1xuICAgICAgICAgICAgICAgIGdfb3V0X3N1bSAtPSBzdGFja0luLmc7XG4gICAgICAgICAgICAgICAgYl9vdXRfc3VtIC09IHN0YWNrSW4uYjtcbiAgICAgICAgICAgICAgICBhX291dF9zdW0gLT0gc3RhY2tJbi5hO1xuXG4gICAgICAgICAgICAgICAgcCA9ICh5dyArICggKCBwID0geCArIHJhZGl1cyArIDEgKSA8IHdpZHRoTWludXMxID8gcCA6IHdpZHRoTWludXMxICkgKSA8PCAyO1xuXG4gICAgICAgICAgICAgICAgcl9pbl9zdW0gKz0gKCBzdGFja0luLnIgPSBwaXhlbHNbcF0pO1xuICAgICAgICAgICAgICAgIGdfaW5fc3VtICs9ICggc3RhY2tJbi5nID0gcGl4ZWxzW3AgKyAxXSk7XG4gICAgICAgICAgICAgICAgYl9pbl9zdW0gKz0gKCBzdGFja0luLmIgPSBwaXhlbHNbcCArIDJdKTtcbiAgICAgICAgICAgICAgICBhX2luX3N1bSArPSAoIHN0YWNrSW4uYSA9IHBpeGVsc1twICsgM10pO1xuXG4gICAgICAgICAgICAgICAgcl9zdW0gKz0gcl9pbl9zdW07XG4gICAgICAgICAgICAgICAgZ19zdW0gKz0gZ19pbl9zdW07XG4gICAgICAgICAgICAgICAgYl9zdW0gKz0gYl9pbl9zdW07XG4gICAgICAgICAgICAgICAgYV9zdW0gKz0gYV9pbl9zdW07XG5cbiAgICAgICAgICAgICAgICBzdGFja0luID0gc3RhY2tJbi5uZXh0O1xuXG4gICAgICAgICAgICAgICAgcl9vdXRfc3VtICs9ICggcHIgPSBzdGFja091dC5yICk7XG4gICAgICAgICAgICAgICAgZ19vdXRfc3VtICs9ICggcGcgPSBzdGFja091dC5nICk7XG4gICAgICAgICAgICAgICAgYl9vdXRfc3VtICs9ICggcGIgPSBzdGFja091dC5iICk7XG4gICAgICAgICAgICAgICAgYV9vdXRfc3VtICs9ICggcGEgPSBzdGFja091dC5hICk7XG5cbiAgICAgICAgICAgICAgICByX2luX3N1bSAtPSBwcjtcbiAgICAgICAgICAgICAgICBnX2luX3N1bSAtPSBwZztcbiAgICAgICAgICAgICAgICBiX2luX3N1bSAtPSBwYjtcbiAgICAgICAgICAgICAgICBhX2luX3N1bSAtPSBwYTtcblxuICAgICAgICAgICAgICAgIHN0YWNrT3V0ID0gc3RhY2tPdXQubmV4dDtcblxuICAgICAgICAgICAgICAgIHlpICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5dyArPSB3aWR0aDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgZm9yICggeCA9IDA7IHggPCB3aWR0aDsgeCsrIClcbiAgICAgICAge1xuICAgICAgICAgICAgZ19pbl9zdW0gPSBiX2luX3N1bSA9IGFfaW5fc3VtID0gcl9pbl9zdW0gPSBnX3N1bSA9IGJfc3VtID0gYV9zdW0gPSByX3N1bSA9IDA7XG5cbiAgICAgICAgICAgIHlpID0geCA8PCAyO1xuICAgICAgICAgICAgcl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHByID0gcGl4ZWxzW3lpXSk7XG4gICAgICAgICAgICBnX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGcgPSBwaXhlbHNbeWkgKyAxXSk7XG4gICAgICAgICAgICBiX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGIgPSBwaXhlbHNbeWkgKyAyXSk7XG4gICAgICAgICAgICBhX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGEgPSBwaXhlbHNbeWkgKyAzXSk7XG5cbiAgICAgICAgICAgIHJfc3VtICs9IHN1bUZhY3RvciAqIHByO1xuICAgICAgICAgICAgZ19zdW0gKz0gc3VtRmFjdG9yICogcGc7XG4gICAgICAgICAgICBiX3N1bSArPSBzdW1GYWN0b3IgKiBwYjtcbiAgICAgICAgICAgIGFfc3VtICs9IHN1bUZhY3RvciAqIHBhO1xuXG4gICAgICAgICAgICBzdGFjayA9IHN0YWNrU3RhcnQ7XG5cbiAgICAgICAgICAgIGZvciggaSA9IDA7IGkgPCByYWRpdXNQbHVzMTsgaSsrIClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGFjay5yID0gcHI7XG4gICAgICAgICAgICAgICAgc3RhY2suZyA9IHBnO1xuICAgICAgICAgICAgICAgIHN0YWNrLmIgPSBwYjtcbiAgICAgICAgICAgICAgICBzdGFjay5hID0gcGE7XG4gICAgICAgICAgICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB5cCA9IHdpZHRoO1xuXG4gICAgICAgICAgICBmb3IoIGkgPSAxOyBpIDw9IHJhZGl1czsgaSsrIClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB5aSA9ICggeXAgKyB4ICkgPDwgMjtcblxuICAgICAgICAgICAgICAgIHJfc3VtICs9ICggc3RhY2suciA9ICggcHIgPSBwaXhlbHNbeWldKSkgKiAoIHJicyA9IHJhZGl1c1BsdXMxIC0gaSApO1xuICAgICAgICAgICAgICAgIGdfc3VtICs9ICggc3RhY2suZyA9ICggcGcgPSBwaXhlbHNbeWkgKyAxXSkpICogcmJzO1xuICAgICAgICAgICAgICAgIGJfc3VtICs9ICggc3RhY2suYiA9ICggcGIgPSBwaXhlbHNbeWkgKyAyXSkpICogcmJzO1xuICAgICAgICAgICAgICAgIGFfc3VtICs9ICggc3RhY2suYSA9ICggcGEgPSBwaXhlbHNbeWkgKyAzXSkpICogcmJzO1xuXG4gICAgICAgICAgICAgICAgcl9pbl9zdW0gKz0gcHI7XG4gICAgICAgICAgICAgICAgZ19pbl9zdW0gKz0gcGc7XG4gICAgICAgICAgICAgICAgYl9pbl9zdW0gKz0gcGI7XG4gICAgICAgICAgICAgICAgYV9pbl9zdW0gKz0gcGE7XG5cbiAgICAgICAgICAgICAgICBzdGFjayA9IHN0YWNrLm5leHQ7XG5cbiAgICAgICAgICAgICAgICBpZiggaSA8IGhlaWdodE1pbnVzMSApXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB5cCArPSB3aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHlpID0geDtcbiAgICAgICAgICAgIHN0YWNrSW4gPSBzdGFja1N0YXJ0O1xuICAgICAgICAgICAgc3RhY2tPdXQgPSBzdGFja0VuZDtcbiAgICAgICAgICAgIGZvciAoIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KysgKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHAgPSB5aSA8PCAyO1xuICAgICAgICAgICAgICAgIHBpeGVsc1twICsgM10gPSBwYSA9IChhX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW07XG4gICAgICAgICAgICAgICAgaWYgKCBwYSA+IDAgKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGEgPSAyNTUgLyBwYTtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW3BdID0gKChyX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0gKSAqIHBhO1xuICAgICAgICAgICAgICAgICAgICBwaXhlbHNbcCArIDFdID0gKChnX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0gKSAqIHBhO1xuICAgICAgICAgICAgICAgICAgICBwaXhlbHNbcCArIDJdID0gKChiX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0gKSAqIHBhO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsc1twXSA9IHBpeGVsc1twICsgMV0gPSBwaXhlbHNbcCArIDJdID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByX3N1bSAtPSByX291dF9zdW07XG4gICAgICAgICAgICAgICAgZ19zdW0gLT0gZ19vdXRfc3VtO1xuICAgICAgICAgICAgICAgIGJfc3VtIC09IGJfb3V0X3N1bTtcbiAgICAgICAgICAgICAgICBhX3N1bSAtPSBhX291dF9zdW07XG5cbiAgICAgICAgICAgICAgICByX291dF9zdW0gLT0gc3RhY2tJbi5yO1xuICAgICAgICAgICAgICAgIGdfb3V0X3N1bSAtPSBzdGFja0luLmc7XG4gICAgICAgICAgICAgICAgYl9vdXRfc3VtIC09IHN0YWNrSW4uYjtcbiAgICAgICAgICAgICAgICBhX291dF9zdW0gLT0gc3RhY2tJbi5hO1xuXG4gICAgICAgICAgICAgICAgcCA9ICggeCArICgoICggcCA9IHkgKyByYWRpdXNQbHVzMSkgPCBoZWlnaHRNaW51czEgPyBwIDogaGVpZ2h0TWludXMxICkgKiB3aWR0aCApKSA8PCAyO1xuXG4gICAgICAgICAgICAgICAgcl9zdW0gKz0gKCByX2luX3N1bSArPSAoIHN0YWNrSW4uciA9IHBpeGVsc1twXSkpO1xuICAgICAgICAgICAgICAgIGdfc3VtICs9ICggZ19pbl9zdW0gKz0gKCBzdGFja0luLmcgPSBwaXhlbHNbcCArIDFdKSk7XG4gICAgICAgICAgICAgICAgYl9zdW0gKz0gKCBiX2luX3N1bSArPSAoIHN0YWNrSW4uYiA9IHBpeGVsc1twICsgMl0pKTtcbiAgICAgICAgICAgICAgICBhX3N1bSArPSAoIGFfaW5fc3VtICs9ICggc3RhY2tJbi5hID0gcGl4ZWxzW3AgKyAzXSkpO1xuXG4gICAgICAgICAgICAgICAgc3RhY2tJbiA9IHN0YWNrSW4ubmV4dDtcblxuICAgICAgICAgICAgICAgIHJfb3V0X3N1bSArPSAoIHByID0gc3RhY2tPdXQuciApO1xuICAgICAgICAgICAgICAgIGdfb3V0X3N1bSArPSAoIHBnID0gc3RhY2tPdXQuZyApO1xuICAgICAgICAgICAgICAgIGJfb3V0X3N1bSArPSAoIHBiID0gc3RhY2tPdXQuYiApO1xuICAgICAgICAgICAgICAgIGFfb3V0X3N1bSArPSAoIHBhID0gc3RhY2tPdXQuYSApO1xuXG4gICAgICAgICAgICAgICAgcl9pbl9zdW0gLT0gcHI7XG4gICAgICAgICAgICAgICAgZ19pbl9zdW0gLT0gcGc7XG4gICAgICAgICAgICAgICAgYl9pbl9zdW0gLT0gcGI7XG4gICAgICAgICAgICAgICAgYV9pbl9zdW0gLT0gcGE7XG5cbiAgICAgICAgICAgICAgICBzdGFja091dCA9IHN0YWNrT3V0Lm5leHQ7XG5cbiAgICAgICAgICAgICAgICB5aSArPSB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJsdXIgRmlsdGVyXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgQmx1clxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgICAqIEBleGFtcGxlXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5CbHVyXSk7XG4gICAgICogbm9kZS5ibHVyUmFkaXVzKDEwKTtcbiAgICAgKi9cbiAgICBLb252YS5GaWx0ZXJzLkJsdXIgPSBmdW5jdGlvbiBCbHVyKGltYWdlRGF0YSkge1xuICAgICAgICB2YXIgcmFkaXVzID0gTWF0aC5yb3VuZCh0aGlzLmJsdXJSYWRpdXMoKSk7XG5cbiAgICAgICAgaWYgKHJhZGl1cyA+IDApIHtcbiAgICAgICAgICAgIGZpbHRlckdhdXNzQmx1clJHQkEoaW1hZ2VEYXRhLCByYWRpdXMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdibHVyUmFkaXVzJywgMCwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG5cbiAgICAvKipcbiAgICAqIGdldC9zZXQgYmx1ciByYWRpdXMuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkJsdXJ9IGZpbHRlclxuICAgICogQG5hbWUgYmx1clJhZGl1c1xuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge0ludGVnZXJ9IHJhZGl1c1xuICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgKi9cbn0pKCk7XG5cbi8qZXNsaW50LWRpc2FibGUgIG1heC1kZXB0aCAqL1xuKGZ1bmN0aW9uKCkge1xuXHQndXNlIHN0cmljdCc7XG5cdGZ1bmN0aW9uIHBpeGVsQXQoaWRhdGEsIHgsIHkpIHtcblx0XHR2YXIgaWR4ID0gKHkgKiBpZGF0YS53aWR0aCArIHgpICogNDtcblx0XHR2YXIgZCA9IFtdO1xuXHRcdGQucHVzaChpZGF0YS5kYXRhW2lkeCsrXSwgaWRhdGEuZGF0YVtpZHgrK10sIGlkYXRhLmRhdGFbaWR4KytdLCBpZGF0YS5kYXRhW2lkeCsrXSk7XG5cdFx0cmV0dXJuIGQ7XG5cdH1cblxuXHRmdW5jdGlvbiByZ2JEaXN0YW5jZShwMSwgcDIpIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHAxWzBdIC0gcDJbMF0sIDIpICsgTWF0aC5wb3cocDFbMV0gLSBwMlsxXSwgMikgKyBNYXRoLnBvdyhwMVsyXSAtIHAyWzJdLCAyKSk7XG5cdH1cblxuXHRmdW5jdGlvbiByZ2JNZWFuKHBUYWIpIHtcblx0XHR2YXIgbSA9IFswLCAwLCAwXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcFRhYi5sZW5ndGg7IGkrKykge1xuXHRcdFx0bVswXSArPSBwVGFiW2ldWzBdO1xuXHRcdFx0bVsxXSArPSBwVGFiW2ldWzFdO1xuXHRcdFx0bVsyXSArPSBwVGFiW2ldWzJdO1xuXHRcdH1cblxuXHRcdG1bMF0gLz0gcFRhYi5sZW5ndGg7XG5cdFx0bVsxXSAvPSBwVGFiLmxlbmd0aDtcblx0XHRtWzJdIC89IHBUYWIubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIG07XG5cdH1cblxuXHRmdW5jdGlvbiBiYWNrZ3JvdW5kTWFzayhpZGF0YSwgdGhyZXNob2xkKSB7XG5cdFx0dmFyIHJnYnZfbm8gPSBwaXhlbEF0KGlkYXRhLCAwLCAwKTtcblx0XHR2YXIgcmdidl9uZSA9IHBpeGVsQXQoaWRhdGEsIGlkYXRhLndpZHRoIC0gMSwgMCk7XG5cdFx0dmFyIHJnYnZfc28gPSBwaXhlbEF0KGlkYXRhLCAwLCBpZGF0YS5oZWlnaHQgLSAxKTtcblx0XHR2YXIgcmdidl9zZSA9IHBpeGVsQXQoaWRhdGEsIGlkYXRhLndpZHRoIC0gMSwgaWRhdGEuaGVpZ2h0IC0gMSk7XG5cblxuXHRcdHZhciB0aHJlcyA9IHRocmVzaG9sZCB8fCAxMDtcblx0XHRpZiAocmdiRGlzdGFuY2Uocmdidl9ubywgcmdidl9uZSkgPCB0aHJlcyAmJiByZ2JEaXN0YW5jZShyZ2J2X25lLCByZ2J2X3NlKSA8IHRocmVzICYmIHJnYkRpc3RhbmNlKHJnYnZfc2UsIHJnYnZfc28pIDwgdGhyZXMgJiYgcmdiRGlzdGFuY2Uocmdidl9zbywgcmdidl9ubykgPCB0aHJlcykge1xuXG5cdFx0XHQvLyBNZWFuIGNvbG9yXG5cdFx0XHR2YXIgbWVhbiA9IHJnYk1lYW4oW3JnYnZfbmUsIHJnYnZfbm8sIHJnYnZfc2UsIHJnYnZfc29dKTtcblxuXHRcdFx0Ly8gTWFzayBiYXNlZCBvbiBjb2xvciBkaXN0YW5jZVxuXHRcdFx0dmFyIG1hc2sgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaWRhdGEud2lkdGggKiBpZGF0YS5oZWlnaHQ7IGkrKykge1xuXHRcdFx0XHR2YXIgZCA9IHJnYkRpc3RhbmNlKG1lYW4sIFtpZGF0YS5kYXRhW2kgKiA0XSwgaWRhdGEuZGF0YVtpICogNCArIDFdLCBpZGF0YS5kYXRhW2kgKiA0ICsgMl1dKTtcblx0XHRcdFx0bWFza1tpXSA9IChkIDwgdGhyZXMpID8gMCA6IDI1NTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hc2s7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gYXBwbHlNYXNrKGlkYXRhLCBtYXNrKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpZGF0YS53aWR0aCAqIGlkYXRhLmhlaWdodDsgaSsrKSB7XG5cdFx0XHRpZGF0YS5kYXRhWzQgKiBpICsgM10gPSBtYXNrW2ldO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGVyb2RlTWFzayhtYXNrLCBzdywgc2gpIHtcblxuXHRcdHZhciB3ZWlnaHRzID0gWzEsIDEsIDEsIDEsIDAsIDEsIDEsIDEsIDFdO1xuXHRcdHZhciBzaWRlID0gTWF0aC5yb3VuZChNYXRoLnNxcnQod2VpZ2h0cy5sZW5ndGgpKTtcblx0XHR2YXIgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUgLyAyKTtcblxuXHRcdHZhciBtYXNrUmVzdWx0ID0gW107XG5cdFx0Zm9yICh2YXIgeSA9IDA7IHkgPCBzaDsgeSsrKSB7XG5cdFx0XHRmb3IgKHZhciB4ID0gMDsgeCA8IHN3OyB4KyspIHtcblxuXHRcdFx0XHR2YXIgc28gPSB5ICogc3cgKyB4O1xuXHRcdFx0XHR2YXIgYSA9IDA7XG5cdFx0XHRcdGZvciAodmFyIGN5ID0gMDsgY3kgPCBzaWRlOyBjeSsrKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgY3ggPSAwOyBjeCA8IHNpZGU7IGN4KyspIHtcblx0XHRcdFx0XHRcdHZhciBzY3kgPSB5ICsgY3kgLSBoYWxmU2lkZTtcblx0XHRcdFx0XHRcdHZhciBzY3ggPSB4ICsgY3ggLSBoYWxmU2lkZTtcblxuXHRcdFx0XHRcdFx0aWYgKHNjeSA+PSAwICYmIHNjeSA8IHNoICYmIHNjeCA+PSAwICYmIHNjeCA8IHN3KSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHNyY09mZiA9IHNjeSAqIHN3ICsgc2N4O1xuXHRcdFx0XHRcdFx0XHR2YXIgd3QgPSB3ZWlnaHRzW2N5ICogc2lkZSArIGN4XTtcblxuXHRcdFx0XHRcdFx0XHRhICs9IG1hc2tbc3JjT2ZmXSAqIHd0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1hc2tSZXN1bHRbc29dID0gKGEgPT09IDI1NSAqIDgpID8gMjU1IDogMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWFza1Jlc3VsdDtcblx0fVxuXG5cdGZ1bmN0aW9uIGRpbGF0ZU1hc2sobWFzaywgc3csIHNoKSB7XG5cblx0XHR2YXIgd2VpZ2h0cyA9IFsxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxXTtcblx0XHR2YXIgc2lkZSA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KHdlaWdodHMubGVuZ3RoKSk7XG5cdFx0dmFyIGhhbGZTaWRlID0gTWF0aC5mbG9vcihzaWRlIC8gMik7XG5cblx0XHR2YXIgbWFza1Jlc3VsdCA9IFtdO1xuXHRcdGZvciAodmFyIHkgPSAwOyB5IDwgc2g7IHkrKykge1xuXHRcdFx0Zm9yICh2YXIgeCA9IDA7IHggPCBzdzsgeCsrKSB7XG5cblx0XHRcdFx0dmFyIHNvID0geSAqIHN3ICsgeDtcblx0XHRcdFx0dmFyIGEgPSAwO1xuXHRcdFx0XHRmb3IgKHZhciBjeSA9IDA7IGN5IDwgc2lkZTsgY3krKykge1xuXHRcdFx0XHRcdGZvciAodmFyIGN4ID0gMDsgY3ggPCBzaWRlOyBjeCsrKSB7XG5cdFx0XHRcdFx0XHR2YXIgc2N5ID0geSArIGN5IC0gaGFsZlNpZGU7XG5cdFx0XHRcdFx0XHR2YXIgc2N4ID0geCArIGN4IC0gaGFsZlNpZGU7XG5cblx0XHRcdFx0XHRcdGlmIChzY3kgPj0gMCAmJiBzY3kgPCBzaCAmJiBzY3ggPj0gMCAmJiBzY3ggPCBzdykge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBzcmNPZmYgPSBzY3kgKiBzdyArIHNjeDtcblx0XHRcdFx0XHRcdFx0dmFyIHd0ID0gd2VpZ2h0c1tjeSAqIHNpZGUgKyBjeF07XG5cblx0XHRcdFx0XHRcdFx0YSArPSBtYXNrW3NyY09mZl0gKiB3dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtYXNrUmVzdWx0W3NvXSA9IChhID49IDI1NSAqIDQpID8gMjU1IDogMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWFza1Jlc3VsdDtcblx0fVxuXG5cdGZ1bmN0aW9uIHNtb290aEVkZ2VNYXNrKG1hc2ssIHN3LCBzaCkge1xuXG5cdFx0dmFyIHdlaWdodHMgPSBbMSAvIDksIDEgLyA5LCAxIC8gOSwgMSAvIDksIDEgLyA5LCAxIC8gOSwgMSAvIDksIDEgLyA5LCAxIC8gOV07XG5cdFx0dmFyIHNpZGUgPSBNYXRoLnJvdW5kKE1hdGguc3FydCh3ZWlnaHRzLmxlbmd0aCkpO1xuXHRcdHZhciBoYWxmU2lkZSA9IE1hdGguZmxvb3Ioc2lkZSAvIDIpO1xuXG5cdFx0dmFyIG1hc2tSZXN1bHQgPSBbXTtcblx0XHRmb3IgKHZhciB5ID0gMDsgeSA8IHNoOyB5KyspIHtcblx0XHRcdGZvciAodmFyIHggPSAwOyB4IDwgc3c7IHgrKykge1xuXG5cdFx0XHRcdHZhciBzbyA9IHkgKiBzdyArIHg7XG5cdFx0XHRcdHZhciBhID0gMDtcblx0XHRcdFx0Zm9yICh2YXIgY3kgPSAwOyBjeSA8IHNpZGU7IGN5KyspIHtcblx0XHRcdFx0XHRmb3IgKHZhciBjeCA9IDA7IGN4IDwgc2lkZTsgY3grKykge1xuXHRcdFx0XHRcdFx0dmFyIHNjeSA9IHkgKyBjeSAtIGhhbGZTaWRlO1xuXHRcdFx0XHRcdFx0dmFyIHNjeCA9IHggKyBjeCAtIGhhbGZTaWRlO1xuXG5cdFx0XHRcdFx0XHRpZiAoc2N5ID49IDAgJiYgc2N5IDwgc2ggJiYgc2N4ID49IDAgJiYgc2N4IDwgc3cpIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgc3JjT2ZmID0gc2N5ICogc3cgKyBzY3g7XG5cdFx0XHRcdFx0XHRcdHZhciB3dCA9IHdlaWdodHNbY3kgKiBzaWRlICsgY3hdO1xuXG5cdFx0XHRcdFx0XHRcdGEgKz0gbWFza1tzcmNPZmZdICogd3Q7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWFza1Jlc3VsdFtzb10gPSBhO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXNrUmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIE1hc2sgRmlsdGVyXG5cdCAqIEBmdW5jdGlvblxuXHQgKiBAbmFtZSBNYXNrXG5cdCAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcblx0ICogQGV4YW1wbGVcbiAgICAgKiBub2RlLmNhY2hlKCk7XG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLk1hc2tdKTtcbiAgICAgKiBub2RlLnRocmVzaG9sZCgyMDApO1xuXHQgKi9cblx0S29udmEuRmlsdGVycy5NYXNrID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG5cdFx0Ly8gRGV0ZWN0IHBpeGVscyBjbG9zZSB0byB0aGUgYmFja2dyb3VuZCBjb2xvclxuXHRcdHZhciB0aHJlc2hvbGQgPSB0aGlzLnRocmVzaG9sZCgpLFxuICAgICAgICBtYXNrID0gYmFja2dyb3VuZE1hc2soaW1hZ2VEYXRhLCB0aHJlc2hvbGQpO1xuXHRcdGlmIChtYXNrKSB7XG5cdFx0XHQvLyBFcm9kZVxuXHRcdFx0bWFzayA9IGVyb2RlTWFzayhtYXNrLCBpbWFnZURhdGEud2lkdGgsIGltYWdlRGF0YS5oZWlnaHQpO1xuXG5cdFx0XHQvLyBEaWxhdGVcblx0XHRcdG1hc2sgPSBkaWxhdGVNYXNrKG1hc2ssIGltYWdlRGF0YS53aWR0aCwgaW1hZ2VEYXRhLmhlaWdodCk7XG5cblx0XHRcdC8vIEdyYWRpZW50XG5cdFx0XHRtYXNrID0gc21vb3RoRWRnZU1hc2sobWFzaywgaW1hZ2VEYXRhLndpZHRoLCBpbWFnZURhdGEuaGVpZ2h0KTtcblxuXHRcdFx0Ly8gQXBwbHkgbWFza1xuXHRcdFx0YXBwbHlNYXNrKGltYWdlRGF0YSwgbWFzayk7XG5cblx0XHRcdC8vIHRvZG8gOiBVcGRhdGUgaGl0IHJlZ2lvbiBmdW5jdGlvbiBhY2NvcmRpbmcgdG8gbWFza1xuXHRcdH1cblxuXHRcdHJldHVybiBpbWFnZURhdGE7XG5cdH07XG5cblx0S29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3RocmVzaG9sZCcsIDAsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xufSkoKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogUkdCIEZpbHRlclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIFJHQlxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgICAqIEBhdXRob3IgaXBwbzYxNVxuICAgICAqIEBleGFtcGxlXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5SR0JdKTtcbiAgICAgKiBub2RlLmJsdWUoMTIwKTtcbiAgICAgKiBub2RlLmdyZWVuKDIwMCk7XG4gICAgICovXG4gICAgS29udmEuRmlsdGVycy5SR0IgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG4gICAgICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgICBuUGl4ZWxzID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICByZWQgPSB0aGlzLnJlZCgpLFxuICAgICAgICAgICAgZ3JlZW4gPSB0aGlzLmdyZWVuKCksXG4gICAgICAgICAgICBibHVlID0gdGhpcy5ibHVlKCksXG4gICAgICAgICAgICBpLCBicmlnaHRuZXNzO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuUGl4ZWxzOyBpICs9IDQpIHtcbiAgICAgICAgICAgIGJyaWdodG5lc3MgPSAoMC4zNCAqIGRhdGFbaV0gKyAwLjUgKiBkYXRhW2kgKyAxXSArIDAuMTYgKiBkYXRhW2kgKyAyXSkgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2ldID0gYnJpZ2h0bmVzcyAqIHJlZDsgLy8gclxuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBicmlnaHRuZXNzICogZ3JlZW47IC8vIGdcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gYnJpZ2h0bmVzcyAqIGJsdWU7IC8vIGJcbiAgICAgICAgICAgIGRhdGFbaSArIDNdID0gZGF0YVtpICsgM107IC8vIGFscGhhXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3JlZCcsIDAsIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlO1xuICAgICAgICBpZiAodmFsID4gMjU1KSB7XG4gICAgICAgICAgICByZXR1cm4gMjU1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICogZ2V0L3NldCBmaWx0ZXIgcmVkIHZhbHVlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5SR0J9IGZpbHRlci5cbiAgICAqIEBuYW1lIHJlZFxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge0ludGVnZXJ9IHJlZCB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NVxuICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdncmVlbicsIDAsIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlO1xuICAgICAgICBpZiAodmFsID4gMjU1KSB7XG4gICAgICAgICAgICByZXR1cm4gMjU1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICogZ2V0L3NldCBmaWx0ZXIgZ3JlZW4gdmFsdWUuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLlJHQn0gZmlsdGVyLlxuICAgICogQG5hbWUgZ3JlZW5cbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSBncmVlbiB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NVxuICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdibHVlJywgMCwgS29udmEuVmFsaWRhdG9ycy5SR0JDb21wb25lbnQsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuICAgIC8qKlxuICAgICogZ2V0L3NldCBmaWx0ZXIgYmx1ZSB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUkdCfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSBibHVlXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7SW50ZWdlcn0gYmx1ZSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NVxuICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgKi9cbn0pKCk7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qKlxuICAgICAqIFJHQkEgRmlsdGVyXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgUkdCQVxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgICAqIEBhdXRob3IgY29kZWZvXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBub2RlLmNhY2hlKCk7XG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLlJHQkFdKTtcbiAgICAgKiBub2RlLmJsdWUoMTIwKTtcbiAgICAgKiBub2RlLmdyZWVuKDIwMCk7XG4gICAgICogbm9kZS5hbHBoYSgwLjMpO1xuICAgICAqL1xuICAgIEtvbnZhLkZpbHRlcnMuUkdCQSA9IGZ1bmN0aW9uIChpbWFnZURhdGEpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICAgIG5QaXhlbHMgPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIHJlZCA9IHRoaXMucmVkKCksXG4gICAgICAgICAgICBncmVlbiA9IHRoaXMuZ3JlZW4oKSxcbiAgICAgICAgICAgIGJsdWUgPSB0aGlzLmJsdWUoKSxcbiAgICAgICAgICAgIGFscGhhID0gdGhpcy5hbHBoYSgpLFxuICAgICAgICAgICAgaSwgaWE7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5QaXhlbHM7IGkgKz0gNCkge1xuICAgICAgICAgICAgaWEgPSAxIC0gYWxwaGE7XG5cbiAgICAgICAgICAgIGRhdGFbaV0gPSByZWQgKiBhbHBoYSArIGRhdGFbaV0gKiBpYTsgLy8gclxuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBncmVlbiAqIGFscGhhICsgZGF0YVtpICsgMV0gKiBpYTsgLy8gZ1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBibHVlICogYWxwaGEgKyBkYXRhW2kgKyAyXSAqIGlhOyAvLyBiXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3JlZCcsIDAsIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlO1xuICAgICAgICBpZiAodmFsID4gMjU1KSB7XG4gICAgICAgICAgICByZXR1cm4gMjU1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICogZ2V0L3NldCBmaWx0ZXIgcmVkIHZhbHVlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5SR0JBfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSByZWRcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSByZWQgdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTVcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZ3JlZW4nLCAwLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhbCA+IDI1NSkge1xuICAgICAgICAgICAgcmV0dXJuIDI1NTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAqIGdldC9zZXQgZmlsdGVyIGdyZWVuIHZhbHVlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5SR0JBfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSBncmVlblxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge0ludGVnZXJ9IGdyZWVuIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1XG4gICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2JsdWUnLCAwLCBLb252YS5WYWxpZGF0b3JzLlJHQkNvbXBvbmVudCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGZpbHRlciBibHVlIHZhbHVlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5SR0JBfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSBibHVlXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7SW50ZWdlcn0gYmx1ZSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NVxuICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdhbHBoYScsIDEsIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlO1xuICAgICAgICBpZiAodmFsID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWx0ZXIgYWxwaGEgdmFsdWUuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLlJHQkF9IGZpbHRlci5cbiAgICAgKiBAbmFtZSBhbHBoYVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Zsb2F0fSBhbHBoYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcmV0dXJucyB7RmxvYXR9XG4gICAgICovXG59KSgpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAqIEhTViBGaWx0ZXIuIEFkanVzdHMgdGhlIGh1ZSwgc2F0dXJhdGlvbiBhbmQgdmFsdWVcbiAgICAqIEBmdW5jdGlvblxuICAgICogQG5hbWUgSFNWXG4gICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgICogQGF1dGhvciBpcHBvNjE1XG4gICAgKiBAZXhhbXBsZVxuICAgICogaW1hZ2UuZmlsdGVycyhbS29udmEuRmlsdGVycy5IU1ZdKTtcbiAgICAqIGltYWdlLnZhbHVlKDIwMCk7XG4gICAgKi9cblxuICAgIEtvbnZhLkZpbHRlcnMuSFNWID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xuICAgICAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgICAgblBpeGVscyA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgdiA9IE1hdGgucG93KDIsIHRoaXMudmFsdWUoKSksXG4gICAgICAgICAgICBzID0gTWF0aC5wb3coMiwgdGhpcy5zYXR1cmF0aW9uKCkpLFxuICAgICAgICAgICAgaCA9IE1hdGguYWJzKCh0aGlzLmh1ZSgpKSArIDM2MCkgJSAzNjAsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIC8vIEJhc2lzIGZvciB0aGUgdGVjaG5pcXVlIHVzZWQ6XG4gICAgICAgIC8vIGh0dHA6Ly9iZWVzYnV6ei5iaXovY29kZS9oc3ZfY29sb3JfdHJhbnNmb3Jtcy5waHBcbiAgICAgICAgLy8gViBpcyB0aGUgdmFsdWUgbXVsdGlwbGllciAoMSBmb3Igbm9uZSwgMiBmb3IgZG91YmxlLCAwLjUgZm9yIGhhbGYpXG4gICAgICAgIC8vIFMgaXMgdGhlIHNhdHVyYXRpb24gbXVsdGlwbGllciAoMSBmb3Igbm9uZSwgMiBmb3IgZG91YmxlLCAwLjUgZm9yIGhhbGYpXG4gICAgICAgIC8vIEggaXMgdGhlIGh1ZSBzaGlmdCBpbiBkZWdyZWVzICgwIHRvIDM2MClcbiAgICAgICAgLy8gdnN1ID0gVipTKmNvcyhIKlBJLzE4MCk7XG4gICAgICAgIC8vIHZzdyA9IFYqUypzaW4oSCpQSS8xODApO1xuICAgICAgICAvL1sgLjI5OVYrLjcwMXZzdSsuMTY4dnN3ICAgIC41ODdWLS41ODd2c3UrLjMzMHZzdyAgICAuMTE0Vi0uMTE0dnN1LS40OTd2c3cgXSBbUl1cbiAgICAgICAgLy9bIC4yOTlWLS4yOTl2c3UtLjMyOHZzdyAgICAuNTg3VisuNDEzdnN1Ky4wMzV2c3cgICAgLjExNFYtLjExNHZzdSsuMjkydnN3IF0qW0ddXG4gICAgICAgIC8vWyAuMjk5Vi0uMzAwdnN1KzEuMjV2c3cgICAgLjU4N1YtLjU4OHZzdS0xLjA1dnN3ICAgIC4xMTRWKy44ODZ2c3UtLjIwM3ZzdyBdIFtCXVxuXG4gICAgICAgIC8vIFByZWNvbXB1dGUgdGhlIHZhbHVlcyBpbiB0aGUgbWF0cml4OlxuICAgICAgICB2YXIgdnN1ID0gdiAqIHMgKiBNYXRoLmNvcyhoICogTWF0aC5QSSAvIDE4MCksXG4gICAgICAgICAgICB2c3cgPSB2ICogcyAqIE1hdGguc2luKGggKiBNYXRoLlBJIC8gMTgwKTtcbiAgICAgICAgLy8gKHJlc3VsdCBzcG90KShzb3VyY2Ugc3BvdClcbiAgICAgICAgdmFyIHJyID0gMC4yOTkgKiB2ICsgMC43MDEgKiB2c3UgKyAwLjE2NyAqIHZzdyxcbiAgICAgICAgICAgIHJnID0gMC41ODcgKiB2IC0gMC41ODcgKiB2c3UgKyAwLjMzMCAqIHZzdyxcbiAgICAgICAgICAgIHJiID0gMC4xMTQgKiB2IC0gMC4xMTQgKiB2c3UgLSAwLjQ5NyAqIHZzdztcbiAgICAgICAgdmFyIGdyID0gMC4yOTkgKiB2IC0gMC4yOTkgKiB2c3UgLSAwLjMyOCAqIHZzdyxcbiAgICAgICAgICAgIGdnID0gMC41ODcgKiB2ICsgMC40MTMgKiB2c3UgKyAwLjAzNSAqIHZzdyxcbiAgICAgICAgICAgIGdiID0gMC4xMTQgKiB2IC0gMC4xMTQgKiB2c3UgKyAwLjI5MyAqIHZzdztcbiAgICAgICAgdmFyIGJyID0gMC4yOTkgKiB2IC0gMC4zMDAgKiB2c3UgKyAxLjI1MCAqIHZzdyxcbiAgICAgICAgICAgIGJnID0gMC41ODcgKiB2IC0gMC41ODYgKiB2c3UgLSAxLjA1MCAqIHZzdyxcbiAgICAgICAgICAgIGJiID0gMC4xMTQgKiB2ICsgMC44ODYgKiB2c3UgLSAwLjIwMCAqIHZzdztcblxuICAgICAgICB2YXIgciwgZywgYiwgYTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgblBpeGVsczsgaSArPSA0KSB7XG4gICAgICAgICAgICByID0gZGF0YVtpICsgMF07XG4gICAgICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgICAgICBiID0gZGF0YVtpICsgMl07XG4gICAgICAgICAgICBhID0gZGF0YVtpICsgM107XG5cbiAgICAgICAgICAgIGRhdGFbaSArIDBdID0gcnIgKiByICsgcmcgKiBnICsgcmIgKiBiO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBnciAqIHIgKyBnZyAqIGcgKyBnYiAqIGI7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IGJyICogciArIGJnICogZyArIGJiICogYjtcbiAgICAgICAgICAgIGRhdGFbaSArIDNdID0gYTsgLy8gYWxwaGFcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdodWUnLCAwLCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcbiAgICAvKipcbiAgICAqIGdldC9zZXQgaHN2IGh1ZSBpbiBkZWdyZWVzLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5IU1Z9IG9yIHtAbGluayBLb252YS5GaWx0ZXJzLkhTTH0gZmlsdGVyLlxuICAgICogQG5hbWUgaHVlXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBodWUgdmFsdWUgYmV0d2VlbiAwIGFuZCAzNTlcbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdzYXR1cmF0aW9uJywgMCwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGhzdiBzYXR1cmF0aW9uLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5IU1Z9IG9yIHtAbGluayBLb252YS5GaWx0ZXJzLkhTTH0gZmlsdGVyLlxuICAgICogQG5hbWUgc2F0dXJhdGlvblxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvbiAwIGlzIG5vIGNoYW5nZSwgLTEuMCBoYWx2ZXMgdGhlIHNhdHVyYXRpb24sIDEuMCBkb3VibGVzLCBldGMuLlxuICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3ZhbHVlJywgMCwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGhzdiB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuSFNWfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSB2YWx1ZVxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgMCBpcyBubyBjaGFuZ2UsIC0xLjAgaGFsdmVzIHRoZSB2YWx1ZSwgMS4wIGRvdWJsZXMsIGV0Yy4uXG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICovXG5cbn0pKCk7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2h1ZScsIDAsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuICAgIC8qKlxuICAgICogZ2V0L3NldCBoc3YgaHVlIGluIGRlZ3JlZXMuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkhTVn0gb3Ige0BsaW5rIEtvbnZhLkZpbHRlcnMuSFNMfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSBodWVcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGh1ZSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDM1OVxuICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3NhdHVyYXRpb24nLCAwLCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcbiAgICAvKipcbiAgICAqIGdldC9zZXQgaHN2IHNhdHVyYXRpb24uIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkhTVn0gb3Ige0BsaW5rIEtvbnZhLkZpbHRlcnMuSFNMfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSBzYXR1cmF0aW9uXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBzYXR1cmF0aW9uIDAgaXMgbm8gY2hhbmdlLCAtMS4wIGhhbHZlcyB0aGUgc2F0dXJhdGlvbiwgMS4wIGRvdWJsZXMsIGV0Yy4uXG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnbHVtaW5hbmNlJywgMCwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGhzbCBsdW1pbmFuY2UuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkhTTH0gZmlsdGVyLlxuICAgICogQG5hbWUgdmFsdWVcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIDAgaXMgbm8gY2hhbmdlLCAtMS4wIGhhbHZlcyB0aGUgdmFsdWUsIDEuMCBkb3VibGVzLCBldGMuLlxuICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBIU0wgRmlsdGVyLiBBZGp1c3RzIHRoZSBodWUsIHNhdHVyYXRpb24gYW5kIGx1bWluYW5jZSAob3IgbGlnaHRuZXNzKVxuICAgICogQGZ1bmN0aW9uXG4gICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgICogQGF1dGhvciBpcHBvNjE1XG4gICAgKiBAZXhhbXBsZVxuICAgICogaW1hZ2UuZmlsdGVycyhbS29udmEuRmlsdGVycy5IU0xdKTtcbiAgICAqIGltYWdlLmx1bWluYW5jZSgyMDApO1xuICAgICovXG5cbiAgICBLb252YS5GaWx0ZXJzLkhTTCA9IGZ1bmN0aW9uIChpbWFnZURhdGEpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICAgIG5QaXhlbHMgPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIHYgPSAxLFxuICAgICAgICAgICAgcyA9IE1hdGgucG93KDIsIHRoaXMuc2F0dXJhdGlvbigpKSxcbiAgICAgICAgICAgIGggPSBNYXRoLmFicygodGhpcy5odWUoKSkgKyAzNjApICUgMzYwLFxuICAgICAgICAgICAgbCA9IHRoaXMubHVtaW5hbmNlKCkgKiAxMjcsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIC8vIEJhc2lzIGZvciB0aGUgdGVjaG5pcXVlIHVzZWQ6XG4gICAgICAgIC8vIGh0dHA6Ly9iZWVzYnV6ei5iaXovY29kZS9oc3ZfY29sb3JfdHJhbnNmb3Jtcy5waHBcbiAgICAgICAgLy8gViBpcyB0aGUgdmFsdWUgbXVsdGlwbGllciAoMSBmb3Igbm9uZSwgMiBmb3IgZG91YmxlLCAwLjUgZm9yIGhhbGYpXG4gICAgICAgIC8vIFMgaXMgdGhlIHNhdHVyYXRpb24gbXVsdGlwbGllciAoMSBmb3Igbm9uZSwgMiBmb3IgZG91YmxlLCAwLjUgZm9yIGhhbGYpXG4gICAgICAgIC8vIEggaXMgdGhlIGh1ZSBzaGlmdCBpbiBkZWdyZWVzICgwIHRvIDM2MClcbiAgICAgICAgLy8gdnN1ID0gVipTKmNvcyhIKlBJLzE4MCk7XG4gICAgICAgIC8vIHZzdyA9IFYqUypzaW4oSCpQSS8xODApO1xuICAgICAgICAvL1sgLjI5OVYrLjcwMXZzdSsuMTY4dnN3ICAgIC41ODdWLS41ODd2c3UrLjMzMHZzdyAgICAuMTE0Vi0uMTE0dnN1LS40OTd2c3cgXSBbUl1cbiAgICAgICAgLy9bIC4yOTlWLS4yOTl2c3UtLjMyOHZzdyAgICAuNTg3VisuNDEzdnN1Ky4wMzV2c3cgICAgLjExNFYtLjExNHZzdSsuMjkydnN3IF0qW0ddXG4gICAgICAgIC8vWyAuMjk5Vi0uMzAwdnN1KzEuMjV2c3cgICAgLjU4N1YtLjU4OHZzdS0xLjA1dnN3ICAgIC4xMTRWKy44ODZ2c3UtLjIwM3ZzdyBdIFtCXVxuXG4gICAgICAgIC8vIFByZWNvbXB1dGUgdGhlIHZhbHVlcyBpbiB0aGUgbWF0cml4OlxuICAgICAgICB2YXIgdnN1ID0gdiAqIHMgKiBNYXRoLmNvcyhoICogTWF0aC5QSSAvIDE4MCksXG4gICAgICAgICAgICB2c3cgPSB2ICogcyAqIE1hdGguc2luKGggKiBNYXRoLlBJIC8gMTgwKTtcbiAgICAgICAgLy8gKHJlc3VsdCBzcG90KShzb3VyY2Ugc3BvdClcbiAgICAgICAgdmFyIHJyID0gMC4yOTkgKiB2ICsgMC43MDEgKiB2c3UgKyAwLjE2NyAqIHZzdyxcbiAgICAgICAgICAgIHJnID0gMC41ODcgKiB2IC0gMC41ODcgKiB2c3UgKyAwLjMzMCAqIHZzdyxcbiAgICAgICAgICAgIHJiID0gMC4xMTQgKiB2IC0gMC4xMTQgKiB2c3UgLSAwLjQ5NyAqIHZzdztcbiAgICAgICAgdmFyIGdyID0gMC4yOTkgKiB2IC0gMC4yOTkgKiB2c3UgLSAwLjMyOCAqIHZzdyxcbiAgICAgICAgICAgIGdnID0gMC41ODcgKiB2ICsgMC40MTMgKiB2c3UgKyAwLjAzNSAqIHZzdyxcbiAgICAgICAgICAgIGdiID0gMC4xMTQgKiB2IC0gMC4xMTQgKiB2c3UgKyAwLjI5MyAqIHZzdztcbiAgICAgICAgdmFyIGJyID0gMC4yOTkgKiB2IC0gMC4zMDAgKiB2c3UgKyAxLjI1MCAqIHZzdyxcbiAgICAgICAgICAgIGJnID0gMC41ODcgKiB2IC0gMC41ODYgKiB2c3UgLSAxLjA1MCAqIHZzdyxcbiAgICAgICAgICAgIGJiID0gMC4xMTQgKiB2ICsgMC44ODYgKiB2c3UgLSAwLjIwMCAqIHZzdztcblxuICAgICAgICB2YXIgciwgZywgYiwgYTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgblBpeGVsczsgaSArPSA0KSB7XG4gICAgICAgICAgICByID0gZGF0YVtpICsgMF07XG4gICAgICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgICAgICBiID0gZGF0YVtpICsgMl07XG4gICAgICAgICAgICBhID0gZGF0YVtpICsgM107XG5cbiAgICAgICAgICAgIGRhdGFbaSArIDBdID0gcnIgKiByICsgcmcgKiBnICsgcmIgKiBiICsgbDtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZ3IgKiByICsgZ2cgKiBnICsgZ2IgKiBiICsgbDtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gYnIgKiByICsgYmcgKiBnICsgYmIgKiBiICsgbDtcbiAgICAgICAgICAgIGRhdGFbaSArIDNdID0gYTsgLy8gYWxwaGFcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBFbWJvc3MgRmlsdGVyLlxuICAgICAqIFBpeGFzdGljIExpYiAtIEVtYm9zcyBmaWx0ZXIgLSB2MC4xLjBcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMDggSmFjb2IgU2VpZGVsaW4sIGpzZWlkZWxpbkBuaWhpbG9naWMuZGssIGh0dHA6Ly9ibG9nLm5paGlsb2dpYy5kay9cbiAgICAgKiBMaWNlbnNlOiBbaHR0cDovL3d3dy5waXhhc3RpYy5jb20vbGliL2xpY2Vuc2UudHh0XVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgICAqIEBleGFtcGxlXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5FbWJvc3NdKTtcbiAgICAgKiBub2RlLmVtYm9zc1N0cmVuZ3RoKDAuOCk7XG4gICAgICogbm9kZS5lbWJvc3NXaGl0ZUxldmVsKDAuMyk7XG4gICAgICogbm9kZS5lbWJvc3NEaXJlY3Rpb24oJ3JpZ2h0Jyk7XG4gICAgICogbm9kZS5lbWJvc3NCbGVuZCh0cnVlKTtcbiAgICAgKi9cbiAgICBLb252YS5GaWx0ZXJzLkVtYm9zcyA9IGZ1bmN0aW9uIChpbWFnZURhdGEpIHtcblxuICAgICAgICAvLyBwaXhhc3RpYyBzdHJlbmd0aCBpcyBiZXR3ZWVuIDAgYW5kIDEwLiAgSSB3YW50IGl0IGJldHdlZW4gMCBhbmQgMVxuICAgICAgICAvLyBwaXhhc3RpYyBncmV5TGV2ZWwgaXMgYmV0d2VlbiAwIGFuZCAyNTUuICBJIHdhbnQgaXQgYmV0d2VlbiAwIGFuZCAxLiAgQWxzbyxcbiAgICAgICAgLy8gYSBtYXggdmFsdWUgb2YgZ3JleUxldmVsIHlpZWxkcyBhIHdoaXRlIGVtYm9zcywgYW5kIHRoZSBtaW4gdmFsdWUgeWllbGRzIGEgYmxhY2tcbiAgICAgICAgLy8gZW1ib3NzLiAgVGhlcmVmb3JlLCBJIGNoYW5nZWQgZ3JleUxldmVsIHRvIHdoaXRlTGV2ZWxcbiAgICAgICAgdmFyIHN0cmVuZ3RoID0gdGhpcy5lbWJvc3NTdHJlbmd0aCgpICogMTAsXG4gICAgICAgICAgICBncmV5TGV2ZWwgPSB0aGlzLmVtYm9zc1doaXRlTGV2ZWwoKSAqIDI1NSxcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IHRoaXMuZW1ib3NzRGlyZWN0aW9uKCksXG4gICAgICAgICAgICBibGVuZCA9IHRoaXMuZW1ib3NzQmxlbmQoKSxcbiAgICAgICAgICAgIGRpclkgPSAwLFxuICAgICAgICAgICAgZGlyWCA9IDAsXG4gICAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgICB3ID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgICAgaCA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgICB3NCA9IHcgKiA0LFxuICAgICAgICAgICAgeSA9IGg7XG5cbiAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ3RvcC1sZWZ0JzpcbiAgICAgICAgICAgICAgICBkaXJZID0gLTE7XG4gICAgICAgICAgICAgICAgZGlyWCA9IC0xO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICBkaXJZID0gLTE7XG4gICAgICAgICAgICAgICAgZGlyWCA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0b3AtcmlnaHQnOlxuICAgICAgICAgICAgICAgIGRpclkgPSAtMTtcbiAgICAgICAgICAgICAgICBkaXJYID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICBkaXJZID0gMDtcbiAgICAgICAgICAgICAgICBkaXJYID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbS1yaWdodCc6XG4gICAgICAgICAgICAgICAgZGlyWSA9IDE7XG4gICAgICAgICAgICAgICAgZGlyWCA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIGRpclkgPSAxO1xuICAgICAgICAgICAgICAgIGRpclggPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tLWxlZnQnOlxuICAgICAgICAgICAgICAgIGRpclkgPSAxO1xuICAgICAgICAgICAgICAgIGRpclggPSAtMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIGRpclkgPSAwO1xuICAgICAgICAgICAgICAgIGRpclggPSAtMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXRZID0gKHkgLSAxKSAqIHc0O1xuXG4gICAgICAgICAgICB2YXIgb3RoZXJZID0gZGlyWTtcbiAgICAgICAgICAgIGlmICh5ICsgb3RoZXJZIDwgMSl7XG4gICAgICAgICAgICAgICAgb3RoZXJZID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5ICsgb3RoZXJZID4gaCkge1xuICAgICAgICAgICAgICAgIG90aGVyWSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvZmZzZXRZT3RoZXIgPSAoeSAtIDEgKyBvdGhlclkpICogdyAqIDQ7XG5cbiAgICAgICAgICAgIHZhciB4ID0gdztcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0WSArICh4IC0gMSkgKiA0O1xuXG4gICAgICAgICAgICAgICAgdmFyIG90aGVyWCA9IGRpclg7XG4gICAgICAgICAgICAgICAgaWYgKHggKyBvdGhlclggPCAxKXtcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJYID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHggKyBvdGhlclggPiB3KSB7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyWCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldE90aGVyID0gb2Zmc2V0WU90aGVyICsgKHggLSAxICsgb3RoZXJYKSAqIDQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgZFIgPSBkYXRhW29mZnNldF0gLSBkYXRhW29mZnNldE90aGVyXTtcbiAgICAgICAgICAgICAgICB2YXIgZEcgPSBkYXRhW29mZnNldCArIDFdIC0gZGF0YVtvZmZzZXRPdGhlciArIDFdO1xuICAgICAgICAgICAgICAgIHZhciBkQiA9IGRhdGFbb2Zmc2V0ICsgMl0gLSBkYXRhW29mZnNldE90aGVyICsgMl07XG5cbiAgICAgICAgICAgICAgICB2YXIgZGlmID0gZFI7XG4gICAgICAgICAgICAgICAgdmFyIGFic0RpZiA9IGRpZiA+IDAgPyBkaWYgOiAtZGlmO1xuXG4gICAgICAgICAgICAgICAgdmFyIGFic0cgPSBkRyA+IDAgPyBkRyA6IC1kRztcbiAgICAgICAgICAgICAgICB2YXIgYWJzQiA9IGRCID4gMCA/IGRCIDogLWRCO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFic0cgPiBhYnNEaWYpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlmID0gZEc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhYnNCID4gYWJzRGlmKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZiA9IGRCO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRpZiAqPSBzdHJlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmIChibGVuZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGRhdGFbb2Zmc2V0XSArIGRpZjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGcgPSBkYXRhW29mZnNldCArIDFdICsgZGlmO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGRhdGFbb2Zmc2V0ICsgMl0gKyBkaWY7XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gKHIgPiAyNTUpID8gMjU1IDogKHIgPCAwID8gMCA6IHIpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIDFdID0gKGcgPiAyNTUpID8gMjU1IDogKGcgPCAwID8gMCA6IGcpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIDJdID0gKGIgPiAyNTUpID8gMjU1IDogKGIgPCAwID8gMCA6IGIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncmV5ID0gZ3JleUxldmVsIC0gZGlmO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JleSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyZXkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGdyZXkgPiAyNTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyZXkgPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldF0gPSBkYXRhW29mZnNldCArIDFdID0gZGF0YVtvZmZzZXQgKyAyXSA9IGdyZXk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IHdoaWxlICgtLXgpO1xuICAgICAgICB9IHdoaWxlICgtLXkpO1xuICAgIH07XG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZW1ib3NzU3RyZW5ndGgnLCAwLjUsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuICAgIC8qKlxuICAgICogZ2V0L3NldCBlbWJvc3Mgc3RyZW5ndGguIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkVtYm9zc30gZmlsdGVyLlxuICAgICogQG5hbWUgZW1ib3NzU3RyZW5ndGhcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIGJldHdlZW4gMCBhbmQgMS4gIERlZmF1bHQgaXMgMC41XG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZW1ib3NzV2hpdGVMZXZlbCcsIDAuNSwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGVtYm9zcyB3aGl0ZSBsZXZlbC4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuRW1ib3NzfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSBlbWJvc3NXaGl0ZUxldmVsXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbWJvc3NXaGl0ZUxldmVsIGJldHdlZW4gMCBhbmQgMS4gIERlZmF1bHQgaXMgMC41XG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZW1ib3NzRGlyZWN0aW9uJywgJ3RvcC1sZWZ0JywgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGVtYm9zcyBkaXJlY3Rpb24uIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkVtYm9zc30gZmlsdGVyLlxuICAgICogQG5hbWUgZW1ib3NzRGlyZWN0aW9uXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbWJvc3NEaXJlY3Rpb24gY2FuIGJlIHRvcC1sZWZ0LCB0b3AsIHRvcC1yaWdodCwgcmlnaHQsIGJvdHRvbS1yaWdodCwgYm90dG9tLCBib3R0b20tbGVmdCBvciBsZWZ0XG4gICAgKiAgIFRoZSBkZWZhdWx0IGlzIHRvcC1sZWZ0XG4gICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZW1ib3NzQmxlbmQnLCBmYWxzZSwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGVtYm9zcyBibGVuZC4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuRW1ib3NzfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSBlbWJvc3NCbGVuZFxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVtYm9zc0JsZW5kXG4gICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAqL1xufSkoKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgZnVuY3Rpb24gcmVtYXAoZnJvbVZhbHVlLCBmcm9tTWluLCBmcm9tTWF4LCB0b01pbiwgdG9NYXgpIHtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcbiAgICAgICAgdmFyIGZyb21SYW5nZSA9IGZyb21NYXggLSBmcm9tTWluLFxuICAgICAgICAgIHRvUmFuZ2UgPSB0b01heCAtIHRvTWluLFxuICAgICAgICAgIHRvVmFsdWU7XG5cbiAgICAgICAgLy8gSWYgZWl0aGVyIHJhbmdlIGlzIDAsIHRoZW4gdGhlIHZhbHVlIGNhbiBvbmx5IGJlIG1hcHBlZCB0byAxIHZhbHVlXG4gICAgICAgIGlmIChmcm9tUmFuZ2UgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0b01pbiArIHRvUmFuZ2UgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b1JhbmdlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9NaW47XG4gICAgICAgIH1cblxuICAgICAgICAvLyAoMSkgdW50cmFuc2xhdGUsICgyKSB1bnNjYWxlLCAoMykgcmVzY2FsZSwgKDQpIHJldHJhbnNsYXRlXG4gICAgICAgIHRvVmFsdWUgPSAoZnJvbVZhbHVlIC0gZnJvbU1pbikgLyBmcm9tUmFuZ2U7XG4gICAgICAgIHRvVmFsdWUgPSAodG9SYW5nZSAqIHRvVmFsdWUpICsgdG9NaW47XG5cbiAgICAgICAgcmV0dXJuIHRvVmFsdWU7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAqIEVuaGFuY2UgRmlsdGVyLiBBZGp1c3RzIHRoZSBjb2xvcnMgc28gdGhhdCB0aGV5IHNwYW4gdGhlIHdpZGVzdFxuICAgICogIHBvc3NpYmxlIHJhbmdlIChpZSAwLTI1NSkuIFBlcmZvcm1zIHcqaCBwaXhlbCByZWFkcyBhbmQgdypoIHBpeGVsXG4gICAgKiAgd3JpdGVzLlxuICAgICogQGZ1bmN0aW9uXG4gICAgKiBAbmFtZSBFbmhhbmNlXG4gICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgICogQGF1dGhvciBpcHBvNjE1XG4gICAgKiBAZXhhbXBsZVxuICAgICogbm9kZS5jYWNoZSgpO1xuICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkVuaGFuY2VdKTtcbiAgICAqIG5vZGUuZW5oYW5jZSgwLjQpO1xuICAgICovXG4gICAgS29udmEuRmlsdGVycy5FbmhhbmNlID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xuICAgICAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgICAgblN1YlBpeGVscyA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgck1pbiA9IGRhdGFbMF0sIHJNYXggPSByTWluLCByLFxuICAgICAgICAgICAgZ01pbiA9IGRhdGFbMV0sIGdNYXggPSBnTWluLCBnLFxuICAgICAgICAgICAgYk1pbiA9IGRhdGFbMl0sIGJNYXggPSBiTWluLCBiLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IGVuaGFuY2luZyBhbnl0aGluZyAtIGRvbid0IGRvIGFueSBjb21wdXRhdGlvblxuICAgICAgICB2YXIgZW5oYW5jZUFtb3VudCA9IHRoaXMuZW5oYW5jZSgpO1xuICAgICAgICBpZiggZW5oYW5jZUFtb3VudCA9PT0gMCApeyByZXR1cm47IH1cblxuICAgICAgICAvLyAxc3QgUGFzcyAtIGZpbmQgdGhlIG1pbiBhbmQgbWF4IGZvciBlYWNoIGNoYW5uZWw6XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuU3ViUGl4ZWxzOyBpICs9IDQpIHtcbiAgICAgICAgICAgIHIgPSBkYXRhW2kgKyAwXTtcbiAgICAgICAgICAgIGlmIChyIDwgck1pbikgeyByTWluID0gcjsgfVxuICAgICAgICAgICAgZWxzZSBpZiAociA+IHJNYXgpIHsgck1heCA9IHI7IH1cbiAgICAgICAgICAgIGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChnIDwgZ01pbikgeyBnTWluID0gZzsgfSBlbHNlXG4gICAgICAgICAgICBpZiAoZyA+IGdNYXgpIHsgZ01heCA9IGc7IH1cbiAgICAgICAgICAgIGIgPSBkYXRhW2kgKyAyXTtcbiAgICAgICAgICAgIGlmIChiIDwgYk1pbikgeyBiTWluID0gYjsgfSBlbHNlXG4gICAgICAgICAgICBpZiAoYiA+IGJNYXgpIHsgYk1heCA9IGI7IH1cbiAgICAgICAgICAgIC8vYSA9IGRhdGFbaSArIDNdO1xuICAgICAgICAgICAgLy9pZiAoYSA8IGFNaW4pIHsgYU1pbiA9IGE7IH0gZWxzZVxuICAgICAgICAgICAgLy9pZiAoYSA+IGFNYXgpIHsgYU1heCA9IGE7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG9ubHkgMSBsZXZlbCAtIGRvbid0IHJlbWFwXG4gICAgICAgIGlmKCByTWF4ID09PSByTWluICl7IHJNYXggPSAyNTU7IHJNaW4gPSAwOyB9XG4gICAgICAgIGlmKCBnTWF4ID09PSBnTWluICl7IGdNYXggPSAyNTU7IGdNaW4gPSAwOyB9XG4gICAgICAgIGlmKCBiTWF4ID09PSBiTWluICl7IGJNYXggPSAyNTU7IGJNaW4gPSAwOyB9XG5cbiAgICAgICAgdmFyIHJNaWQsIHJHb2FsTWF4LCByR29hbE1pbixcbiAgICAgICAgICAgIGdNaWQsIGdHb2FsTWF4LCBnR29hbE1pbixcbiAgICAgICAgICAgIGJNaWQsIGJHb2FsTWF4LCBiR29hbE1pbjtcblxuICAgICAgICAvLyBJZiB0aGUgZW5oYW5jZW1lbnQgaXMgcG9zaXRpdmUgLSBzdHJldGNoIHRoZSBoaXN0b2dyYW1cbiAgICAgICAgaWYgKCBlbmhhbmNlQW1vdW50ID4gMCApe1xuICAgICAgICAgICAgckdvYWxNYXggPSByTWF4ICsgZW5oYW5jZUFtb3VudCAqICgyNTUgLSByTWF4KTtcbiAgICAgICAgICAgIHJHb2FsTWluID0gck1pbiAtIGVuaGFuY2VBbW91bnQgKiAock1pbiAtIDApO1xuICAgICAgICAgICAgZ0dvYWxNYXggPSBnTWF4ICsgZW5oYW5jZUFtb3VudCAqICgyNTUgLSBnTWF4KTtcbiAgICAgICAgICAgIGdHb2FsTWluID0gZ01pbiAtIGVuaGFuY2VBbW91bnQgKiAoZ01pbiAtIDApO1xuICAgICAgICAgICAgYkdvYWxNYXggPSBiTWF4ICsgZW5oYW5jZUFtb3VudCAqICgyNTUgLSBiTWF4KTtcbiAgICAgICAgICAgIGJHb2FsTWluID0gYk1pbiAtIGVuaGFuY2VBbW91bnQgKiAoYk1pbiAtIDApO1xuICAgICAgICAvLyBJZiB0aGUgZW5oYW5jZW1lbnQgaXMgbmVnYXRpdmUgLSAgIGNvbXByZXNzIHRoZSBoaXN0b2dyYW1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJNaWQgPSAock1heCArIHJNaW4pICogMC41O1xuICAgICAgICAgICAgckdvYWxNYXggPSByTWF4ICsgZW5oYW5jZUFtb3VudCAqIChyTWF4IC0gck1pZCk7XG4gICAgICAgICAgICByR29hbE1pbiA9IHJNaW4gKyBlbmhhbmNlQW1vdW50ICogKHJNaW4gLSByTWlkKTtcbiAgICAgICAgICAgIGdNaWQgPSAoZ01heCArIGdNaW4pICogMC41O1xuICAgICAgICAgICAgZ0dvYWxNYXggPSBnTWF4ICsgZW5oYW5jZUFtb3VudCAqIChnTWF4IC0gZ01pZCk7XG4gICAgICAgICAgICBnR29hbE1pbiA9IGdNaW4gKyBlbmhhbmNlQW1vdW50ICogKGdNaW4gLSBnTWlkKTtcbiAgICAgICAgICAgIGJNaWQgPSAoYk1heCArIGJNaW4pICogMC41O1xuICAgICAgICAgICAgYkdvYWxNYXggPSBiTWF4ICsgZW5oYW5jZUFtb3VudCAqIChiTWF4IC0gYk1pZCk7XG4gICAgICAgICAgICBiR29hbE1pbiA9IGJNaW4gKyBlbmhhbmNlQW1vdW50ICogKGJNaW4gLSBiTWlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhc3MgMiAtIHJlbWFwIGV2ZXJ5dGhpbmcsIGV4Y2VwdCB0aGUgYWxwaGFcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5TdWJQaXhlbHM7IGkgKz0gNCkge1xuICAgICAgICAgICAgZGF0YVtpICsgMF0gPSByZW1hcChkYXRhW2kgKyAwXSwgck1pbiwgck1heCwgckdvYWxNaW4sIHJHb2FsTWF4KTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gcmVtYXAoZGF0YVtpICsgMV0sIGdNaW4sIGdNYXgsIGdHb2FsTWluLCBnR29hbE1heCk7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IHJlbWFwKGRhdGFbaSArIDJdLCBiTWluLCBiTWF4LCBiR29hbE1pbiwgYkdvYWxNYXgpO1xuICAgICAgICAgICAgLy9kYXRhW2kgKyAzXSA9IHJlbWFwKGRhdGFbaSArIDNdLCBhTWluLCBhTWF4LCBhR29hbE1pbiwgYUdvYWxNYXgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdlbmhhbmNlJywgMCwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG5cbiAgICAvKipcbiAgICAqIGdldC9zZXQgZW5oYW5jZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuRW5oYW5jZX0gZmlsdGVyLlxuICAgICogQG5hbWUgZW5oYW5jZVxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge0Zsb2F0fSBhbW91bnRcbiAgICAqIEByZXR1cm5zIHtGbG9hdH1cbiAgICAqL1xufSkoKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogUG9zdGVyaXplIEZpbHRlci4gQWRqdXN0cyB0aGUgY2hhbm5lbHMgc28gdGhhdCB0aGVyZSBhcmUgbm8gbW9yZVxuICAgICAqICB0aGFuIG4gZGlmZmVyZW50IHZhbHVlcyBmb3IgdGhhdCBjaGFubmVsLiBUaGlzIGlzIGFsc28gYXBwbGllZFxuICAgICAqICB0byB0aGUgYWxwaGEgY2hhbm5lbC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBQb3N0ZXJpemVcbiAgICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuUG9zdGVyaXplXSk7XG4gICAgICogbm9kZS5sZXZlbHMoMC44KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZpbHRlcnMuUG9zdGVyaXplID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xuICAgICAgICAvLyBsZXZlbCBtdXN0IGJlIGJldHdlZW4gMSBhbmQgMjU1XG4gICAgICAgIHZhciBsZXZlbHMgPSBNYXRoLnJvdW5kKHRoaXMubGV2ZWxzKCkgKiAyNTQpICsgMSxcbiAgICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgc2NhbGUgPSAoMjU1IC8gbGV2ZWxzKSxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBkYXRhW2ldID0gTWF0aC5mbG9vcihkYXRhW2ldIC8gc2NhbGUpICogc2NhbGU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2xldmVscycsIDAuNSwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG5cbiAgICAvKipcbiAgICAqIGdldC9zZXQgbGV2ZWxzLiAgTXVzdCBiZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuICBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5Qb3N0ZXJpemV9IGZpbHRlci5cbiAgICAqIEBuYW1lIGxldmVsc1xuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge051bWJlcn0gbGV2ZWwgYmV0d2VlbiAwIGFuZCAxXG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICovXG59KSgpO1xuXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTm9pc2UgRmlsdGVyLiBSYW5kb21seSBhZGRzIG9yIHN1YnN0cmFjdHMgdG8gdGhlIGNvbG9yIGNoYW5uZWxzXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBuYW1lIE5vaXNlXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxyXG4gICAgICogQGF1dGhvciBpcHBvNjE1XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogbm9kZS5jYWNoZSgpO1xyXG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLk5vaXNlXSk7XHJcbiAgICAgKiBub2RlLm5vaXNlKDAuOCk7XHJcbiAgICAgKi9cclxuICAgIEtvbnZhLkZpbHRlcnMuTm9pc2UgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgdmFyIGFtb3VudCA9IHRoaXMubm9pc2UoKSAqIDI1NSxcclxuICAgICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxyXG4gICAgICAgICAgICBuUGl4ZWxzID0gZGF0YS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGhhbGYgPSBhbW91bnQgLyAyLFxyXG4gICAgICAgICAgICBpO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgblBpeGVsczsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgIGRhdGFbaSArIDBdICs9IGhhbGYgLSAyICogaGFsZiAqIE1hdGgucmFuZG9tKCk7XHJcbiAgICAgICAgICAgIGRhdGFbaSArIDFdICs9IGhhbGYgLSAyICogaGFsZiAqIE1hdGgucmFuZG9tKCk7XHJcbiAgICAgICAgICAgIGRhdGFbaSArIDJdICs9IGhhbGYgLSAyICogaGFsZiAqIE1hdGgucmFuZG9tKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnbm9pc2UnLCAwLjIsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBnZXQvc2V0IG5vaXNlIGFtb3VudC4gIE11c3QgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLk5vaXNlfSBmaWx0ZXIuXHJcbiAgICAqIEBuYW1lIG5vaXNlXHJcbiAgICAqIEBtZXRob2RcclxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBub2lzZVxyXG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgKi9cclxufSkoKTtcclxuXG4vKmVzbGludC1kaXNhYmxlIG1heC1kZXB0aCAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQaXhlbGF0ZSBGaWx0ZXIuIEF2ZXJhZ2VzIGdyb3VwcyBvZiBwaXhlbHMgYW5kIHJlZHJhd3NcclxuICAgICAqICB0aGVtIGFzIGxhcmdlciBwaXhlbHNcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQG5hbWUgUGl4ZWxhdGVcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXHJcbiAgICAgKiBAYXV0aG9yIGlwcG82MTVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBub2RlLmNhY2hlKCk7XHJcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuUGl4ZWxhdGVdKTtcclxuICAgICAqIG5vZGUucGl4ZWxTaXplKDEwKTtcclxuICAgICAqL1xyXG5cclxuICAgIEtvbnZhLkZpbHRlcnMuUGl4ZWxhdGUgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XHJcblxyXG4gICAgICAgIHZhciBwaXhlbFNpemUgPSBNYXRoLmNlaWwodGhpcy5waXhlbFNpemUoKSksXHJcbiAgICAgICAgICAgIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0LFxyXG4gICAgICAgICAgICB4LCB5LCBpLFxyXG4gICAgICAgICAgICAvL3BpeGVsc1BlckJpbiA9IHBpeGVsU2l6ZSAqIHBpeGVsU2l6ZSxcclxuICAgICAgICAgICAgcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEsXHJcbiAgICAgICAgICAgIG5CaW5zWCA9IE1hdGguY2VpbCh3aWR0aCAvIHBpeGVsU2l6ZSksXHJcbiAgICAgICAgICAgIG5CaW5zWSA9IE1hdGguY2VpbChoZWlnaHQgLyBwaXhlbFNpemUpLFxyXG4gICAgICAgICAgICB4QmluU3RhcnQsIHhCaW5FbmQsIHlCaW5TdGFydCwgeUJpbkVuZCxcclxuICAgICAgICAgICAgeEJpbiwgeUJpbiwgcGl4ZWxzSW5CaW47XHJcbiAgICAgICAgaW1hZ2VEYXRhID0gaW1hZ2VEYXRhLmRhdGE7XHJcblxyXG4gICAgICAgIGZvciAoeEJpbiA9IDA7IHhCaW4gPCBuQmluc1g7IHhCaW4gKz0gMSkge1xyXG4gICAgICAgICAgICBmb3IgKHlCaW4gPSAwOyB5QmluIDwgbkJpbnNZOyB5QmluICs9IDEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBjb2xvciBhY2N1bWxhdG9ycyB0byAwXHJcbiAgICAgICAgICAgICAgICByZWQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZ3JlZW4gPSAwO1xyXG4gICAgICAgICAgICAgICAgYmx1ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBhbHBoYSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHBpeGVscyBhcmUgaW5jbHVkZWQgaW4gdGhpcyBiaW5cclxuICAgICAgICAgICAgICAgIHhCaW5TdGFydCA9IHhCaW4gKiBwaXhlbFNpemU7XHJcbiAgICAgICAgICAgICAgICB4QmluRW5kID0geEJpblN0YXJ0ICsgcGl4ZWxTaXplO1xyXG4gICAgICAgICAgICAgICAgeUJpblN0YXJ0ID0geUJpbiAqIHBpeGVsU2l6ZTtcclxuICAgICAgICAgICAgICAgIHlCaW5FbmQgPSB5QmluU3RhcnQgKyBwaXhlbFNpemU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIGFsbCBvZiB0aGUgcGl4ZWxzIHRvIHRoaXMgYmluIVxyXG4gICAgICAgICAgICAgICAgcGl4ZWxzSW5CaW4gPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yICh4ID0geEJpblN0YXJ0OyB4IDwgeEJpbkVuZDsgeCArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIHggPj0gd2lkdGggKXsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHkgPSB5QmluU3RhcnQ7IHkgPCB5QmluRW5kOyB5ICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIHkgPj0gaGVpZ2h0ICl7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAod2lkdGggKiB5ICsgeCkgKiA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWQgKz0gaW1hZ2VEYXRhW2kgKyAwXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JlZW4gKz0gaW1hZ2VEYXRhW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmx1ZSArPSBpbWFnZURhdGFbaSArIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYSArPSBpbWFnZURhdGFbaSArIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbHNJbkJpbiArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNoYW5uZWxzIGFyZSBiZXR3ZWVuIDAtMjU1XHJcbiAgICAgICAgICAgICAgICByZWQgPSByZWQgLyBwaXhlbHNJbkJpbjtcclxuICAgICAgICAgICAgICAgIGdyZWVuID0gZ3JlZW4gLyBwaXhlbHNJbkJpbjtcclxuICAgICAgICAgICAgICAgIGJsdWUgPSBibHVlIC8gcGl4ZWxzSW5CaW47XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRHJhdyB0aGlzIGJpblxyXG4gICAgICAgICAgICAgICAgZm9yICh4ID0geEJpblN0YXJ0OyB4IDwgeEJpbkVuZDsgeCArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIHggPj0gd2lkdGggKXsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHkgPSB5QmluU3RhcnQ7IHkgPCB5QmluRW5kOyB5ICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIHkgPj0gaGVpZ2h0ICl7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAod2lkdGggKiB5ICsgeCkgKiA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGFbaSArIDBdID0gcmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGFbaSArIDFdID0gZ3JlZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YVtpICsgMl0gPSBibHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGFbaSArIDNdID0gYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3BpeGVsU2l6ZScsIDgsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBnZXQvc2V0IHBpeGVsIHNpemUuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLlBpeGVsYXRlfSBmaWx0ZXIuXHJcbiAgICAqIEBuYW1lIHBpeGVsU2l6ZVxyXG4gICAgKiBAbWV0aG9kXHJcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgKiBAcGFyYW0ge0ludGVnZXJ9IHBpeGVsU2l6ZVxyXG4gICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cclxuICAgICovXHJcbn0pKCk7XHJcblxuKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8qKlxyXG4gICAgICogVGhyZXNob2xkIEZpbHRlci4gUHVzaGVzIGFueSB2YWx1ZSBhYm92ZSB0aGUgbWlkIHBvaW50IHRvXHJcbiAgICAgKiAgdGhlIG1heCBhbmQgYW55IHZhbHVlIGJlbG93IHRoZSBtaWQgcG9pbnQgdG8gdGhlIG1pbi5cclxuICAgICAqICBUaGlzIGFmZmVjdHMgdGhlIGFscGhhIGNoYW5uZWwuXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBuYW1lIFRocmVzaG9sZFxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcclxuICAgICAqIEBhdXRob3IgaXBwbzYxNVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIG5vZGUuY2FjaGUoKTtcclxuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5UaHJlc2hvbGRdKTtcclxuICAgICAqIG5vZGUudGhyZXNob2xkKDAuMSk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GaWx0ZXJzLlRocmVzaG9sZCA9IGZ1bmN0aW9uIChpbWFnZURhdGEpIHtcclxuICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLnRocmVzaG9sZCgpICogMjU1LFxyXG4gICAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXHJcbiAgICAgICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoLFxyXG4gICAgICAgICAgICBpO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgZGF0YVtpXSA9IGRhdGFbaV0gPCBsZXZlbCA/IDAgOiAyNTU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAndGhyZXNob2xkJywgMC41LCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcclxuXHJcbiAgICAvKipcclxuICAgICogZ2V0L3NldCB0aHJlc2hvbGQuICBNdXN0IGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5UaHJlc2hvbGR9IG9yIHtAbGluayBLb252YS5GaWx0ZXJzLk1hc2t9IGZpbHRlci5cclxuICAgICogQG5hbWUgdGhyZXNob2xkXHJcbiAgICAqIEBtZXRob2RcclxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXHJcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aHJlc2hvbGRcclxuICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICovXHJcbn0pKCk7XHJcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBTZXBpYSBGaWx0ZXJcbiAgICAgKiBCYXNlZCBvbjogUGl4YXN0aWMgTGliIC0gU2VwaWEgZmlsdGVyIC0gdjAuMS4wXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDA4IEphY29iIFNlaWRlbGluLCBqc2VpZGVsaW5AbmloaWxvZ2ljLmRrLCBodHRwOi8vYmxvZy5uaWhpbG9naWMuZGsvXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgU2VwaWFcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAgKiBAYXV0aG9yIEphY29iIFNlaWRlbGluIDxqc2VpZGVsaW5AbmloaWxvZ2ljLmRrPlxuICAgICAqIEBsaWNlbnNlIE1QTCB2MS4xIFtodHRwOi8vd3d3LnBpeGFzdGljLmNvbS9saWIvbGljZW5zZS50eHRdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBub2RlLmNhY2hlKCk7XG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLlNlcGlhXSk7XG4gICAgICovXG4gICAgS29udmEuRmlsdGVycy5TZXBpYSA9IGZ1bmN0aW9uIChpbWFnZURhdGEpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICAgIHcgPSBpbWFnZURhdGEud2lkdGgsXG4gICAgICAgICAgICB5ID0gaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgICAgICAgIHc0ID0gdyAqIDQsXG4gICAgICAgICAgICBvZmZzZXRZLCB4LCBvZmZzZXQsIG9yLCBvZywgb2IsIHIsIGcsIGI7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgb2Zmc2V0WSA9ICh5IC0gMSkgKiB3NDtcbiAgICAgICAgICAgIHggPSB3O1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG9mZnNldFkgKyAoeCAtIDEpICogNDtcblxuICAgICAgICAgICAgICAgIG9yID0gZGF0YVtvZmZzZXRdO1xuICAgICAgICAgICAgICAgIG9nID0gZGF0YVtvZmZzZXQgKyAxXTtcbiAgICAgICAgICAgICAgICBvYiA9IGRhdGFbb2Zmc2V0ICsgMl07XG5cbiAgICAgICAgICAgICAgICByID0gb3IgKiAwLjM5MyArIG9nICogMC43NjkgKyBvYiAqIDAuMTg5O1xuICAgICAgICAgICAgICAgIGcgPSBvciAqIDAuMzQ5ICsgb2cgKiAwLjY4NiArIG9iICogMC4xNjg7XG4gICAgICAgICAgICAgICAgYiA9IG9yICogMC4yNzIgKyBvZyAqIDAuNTM0ICsgb2IgKiAwLjEzMTtcblxuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IHIgPiAyNTUgPyAyNTUgOiByO1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgMV0gPSBnID4gMjU1ID8gMjU1IDogZztcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIDJdID0gYiA+IDI1NSA/IDI1NSA6IGI7XG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAzXSA9IGRhdGFbb2Zmc2V0ICsgM107XG4gICAgICAgICAgICB9IHdoaWxlICgtLXgpO1xuICAgICAgICB9IHdoaWxlICgtLXkpO1xuICAgIH07XG59KSgpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBTb2xhcml6ZSBGaWx0ZXJcbiAgICAgKiBQaXhhc3RpYyBMaWIgLSBTb2xhcml6ZSBmaWx0ZXIgLSB2MC4xLjBcbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMDggSmFjb2IgU2VpZGVsaW4sIGpzZWlkZWxpbkBuaWhpbG9naWMuZGssIGh0dHA6Ly9ibG9nLm5paGlsb2dpYy5kay9cbiAgICAgKiBMaWNlbnNlOiBbaHR0cDovL3d3dy5waXhhc3RpYy5jb20vbGliL2xpY2Vuc2UudHh0XVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIFNvbGFyaXplXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBub2RlLmNhY2hlKCk7XG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLlNvbGFyaXplXSk7XG4gICAgICovXG4gICAgS29udmEuRmlsdGVycy5Tb2xhcml6ZSA9IGZ1bmN0aW9uIChpbWFnZURhdGEpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICAgIHcgPSBpbWFnZURhdGEud2lkdGgsXG4gICAgICAgICAgICBoID0gaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgICAgICAgIHc0ID0gdyAqIDQsXG4gICAgICAgICAgICB5ID0gaDtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0WSA9ICh5IC0gMSkgKiB3NDtcbiAgICAgICAgICAgIHZhciB4ID0gdztcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0WSArICh4IC0gMSkgKiA0O1xuICAgICAgICAgICAgICAgIHZhciByID0gZGF0YVtvZmZzZXRdO1xuICAgICAgICAgICAgICAgIHZhciBnID0gZGF0YVtvZmZzZXQgKyAxXTtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGRhdGFbb2Zmc2V0ICsgMl07XG5cbiAgICAgICAgICAgICAgICBpZiAociA+IDEyNykge1xuICAgICAgICAgICAgICAgICAgICByID0gMjU1IC0gcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGcgPiAxMjcpIHtcbiAgICAgICAgICAgICAgICAgICAgZyA9IDI1NSAtIGc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiID4gMTI3KSB7XG4gICAgICAgICAgICAgICAgICAgIGIgPSAyNTUgLSBiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IHI7XG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAxXSA9IGc7XG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAyXSA9IGI7XG4gICAgICAgICAgICB9IHdoaWxlICgtLXgpO1xuICAgICAgICB9IHdoaWxlICgtLXkpO1xuICAgIH07XG59KSgpO1xuXG5cblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgLypcbiAgICogVG9Qb2xhciBGaWx0ZXIuIENvbnZlcnRzIGltYWdlIGRhdGEgdG8gcG9sYXIgY29vcmRpbmF0ZXMuIFBlcmZvcm1zXG4gICAqICB3KmgqNCBwaXhlbCByZWFkcyBhbmQgdypoIHBpeGVsIHdyaXRlcy4gVGhlIHIgYXhpcyBpcyBwbGFjZWQgYWxvbmdcbiAgICogIHdoYXQgd291bGQgYmUgdGhlIHkgYXhpcyBhbmQgdGhlIHRoZXRhIGF4aXMgYWxvbmcgdGhlIHggYXhpcy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBhdXRob3IgaXBwbzYxNVxuICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gc3JjLCB0aGUgc291cmNlIGltYWdlIGRhdGEgKHdoYXQgd2lsbCBiZSB0cmFuc2Zvcm1lZClcbiAgICogQHBhcmFtIHtJbWFnZURhdGF9IGRzdCwgdGhlIGRlc3RpbmF0aW9uIGltYWdlIGRhdGEgKHdoZXJlIGl0IHdpbGwgYmUgc2F2ZWQpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHQucG9sYXJDZW50ZXJYXSBob3Jpem9udGFsIGxvY2F0aW9uIGZvciB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUsXG4gICAqICBkZWZhdWx0IGlzIGluIHRoZSBtaWRkbGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHQucG9sYXJDZW50ZXJZXSB2ZXJ0aWNhbCBsb2NhdGlvbiBmb3IgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlLFxuICAgKiAgZGVmYXVsdCBpcyBpbiB0aGUgbWlkZGxlXG4gICAqL1xuXG4gICAgdmFyIFRvUG9sYXIgPSBmdW5jdGlvbihzcmMsIGRzdCwgb3B0KXtcblxuICAgICAgICB2YXIgc3JjUGl4ZWxzID0gc3JjLmRhdGEsXG4gICAgICAgICAgICBkc3RQaXhlbHMgPSBkc3QuZGF0YSxcbiAgICAgICAgICAgIHhTaXplID0gc3JjLndpZHRoLFxuICAgICAgICAgICAgeVNpemUgPSBzcmMuaGVpZ2h0LFxuICAgICAgICAgICAgeE1pZCA9IG9wdC5wb2xhckNlbnRlclggfHwgeFNpemUgLyAyLFxuICAgICAgICAgICAgeU1pZCA9IG9wdC5wb2xhckNlbnRlclkgfHwgeVNpemUgLyAyLFxuICAgICAgICAgICAgaSwgeCwgeSwgciA9IDAsIGcgPSAwLCBiID0gMCwgYSA9IDA7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgbGFyZ2VzdCByYWRpdXNcbiAgICAgICAgdmFyIHJhZCwgck1heCA9IE1hdGguc3FydCggeE1pZCAqIHhNaWQgKyB5TWlkICogeU1pZCApO1xuICAgICAgICB4ID0geFNpemUgLSB4TWlkO1xuICAgICAgICB5ID0geVNpemUgLSB5TWlkO1xuICAgICAgICByYWQgPSBNYXRoLnNxcnQoIHggKiB4ICsgeSAqIHkgKTtcbiAgICAgICAgck1heCA9IChyYWQgPiByTWF4KSA/IHJhZCA6IHJNYXg7XG5cbiAgICAgICAgLy8gV2UnbGwgYmUgdWlzbmcgeSBhcyB0aGUgcmFkaXVzLCBhbmQgeCBhcyB0aGUgYW5nbGUgKHRoZXRhPXQpXG4gICAgICAgIHZhciByU2l6ZSA9IHlTaXplLFxuICAgICAgICAgICAgdFNpemUgPSB4U2l6ZSxcbiAgICAgICAgICAgIHJhZGl1cywgdGhldGE7XG5cbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb3ZlciBhbGwgYW5nbGVzICgwLTM2MCkgYW5kIHdlIG5lZWQgdG8gY29udmVydCB0b1xuICAgICAgICAvLyByYWRpYW5zICgqUEkvMTgwKVxuICAgICAgICB2YXIgY29udmVyc2lvbiA9IDM2MCAvIHRTaXplICogTWF0aC5QSSAvIDE4MCwgc2luLCBjb3M7XG5cbiAgICAgICAgLy8gdmFyIHgxLCB4MiwgeDFpLCB4MmksIHkxLCB5MiwgeTFpLCB5MmksIHNjYWxlO1xuXG4gICAgICAgIGZvciggdGhldGEgPSAwOyB0aGV0YSA8IHRTaXplOyB0aGV0YSArPSAxICl7XG4gICAgICAgICAgICBzaW4gPSBNYXRoLnNpbih0aGV0YSAqIGNvbnZlcnNpb24pO1xuICAgICAgICAgICAgY29zID0gTWF0aC5jb3ModGhldGEgKiBjb252ZXJzaW9uKTtcbiAgICAgICAgICAgIGZvciggcmFkaXVzID0gMDsgcmFkaXVzIDwgclNpemU7IHJhZGl1cyArPSAxICl7XG4gICAgICAgICAgICAgICAgeCA9IE1hdGguZmxvb3IoeE1pZCArIHJNYXggKiByYWRpdXMgLyByU2l6ZSAqIGNvcyk7XG4gICAgICAgICAgICAgICAgeSA9IE1hdGguZmxvb3IoeU1pZCArIHJNYXggKiByYWRpdXMgLyByU2l6ZSAqIHNpbik7XG4gICAgICAgICAgICAgICAgaSA9ICh5ICogeFNpemUgKyB4KSAqIDQ7XG4gICAgICAgICAgICAgICAgciA9IHNyY1BpeGVsc1tpICsgMF07XG4gICAgICAgICAgICAgICAgZyA9IHNyY1BpeGVsc1tpICsgMV07XG4gICAgICAgICAgICAgICAgYiA9IHNyY1BpeGVsc1tpICsgMl07XG4gICAgICAgICAgICAgICAgYSA9IHNyY1BpeGVsc1tpICsgM107XG5cbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBpdFxuICAgICAgICAgICAgICAgIC8vaSA9ICh0aGV0YSAqIHhTaXplICArICByYWRpdXMpICogNDtcbiAgICAgICAgICAgICAgICBpID0gKHRoZXRhICsgcmFkaXVzICogeFNpemUpICogNDtcbiAgICAgICAgICAgICAgICBkc3RQaXhlbHNbaSArIDBdID0gcjtcbiAgICAgICAgICAgICAgICBkc3RQaXhlbHNbaSArIDFdID0gZztcbiAgICAgICAgICAgICAgICBkc3RQaXhlbHNbaSArIDJdID0gYjtcbiAgICAgICAgICAgICAgICBkc3RQaXhlbHNbaSArIDNdID0gYTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogRnJvbVBvbGFyIEZpbHRlci4gQ29udmVydHMgaW1hZ2UgZGF0YSBmcm9tIHBvbGFyIGNvb3JkaW5hdGVzIGJhY2sgdG8gcmVjdGFuZ3VsYXIuXG4gICAgICogIFBlcmZvcm1zIHcqaCo0IHBpeGVsIHJlYWRzIGFuZCB3KmggcGl4ZWwgd3JpdGVzLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBhdXRob3IgaXBwbzYxNVxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IHNyYywgdGhlIHNvdXJjZSBpbWFnZSBkYXRhICh3aGF0IHdpbGwgYmUgdHJhbnNmb3JtZWQpXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IGRzdCwgdGhlIGRlc3RpbmF0aW9uIGltYWdlIGRhdGEgKHdoZXJlIGl0IHdpbGwgYmUgc2F2ZWQpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0LnBvbGFyQ2VudGVyWF0gaG9yaXpvbnRhbCBsb2NhdGlvbiBmb3IgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlLFxuICAgICAqICBkZWZhdWx0IGlzIGluIHRoZSBtaWRkbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdC5wb2xhckNlbnRlclldIHZlcnRpY2FsIGxvY2F0aW9uIGZvciB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUsXG4gICAgICogIGRlZmF1bHQgaXMgaW4gdGhlIG1pZGRsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0LnBvbGFyUm90YXRpb25dIGFtb3VudCB0byByb3RhdGUgdGhlIGltYWdlIGNvdW50ZXJjbG9ja3dpcyxcbiAgICAgKiAgMCBpcyBubyByb3RhdGlvbiwgMzYwIGRlZ3JlZXMgaXMgYSBmdWxsIHJvdGF0aW9uXG4gICAgICovXG5cbiAgICB2YXIgRnJvbVBvbGFyID0gZnVuY3Rpb24oc3JjLCBkc3QsIG9wdCl7XG5cbiAgICAgICAgdmFyIHNyY1BpeGVscyA9IHNyYy5kYXRhLFxuICAgICAgICAgICAgZHN0UGl4ZWxzID0gZHN0LmRhdGEsXG4gICAgICAgICAgICB4U2l6ZSA9IHNyYy53aWR0aCxcbiAgICAgICAgICAgIHlTaXplID0gc3JjLmhlaWdodCxcbiAgICAgICAgICAgIHhNaWQgPSBvcHQucG9sYXJDZW50ZXJYIHx8IHhTaXplIC8gMixcbiAgICAgICAgICAgIHlNaWQgPSBvcHQucG9sYXJDZW50ZXJZIHx8IHlTaXplIC8gMixcbiAgICAgICAgICAgIGksIHgsIHksIGR4LCBkeSwgciA9IDAsIGcgPSAwLCBiID0gMCwgYSA9IDA7XG5cblxuICAgICAgICAvLyBGaW5kIHRoZSBsYXJnZXN0IHJhZGl1c1xuICAgICAgICB2YXIgcmFkLCByTWF4ID0gTWF0aC5zcXJ0KCB4TWlkICogeE1pZCArIHlNaWQgKiB5TWlkICk7XG4gICAgICAgIHggPSB4U2l6ZSAtIHhNaWQ7XG4gICAgICAgIHkgPSB5U2l6ZSAtIHlNaWQ7XG4gICAgICAgIHJhZCA9IE1hdGguc3FydCggeCAqIHggKyB5ICogeSApO1xuICAgICAgICByTWF4ID0gKHJhZCA+IHJNYXgpID8gcmFkIDogck1heDtcblxuICAgICAgICAvLyBXZSdsbCBiZSB1aXNuZyB4IGFzIHRoZSByYWRpdXMsIGFuZCB5IGFzIHRoZSBhbmdsZSAodGhldGE9dClcbiAgICAgICAgdmFyIHJTaXplID0geVNpemUsXG4gICAgICAgIHRTaXplID0geFNpemUsXG4gICAgICAgIHJhZGl1cywgdGhldGEsXG4gICAgICAgIHBoYXNlU2hpZnQgPSBvcHQucG9sYXJSb3RhdGlvbiB8fCAwO1xuXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gY29udmVydCB0byBkZWdyZWVzIGFuZCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZVxuICAgICAgICAvLyBpdCdzIGJldHdlZW4gKDAtMzYwKVxuICAgICAgICAvLyB2YXIgY29udmVyc2lvbiA9IHRTaXplLzM2MCoxODAvTWF0aC5QSTtcbiAgICAgICAgLy92YXIgY29udmVyc2lvbiA9IHRTaXplLzM2MCoxODAvTWF0aC5QSTtcblxuICAgICAgICB2YXIgeDEsIHkxO1xuXG4gICAgICAgIGZvciggeCA9IDA7IHggPCB4U2l6ZTsgeCArPSAxICl7XG4gICAgICAgICAgICBmb3IoIHkgPSAwOyB5IDwgeVNpemU7IHkgKz0gMSApe1xuICAgICAgICAgICAgICAgIGR4ID0geCAtIHhNaWQ7XG4gICAgICAgICAgICAgICAgZHkgPSB5IC0geU1pZDtcbiAgICAgICAgICAgICAgICByYWRpdXMgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpICogclNpemUgLyByTWF4O1xuICAgICAgICAgICAgICAgIHRoZXRhID0gKE1hdGguYXRhbjIoZHksIGR4KSAqIDE4MCAvIE1hdGguUEkgKyAzNjAgKyBwaGFzZVNoaWZ0KSAlIDM2MDtcbiAgICAgICAgICAgICAgICB0aGV0YSA9IHRoZXRhICogdFNpemUgLyAzNjA7XG4gICAgICAgICAgICAgICAgeDEgPSBNYXRoLmZsb29yKHRoZXRhKTtcbiAgICAgICAgICAgICAgICB5MSA9IE1hdGguZmxvb3IocmFkaXVzKTtcbiAgICAgICAgICAgICAgICBpID0gKHkxICogeFNpemUgKyB4MSkgKiA0O1xuICAgICAgICAgICAgICAgIHIgPSBzcmNQaXhlbHNbaSArIDBdO1xuICAgICAgICAgICAgICAgIGcgPSBzcmNQaXhlbHNbaSArIDFdO1xuICAgICAgICAgICAgICAgIGIgPSBzcmNQaXhlbHNbaSArIDJdO1xuICAgICAgICAgICAgICAgIGEgPSBzcmNQaXhlbHNbaSArIDNdO1xuXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgaXRcbiAgICAgICAgICAgICAgICBpID0gKHkgKiB4U2l6ZSArIHgpICogNDtcbiAgICAgICAgICAgICAgICBkc3RQaXhlbHNbaSArIDBdID0gcjtcbiAgICAgICAgICAgICAgICBkc3RQaXhlbHNbaSArIDFdID0gZztcbiAgICAgICAgICAgICAgICBkc3RQaXhlbHNbaSArIDJdID0gYjtcbiAgICAgICAgICAgICAgICBkc3RQaXhlbHNbaSArIDNdID0gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vS29udmEuRmlsdGVycy5Ub1BvbGFyID0gS29udmEuVXRpbC5fRmlsdGVyV3JhcERvdWJsZUJ1ZmZlcihUb1BvbGFyKTtcbiAgICAvL0tvbnZhLkZpbHRlcnMuRnJvbVBvbGFyID0gS29udmEuVXRpbC5fRmlsdGVyV3JhcERvdWJsZUJ1ZmZlcihGcm9tUG9sYXIpO1xuXG4gICAgLy8gY3JlYXRlIGEgdGVtcG9yYXJ5IGNhbnZhcyBmb3Igd29ya2luZyAtIHNoYXJlZCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzXG4gICAgdmFyIHRlbXBDYW52YXMgPSBLb252YS5VdGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcblxuICAgIC8qXG4gICAgICogS2FsZWlkb3Njb3BlIEZpbHRlci5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBLYWxlaWRvc2NvcGVcbiAgICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBleGFtcGxlXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5LYWxlaWRvc2NvcGVdKTtcbiAgICAgKiBub2RlLmthbGVpZG9zY29wZVBvd2VyKDMpO1xuICAgICAqIG5vZGUua2FsZWlkb3Njb3BlQW5nbGUoNDUpO1xuICAgICAqL1xuICAgIEtvbnZhLkZpbHRlcnMuS2FsZWlkb3Njb3BlID0gZnVuY3Rpb24oaW1hZ2VEYXRhKXtcbiAgICAgICAgdmFyIHhTaXplID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgICAgeVNpemUgPSBpbWFnZURhdGEuaGVpZ2h0O1xuXG4gICAgICAgIHZhciB4LCB5LCB4b2ZmLCBpLCByLCBnLCBiLCBhLCBzcmNQb3MsIGRzdFBvcztcbiAgICAgICAgdmFyIHBvd2VyID0gTWF0aC5yb3VuZCggdGhpcy5rYWxlaWRvc2NvcGVQb3dlcigpICk7XG4gICAgICAgIHZhciBhbmdsZSA9IE1hdGgucm91bmQoIHRoaXMua2FsZWlkb3Njb3BlQW5nbGUoKSApO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gTWF0aC5mbG9vcih4U2l6ZSAqIChhbmdsZSAlIDM2MCkgLyAzNjApO1xuXG4gICAgICAgIGlmKCBwb3dlciA8IDEgKXtyZXR1cm47IH1cblxuICAgICAgICAvLyBXb3JrIHdpdGggb3VyIHNoYXJlZCBidWZmZXIgY2FudmFzXG4gICAgICAgIHRlbXBDYW52YXMud2lkdGggPSB4U2l6ZTtcbiAgICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSB5U2l6ZTtcbiAgICAgICAgdmFyIHNjcmF0Y2hEYXRhID0gdGVtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmdldEltYWdlRGF0YSgwLCAwLCB4U2l6ZSwgeVNpemUpO1xuXG4gICAgICAgIC8vIENvbnZlcnQgdGhoZSBvcmlnaW5hbCB0byBwb2xhciBjb29yZGluYXRlc1xuICAgICAgICBUb1BvbGFyKCBpbWFnZURhdGEsIHNjcmF0Y2hEYXRhLCB7XG4gICAgICAgICAgICBwb2xhckNlbnRlclg6IHhTaXplIC8gMixcbiAgICAgICAgICAgIHBvbGFyQ2VudGVyWTogeVNpemUgLyAyXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIERldGVybWluZSBob3cgYmlnIGVhY2ggc2VjdGlvbiB3aWxsIGJlLCBpZiBpdCdzIHRvbyBzbWFsbFxuICAgICAgICAvLyBtYWtlIGl0IGJpZ2dlclxuICAgICAgICB2YXIgbWluU2VjdGlvblNpemUgPSB4U2l6ZSAvIE1hdGgucG93KDIsIHBvd2VyKTtcbiAgICAgICAgd2hpbGUoIG1pblNlY3Rpb25TaXplIDw9IDgpe1xuICAgICAgICAgICAgbWluU2VjdGlvblNpemUgPSBtaW5TZWN0aW9uU2l6ZSAqIDI7XG4gICAgICAgICAgICBwb3dlciAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIG1pblNlY3Rpb25TaXplID0gTWF0aC5jZWlsKG1pblNlY3Rpb25TaXplKTtcbiAgICAgICAgdmFyIHNlY3Rpb25TaXplID0gbWluU2VjdGlvblNpemU7XG5cbiAgICAgICAgLy8gQ29weSB0aGUgb2Zmc2V0IHJlZ2lvbiB0byAwXG4gICAgICAgIC8vIERlcGVuZGluZyBvbiB0aGUgc2l6ZSBvZiBmaWx0ZXIgYW5kIGxvY2F0aW9uIG9mIHRoZSBvZmZzZXQgd2UgbWF5IG5lZWRcbiAgICAgICAgLy8gdG8gY29weSB0aGUgc2VjdGlvbiBiYWNrd2FyZHMgdG8gcHJldmVudCBpdCBmcm9tIHJld3JpdGluZyBpdHNlbGZcbiAgICAgICAgdmFyIHhTdGFydCA9IDAsXG4gICAgICAgICAgeEVuZCA9IHNlY3Rpb25TaXplLFxuICAgICAgICAgIHhEZWx0YSA9IDE7XG4gICAgICAgIGlmKCBvZmZzZXQgKyBtaW5TZWN0aW9uU2l6ZSA+IHhTaXplICl7XG4gICAgICAgICAgICB4U3RhcnQgPSBzZWN0aW9uU2l6ZTtcbiAgICAgICAgICAgIHhFbmQgPSAwO1xuICAgICAgICAgICAgeERlbHRhID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKCB5ID0gMDsgeSA8IHlTaXplOyB5ICs9IDEgKXtcbiAgICAgICAgICAgIGZvciggeCA9IHhTdGFydDsgeCAhPT0geEVuZDsgeCArPSB4RGVsdGEgKXtcbiAgICAgICAgICAgICAgICB4b2ZmID0gTWF0aC5yb3VuZCh4ICsgb2Zmc2V0KSAlIHhTaXplO1xuICAgICAgICAgICAgICAgIHNyY1BvcyA9ICh4U2l6ZSAqIHkgKyB4b2ZmKSAqIDQ7XG4gICAgICAgICAgICAgICAgciA9IHNjcmF0Y2hEYXRhLmRhdGFbc3JjUG9zICsgMF07XG4gICAgICAgICAgICAgICAgZyA9IHNjcmF0Y2hEYXRhLmRhdGFbc3JjUG9zICsgMV07XG4gICAgICAgICAgICAgICAgYiA9IHNjcmF0Y2hEYXRhLmRhdGFbc3JjUG9zICsgMl07XG4gICAgICAgICAgICAgICAgYSA9IHNjcmF0Y2hEYXRhLmRhdGFbc3JjUG9zICsgM107XG4gICAgICAgICAgICAgICAgZHN0UG9zID0gKHhTaXplICogeSArIHgpICogNDtcbiAgICAgICAgICAgICAgICBzY3JhdGNoRGF0YS5kYXRhW2RzdFBvcyArIDBdID0gcjtcbiAgICAgICAgICAgICAgICBzY3JhdGNoRGF0YS5kYXRhW2RzdFBvcyArIDFdID0gZztcbiAgICAgICAgICAgICAgICBzY3JhdGNoRGF0YS5kYXRhW2RzdFBvcyArIDJdID0gYjtcbiAgICAgICAgICAgICAgICBzY3JhdGNoRGF0YS5kYXRhW2RzdFBvcyArIDNdID0gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBlcmZvcm0gdGhlIGFjdHVhbCBlZmZlY3RcbiAgICAgICAgZm9yKCB5ID0gMDsgeSA8IHlTaXplOyB5ICs9IDEgKXtcbiAgICAgICAgICAgIHNlY3Rpb25TaXplID0gTWF0aC5mbG9vciggbWluU2VjdGlvblNpemUgKTtcbiAgICAgICAgICAgIGZvciggaSA9IDA7IGkgPCBwb3dlcjsgaSArPSAxICl7XG4gICAgICAgICAgICAgICAgZm9yKCB4ID0gMDsgeCA8IHNlY3Rpb25TaXplICsgMTsgeCArPSAxICl7XG4gICAgICAgICAgICAgICAgICAgIHNyY1BvcyA9ICh4U2l6ZSAqIHkgKyB4KSAqIDQ7XG4gICAgICAgICAgICAgICAgICAgIHIgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDBdO1xuICAgICAgICAgICAgICAgICAgICBnID0gc2NyYXRjaERhdGEuZGF0YVtzcmNQb3MgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgYiA9IHNjcmF0Y2hEYXRhLmRhdGFbc3JjUG9zICsgMl07XG4gICAgICAgICAgICAgICAgICAgIGEgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDNdO1xuICAgICAgICAgICAgICAgICAgICBkc3RQb3MgPSAoeFNpemUgKiB5ICsgc2VjdGlvblNpemUgKiAyIC0geCAtIDEpICogNDtcbiAgICAgICAgICAgICAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAwXSA9IHI7XG4gICAgICAgICAgICAgICAgICAgIHNjcmF0Y2hEYXRhLmRhdGFbZHN0UG9zICsgMV0gPSBnO1xuICAgICAgICAgICAgICAgICAgICBzY3JhdGNoRGF0YS5kYXRhW2RzdFBvcyArIDJdID0gYjtcbiAgICAgICAgICAgICAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAzXSA9IGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlY3Rpb25TaXplICo9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0IGJhY2sgZnJvbSBwb2xhciBjb29yZGluYXRlc1xuICAgICAgICBGcm9tUG9sYXIoc2NyYXRjaERhdGEsIGltYWdlRGF0YSwge3BvbGFyUm90YXRpb246IDB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGthbGVpZG9zY29wZSBwb3dlci4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuS2FsZWlkb3Njb3BlfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSBrYWxlaWRvc2NvcGVQb3dlclxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge0ludGVnZXJ9IHBvd2VyIG9mIGthbGVpZG9zY29wZVxuICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgKi9cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAna2FsZWlkb3Njb3BlUG93ZXInLCAyLCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcblxuICAgIC8qKlxuICAgICogZ2V0L3NldCBrYWxlaWRvc2NvcGUgYW5nbGUuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkthbGVpZG9zY29wZX0gZmlsdGVyLlxuICAgICogQG5hbWUga2FsZWlkb3Njb3BlQW5nbGVcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSBkZWdyZWVzXG4gICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAqL1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdrYWxlaWRvc2NvcGVBbmdsZScsIDAsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuXG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qKlxuICAgICAqIENvbnRhaW5lciBjb25zdHJ1Y3Rvci4mbmJzcDsgQ29udGFpbmVycyBhcmUgdXNlZCB0byBjb250YWluIG5vZGVzIG9yIG90aGVyIGNvbnRhaW5lcnNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYXVnbWVudHMgS29udmEuTm9kZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuY2xpcF0gc2V0IGNsaXBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWF0gc2V0IGNsaXAgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBZXSBzZXQgY2xpcCB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFdpZHRoXSBzZXQgY2xpcCB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBIZWlnaHRdIHNldCBjbGlwIGhlaWdodFxuXG4gICAgICovXG4gICAgS29udmEuQ29udGFpbmVyID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLlV0aWwuYWRkTWV0aG9kcyhLb252YS5Db250YWluZXIsIHtcbiAgICAgICAgX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgS29udmEuQ29sbGVjdGlvbigpO1xuICAgICAgICAgICAgS29udmEuTm9kZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXR1cm5zIGEge0BsaW5rIEtvbnZhLkNvbGxlY3Rpb259IG9mIGRpcmVjdCBkZXNjZW5kYW50IG5vZGVzXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZpbHRlckZ1bmNdIGZpbHRlciBmdW5jdGlvblxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuQ29sbGVjdGlvbn1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gZ2V0IGFsbCBjaGlsZHJlblxuICAgICAgICAgKiB2YXIgY2hpbGRyZW4gPSBsYXllci5nZXRDaGlsZHJlbigpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBnZXQgb25seSBjaXJjbGVzXG4gICAgICAgICAqIHZhciBjaXJjbGVzID0gbGF5ZXIuZ2V0Q2hpbGRyZW4oZnVuY3Rpb24obm9kZSl7XG4gICAgICAgICAqICAgIHJldHVybiBub2RlLmdldENsYXNzTmFtZSgpID09PSAnQ2lyY2xlJztcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICBnZXRDaGlsZHJlbjogZnVuY3Rpb24oZmlsdGVyRnVuYykge1xuICAgICAgICAgICAgaWYgKCFmaWx0ZXJGdW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gbmV3IEtvbnZhLkNvbGxlY3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZWFjaChmdW5jdGlvbihjaGlsZCl7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlckZ1bmMoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRldGVybWluZSBpZiBub2RlIGhhcyBjaGlsZHJlblxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaGFzQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2hpbGRyZW4oKS5sZW5ndGggPiAwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogcmVtb3ZlIGFsbCBjaGlsZHJlblxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBLb252YS5Db2xsZWN0aW9uLnRvQ29sbGVjdGlvbih0aGlzLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIC8vIHJlc2V0IHBhcmVudCB0byBwcmV2ZW50IG1hbnkgX3NldENoaWxkcmVuSW5kaWNlcyBjYWxsc1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjaGlsZC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgY2hpbGQuaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnJlbW92ZUNoaWxkcmVuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoaWxkLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGRyZW4gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBLb252YS5Db2xsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRlc3Ryb3kgYWxsIGNoaWxkcmVuXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGRlc3Ryb3lDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIHZhciBjaGlsZHJlbiA9IEtvbnZhLkNvbGxlY3Rpb24udG9Db2xsZWN0aW9uKHRoaXMuY2hpbGRyZW4pO1xuICAgICAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgcGFyZW50IHRvIHByZXZlbnQgbWFueSBfc2V0Q2hpbGRyZW5JbmRpY2VzIGNhbGxzXG4gICAgICAgICAgICAgICAgZGVsZXRlIGNoaWxkLnBhcmVudDtcbiAgICAgICAgICAgICAgICBjaGlsZC5pbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgY2hpbGQuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGRyZW4gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBLb252YS5Db2xsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBub2RlIG9yIG5vZGVzIHRvIGNvbnRhaW5lci5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0gey4uLktvbnZhLk5vZGV9IGNoaWxkXG4gICAgICAgICAqIEByZXR1cm5zIHtDb250YWluZXJ9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGxheWVyLmFkZChzaGFwZTEsIHNoYXBlMiwgc2hhcGUzKTtcbiAgICAgICAgICovXG4gICAgICAgIGFkZDogZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoaWxkLmdldFBhcmVudCgpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQubW92ZVRvKHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlQWRkKGNoaWxkKTtcbiAgICAgICAgICAgIGNoaWxkLmluZGV4ID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgdGhpcy5fZmlyZSgnYWRkJywge1xuICAgICAgICAgICAgICAgIGNoaWxkOiBjaGlsZFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGlmIG5vZGUgdW5kZXIgZHJhZyB3ZSBuZWVkIHRvIHVwZGF0ZSBkcmFnIGFuaW1hdGlvblxuICAgICAgICAgICAgaWYgKEtvbnZhLkREICYmIGNoaWxkLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgICAgIEtvbnZhLkRELmFuaW0uc2V0TGF5ZXJzKGNoaWxkLmdldExheWVyKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGFpbmFibGVcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGRlc3Ryb3kgY2hpbGRyZW5cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0NoaWxkcmVuKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lDaGlsZHJlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhlbiBkZXN0cm95IHNlbGZcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJuIGEge0BsaW5rIEtvbnZhLkNvbGxlY3Rpb259IG9mIG5vZGVzIHRoYXQgbWF0Y2ggdGhlIHNlbGVjdG9yLiAgVXNlICcjJyBmb3IgaWQgc2VsZWN0aW9uc1xuICAgICAgICAgKiBhbmQgJy4nIGZvciBuYW1lIHNlbGVjdGlvbnMuICBZb3UgY2FuIGFsc28gc2VsZWN0IGJ5IHR5cGUgb3IgY2xhc3MgbmFtZS4gUGFzcyBtdWx0aXBsZSBzZWxlY3RvcnNcbiAgICAgICAgICogc2VwYXJhdGVkIGJ5IGEgc3BhY2UuXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gICAgICAgICAqIEByZXR1cm5zIHtDb2xsZWN0aW9ufVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBzZWxlY3Qgbm9kZSB3aXRoIGlkIGZvb1xuICAgICAgICAgKiB2YXIgbm9kZSA9IHN0YWdlLmZpbmQoJyNmb28nKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gc2VsZWN0IG5vZGVzIHdpdGggbmFtZSBiYXIgaW5zaWRlIGxheWVyXG4gICAgICAgICAqIHZhciBub2RlcyA9IGxheWVyLmZpbmQoJy5iYXInKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gc2VsZWN0IGFsbCBncm91cHMgaW5zaWRlIGxheWVyXG4gICAgICAgICAqIHZhciBub2RlcyA9IGxheWVyLmZpbmQoJ0dyb3VwJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIHNlbGVjdCBhbGwgcmVjdGFuZ2xlcyBpbnNpZGUgbGF5ZXJcbiAgICAgICAgICogdmFyIG5vZGVzID0gbGF5ZXIuZmluZCgnUmVjdCcpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBzZWxlY3Qgbm9kZSB3aXRoIGFuIGlkIG9mIGZvbyBvciBhIG5hbWUgb2YgYmFyIGluc2lkZSBsYXllclxuICAgICAgICAgKiB2YXIgbm9kZXMgPSBsYXllci5maW5kKCcjZm9vLCAuYmFyJyk7XG4gICAgICAgICAqL1xuICAgICAgICBmaW5kOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICAgICAgdmFyIHJldEFyciA9IFtdLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yQXJyID0gc2VsZWN0b3IucmVwbGFjZSgvIC9nLCAnJykuc3BsaXQoJywnKSxcbiAgICAgICAgICAgICAgICBsZW4gPSBzZWxlY3RvckFyci5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbiwgaSwgc2VsLCBhcnIsIG5vZGUsIGNoaWxkcmVuLCBjbGVuO1xuXG4gICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICBzZWwgPSBzZWxlY3RvckFycltuXTtcbiAgICAgICAgICAgICAgICBpZiAoIUtvbnZhLlV0aWwuaXNWYWxpZFNlbGVjdG9yKHNlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdTZWxlY3RvciBcIicgKyBzZWwgKyAnXCIgaXMgaW52YWxpZC4gQWxsb3dlZCBzZWxlY3RvcnMgZXhhbXBsZXMgYXJlIFwiI2Zvb1wiLCBcIi5iYXJcIiBvciBcIkdyb3VwXCIuJyk7XG4gICAgICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwud2FybignSWYgeW91IGhhdmUgYSBjdXN0b20gc2hhcGUgd2l0aCBzdWNoIGNsYXNzTmFtZSwgcGxlYXNlIGNoYW5nZSBpdCB0byBzdGFydCB3aXRoIHVwcGVyIGxldHRlciBsaWtlIFwiVHJpYW5nbGVcIi4nKTtcbiAgICAgICAgICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdLb252YSBpcyBhd2Vzb21lLCByaWdodD8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWQgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICBpZihzZWwuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMuX2dldE5vZGVCeUlkKHNlbC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG5hbWUgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHNlbC5jaGFyQXQoMCkgPT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICBhcnIgPSB0aGlzLl9nZXROb2Rlc0J5TmFtZShzZWwuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICByZXRBcnIgPSByZXRBcnIuY29uY2F0KGFycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHVucmVjb2duaXplZCBzZWxlY3RvciwgcGFzcyB0byBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgY2xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRBcnIgPSByZXRBcnIuY29uY2F0KGNoaWxkcmVuW2ldLl9nZXQoc2VsKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBLb252YS5Db2xsZWN0aW9uLnRvQ29sbGVjdGlvbihyZXRBcnIpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJuIGEgZmlyc3Qgbm9kZSBmcm9tIGBmaW5kYCBtZXRob2RcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIHNlbGVjdCBub2RlIHdpdGggaWQgZm9vXG4gICAgICAgICAqIHZhciBub2RlID0gc3RhZ2UuZmluZE9uZSgnI2ZvbycpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBzZWxlY3Qgbm9kZSB3aXRoIG5hbWUgYmFyIGluc2lkZSBsYXllclxuICAgICAgICAgKiB2YXIgbm9kZXMgPSBsYXllci5maW5kT25lKCcuYmFyJyk7XG4gICAgICAgICAqL1xuICAgICAgICBmaW5kT25lOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZChzZWxlY3RvcilbMF07XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXROb2RlQnlJZDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IEtvbnZhLmlkc1trZXldO1xuXG4gICAgICAgICAgICBpZihub2RlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5pc0FuY2VzdG9yT2Yobm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0Tm9kZXNCeU5hbWU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdmFyIGFyciA9IEtvbnZhLm5hbWVzW2tleV0gfHwgW107XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RGVzY2VuZGFudHMoYXJyKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldDogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHZhciByZXRBcnIgPSBLb252YS5Ob2RlLnByb3RvdHlwZS5fZ2V0LmNhbGwodGhpcywgc2VsZWN0b3IpO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGZvcih2YXIgbiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgIHJldEFyciA9IHJldEFyci5jb25jYXQoY2hpbGRyZW5bbl0uX2dldChzZWxlY3RvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZXh0ZW5kZXJzXG4gICAgICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBLb252YS5Ob2RlLnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICBvYmouY2hpbGRyZW4gPSBbXTtcblxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGZvcih2YXIgbiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW25dO1xuICAgICAgICAgICAgICAgIG9iai5jaGlsZHJlbi5wdXNoKGNoaWxkLnRvT2JqZWN0KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0RGVzY2VuZGFudHM6IGZ1bmN0aW9uKGFycikge1xuICAgICAgICAgICAgdmFyIHJldEFyciA9IFtdO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgICAgICBmb3IodmFyIG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGFycltuXTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmlzQW5jZXN0b3JPZihub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXRBcnIucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZXRlcm1pbmUgaWYgbm9kZSBpcyBhbiBhbmNlc3RvclxuICAgICAgICAgKiBvZiBkZXNjZW5kYW50XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtLb252YS5Ob2RlfSBub2RlXG4gICAgICAgICAqL1xuICAgICAgICBpc0FuY2VzdG9yT2Y6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgICAgICAgd2hpbGUocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYocGFyZW50Ll9pZCA9PT0gdGhpcy5faWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBjbG9uZTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIG1ldGhvZFxuICAgICAgICAgICAgdmFyIG5vZGUgPSBLb252YS5Ob2RlLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsIG9iaik7XG5cbiAgICAgICAgICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKG5vKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hZGQobm8uY2xvbmUoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGFsbCBzaGFwZXMgdGhhdCBpbnRlcnNlY3QgYSBwb2ludC4gIE5vdGU6IGJlY2F1c2UgdGhpcyBtZXRob2QgbXVzdCBjbGVhciBhIHRlbXBvcmFyeVxuICAgICAgICAgKiBjYW52YXMgYW5kIHJlZHJhdyBldmVyeSBzaGFwZSBpbnNpZGUgdGhlIGNvbnRhaW5lciwgaXQgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3Igc3BlY2lhbCBzaXRhdGlvbnNcbiAgICAgICAgICogYmVjYXVzZSBpdCBwZXJmb3JtcyB2ZXJ5IHBvb3JseS4gIFBsZWFzZSB1c2UgdGhlIHtAbGluayBLb252YS5TdGFnZSNnZXRJbnRlcnNlY3Rpb259IG1ldGhvZCBpZiBhdCBhbGwgcG9zc2libGVcbiAgICAgICAgICogYmVjYXVzZSBpdCBwZXJmb3JtcyBtdWNoIGJldHRlclxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy54XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueVxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGFycmF5IG9mIHNoYXBlc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QWxsSW50ZXJzZWN0aW9uczogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgICAgICB2YXIgYXJyID0gW107XG5cbiAgICAgICAgICAgIHRoaXMuZmluZCgnU2hhcGUnKS5lYWNoKGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgICAgICAgICAgaWYoc2hhcGUuaXNWaXNpYmxlKCkgJiYgc2hhcGUuaW50ZXJzZWN0cyhwb3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKHNoYXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgfSxcbiAgICAgICAgX3NldENoaWxkcmVuSW5kaWNlczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmVhY2goZnVuY3Rpb24oY2hpbGQsIG4pIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5pbmRleCA9IG47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhd1NjZW5lOiBmdW5jdGlvbihjYW4sIHRvcCwgY2FjaGluZykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLFxuICAgICAgICAgICAgICAgIGNhbnZhcyA9IGNhbiB8fCAobGF5ZXIgJiYgbGF5ZXIuZ2V0Q2FudmFzKCkpLFxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjYW52YXMgJiYgY2FudmFzLmdldENvbnRleHQoKSxcbiAgICAgICAgICAgICAgICBjYWNoZWRDYW52YXMgPSB0aGlzLl9jYWNoZS5jYW52YXMsXG4gICAgICAgICAgICAgICAgY2FjaGVkU2NlbmVDYW52YXMgPSBjYWNoZWRDYW52YXMgJiYgY2FjaGVkQ2FudmFzLnNjZW5lO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgICAgIGlmICghY2FjaGluZyAmJiBjYWNoZWRTY2VuZUNhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuX2FwcGx5VHJhbnNmb3JtKHRoaXMsIGNvbnRleHQsIHRvcCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdDYWNoZWRTY2VuZUNhbnZhcyhjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmF3Q2hpbGRyZW4oY2FudmFzLCAnZHJhd1NjZW5lJywgdG9wLCBmYWxzZSwgY2FjaGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYXdIaXQ6IGZ1bmN0aW9uKGNhbiwgdG9wLCBjYWNoaW5nKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksXG4gICAgICAgICAgICAgICAgY2FudmFzID0gY2FuIHx8IChsYXllciAmJiBsYXllci5oaXRDYW52YXMpLFxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjYW52YXMgJiYgY2FudmFzLmdldENvbnRleHQoKSxcbiAgICAgICAgICAgICAgICBjYWNoZWRDYW52YXMgPSB0aGlzLl9jYWNoZS5jYW52YXMsXG4gICAgICAgICAgICAgICAgY2FjaGVkSGl0Q2FudmFzID0gY2FjaGVkQ2FudmFzICYmIGNhY2hlZENhbnZhcy5oaXQ7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZERyYXdIaXQoY2FudmFzKSkge1xuICAgICAgICAgICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5jbGVhckhpdENhY2hlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY2FjaGluZyAmJiBjYWNoZWRIaXRDYW52YXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9hcHBseVRyYW5zZm9ybSh0aGlzLCBjb250ZXh0LCB0b3ApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmF3Q2FjaGVkSGl0Q2FudmFzKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdDaGlsZHJlbihjYW52YXMsICdkcmF3SGl0JywgdG9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgX2RyYXdDaGlsZHJlbjogZnVuY3Rpb24oY2FudmFzLCBkcmF3TWV0aG9kLCB0b3AsIGNhY2hpbmcsIHNraXBCdWZmZXIpIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKSxcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gY2FudmFzICYmIGNhbnZhcy5nZXRDb250ZXh0KCksXG4gICAgICAgICAgICAgICAgY2xpcFdpZHRoID0gdGhpcy5nZXRDbGlwV2lkdGgoKSxcbiAgICAgICAgICAgICAgICBjbGlwSGVpZ2h0ID0gdGhpcy5nZXRDbGlwSGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgaGFzQ2xpcCA9IGNsaXBXaWR0aCAmJiBjbGlwSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGNsaXBYLCBjbGlwWTtcblxuICAgICAgICAgICAgaWYgKGhhc0NsaXAgJiYgbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBjbGlwWCA9IHRoaXMuZ2V0Q2xpcFgoKTtcbiAgICAgICAgICAgICAgICBjbGlwWSA9IHRoaXMuZ2V0Q2xpcFkoKTtcblxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGxheWVyLl9hcHBseVRyYW5zZm9ybSh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVjdChjbGlwWCwgY2xpcFksIGNsaXBXaWR0aCwgY2xpcEhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jbGlwKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXNldCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFtkcmF3TWV0aG9kXShjYW52YXMsIHRvcCwgY2FjaGluZywgc2tpcEJ1ZmZlcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGhhc0NsaXApIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2hvdWxkRHJhd0hpdDogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgICAgICAgICB2YXIgZGQgPSBLb252YS5ERDtcbiAgICAgICAgICAgIHZhciBsYXllclVuZGVyRHJhZyA9IGRkICYmIEtvbnZhLmlzRHJhZ2dpbmcoKSAmJiAoS29udmEuREQuYW5pbS5nZXRMYXllcnMoKS5pbmRleE9mKGxheWVyKSAhPT0gLTEpO1xuICAgICAgICAgICAgcmV0dXJuIChjYW52YXMgJiYgY2FudmFzLmlzQ2FjaGUpIHx8IChsYXllciAmJiBsYXllci5oaXRHcmFwaEVuYWJsZWQoKSlcbiAgICAgICAgICAgICAgICAmJiB0aGlzLmlzVmlzaWJsZSgpICYmICFsYXllclVuZGVyRHJhZztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q2xpZW50UmVjdDogZnVuY3Rpb24oc2tpcFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFk7XG4gICAgICAgICAgICB2YXIgc2VsZlJlY3QgPSB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gY2hpbGQuZ2V0Q2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gc2tpcCBpbnZpc2libGUgY2hpbGRyZW4gKGxpa2UgZW1wdHkgZ3JvdXBzKVxuICAgICAgICAgICAgICAgIC8vIG9yIGRvbid0IHNraXAuLi4gaG1tbS4uLlxuICAgICAgICAgICAgICAgIC8vIGlmIChyZWN0LndpZHRoID09PSAwICYmIHJlY3QuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgICAgICBpZiAobWluWCA9PT0gdW5kZWZpbmVkKSB7IC8vIGluaXRpYWwgdmFsdWUgZm9yIGZpcnN0IGNoaWxkXG4gICAgICAgICAgICAgICAgICAgIG1pblggPSByZWN0Lng7XG4gICAgICAgICAgICAgICAgICAgIG1pblkgPSByZWN0Lnk7XG4gICAgICAgICAgICAgICAgICAgIG1heFggPSByZWN0LnggKyByZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBtYXhZID0gcmVjdC55ICsgcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHJlY3QueCk7XG4gICAgICAgICAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCByZWN0LnkpO1xuICAgICAgICAgICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgcmVjdC54ICsgcmVjdC53aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCByZWN0LnkgKyByZWN0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZlJlY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IG1pblgsXG4gICAgICAgICAgICAgICAgICAgIHk6IG1pblksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBtYXhYIC0gbWluWCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBtYXhZIC0gbWluWVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc2tpcFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1lZFJlY3Qoc2VsZlJlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbGZSZWN0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5Db250YWluZXIsIEtvbnZhLk5vZGUpO1xuICAgIC8vIGRlcHJlY2F0ZWQgbWV0aG9kc1xuICAgIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuZ2V0ID0gS29udmEuQ29udGFpbmVyLnByb3RvdHlwZS5maW5kO1xuXG4gICAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5Db250YWluZXIsICdjbGlwJywgWyd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0J10pO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgY2xpcFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbmFtZSBjbGlwXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2xpcFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjbGlwLnhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2xpcC55XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNsaXAud2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2xpcC5oZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNsaXBcbiAgICAgKiB2YXIgY2xpcCA9IGNvbnRhaW5lci5jbGlwKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgY2xpcFxuICAgICAqIGNvbnRhaW5lci5zZXRDbGlwKHtcbiAgICAgKiAgIHg6IDIwLFxuICAgICAqICAgeTogMjAsXG4gICAgICogICB3aWR0aDogMjAsXG4gICAgICogICBoZWlnaHQ6IDIwXG4gICAgICogfSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Db250YWluZXIsICdjbGlwWCcpO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgY2xpcCB4XG4gICAgICogQG5hbWUgY2xpcFhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY2xpcCB4XG4gICAgICogdmFyIGNsaXBYID0gY29udGFpbmVyLmNsaXBYKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgY2xpcCB4XG4gICAgICogY29udGFpbmVyLmNsaXBYKDEwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkNvbnRhaW5lciwgJ2NsaXBZJyk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBjbGlwIHlcbiAgICAgKiBAbmFtZSBjbGlwWVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjbGlwIHlcbiAgICAgKiB2YXIgY2xpcFkgPSBjb250YWluZXIuY2xpcFkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBjbGlwIHlcbiAgICAgKiBjb250YWluZXIuY2xpcFkoMTApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQ29udGFpbmVyLCAnY2xpcFdpZHRoJyk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBjbGlwIHdpZHRoXG4gICAgICogQG5hbWUgY2xpcFdpZHRoXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjbGlwIHdpZHRoXG4gICAgICogdmFyIGNsaXBXaWR0aCA9IGNvbnRhaW5lci5jbGlwV2lkdGgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBjbGlwIHdpZHRoXG4gICAgICogY29udGFpbmVyLmNsaXBXaWR0aCgxMDApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQ29udGFpbmVyLCAnY2xpcEhlaWdodCcpO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgY2xpcCBoZWlnaHRcbiAgICAgKiBAbmFtZSBjbGlwSGVpZ2h0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY2xpcCBoZWlnaHRcbiAgICAgKiB2YXIgY2xpcEhlaWdodCA9IGNvbnRhaW5lci5jbGlwSGVpZ2h0KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgY2xpcCBoZWlnaHRcbiAgICAgKiBjb250YWluZXIuY2xpcEhlaWdodCgxMDApO1xuICAgICAqL1xuXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLkNvbnRhaW5lcik7XG59KSgpO1xuXG4oZnVuY3Rpb24oS29udmEpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIEhBU19TSEFET1cgPSAnaGFzU2hhZG93JztcbiAgICB2YXIgU0hBRE9XX1JHQkEgPSAnc2hhZG93UkdCQSc7XG5cbiAgICBmdW5jdGlvbiBfZmlsbEZ1bmMoY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3N0cm9rZUZ1bmMoY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZmlsbEZ1bmNIaXQoY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3N0cm9rZUZ1bmNIaXQoY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jbGVhckhhc1NoYWRvd0NhY2hlKCkge1xuICAgICAgICB0aGlzLl9jbGVhckNhY2hlKEhBU19TSEFET1cpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jbGVhckdldFNoYWRvd1JHQkFDYWNoZSgpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJDYWNoZShTSEFET1dfUkdCQSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hhcGUgY29uc3RydWN0b3IuICBTaGFwZXMgYXJlIHByaW1pdGl2ZSBvYmplY3RzIHN1Y2ggYXMgcmVjdGFuZ2xlcyxcbiAgICAgKiAgY2lyY2xlcywgdGV4dCwgbGluZXMsIGV0Yy5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYXVnbWVudHMgS29udmEuTm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGN1c3RvbVNoYXBlID0gbmV3IEtvbnZhLlNoYXBlKHtcbiAgICAgICAgICogICB4OiA1LFxuICAgICAgICAgKiAgIHk6IDEwLFxuICAgICAgICAgKiAgIGZpbGw6ICdyZWQnLFxuICAgICAgICAgKiAgIC8vIGEgS29udmEuQ2FudmFzIHJlbmRlcmVyIGlzIHBhc3NlZCBpbnRvIHRoZSBkcmF3RnVuYyBmdW5jdGlvblxuICAgICAgICAgKiAgIGRyYXdGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgICAqICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgKiAgICAgY29udGV4dC5tb3ZlVG8oMjAwLCA1MCk7XG4gICAgICAgICAqICAgICBjb250ZXh0LmxpbmVUbyg0MjAsIDgwKTtcbiAgICAgICAgICogICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbygzMDAsIDEwMCwgMjYwLCAxNzApO1xuICAgICAgICAgKiAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICogICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICAgKiAgIH1cbiAgICAgICAgICp9KTtcbiAgICAgKi9cbiAgICBLb252YS5TaGFwZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5VdGlsLmFkZE1ldGhvZHMoS29udmEuU2hhcGUsIHtcbiAgICAgICAgX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZVR5cGUgPSAnU2hhcGUnO1xuICAgICAgICAgICAgdGhpcy5fZmlsbEZ1bmMgPSBfZmlsbEZ1bmM7XG4gICAgICAgICAgICB0aGlzLl9zdHJva2VGdW5jID0gX3N0cm9rZUZ1bmM7XG4gICAgICAgICAgICB0aGlzLl9maWxsRnVuY0hpdCA9IF9maWxsRnVuY0hpdDtcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZUZ1bmNIaXQgPSBfc3Ryb2tlRnVuY0hpdDtcblxuICAgICAgICAgICAgLy8gc2V0IGNvbG9yS2V5XG4gICAgICAgICAgICB2YXIgc2hhcGVzID0gS29udmEuc2hhcGVzO1xuICAgICAgICAgICAgdmFyIGtleTtcblxuICAgICAgICAgICAgd2hpbGUodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGtleSA9IEtvbnZhLlV0aWwuZ2V0UmFuZG9tQ29sb3IoKTtcbiAgICAgICAgICAgICAgICBpZihrZXkgJiYgISgga2V5IGluIHNoYXBlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNvbG9yS2V5ID0ga2V5O1xuICAgICAgICAgICAgc2hhcGVzW2tleV0gPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICBLb252YS5Ob2RlLmNhbGwodGhpcywgY29uZmlnKTtcblxuICAgICAgICAgICAgdGhpcy5vbignc2hhZG93Q29sb3JDaGFuZ2Uua29udmEgc2hhZG93Qmx1ckNoYW5nZS5rb252YSBzaGFkb3dPZmZzZXRDaGFuZ2Uua29udmEgc2hhZG93T3BhY2l0eUNoYW5nZS5rb252YSBzaGFkb3dFbmFibGVkQ2hhbmdlLmtvbnZhJywgX2NsZWFySGFzU2hhZG93Q2FjaGUpO1xuXG4gICAgICAgICAgICB0aGlzLm9uKCdzaGFkb3dDb2xvckNoYW5nZS5rb252YSBzaGFkb3dPcGFjaXR5Q2hhbmdlLmtvbnZhIHNoYWRvd0VuYWJsZWRDaGFuZ2Uua29udmEnLCBfY2xlYXJHZXRTaGFkb3dSR0JBQ2FjaGUpO1xuICAgICAgICB9LFxuICAgICAgICBoYXNDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGdldENoaWxkcmVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBjYW52YXMgY29udGV4dCB0aWVkIHRvIHRoZSBsYXllclxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLkNvbnRleHR9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRDb250ZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExheWVyKCkuZ2V0Q29udGV4dCgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGNhbnZhcyByZW5kZXJlciB0aWVkIHRvIHRoZSBsYXllci4gIE5vdGUgdGhhdCB0aGlzIHJldHVybnMgYSBjYW52YXMgcmVuZGVyZXIsIG5vdCBhIGNhbnZhcyBlbGVtZW50XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuQ2FudmFzfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExheWVyKCkuZ2V0Q2FudmFzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXR1cm5zIHdoZXRoZXIgb3Igbm90IGEgc2hhZG93IHdpbGwgYmUgcmVuZGVyZWRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaGFzU2hhZG93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZShIQVNfU0hBRE9XLCB0aGlzLl9oYXNTaGFkb3cpO1xuICAgICAgICB9LFxuICAgICAgICBfaGFzU2hhZG93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNoYWRvd0VuYWJsZWQoKSAmJiAodGhpcy5nZXRTaGFkb3dPcGFjaXR5KCkgIT09IDAgJiYgISEodGhpcy5nZXRTaGFkb3dDb2xvcigpIHx8IHRoaXMuZ2V0U2hhZG93Qmx1cigpIHx8IHRoaXMuZ2V0U2hhZG93T2Zmc2V0WCgpIHx8IHRoaXMuZ2V0U2hhZG93T2Zmc2V0WSgpKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFNoYWRvd1JHQkE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKFNIQURPV19SR0JBLCB0aGlzLl9nZXRTaGFkb3dSR0JBKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldFNoYWRvd1JHQkE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzU2hhZG93KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmdiYSA9IEtvbnZhLlV0aWwuY29sb3JUb1JHQkEodGhpcy5zaGFkb3dDb2xvcigpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3JnYmEoJyArIHJnYmEuciArICcsJyArIHJnYmEuZyArICcsJyArIHJnYmEuYiArICcsJyArIChyZ2JhLmEgKiAodGhpcy5nZXRTaGFkb3dPcGFjaXR5KCkgfHwgMSkpICsgJyknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc2hhcGUgd2lsbCBiZSBmaWxsZWRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaGFzRmlsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gISEodGhpcy5nZXRGaWxsKCkgfHwgdGhpcy5nZXRGaWxsUGF0dGVybkltYWdlKCkgfHwgdGhpcy5nZXRGaWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzKCkgfHwgdGhpcy5nZXRGaWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzKCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc2hhcGUgd2lsbCBiZSBzdHJva2VkXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGhhc1N0cm9rZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gISEodGhpcy5zdHJva2UoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZXRlcm1pbmVzIGlmIHBvaW50IGlzIGluIHRoZSBzaGFwZSwgcmVnYXJkbGVzcyBpZiBvdGhlciBzaGFwZXMgYXJlIG9uIHRvcCBvZiBpdC4gIE5vdGU6IGJlY2F1c2VcbiAgICAgICAgICogIHRoaXMgbWV0aG9kIGNsZWFycyBhIHRlbXBvcmFyeSBjYW52YXMgYW5kIHRoZW4gcmVkcmF3cyB0aGUgc2hhcGUsIGl0IHBlcmZvcm1zIHZlcnkgcG9vcmx5IGlmIGV4ZWN1dGVkIG1hbnkgdGltZXNcbiAgICAgICAgICogIGNvbnNlY3V0aXZlbHkuICBQbGVhc2UgdXNlIHRoZSB7QGxpbmsgS29udmEuU3RhZ2UjZ2V0SW50ZXJzZWN0aW9ufSBtZXRob2QgaWYgYXQgYWxsIHBvc3NpYmxlXG4gICAgICAgICAqICBiZWNhdXNlIGl0IHBlcmZvcm1zIG11Y2ggYmV0dGVyXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50LnhcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50LnlcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpbnRlcnNlY3RzOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpLFxuICAgICAgICAgICAgICAgIGJ1ZmZlckhpdENhbnZhcyA9IHN0YWdlLmJ1ZmZlckhpdENhbnZhcyxcbiAgICAgICAgICAgICAgICBwO1xuXG4gICAgICAgICAgICBidWZmZXJIaXRDYW52YXMuZ2V0Q29udGV4dCgpLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdTY2VuZShidWZmZXJIaXRDYW52YXMpO1xuICAgICAgICAgICAgcCA9IGJ1ZmZlckhpdENhbnZhcy5jb250ZXh0LmdldEltYWdlRGF0YShNYXRoLnJvdW5kKHBvaW50LngpLCBNYXRoLnJvdW5kKHBvaW50LnkpLCAxLCAxKS5kYXRhO1xuICAgICAgICAgICAgcmV0dXJuIHBbM10gPiAwO1xuICAgICAgICB9LFxuICAgICAgICAvLyBleHRlbmRzIE5vZGUucHJvdG90eXBlLmRlc3Ryb3lcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICAgICAgICBkZWxldGUgS29udmEuc2hhcGVzW3RoaXMuY29sb3JLZXldO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIF91c2VCdWZmZXJDYW52YXM6IGZ1bmN0aW9uKGNhY2hpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiAhY2FjaGluZyAmJiAodGhpcy5wZXJmZWN0RHJhd0VuYWJsZWQoKSAmJiAodGhpcy5nZXRBYnNvbHV0ZU9wYWNpdHkoKSAhPT0gMSkgJiYgdGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5oYXNTdHJva2UoKSAmJiB0aGlzLmdldFN0YWdlKCkpIHx8XG4gICAgICAgICAgICAgICAgICAgKHRoaXMucGVyZmVjdERyYXdFbmFibGVkKCkgJiYgdGhpcy5oYXNTaGFkb3coKSAmJiAodGhpcy5nZXRBYnNvbHV0ZU9wYWNpdHkoKSAhPT0gMSkgJiYgdGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5oYXNTdHJva2UoKSAmJiB0aGlzLmdldFN0YWdlKCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJuIHNlbGYgcmVjdGFuZ2xlICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSBvZiBzaGFwZS5cbiAgICAgICAgICogVGhpcyBtZXRob2QgYXJlIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgdHJhbnNmb3JtYXRpb24gYW5kIHN0eWxlcy5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gcmVjdCB3aXRoIHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSBwcm9wZXJ0aWVzXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIHJlY3QuZ2V0U2VsZlJlY3QoKTsgIC8vIHJldHVybiB7eDowLCB5OjAsIHdpZHRoOnJlY3Qud2lkdGgoKSwgaGVpZ2h0OnJlY3QuaGVpZ2h0KCl9XG4gICAgICAgICAqIGNpcmNsZS5nZXRTZWxmUmVjdCgpOyAgLy8gcmV0dXJuIHt4OiAtIGNpcmNsZS53aWR0aCgpIC8gMiwgeTogLSBjaXJjbGUuaGVpZ2h0KCkgLyAyLCB3aWR0aDpjaXJjbGUud2lkdGgoKSwgaGVpZ2h0OmNpcmNsZS5oZWlnaHQoKX1cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGdldFNlbGZSZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMuX2NlbnRyb2lkID8gTWF0aC5yb3VuZCgtc2l6ZS53aWR0aCAvIDIpIDogMCxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLl9jZW50cm9pZCA/IE1hdGgucm91bmQoLXNpemUuaGVpZ2h0IC8gMikgOiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGdldENsaWVudFJlY3Q6IGZ1bmN0aW9uKHNraXBUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHZhciBmaWxsUmVjdCA9IHRoaXMuZ2V0U2VsZlJlY3QoKTtcblxuICAgICAgICAgICAgdmFyIHN0cm9rZVdpZHRoID0gKHRoaXMuaGFzU3Ryb2tlKCkgJiYgdGhpcy5zdHJva2VXaWR0aCgpKSB8fCAwO1xuICAgICAgICAgICAgdmFyIGZpbGxBbmRTdHJva2VXaWR0aCA9IGZpbGxSZWN0LndpZHRoICsgc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgICB2YXIgZmlsbEFuZFN0cm9rZUhlaWdodCA9IGZpbGxSZWN0LmhlaWdodCArIHN0cm9rZVdpZHRoO1xuXG4gICAgICAgICAgICB2YXIgc2hhZG93T2Zmc2V0WCA9IHRoaXMuc2hhZG93T2Zmc2V0WCgpO1xuICAgICAgICAgICAgdmFyIHNoYWRvd09mZnNldFkgPSB0aGlzLnNoYWRvd09mZnNldFkoKTtcblxuICAgICAgICAgICAgdmFyIHByZVdpZHRoID0gZmlsbEFuZFN0cm9rZVdpZHRoICsgTWF0aC5hYnMoc2hhZG93T2Zmc2V0WCk7XG4gICAgICAgICAgICB2YXIgcHJlSGVpZ2h0ID0gZmlsbEFuZFN0cm9rZUhlaWdodCArIE1hdGguYWJzKHNoYWRvd09mZnNldFkpO1xuXG4gICAgICAgICAgICB2YXIgYmx1clJhZGl1cyA9ICh0aGlzLmhhc1NoYWRvdygpICYmIHRoaXMuc2hhZG93Qmx1cigpIHx8IDApO1xuXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBwcmVXaWR0aCArIGJsdXJSYWRpdXMgKiAyO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHByZUhlaWdodCArIGJsdXJSYWRpdXMgKiAyO1xuXG4gICAgICAgICAgICAvLyBpZiBzdHJva2UsIGZvciBleGFtcGxlID0gM1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBzZXQgeCB0byAxLjUsIGJ1dCBhZnRlciBNYXRoLnJvdW5kIGl0IHdpbGwgYmUgMlxuICAgICAgICAgICAgLy8gYXMgd2UgaGF2ZSBhZGRpdGlvbmFsIG9mZnNldCB3ZSBuZWVkIHRvIGluY3JlYXNlIHdpZHRoIGFuZCBoZWlnaHQgYnkgMSBwaXhlbFxuICAgICAgICAgICAgdmFyIHJvdW5kaW5nT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGlmIChNYXRoLnJvdW5kKHN0cm9rZVdpZHRoIC8gMikgIT09IHN0cm9rZVdpZHRoIC8gMikge1xuICAgICAgICAgICAgICAgIHJvdW5kaW5nT2Zmc2V0ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZWN0ID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCArIHJvdW5kaW5nT2Zmc2V0LFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0ICsgcm91bmRpbmdPZmZzZXQsXG4gICAgICAgICAgICAgICAgeDogLU1hdGgucm91bmQoc3Ryb2tlV2lkdGggLyAyICsgYmx1clJhZGl1cykgKyBNYXRoLm1pbihzaGFkb3dPZmZzZXRYLCAwKSArIGZpbGxSZWN0LngsXG4gICAgICAgICAgICAgICAgeTogLU1hdGgucm91bmQoc3Ryb2tlV2lkdGggLyAyICsgYmx1clJhZGl1cykgKyBNYXRoLm1pbihzaGFkb3dPZmZzZXRZLCAwKSArIGZpbGxSZWN0LnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXNraXBUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtZWRSZWN0KHJlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYXdTY2VuZTogZnVuY3Rpb24oY2FuLCB0b3AsIGNhY2hpbmcsIHNraXBCdWZmZXIpIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKSxcbiAgICAgICAgICAgICAgICBjYW52YXMgPSBjYW4gfHwgbGF5ZXIuZ2V0Q2FudmFzKCksXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCksXG4gICAgICAgICAgICAgICAgY2FjaGVkQ2FudmFzID0gdGhpcy5fY2FjaGUuY2FudmFzLFxuICAgICAgICAgICAgICAgIGRyYXdGdW5jID0gdGhpcy5zY2VuZUZ1bmMoKSxcbiAgICAgICAgICAgICAgICBoYXNTaGFkb3cgPSB0aGlzLmhhc1NoYWRvdygpLFxuICAgICAgICAgICAgICAgIGhhc1N0cm9rZSA9IHRoaXMuaGFzU3Ryb2tlKCksXG4gICAgICAgICAgICAgICAgc3RhZ2UsIGJ1ZmZlckNhbnZhcywgYnVmZmVyQ29udGV4dDtcblxuICAgICAgICAgICAgaWYoIXRoaXMuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWNoZWRDYW52YXMpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBsYXllci5fYXBwbHlUcmFuc2Zvcm0odGhpcywgY29udGV4dCwgdG9wKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmF3Q2FjaGVkU2NlbmVDYW52YXMoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRyYXdGdW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIC8vIGlmIGJ1ZmZlciBjYW52YXMgaXMgbmVlZGVkXG4gICAgICAgICAgICBpZiAodGhpcy5fdXNlQnVmZmVyQ2FudmFzKGNhY2hpbmcpICYmICFza2lwQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XG4gICAgICAgICAgICAgICAgYnVmZmVyQ2FudmFzID0gc3RhZ2UuYnVmZmVyQ2FudmFzO1xuICAgICAgICAgICAgICAgIGJ1ZmZlckNvbnRleHQgPSBidWZmZXJDYW52YXMuZ2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlckNvbnRleHQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBidWZmZXJDb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBidWZmZXJDb250ZXh0Ll9hcHBseUxpbmVKb2luKHRoaXMpO1xuICAgICAgICAgICAgICAgIC8vIGxheWVyIG1pZ2h0IGJlIHVuZGVmaW5lZCBpZiB3ZSBhcmUgdXNpbmcgY2FjaGUgYmVmb3JlIGFkZGluZyB0byBsYXllclxuICAgICAgICAgICAgICAgIGlmICghY2FjaGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLl9hcHBseVRyYW5zZm9ybSh0aGlzLCBidWZmZXJDb250ZXh0LCB0b3ApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSB0aGlzLmdldEFic29sdXRlVHJhbnNmb3JtKHRvcCkuZ2V0TWF0cml4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zZm9ybShtWzBdLCBtWzFdLCBtWzJdLCBtWzNdLCBtWzRdLCBtWzVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRyYXdGdW5jLmNhbGwodGhpcywgYnVmZmVyQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgYnVmZmVyQ29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzU2hhZG93ICYmICFjYW52YXMuaGl0Q2FudmFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5U2hhZG93KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5fYXBwbHlPcGFjaXR5KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoYnVmZmVyQ2FudmFzLl9jYW52YXMsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5fYXBwbHlPcGFjaXR5KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShidWZmZXJDYW52YXMuX2NhbnZhcywgMCwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgYnVmZmVyIGNhbnZhcyBpcyBub3QgbmVlZGVkXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Ll9hcHBseUxpbmVKb2luKHRoaXMpO1xuICAgICAgICAgICAgICAgIC8vIGxheWVyIG1pZ2h0IGJlIHVuZGVmaW5lZCBpZiB3ZSBhcmUgdXNpbmcgY2FjaGUgYmVmb3JlIGFkZGluZyB0byBsYXllclxuICAgICAgICAgICAgICAgIGlmICghY2FjaGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLl9hcHBseVRyYW5zZm9ybSh0aGlzLCBjb250ZXh0LCB0b3ApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB0aGlzLmdldEFic29sdXRlVHJhbnNmb3JtKHRvcCkuZ2V0TWF0cml4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zZm9ybShvWzBdLCBvWzFdLCBvWzJdLCBvWzNdLCBvWzRdLCBvWzVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChoYXNTaGFkb3cgJiYgaGFzU3Ryb2tlICYmICFjYW52YXMuaGl0Q2FudmFzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBhcHBseSBzaGFkb3dcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Ll9hcHBseU9wYWNpdHkodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5fYXBwbHlTaGFkb3codGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGRyYXdGdW5jLmNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBzaGFwZSBoYXMgc3Ryb2tlIHdlIG5lZWQgdG8gcmVkcmF3IHNoYXBlXG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSB3aWxsIHNlZSBhIHNoYWRvdyB1bmRlciBzdHJva2UgKGFuZCBvdmVyIGZpbGwpXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBJIHRoaW5rIHRoaXMgaXMgdW5leHBlY3RlZCBiZWhhdmlvclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5nZXRTaGFkb3dGb3JTdHJva2VFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdGdW5jLmNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhc1NoYWRvdyAmJiAhY2FudmFzLmhpdENhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Ll9hcHBseU9wYWNpdHkodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5fYXBwbHlTaGFkb3codGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGRyYXdGdW5jLmNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FjaGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5fYXBwbHlPcGFjaXR5KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRyYXdGdW5jLmNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZHJhd0hpdDogZnVuY3Rpb24oY2FuLCB0b3AsIGNhY2hpbmcpIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKSxcbiAgICAgICAgICAgICAgICBjYW52YXMgPSBjYW4gfHwgbGF5ZXIuaGl0Q2FudmFzLFxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgpLFxuICAgICAgICAgICAgICAgIGRyYXdGdW5jID0gdGhpcy5oaXRGdW5jKCkgfHwgdGhpcy5zY2VuZUZ1bmMoKSxcbiAgICAgICAgICAgICAgICBjYWNoZWRDYW52YXMgPSB0aGlzLl9jYWNoZS5jYW52YXMsXG4gICAgICAgICAgICAgICAgY2FjaGVkSGl0Q2FudmFzID0gY2FjaGVkQ2FudmFzICYmIGNhY2hlZENhbnZhcy5oaXQ7XG5cbiAgICAgICAgICAgIGlmKCF0aGlzLnNob3VsZERyYXdIaXQoY2FudmFzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIuY2xlYXJIaXRDYWNoZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhY2hlZEhpdENhbnZhcykge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGxheWVyLl9hcHBseVRyYW5zZm9ybSh0aGlzLCBjb250ZXh0LCB0b3ApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdDYWNoZWRIaXRDYW52YXMoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRyYXdGdW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5TGluZUpvaW4odGhpcyk7XG4gICAgICAgICAgICBpZiAoIWNhY2hpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuX2FwcGx5VHJhbnNmb3JtKHRoaXMsIGNvbnRleHQsIHRvcCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB0aGlzLmdldEFic29sdXRlVHJhbnNmb3JtKHRvcCkuZ2V0TWF0cml4KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQudHJhbnNmb3JtKG9bMF0sIG9bMV0sIG9bMl0sIG9bM10sIG9bNF0sIG9bNV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRyYXdGdW5jLmNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBkcmF3IGhpdCBncmFwaCB1c2luZyB0aGUgY2FjaGVkIHNjZW5lIGNhbnZhc1xuICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICAgICogQHBhcmFtIHtJbnRlZ2VyfSBhbHBoYVRocmVzaG9sZCBhbHBoYSBjaGFubmVsIHRocmVzaG9sZCB0aGF0IGRldGVybWluZXMgd2hldGhlciBvciBub3RcbiAgICAgICAgKiAgYSBwaXhlbCBzaG91bGQgYmUgZHJhd24gb250byB0aGUgaGl0IGdyYXBoLiAgTXVzdCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1LlxuICAgICAgICAqICBUaGUgZGVmYXVsdCBpcyAwXG4gICAgICAgICogQHJldHVybnMge0tvbnZhLlNoYXBlfVxuICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICogc2hhcGUuY2FjaGUoKTtcbiAgICAgICAgKiBzaGFwZS5kcmF3SGl0RnJvbUNhY2hlKCk7XG4gICAgICAgICovXG4gICAgICAgIGRyYXdIaXRGcm9tQ2FjaGU6IGZ1bmN0aW9uKGFscGhhVGhyZXNob2xkKSB7XG4gICAgICAgICAgICB2YXIgdGhyZXNob2xkID0gYWxwaGFUaHJlc2hvbGQgfHwgMCxcbiAgICAgICAgICAgICAgICBjYWNoZWRDYW52YXMgPSB0aGlzLl9jYWNoZS5jYW52YXMsXG4gICAgICAgICAgICAgICAgc2NlbmVDYW52YXMgPSB0aGlzLl9nZXRDYWNoZWRTY2VuZUNhbnZhcygpLFxuICAgICAgICAgICAgICAgIGhpdENhbnZhcyA9IGNhY2hlZENhbnZhcy5oaXQsXG4gICAgICAgICAgICAgICAgaGl0Q29udGV4dCA9IGhpdENhbnZhcy5nZXRDb250ZXh0KCksXG4gICAgICAgICAgICAgICAgaGl0V2lkdGggPSBoaXRDYW52YXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICBoaXRIZWlnaHQgPSBoaXRDYW52YXMuZ2V0SGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgaGl0SW1hZ2VEYXRhLCBoaXREYXRhLCBsZW4sIHJnYkNvbG9yS2V5LCBpLCBhbHBoYTtcblxuICAgICAgICAgICAgaGl0Q29udGV4dC5jbGVhcigpO1xuICAgICAgICAgICAgaGl0Q29udGV4dC5kcmF3SW1hZ2Uoc2NlbmVDYW52YXMuX2NhbnZhcywgMCwgMCwgaGl0V2lkdGgsIGhpdEhlaWdodCk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaGl0SW1hZ2VEYXRhID0gaGl0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaGl0V2lkdGgsIGhpdEhlaWdodCk7XG4gICAgICAgICAgICAgICAgaGl0RGF0YSA9IGhpdEltYWdlRGF0YS5kYXRhO1xuICAgICAgICAgICAgICAgIGxlbiA9IGhpdERhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJnYkNvbG9yS2V5ID0gS29udmEuVXRpbC5faGV4VG9SZ2IodGhpcy5jb2xvcktleSk7XG5cbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIG5vbiB0cmFuc3BhcmVudCBwaXhlbHMgd2l0aCBjb2xvciBrZXlcbiAgICAgICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IGhpdERhdGFbaSArIDNdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGEgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdERhdGFbaV0gPSByZ2JDb2xvcktleS5yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGl0RGF0YVtpICsgMV0gPSByZ2JDb2xvcktleS5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGl0RGF0YVtpICsgMl0gPSByZ2JDb2xvcktleS5iO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGl0RGF0YVtpICsgM10gPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXREYXRhW2kgKyAzXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGl0Q29udGV4dC5wdXRJbWFnZURhdGEoaGl0SW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICBLb252YS5VdGlsLmVycm9yKCdVbmFibGUgdG8gZHJhdyBoaXQgZ3JhcGggZnJvbSBjYWNoZWQgc2NlbmUgY2FudmFzLiAnICsgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5TaGFwZSwgS29udmEuTm9kZSk7XG5cbiAgICAvLyBhZGQgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc3Ryb2tlJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHN0cm9rZSBjb2xvclxuICAgICAqIEBuYW1lIHN0cm9rZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzdHJva2UgY29sb3JcbiAgICAgKiB2YXIgc3Ryb2tlID0gc2hhcGUuc3Ryb2tlKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc3Ryb2tlIGNvbG9yIHdpdGggY29sb3Igc3RyaW5nXG4gICAgICogc2hhcGUuc3Ryb2tlKCdncmVlbicpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHN0cm9rZSBjb2xvciB3aXRoIGhleFxuICAgICAqIHNoYXBlLnN0cm9rZSgnIzAwZmYwMCcpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHN0cm9rZSBjb2xvciB3aXRoIHJnYlxuICAgICAqIHNoYXBlLnN0cm9rZSgncmdiKDAsMjU1LDApJyk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc3Ryb2tlIGNvbG9yIHdpdGggcmdiYSBhbmQgbWFrZSBpdCA1MCUgb3BhcXVlXG4gICAgICogc2hhcGUuc3Ryb2tlKCdyZ2JhKDAsMjU1LDAsMC41Jyk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZERlcHJlY2F0ZWRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzdHJva2VSZWQnLCAwLCBLb252YS5WYWxpZGF0b3JzLlJHQkNvbXBvbmVudCk7XG4gICAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc3Ryb2tlR3JlZW4nLCAwLCBLb252YS5WYWxpZGF0b3JzLlJHQkNvbXBvbmVudCk7XG4gICAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc3Ryb2tlQmx1ZScsIDAsIEtvbnZhLlZhbGlkYXRvcnMuUkdCQ29tcG9uZW50KTtcbiAgICBLb252YS5GYWN0b3J5LmFkZERlcHJlY2F0ZWRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzdHJva2VBbHBoYScsIDEsIEtvbnZhLlZhbGlkYXRvcnMuYWxwaGFDb21wb25lbnQpO1xuXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3N0cm9rZVdpZHRoJywgMik7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHN0cm9rZSB3aWR0aFxuICAgICAqIEBuYW1lIHN0cm9rZVdpZHRoXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3Ryb2tlV2lkdGhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHN0cm9rZSB3aWR0aFxuICAgICAqIHZhciBzdHJva2VXaWR0aCA9IHNoYXBlLnN0cm9rZVdpZHRoKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc3Ryb2tlIHdpZHRoXG4gICAgICogc2hhcGUuc3Ryb2tlV2lkdGgoKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc3Ryb2tlSGl0RW5hYmxlZCcsIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBzdHJva2VIaXRFbmFibGVkIHByb3BlcnR5LiBVc2VmdWwgZm9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cbiAgICAgKiBZb3UgbWF5IHNldCBgc2hhcGUuc3Ryb2tlSGl0RW5hYmxlZChmYWxzZSlgLiBJbiB0aGlzIGNhc2Ugc3Ryb2tlIHdpbGwgYmUgbm8gZHJhdyBvbiBoaXQgY2FudmFzLCBzbyBoaXQgYXJlYVxuICAgICAqIG9mIHNoYXBlIHdpbGwgYmUgZGVjcmVhc2VkIChieSBsaW5lV2lkdGggLyAyKS4gUmVtZW1iZXIgdGhhdCBub24gY2xvc2VkIGxpbmUgd2l0aCBgc3Ryb2tlSGl0RW5hYmxlZCA9IGZhbHNlYFxuICAgICAqIHdpbGwgYmUgbm90IGRyYXduIG9uIGhpdCBjYW52YXMsIHRoYXQgaXMgbWVhbiBsaW5lIHdpbGwgbm8gdHJpZ2dlciBwb2ludGVyIGV2ZW50cyAobGlrZSBtb3VzZW92ZXIpXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQG5hbWUgc3Ryb2tlSGl0RW5hYmxlZFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzdHJva2VIaXRFbmFibGVkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc3Ryb2tlSGl0RW5hYmxlZFxuICAgICAqIHZhciBzdHJva2VIaXRFbmFibGVkID0gc2hhcGUuc3Ryb2tlSGl0RW5hYmxlZCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHN0cm9rZUhpdEVuYWJsZWRcbiAgICAgKiBzaGFwZS5zdHJva2VIaXRFbmFibGVkKCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3BlcmZlY3REcmF3RW5hYmxlZCcsIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBwZXJmZWN0RHJhd0VuYWJsZWQuIElmIGEgc2hhcGUgaGFzIGZpbGwsIHN0cm9rZSBhbmQgb3BhY2l0eSB5b3UgbWF5IHNldCBgcGVyZmVjdERyYXdFbmFibGVkYCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgICAqIFNlZSBodHRwOi8va29udmFqcy5naXRodWIuaW8vZG9jcy9wZXJmb3JtYW5jZS9EaXNhYmxlX1BlcmZlY3RfRHJhdy5odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBuYW1lIHBlcmZlY3REcmF3RW5hYmxlZFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBwZXJmZWN0RHJhd0VuYWJsZWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBwZXJmZWN0RHJhd0VuYWJsZWRcbiAgICAgKiB2YXIgcGVyZmVjdERyYXdFbmFibGVkID0gc2hhcGUucGVyZmVjdERyYXdFbmFibGVkKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgcGVyZmVjdERyYXdFbmFibGVkXG4gICAgICogc2hhcGUucGVyZmVjdERyYXdFbmFibGVkKCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3NoYWRvd0ZvclN0cm9rZUVuYWJsZWQnLCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZC4gVXNlZnVsIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gICAgICogWW91IG1heSBzZXQgYHNoYXBlLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWQoZmFsc2UpYC4gSW4gdGhpcyBjYXNlIHN0cm9rZSB3aWxsIGJlIG5vIGRyYXcgc2hhZG93IGZvciBzdHJva2UuXG4gICAgICogUmVtZW1iZXIgaWYgeW91IHNldCBgc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZCA9IGZhbHNlYCBmb3Igbm9uIGNsb3NlZCBsaW5lIC0gdGhhdCBsaW5lIHdpdGggaGF2ZSBubyBzaGFkb3chLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBuYW1lIHNoYWRvd0ZvclN0cm9rZUVuYWJsZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHNoYWRvd0ZvclN0cm9rZUVuYWJsZWRcbiAgICAgKiB2YXIgc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZCA9IHNoYXBlLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWQoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzaGFkb3dGb3JTdHJva2VFbmFibGVkXG4gICAgICogc2hhcGUuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZCgpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdsaW5lSm9pbicpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBsaW5lIGpvaW4uICBDYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZVxuICAgICAqICBkZWZhdWx0IGlzIG1pdGVyXG4gICAgICogQG5hbWUgbGluZUpvaW5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lSm9pblxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgbGluZSBqb2luXG4gICAgICogdmFyIGxpbmVKb2luID0gc2hhcGUubGluZUpvaW4oKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBsaW5lIGpvaW5cbiAgICAgKiBzaGFwZS5saW5lSm9pbigncm91bmQnKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnbGluZUNhcCcpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBsaW5lIGNhcC4gIENhbiBiZSBidXR0LCByb3VuZCwgb3Igc3F1YXJlXG4gICAgICogQG5hbWUgbGluZUNhcFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmVDYXBcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGxpbmUgY2FwXG4gICAgICogdmFyIGxpbmVDYXAgPSBzaGFwZS5saW5lQ2FwKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgbGluZSBjYXBcbiAgICAgKiBzaGFwZS5saW5lQ2FwKCdyb3VuZCcpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzY2VuZUZ1bmMnKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgc2NlbmUgZHJhdyBmdW5jdGlvblxuICAgICAqIEBuYW1lIHNjZW5lRnVuY1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZHJhd0Z1bmMgZHJhd2luZyBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzY2VuZSBkcmF3IGZ1bmN0aW9uXG4gICAgICogdmFyIHNjZW5lRnVuYyA9IHNoYXBlLnNjZW5lRnVuYygpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNjZW5lIGRyYXcgZnVuY3Rpb25cbiAgICAgKiBzaGFwZS5zY2VuZUZ1bmMoZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAqICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgKiAgIGNvbnRleHQucmVjdCgwLCAwLCB0aGlzLndpZHRoKCksIHRoaXMuaGVpZ2h0KCkpO1xuICAgICAqICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgKiAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAqIH0pO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdoaXRGdW5jJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGhpdCBkcmF3IGZ1bmN0aW9uXG4gICAgICogQG5hbWUgaGl0RnVuY1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZHJhd0Z1bmMgZHJhd2luZyBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBoaXQgZHJhdyBmdW5jdGlvblxuICAgICAqIHZhciBoaXRGdW5jID0gc2hhcGUuaGl0RnVuYygpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGhpdCBkcmF3IGZ1bmN0aW9uXG4gICAgICogc2hhcGUuaGl0RnVuYyhmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICogICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAqICAgY29udGV4dC5yZWN0KDAsIDAsIHRoaXMud2lkdGgoKSwgdGhpcy5oZWlnaHQoKSk7XG4gICAgICogICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAqICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICogfSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2Rhc2gnKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZGFzaCBhcnJheSBmb3Igc3Ryb2tlLlxuICAgICAqIEBuYW1lIGRhc2hcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhc2hcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgLy8gYXBwbHkgZGFzaGVkIHN0cm9rZSB0aGF0IGlzIDEwcHggbG9uZyBhbmQgNSBwaXhlbHMgYXBhcnRcbiAgICAgKiAgbGluZS5kYXNoKFsxMCwgNV0pO1xuICAgICAqICAvLyBhcHBseSBkYXNoZWQgc3Ryb2tlIHRoYXQgaXMgbWFkZSB1cCBvZiBhbHRlcm5hdGluZyBkYXNoZWRcbiAgICAgKiAgLy8gbGluZXMgdGhhdCBhcmUgMTBweCBsb25nIGFuZCAyMHB4IGFwYXJ0LCBhbmQgZG90cyB0aGF0IGhhdmVcbiAgICAgKiAgLy8gYSByYWRpdXMgb2YgNXB4IGFuZCBhcmUgMjBweCBhcGFydFxuICAgICAqICBsaW5lLmRhc2goWzEwLCAyMCwgMC4wMDEsIDIwXSk7XG4gICAgICovXG5cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93Q29sb3InKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgc2hhZG93IGNvbG9yXG4gICAgICogQG5hbWUgc2hhZG93Q29sb3JcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc2hhZG93IGNvbG9yXG4gICAgICogdmFyIHNoYWRvdyA9IHNoYXBlLnNoYWRvd0NvbG9yKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc2hhZG93IGNvbG9yIHdpdGggY29sb3Igc3RyaW5nXG4gICAgICogc2hhcGUuc2hhZG93Q29sb3IoJ2dyZWVuJyk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc2hhZG93IGNvbG9yIHdpdGggaGV4XG4gICAgICogc2hhcGUuc2hhZG93Q29sb3IoJyMwMGZmMDAnKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzaGFkb3cgY29sb3Igd2l0aCByZ2JcbiAgICAgKiBzaGFwZS5zaGFkb3dDb2xvcigncmdiKDAsMjU1LDApJyk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc2hhZG93IGNvbG9yIHdpdGggcmdiYSBhbmQgbWFrZSBpdCA1MCUgb3BhcXVlXG4gICAgICogc2hhcGUuc2hhZG93Q29sb3IoJ3JnYmEoMCwyNTUsMCwwLjUnKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkRGVwcmVjYXRlZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3NoYWRvd1JlZCcsIDAsIEtvbnZhLlZhbGlkYXRvcnMuUkdCQ29tcG9uZW50KTtcbiAgICBLb252YS5GYWN0b3J5LmFkZERlcHJlY2F0ZWRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dHcmVlbicsIDAsIEtvbnZhLlZhbGlkYXRvcnMuUkdCQ29tcG9uZW50KTtcbiAgICBLb252YS5GYWN0b3J5LmFkZERlcHJlY2F0ZWRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dCbHVlJywgMCwgS29udmEuVmFsaWRhdG9ycy5SR0JDb21wb25lbnQpO1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkRGVwcmVjYXRlZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3NoYWRvd0FscGhhJywgMSwgS29udmEuVmFsaWRhdG9ycy5hbHBoYUNvbXBvbmVudCk7XG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3NoYWRvd0JsdXInKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgc2hhZG93IGJsdXJcbiAgICAgKiBAbmFtZSBzaGFkb3dCbHVyXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYmx1clxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc2hhZG93IGJsdXJcbiAgICAgKiB2YXIgc2hhZG93Qmx1ciA9IHNoYXBlLnNoYWRvd0JsdXIoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzaGFkb3cgYmx1clxuICAgICAqIHNoYXBlLnNoYWRvd0JsdXIoMTApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dPcGFjaXR5Jyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHNoYWRvdyBvcGFjaXR5LiAgbXVzdCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBuYW1lIHNoYWRvd09wYWNpdHlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcGFjaXR5XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzaGFkb3cgb3BhY2l0eVxuICAgICAqIHZhciBzaGFkb3dPcGFjaXR5ID0gc2hhcGUuc2hhZG93T3BhY2l0eSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNoYWRvdyBvcGFjaXR5XG4gICAgICogc2hhcGUuc2hhZG93T3BhY2l0eSgwLjUpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93T2Zmc2V0JywgWyd4JywgJ3knXSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHNoYWRvdyBvZmZzZXRcbiAgICAgKiBAbmFtZSBzaGFkb3dPZmZzZXRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0LnhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0LnlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHNoYWRvdyBvZmZzZXRcbiAgICAgKiB2YXIgc2hhZG93T2Zmc2V0ID0gc2hhcGUuc2hhZG93T2Zmc2V0KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc2hhZG93IG9mZnNldFxuICAgICAqIHNoYXBlLnNoYWRvd09mZnNldCh7XG4gICAgICogICB4OiAyMFxuICAgICAqICAgeTogMTBcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93T2Zmc2V0WCcsIDApO1xuXG4gICAgIC8qKlxuICAgICAqIGdldC9zZXQgc2hhZG93IG9mZnNldCB4XG4gICAgICogQG5hbWUgc2hhZG93T2Zmc2V0WFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHNoYWRvdyBvZmZzZXQgeFxuICAgICAqIHZhciBzaGFkb3dPZmZzZXRYID0gc2hhcGUuc2hhZG93T2Zmc2V0WCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNoYWRvdyBvZmZzZXQgeFxuICAgICAqIHNoYXBlLnNoYWRvd09mZnNldFgoNSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3NoYWRvd09mZnNldFknLCAwKTtcblxuICAgICAvKipcbiAgICAgKiBnZXQvc2V0IHNoYWRvdyBvZmZzZXQgeVxuICAgICAqIEBuYW1lIHNoYWRvd09mZnNldFlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzaGFkb3cgb2Zmc2V0IHlcbiAgICAgKiB2YXIgc2hhZG93T2Zmc2V0WSA9IHNoYXBlLnNoYWRvd09mZnNldFkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzaGFkb3cgb2Zmc2V0IHlcbiAgICAgKiBzaGFwZS5zaGFkb3dPZmZzZXRZKDUpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUGF0dGVybkltYWdlJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBuYW1lIGZpbGxQYXR0ZXJuSW1hZ2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtJbWFnZX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiB2YXIgZmlsbFBhdHRlcm5JbWFnZSA9IHNoYXBlLmZpbGxQYXR0ZXJuSW1hZ2UoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiB2YXIgaW1hZ2VPYmogPSBuZXcgSW1hZ2UoKTtcbiAgICAgKiBpbWFnZU9iai5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgKiAgIHNoYXBlLmZpbGxQYXR0ZXJuSW1hZ2UoaW1hZ2VPYmopO1xuICAgICAqIH07XG4gICAgICogaW1hZ2VPYmouc3JjID0gJ3BhdGgvdG8vaW1hZ2UvanBnJztcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbCcpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIGNvbG9yXG4gICAgICogQG5hbWUgZmlsbFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIGNvbG9yXG4gICAgICogdmFyIGZpbGwgPSBzaGFwZS5maWxsKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBjb2xvciB3aXRoIGNvbG9yIHN0cmluZ1xuICAgICAqIHNoYXBlLmZpbGwoJ2dyZWVuJyk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBjb2xvciB3aXRoIGhleFxuICAgICAqIHNoYXBlLmZpbGwoJyMwMGZmMDAnKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIGNvbG9yIHdpdGggcmdiXG4gICAgICogc2hhcGUuZmlsbCgncmdiKDAsMjU1LDApJyk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBjb2xvciB3aXRoIHJnYmEgYW5kIG1ha2UgaXQgNTAlIG9wYXF1ZVxuICAgICAqIHNoYXBlLmZpbGwoJ3JnYmEoMCwyNTUsMCwwLjUnKTtcbiAgICAgKlxuICAgICAqIC8vIHNoYXBlIHdpdGhvdXQgZmlsbFxuICAgICAqIHNoYXBlLmZpbGwobnVsbCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZERlcHJlY2F0ZWRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUmVkJywgMCwgS29udmEuVmFsaWRhdG9ycy5SR0JDb21wb25lbnQpO1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkRGVwcmVjYXRlZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxHcmVlbicsIDAsIEtvbnZhLlZhbGlkYXRvcnMuUkdCQ29tcG9uZW50KTtcbiAgICBLb252YS5GYWN0b3J5LmFkZERlcHJlY2F0ZWRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsQmx1ZScsIDAsIEtvbnZhLlZhbGlkYXRvcnMuUkdCQ29tcG9uZW50KTtcbiAgICBLb252YS5GYWN0b3J5LmFkZERlcHJlY2F0ZWRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsQWxwaGEnLCAxLCBLb252YS5WYWxpZGF0b3JzLmFscGhhQ29tcG9uZW50KTtcblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5YJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiB4XG4gICAgICogQG5hbWUgZmlsbFBhdHRlcm5YXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIHhcbiAgICAgKiB2YXIgZmlsbFBhdHRlcm5YID0gc2hhcGUuZmlsbFBhdHRlcm5YKCk7XG4gICAgICogLy8gc2V0IGZpbGwgcGF0dGVybiB4XG4gICAgICogc2hhcGUuZmlsbFBhdHRlcm5YKDIwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5ZJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiB5XG4gICAgICogQG5hbWUgZmlsbFBhdHRlcm5ZXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIHlcbiAgICAgKiB2YXIgZmlsbFBhdHRlcm5ZID0gc2hhcGUuZmlsbFBhdHRlcm5ZKCk7XG4gICAgICogLy8gc2V0IGZpbGwgcGF0dGVybiB5XG4gICAgICogc2hhcGUuZmlsbFBhdHRlcm5ZKDIwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wcycpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIGxpbmVhciBncmFkaWVudCBjb2xvciBzdG9wc1xuICAgICAqIEBuYW1lIGZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbG9yU3RvcHNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGNvbG9yU3RvcHNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIGxpbmVhciBncmFkaWVudCBjb2xvciBzdG9wc1xuICAgICAqIHZhciBjb2xvclN0b3BzID0gc2hhcGUuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wcygpO1xuICAgICAqXG4gICAgICogLy8gY3JlYXRlIGEgbGluZWFyIGdyYWRpZW50IHRoYXQgc3RhcnRzIHdpdGggcmVkLCBjaGFuZ2VzIHRvIGJsdWVcbiAgICAgKiAvLyBoYWxmd2F5IHRocm91Z2gsIGFuZCB0aGVuIGNoYW5nZXMgdG8gZ3JlZW5cbiAgICAgKiBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzKDAsICdyZWQnLCAwLjUsICdibHVlJywgMSwgJ2dyZWVuJyk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHJhZGl1c1xuICAgICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcmFkaXVzXG4gICAgICogdmFyIHN0YXJ0UmFkaXVzID0gc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcmFkaXVzXG4gICAgICogc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXMoMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1cycsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcmFkaXVzXG4gICAgICogQG5hbWUgZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCByYWRpYWwgZ3JhZGllbnQgZW5kIHJhZGl1c1xuICAgICAqIHZhciBlbmRSYWRpdXMgPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCByYWRpYWwgZ3JhZGllbnQgZW5kIHJhZGl1c1xuICAgICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1cygxMDApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGNvbG9yIHN0b3BzXG4gICAgICogQG5hbWUgZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbG9yU3RvcHNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgY29sb3Igc3RvcHNcbiAgICAgKiB2YXIgY29sb3JTdG9wcyA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMoKTtcbiAgICAgKlxuICAgICAqIC8vIGNyZWF0ZSBhIHJhZGlhbCBncmFkaWVudCB0aGF0IHN0YXJ0cyB3aXRoIHJlZCwgY2hhbmdlcyB0byBibHVlXG4gICAgICogLy8gaGFsZndheSB0aHJvdWdoLCBhbmQgdGhlbiBjaGFuZ2VzIHRvIGdyZWVuXG4gICAgICogc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wcygwLCAncmVkJywgMC41LCAnYmx1ZScsIDEsICdncmVlbicpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUGF0dGVyblJlcGVhdCcsICdyZXBlYXQnKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCBwYXR0ZXJuIHJlcGVhdC4gIENhbiBiZSAncmVwZWF0JywgJ3JlcGVhdC14JywgJ3JlcGVhdC15Jywgb3IgJ25vLXJlcGVhdCcuICBUaGUgZGVmYXVsdCBpcyAncmVwZWF0J1xuICAgICAqIEBuYW1lIGZpbGxQYXR0ZXJuUmVwZWF0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVwZWF0XG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gcmVwZWF0XG4gICAgICogdmFyIHJlcGVhdCA9IHNoYXBlLmZpbGxQYXR0ZXJuUmVwZWF0KCk7XG4gICAgICpcbiAgICAgKiAvLyByZXBlYXQgcGF0dGVybiBpbiB4IGRpcmVjdGlvbiBvbmx5XG4gICAgICogc2hhcGUuZmlsbFBhdHRlcm5SZXBlYXQoJ3JlcGVhdC14Jyk7XG4gICAgICpcbiAgICAgKiAvLyBkbyBub3QgcmVwZWF0IHRoZSBwYXR0ZXJuXG4gICAgICogc2hhcGUuZmlsbFBhdHRlcm5SZXBlYXQoJ25vIHJlcGVhdCcpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsRW5hYmxlZCcsIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIGVuYWJsZWQgZmxhZ1xuICAgICAqIEBuYW1lIGZpbGxFbmFibGVkXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIGVuYWJsZWQgZmxhZ1xuICAgICAqIHZhciBmaWxsRW5hYmxlZCA9IHNoYXBlLmZpbGxFbmFibGVkKCk7XG4gICAgICpcbiAgICAgKiAvLyBkaXNhYmxlIGZpbGxcbiAgICAgKiBzaGFwZS5maWxsRW5hYmxlZChmYWxzZSk7XG4gICAgICpcbiAgICAgKiAvLyBlbmFibGUgZmlsbFxuICAgICAqIHNoYXBlLmZpbGxFbmFibGVkKHRydWUpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzdHJva2VFbmFibGVkJywgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHN0cm9rZSBlbmFibGVkIGZsYWdcbiAgICAgKiBAbmFtZSBzdHJva2VFbmFibGVkXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzdHJva2UgZW5hYmxlZCBmbGFnXG4gICAgICogdmFyIHN0cm9rZUVuYWJsZWQgPSBzaGFwZS5zdHJva2VFbmFibGVkKCk7XG4gICAgICpcbiAgICAgKiAvLyBkaXNhYmxlIHN0cm9rZVxuICAgICAqIHNoYXBlLnN0cm9rZUVuYWJsZWQoZmFsc2UpO1xuICAgICAqXG4gICAgICogLy8gZW5hYmxlIHN0cm9rZVxuICAgICAqIHNoYXBlLnN0cm9rZUVuYWJsZWQodHJ1ZSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3NoYWRvd0VuYWJsZWQnLCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgc2hhZG93IGVuYWJsZWQgZmxhZ1xuICAgICAqIEBuYW1lIHNoYWRvd0VuYWJsZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHNoYWRvdyBlbmFibGVkIGZsYWdcbiAgICAgKiB2YXIgc2hhZG93RW5hYmxlZCA9IHNoYXBlLnNoYWRvd0VuYWJsZWQoKTtcbiAgICAgKlxuICAgICAqIC8vIGRpc2FibGUgc2hhZG93XG4gICAgICogc2hhcGUuc2hhZG93RW5hYmxlZChmYWxzZSk7XG4gICAgICpcbiAgICAgKiAvLyBlbmFibGUgc2hhZG93XG4gICAgICogc2hhcGUuc2hhZG93RW5hYmxlZCh0cnVlKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZGFzaEVuYWJsZWQnLCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZGFzaCBlbmFibGVkIGZsYWdcbiAgICAgKiBAbmFtZSBkYXNoRW5hYmxlZFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZGFzaCBlbmFibGVkIGZsYWdcbiAgICAgKiB2YXIgZGFzaEVuYWJsZWQgPSBzaGFwZS5kYXNoRW5hYmxlZCgpO1xuICAgICAqXG4gICAgICogLy8gZGlzYWJsZSBkYXNoXG4gICAgICogc2hhcGUuZGFzaEVuYWJsZWQoZmFsc2UpO1xuICAgICAqXG4gICAgICogLy8gZW5hYmxlIGRhc2hcbiAgICAgKiBzaGFwZS5kYXNoRW5hYmxlZCh0cnVlKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc3Ryb2tlU2NhbGVFbmFibGVkJywgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHN0cm9rZVNjYWxlIGVuYWJsZWQgZmxhZ1xuICAgICAqIEBuYW1lIHN0cm9rZVNjYWxlRW5hYmxlZFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc3Ryb2tlIHNjYWxlIGVuYWJsZWQgZmxhZ1xuICAgICAqIHZhciBzdHJva2VTY2FsZUVuYWJsZWQgPSBzaGFwZS5zdHJva2VTY2FsZUVuYWJsZWQoKTtcbiAgICAgKlxuICAgICAqIC8vIGRpc2FibGUgc3Ryb2tlIHNjYWxlXG4gICAgICogc2hhcGUuc3Ryb2tlU2NhbGVFbmFibGVkKGZhbHNlKTtcbiAgICAgKlxuICAgICAqIC8vIGVuYWJsZSBzdHJva2Ugc2NhbGVcbiAgICAgKiBzaGFwZS5zdHJva2VTY2FsZUVuYWJsZWQodHJ1ZSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQcmlvcml0eScsICdjb2xvcicpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHByaW9yaXR5LiAgY2FuIGJlIGNvbG9yLCBwYXR0ZXJuLCBsaW5lYXItZ3JhZGllbnQsIG9yIHJhZGlhbC1ncmFkaWVudC4gIFRoZSBkZWZhdWx0IGlzIGNvbG9yLlxuICAgICAqICAgVGhpcyBpcyBoYW5keSBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy5cbiAgICAgKiBAbmFtZSBmaWxsUHJpb3JpdHlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcmlvcml0eVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBwcmlvcml0eVxuICAgICAqIHZhciBmaWxsUHJpb3JpdHkgPSBzaGFwZS5maWxsUHJpb3JpdHkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHByaW9yaXR5XG4gICAgICogc2hhcGUuZmlsbFByaW9yaXR5KCdsaW5lYXItZ3JhZGllbnQnKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQYXR0ZXJuT2Zmc2V0JywgWyd4JywgJ3knXSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiBvZmZzZXRcbiAgICAgKiBAbmFtZSBmaWxsUGF0dGVybk9mZnNldFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9mZnNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQueFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQueVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIG9mZnNldFxuICAgICAqIHZhciBwYXR0ZXJuT2Zmc2V0ID0gc2hhcGUuZmlsbFBhdHRlcm5PZmZzZXQoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHBhdHRlcm4gb2Zmc2V0XG4gICAgICogc2hhcGUuZmlsbFBhdHRlcm5PZmZzZXQoe1xuICAgICAqICAgeDogMjBcbiAgICAgKiAgIHk6IDEwXG4gICAgICogfSk7XG4gICAgICovXG5cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5PZmZzZXRYJywgMCk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gb2Zmc2V0IHhcbiAgICAgKiBAbmFtZSBmaWxsUGF0dGVybk9mZnNldFhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gb2Zmc2V0IHhcbiAgICAgKiB2YXIgcGF0dGVybk9mZnNldFggPSBzaGFwZS5maWxsUGF0dGVybk9mZnNldFgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHBhdHRlcm4gb2Zmc2V0IHhcbiAgICAgKiBzaGFwZS5maWxsUGF0dGVybk9mZnNldFgoMjApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUGF0dGVybk9mZnNldFknLCAwKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiBvZmZzZXQgeVxuICAgICAqIEBuYW1lIGZpbGxQYXR0ZXJuT2Zmc2V0WVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiBvZmZzZXQgeVxuICAgICAqIHZhciBwYXR0ZXJuT2Zmc2V0WSA9IHNoYXBlLmZpbGxQYXR0ZXJuT2Zmc2V0WSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgcGF0dGVybiBvZmZzZXQgeVxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuT2Zmc2V0WSgxMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUGF0dGVyblNjYWxlJywgWyd4JywgJ3knXSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiBzY2FsZVxuICAgICAqIEBuYW1lIGZpbGxQYXR0ZXJuU2NhbGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZS54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlLnlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiBzY2FsZVxuICAgICAqIHZhciBwYXR0ZXJuU2NhbGUgPSBzaGFwZS5maWxsUGF0dGVyblNjYWxlKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBwYXR0ZXJuIHNjYWxlXG4gICAgICogc2hhcGUuZmlsbFBhdHRlcm5TY2FsZSh7XG4gICAgICogICB4OiAyXG4gICAgICogICB5OiAyXG4gICAgICogfSk7XG4gICAgICovXG5cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5TY2FsZVgnLCAxKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiBzY2FsZSB4XG4gICAgICogQG5hbWUgZmlsbFBhdHRlcm5TY2FsZVhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gc2NhbGUgeFxuICAgICAqIHZhciBwYXR0ZXJuU2NhbGVYID0gc2hhcGUuZmlsbFBhdHRlcm5TY2FsZVgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHBhdHRlcm4gc2NhbGUgeFxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuU2NhbGVYKDIpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUGF0dGVyblNjYWxlWScsIDEpO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCBwYXR0ZXJuIHNjYWxlIHlcbiAgICAgKiBAbmFtZSBmaWxsUGF0dGVyblNjYWxlWVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiBzY2FsZSB5XG4gICAgICogdmFyIHBhdHRlcm5TY2FsZVkgPSBzaGFwZS5maWxsUGF0dGVyblNjYWxlWSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgcGF0dGVybiBzY2FsZSB5XG4gICAgICogc2hhcGUuZmlsbFBhdHRlcm5TY2FsZVkoMik7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50JywgWyd4JywgJ3knXSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50XG4gICAgICogQG5hbWUgZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXJ0UG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRQb2ludC54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0UG9pbnQueVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnRcbiAgICAgKiB2YXIgc3RhcnRQb2ludCA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnQoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIGxpbmVhciBncmFkaWVudCBzdGFydCBwb2ludFxuICAgICAqIHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnQoe1xuICAgICAqICAgeDogMjBcbiAgICAgKiAgIHk6IDEwXG4gICAgICogfSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYJywgMCk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIGxpbmVhciBncmFkaWVudCBzdGFydCBwb2ludCB4XG4gICAgICogQG5hbWUgZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIGxpbmVhciBncmFkaWVudCBzdGFydCBwb2ludCB4XG4gICAgICogdmFyIHN0YXJ0UG9pbnRYID0gc2hhcGUuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIGxpbmVhciBncmFkaWVudCBzdGFydCBwb2ludCB4XG4gICAgICogc2hhcGUuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFgoMjApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WScsIDApO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeVxuICAgICAqIEBuYW1lIGZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeVxuICAgICAqIHZhciBzdGFydFBvaW50WSA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeVxuICAgICAqIHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZKDIwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50JywgWyd4JywgJ3knXSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludFxuICAgICAqIEBuYW1lIGZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW5kUG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kUG9pbnQueFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRQb2ludC55XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnRcbiAgICAgKiB2YXIgZW5kUG9pbnQgPSBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludFxuICAgICAqIHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50KHtcbiAgICAgKiAgIHg6IDIwXG4gICAgICogICB5OiAxMFxuICAgICAqIH0pO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFgnLCAwKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludCB4XG4gICAgICogQG5hbWUgZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgZW5kIHBvaW50IHhcbiAgICAgKiB2YXIgZW5kUG9pbnRYID0gc2hhcGUuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgZW5kIHBvaW50IHhcbiAgICAgKiBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFgoMjApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFknLCAwKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludCB5XG4gICAgICogQG5hbWUgZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgZW5kIHBvaW50IHlcbiAgICAgKiB2YXIgZW5kUG9pbnRZID0gc2hhcGUuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgZW5kIHBvaW50IHlcbiAgICAgKiBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFkoMjApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludCcsIFsneCcsICd5J10pO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludFxuICAgICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFydFBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0UG9pbnQueFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFBvaW50LnlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHBvaW50XG4gICAgICogdmFyIHN0YXJ0UG9pbnQgPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnRcbiAgICAgKiBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50KHtcbiAgICAgKiAgIHg6IDIwXG4gICAgICogICB5OiAxMFxuICAgICAqIH0pO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WCcsIDApO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgICAqIHZhciBzdGFydFBvaW50WCA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYKDIwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFknLCAwKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHBvaW50IHlcbiAgICAgKiBAbmFtZSBmaWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHBvaW50IHlcbiAgICAgKiB2YXIgc3RhcnRQb2ludFkgPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHBvaW50IHlcbiAgICAgKiBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WSgyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludCcsIFsneCcsICd5J10pO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnRcbiAgICAgKiBAbmFtZSBmaWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVuZFBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZFBvaW50LnhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kUG9pbnQueVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgZW5kIHBvaW50XG4gICAgICogdmFyIGVuZFBvaW50ID0gc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnQoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnRcbiAgICAgKiBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludCh7XG4gICAgICogICB4OiAyMFxuICAgICAqICAgeTogMTBcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYJywgMCk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnQgeFxuICAgICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludCB4XG4gICAgICogdmFyIGVuZFBvaW50WCA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludCB4XG4gICAgICogc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYKDIwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZJywgMCk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnQgeVxuICAgICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludCB5XG4gICAgICogdmFyIGVuZFBvaW50WSA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludCB5XG4gICAgICogc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZKDIwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5Sb3RhdGlvbicsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBuYW1lIGZpbGxQYXR0ZXJuUm90YXRpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByb3RhdGlvblxuICAgICAqIEByZXR1cm5zIHtLb252YS5TaGFwZX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gcm90YXRpb25cbiAgICAgKiB2YXIgcGF0dGVyblJvdGF0aW9uID0gc2hhcGUuZmlsbFBhdHRlcm5Sb3RhdGlvbigpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgcGF0dGVybiByb3RhdGlvblxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuUm90YXRpb24oMjApO1xuICAgICAqL1xuXG5cbiAgICBLb252YS5GYWN0b3J5LmJhY2tDb21wYXQoS29udmEuU2hhcGUsIHtcbiAgICAgICAgZGFzaEFycmF5OiAnZGFzaCcsXG4gICAgICAgIGdldERhc2hBcnJheTogJ2dldERhc2gnLFxuICAgICAgICBzZXREYXNoQXJyYXk6ICdnZXREYXNoJyxcblxuICAgICAgICBkcmF3RnVuYzogJ3NjZW5lRnVuYycsXG4gICAgICAgIGdldERyYXdGdW5jOiAnZ2V0U2NlbmVGdW5jJyxcbiAgICAgICAgc2V0RHJhd0Z1bmM6ICdzZXRTY2VuZUZ1bmMnLFxuXG4gICAgICAgIGRyYXdIaXRGdW5jOiAnaGl0RnVuYycsXG4gICAgICAgIGdldERyYXdIaXRGdW5jOiAnZ2V0SGl0RnVuYycsXG4gICAgICAgIHNldERyYXdIaXRGdW5jOiAnc2V0SGl0RnVuYydcbiAgICB9KTtcblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5TaGFwZSk7XG59KShLb252YSk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gQ09OU1RBTlRTXG4gICAgdmFyIFNUQUdFID0gJ1N0YWdlJyxcbiAgICAgICAgU1RSSU5HID0gJ3N0cmluZycsXG4gICAgICAgIFBYID0gJ3B4JyxcblxuICAgICAgICBNT1VTRU9VVCA9ICdtb3VzZW91dCcsXG4gICAgICAgIE1PVVNFTEVBVkUgPSAnbW91c2VsZWF2ZScsXG4gICAgICAgIE1PVVNFT1ZFUiA9ICdtb3VzZW92ZXInLFxuICAgICAgICBNT1VTRUVOVEVSID0gJ21vdXNlZW50ZXInLFxuICAgICAgICBNT1VTRU1PVkUgPSAnbW91c2Vtb3ZlJyxcbiAgICAgICAgTU9VU0VET1dOID0gJ21vdXNlZG93bicsXG4gICAgICAgIE1PVVNFVVAgPSAnbW91c2V1cCcsXG4gICAgICAgIENMSUNLID0gJ2NsaWNrJyxcbiAgICAgICAgREJMX0NMSUNLID0gJ2RibGNsaWNrJyxcbiAgICAgICAgVE9VQ0hTVEFSVCA9ICd0b3VjaHN0YXJ0JyxcbiAgICAgICAgVE9VQ0hFTkQgPSAndG91Y2hlbmQnLFxuICAgICAgICBUQVAgPSAndGFwJyxcbiAgICAgICAgREJMX1RBUCA9ICdkYmx0YXAnLFxuICAgICAgICBUT1VDSE1PVkUgPSAndG91Y2htb3ZlJyxcbiAgICAgICAgRE9NTU9VU0VTQ1JPTEwgPSAnRE9NTW91c2VTY3JvbGwnLFxuICAgICAgICBNT1VTRVdIRUVMID0gJ21vdXNld2hlZWwnLFxuICAgICAgICBXSEVFTCA9ICd3aGVlbCcsXG5cbiAgICAgICAgQ09OVEVOVF9NT1VTRU9VVCA9ICdjb250ZW50TW91c2VvdXQnLFxuICAgICAgICBDT05URU5UX01PVVNFT1ZFUiA9ICdjb250ZW50TW91c2VvdmVyJyxcbiAgICAgICAgQ09OVEVOVF9NT1VTRU1PVkUgPSAnY29udGVudE1vdXNlbW92ZScsXG4gICAgICAgIENPTlRFTlRfTU9VU0VET1dOID0gJ2NvbnRlbnRNb3VzZWRvd24nLFxuICAgICAgICBDT05URU5UX01PVVNFVVAgPSAnY29udGVudE1vdXNldXAnLFxuICAgICAgICBDT05URU5UX0NMSUNLID0gJ2NvbnRlbnRDbGljaycsXG4gICAgICAgIENPTlRFTlRfREJMX0NMSUNLID0gJ2NvbnRlbnREYmxjbGljaycsXG4gICAgICAgIENPTlRFTlRfVE9VQ0hTVEFSVCA9ICdjb250ZW50VG91Y2hzdGFydCcsXG4gICAgICAgIENPTlRFTlRfVE9VQ0hFTkQgPSAnY29udGVudFRvdWNoZW5kJyxcbiAgICAgICAgQ09OVEVOVF9EQkxfVEFQID0gJ2NvbnRlbnREYmx0YXAnLFxuICAgICAgICBDT05URU5UX1RBUCA9ICdjb250ZW50VGFwJyxcbiAgICAgICAgQ09OVEVOVF9UT1VDSE1PVkUgPSAnY29udGVudFRvdWNobW92ZScsXG5cbiAgICAgICAgRElWID0gJ2RpdicsXG4gICAgICAgIFJFTEFUSVZFID0gJ3JlbGF0aXZlJyxcbiAgICAgICAgS09OVkFfQ09OVEVOVCA9ICdrb252YWpzLWNvbnRlbnQnLFxuICAgICAgICBTUEFDRSA9ICcgJyxcbiAgICAgICAgVU5ERVJTQ09SRSA9ICdfJyxcbiAgICAgICAgQ09OVEFJTkVSID0gJ2NvbnRhaW5lcicsXG4gICAgICAgIEVNUFRZX1NUUklORyA9ICcnLFxuICAgICAgICBFVkVOVFMgPSBbTU9VU0VET1dOLCBNT1VTRU1PVkUsIE1PVVNFVVAsIE1PVVNFT1VULCBUT1VDSFNUQVJULCBUT1VDSE1PVkUsIFRPVUNIRU5ELCBNT1VTRU9WRVIsIERPTU1PVVNFU0NST0xMLCBNT1VTRVdIRUVMLCBXSEVFTF0sXG5cbiAgICAgICAgLy8gY2FjaGVkIHZhcmlhYmxlc1xuICAgICAgICBldmVudHNMZW5ndGggPSBFVkVOVFMubGVuZ3RoO1xuXG4gICAgZnVuY3Rpb24gYWRkRXZlbnQoY3R4LCBldmVudE5hbWUpIHtcbiAgICAgICAgY3R4LmNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgY3R4W1VOREVSU0NPUkUgKyBldmVudE5hbWVdKGV2dCk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFnZSBjb25zdHJ1Y3Rvci4gIEEgc3RhZ2UgaXMgdXNlZCB0byBjb250YWluIG11bHRpcGxlIGxheWVyc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5Db250YWluZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudH0gY29uZmlnLmNvbnRhaW5lciBDb250YWluZXIgaWQgb3IgRE9NIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHN0YWdlID0gbmV3IEtvbnZhLlN0YWdlKHtcbiAgICAgICAgICogICB3aWR0aDogNTAwLFxuICAgICAgICAgKiAgIGhlaWdodDogODAwLFxuICAgICAgICAgKiAgIGNvbnRhaW5lcjogJ2NvbnRhaW5lcklkJ1xuICAgICAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBLb252YS5TdGFnZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgICB9O1xuXG4gICAgS29udmEuVXRpbC5hZGRNZXRob2RzKEtvbnZhLlN0YWdlLCB7XG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5ub2RlVHlwZSA9IFNUQUdFO1xuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgS29udmEuQ29udGFpbmVyLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuX2lkID0gS29udmEuaWRDb3VudGVyKys7XG4gICAgICAgICAgICB0aGlzLl9idWlsZERPTSgpO1xuICAgICAgICAgICAgdGhpcy5fYmluZENvbnRlbnRFdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZU5lc3RlZFRyYW5zZm9ybXMgPSBmYWxzZTtcbiAgICAgICAgICAgIEtvbnZhLnN0YWdlcy5wdXNoKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBfdmFsaWRhdGVBZGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQuZ2V0VHlwZSgpICE9PSAnTGF5ZXInKSB7XG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC50aHJvdygnWW91IG1heSBvbmx5IGFkZCBsYXllcnMgdG8gdGhlIHN0YWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IGNvbnRhaW5lciBkb20gZWxlbWVudCB3aGljaCBjb250YWlucyB0aGUgc3RhZ2Ugd3JhcHBlciBkaXYgZWxlbWVudFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtEb21FbGVtZW50fSBjb250YWluZXIgY2FuIHBhc3MgaW4gYSBkb20gZWxlbWVudCBvciBpZCBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHNldENvbnRhaW5lcjogZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgICAgICAgICBpZiggdHlwZW9mIGNvbnRhaW5lciA9PT0gU1RSSU5HKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gY29udGFpbmVyO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IEtvbnZhLmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0NhbiBub3QgZmluZCBjb250YWluZXIgaW4gZG9jdW1lbnQgd2l0aCBpZCAnICsgaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2V0QXR0cihDT05UQUlORVIsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgc2hvdWxkRHJhd0hpdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5kcmF3LmNhbGwodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRyYXcgbGF5ZXIgc2NlbmUgZ3JhcGhzXG4gICAgICAgICAqIEBuYW1lIGRyYXdcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkcmF3IGxheWVyIGhpdCBncmFwaHNcbiAgICAgICAgICogQG5hbWUgZHJhd0hpdFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCBoZWlnaHRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRIZWlnaHQuY2FsbCh0aGlzLCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplRE9NKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCB3aWR0aFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICAgICAqL1xuICAgICAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplRE9NKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNsZWFyIGFsbCBsYXllcnNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXJzID0gdGhpcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICBsZW4gPSBsYXllcnMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG47XG5cbiAgICAgICAgICAgIGZvcihuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJzW25dLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICAgICAgICBvYmogPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iai5jb250YWluZXIgPSBLb252YS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KERJVik7XG4gICAgICAgICAgICByZXR1cm4gS29udmEuQ29udGFpbmVyLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsIG9iaik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZXN0cm95IHN0YWdlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuY29udGVudDtcbiAgICAgICAgICAgIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICBpZihjb250ZW50ICYmIEtvbnZhLlV0aWwuX2lzSW5Eb2N1bWVudChjb250ZW50KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29udGFpbmVyKCkucmVtb3ZlQ2hpbGQoY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBLb252YS5zdGFnZXMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgS29udmEuc3RhZ2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBwb2ludGVyIHBvc2l0aW9uIHdoaWNoIGNhbiBiZSBhIHRvdWNoIHBvc2l0aW9uIG9yIG1vdXNlIHBvc2l0aW9uXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0UG9pbnRlclBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvaW50ZXJQb3M7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFN0YWdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IHN0YWdlIGNvbnRlbnQgZGl2IGVsZW1lbnQgd2hpY2ggaGFzIHRoZVxuICAgICAgICAgKiAgdGhlIGNsYXNzIG5hbWUgXCJrb252YWpzLWNvbnRlbnRcIlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGdldENvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBjb21wb3NpdGUgZGF0YSBVUkxcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5jYWxsYmFja10gZnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiB0aGUgY29tcG9zaXRlIGhhcyBjb21wbGV0ZWQuIERlcHJlY2F0ZWQgYXMgbWV0aG9kIGlzIHN5bmMgbm93LlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5taW1lVHlwZV0gY2FuIGJlIFwiaW1hZ2UvcG5nXCIgb3IgXCJpbWFnZS9qcGVnXCIuXG4gICAgICAgICAqICBcImltYWdlL3BuZ1wiIGlzIHRoZSBkZWZhdWx0XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdIHggcG9zaXRpb24gb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV0geSBwb3NpdGlvbiBvZiBjYW52YXMgc2VjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF0gd2lkdGggb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XSBoZWlnaHQgb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucXVhbGl0eV0ganBlZyBxdWFsaXR5LiAgSWYgdXNpbmcgYW4gXCJpbWFnZS9qcGVnXCIgbWltZVR5cGUsXG4gICAgICAgICAqICB5b3UgY2FuIHNwZWNpZnkgdGhlIHF1YWxpdHkgZnJvbSAwIHRvIDEsIHdoZXJlIDAgaXMgdmVyeSBwb29yIHF1YWxpdHkgYW5kIDFcbiAgICAgICAgICogIGlzIHZlcnkgaGlnaCBxdWFsaXR5XG4gICAgICAgICAqL1xuICAgICAgICB0b0RhdGFVUkw6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gICAgICAgICAgICB2YXIgbWltZVR5cGUgPSBjb25maWcubWltZVR5cGUgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBxdWFsaXR5ID0gY29uZmlnLnF1YWxpdHkgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICB4ID0gY29uZmlnLnggfHwgMCxcbiAgICAgICAgICAgICAgICB5ID0gY29uZmlnLnkgfHwgMCxcbiAgICAgICAgICAgICAgICBjYW52YXMgPSBuZXcgS29udmEuU2NlbmVDYW52YXMoe1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogY29uZmlnLndpZHRoIHx8IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjb25maWcuaGVpZ2h0IHx8IHRoaXMuZ2V0SGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgICAgIHBpeGVsUmF0aW86IGNvbmZpZy5waXhlbFJhdGlvXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgX2NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgpLl9jb250ZXh0LFxuICAgICAgICAgICAgICAgIGxheWVycyA9IHRoaXMuY2hpbGRyZW47XG5cbiAgICAgICAgICAgIGlmKHggfHwgeSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LnRyYW5zbGF0ZSgtMSAqIHgsIC0xICogeSk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgbGF5ZXJzLmVhY2goZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBsYXllci5nZXRDYW52YXMoKS5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBsYXllci5nZXRDYW52YXMoKS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmF0aW8gPSBsYXllci5nZXRDYW52YXMoKS5nZXRQaXhlbFJhdGlvKCk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQuZHJhd0ltYWdlKGxheWVyLmdldENhbnZhcygpLl9jYW52YXMsIDAsIDAsIHdpZHRoIC8gcmF0aW8sIGhlaWdodCAvIHJhdGlvKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHNyYyA9IGNhbnZhcy50b0RhdGFVUkwobWltZVR5cGUsIHF1YWxpdHkpO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmNhbGxiYWNrKHNyYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzcmM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjb252ZXJ0cyBzdGFnZSBpbnRvIGFuIGltYWdlLlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25maWcuY2FsbGJhY2sgZnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiB0aGUgY29tcG9zaXRlIGhhcyBjb21wbGV0ZWRcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubWltZVR5cGVdIGNhbiBiZSBcImltYWdlL3BuZ1wiIG9yIFwiaW1hZ2UvanBlZ1wiLlxuICAgICAgICAgKiAgXCJpbWFnZS9wbmdcIiBpcyB0aGUgZGVmYXVsdFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XSB4IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldIHkgcG9zaXRpb24gb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdIHdpZHRoIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF0gaGVpZ2h0IG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnF1YWxpdHldIGpwZWcgcXVhbGl0eS4gIElmIHVzaW5nIGFuIFwiaW1hZ2UvanBlZ1wiIG1pbWVUeXBlLFxuICAgICAgICAgKiAgeW91IGNhbiBzcGVjaWZ5IHRoZSBxdWFsaXR5IGZyb20gMCB0byAxLCB3aGVyZSAwIGlzIHZlcnkgcG9vciBxdWFsaXR5IGFuZCAxXG4gICAgICAgICAqICBpcyB2ZXJ5IGhpZ2ggcXVhbGl0eVxuICAgICAgICAgKi9cbiAgICAgICAgdG9JbWFnZTogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICB2YXIgY2IgPSBjb25maWcuY2FsbGJhY2s7XG5cbiAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFjayA9IGZ1bmN0aW9uKGRhdGFVcmwpIHtcbiAgICAgICAgICAgICAgICBLb252YS5VdGlsLl9nZXRJbWFnZShkYXRhVXJsLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IoaW1nKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnRvRGF0YVVSTChjb25maWcpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IHZpc2libGUgaW50ZXJzZWN0aW9uIHNoYXBlLiBUaGlzIGlzIHRoZSBwcmVmZXJyZWRcbiAgICAgICAgICogIG1ldGhvZCBmb3IgZGV0ZXJtaW5pbmcgaWYgYSBwb2ludCBpbnRlcnNlY3RzIGEgc2hhcGUgb3Igbm90XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9zXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zLnlcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtzZWxlY3Rvcl1cbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIHZhciBzaGFwZSA9IHN0YWdlLmdldEludGVyc2VjdGlvbih7eDogNTAsIHk6IDUwfSk7XG4gICAgICAgICAqIC8vIG9yIGlmIHlvdSBpbnRlcmVzdGVkIGluIHNoYXBlIHBhcmVudDpcbiAgICAgICAgICogdmFyIGdyb3VwID0gc3RhZ2UuZ2V0SW50ZXJzZWN0aW9uKHt4OiA1MCwgeTogNTB9LCAnR3JvdXAnKTtcbiAgICAgICAgICovXG4gICAgICAgIGdldEludGVyc2VjdGlvbjogZnVuY3Rpb24ocG9zLCBzZWxlY3Rvcikge1xuICAgICAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuZ2V0Q2hpbGRyZW4oKSxcbiAgICAgICAgICAgICAgICBsZW4gPSBsYXllcnMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGVuZCA9IGxlbiAtIDEsXG4gICAgICAgICAgICAgICAgbiwgc2hhcGU7XG5cbiAgICAgICAgICAgIGZvcihuID0gZW5kOyBuID49IDA7IG4tLSkge1xuICAgICAgICAgICAgICAgIHNoYXBlID0gbGF5ZXJzW25dLmdldEludGVyc2VjdGlvbihwb3MsIHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIF9yZXNpemVET006IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYodGhpcy5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpLFxuICAgICAgICAgICAgICAgICAgICBsYXllcnMgPSB0aGlzLmdldENoaWxkcmVuKCksXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IGxheWVycy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIG4sIGxheWVyO1xuXG4gICAgICAgICAgICAgICAgLy8gc2V0IGNvbnRlbnQgZGltZW5zaW9uc1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5zdHlsZS53aWR0aCA9IHdpZHRoICsgUFg7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFBYO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXJDYW52YXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlckhpdENhbnZhcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gc2V0IGxheWVyIGRpbWVuc2lvbnNcbiAgICAgICAgICAgICAgICBmb3IobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgICAgICBsYXllciA9IGxheWVyc1tuXTtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZHJhdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFkZCBsYXllciBvciBsYXllcnMgdG8gc3RhZ2VcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7Li4uS29udmEuTGF5ZXJ9IGxheWVyXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIHN0YWdlLmFkZChsYXllcjEsIGxheWVyMiwgbGF5ZXIzKTtcbiAgICAgICAgICovXG4gICAgICAgIGFkZDogZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCBsYXllcik7XG4gICAgICAgICAgICBsYXllci5fc2V0Q2FudmFzU2l6ZSh0aGlzLndpZHRoKCksIHRoaXMuaGVpZ2h0KCkpO1xuXG4gICAgICAgICAgICAvLyBkcmF3IGxheWVyIGFuZCBhcHBlbmQgY2FudmFzIHRvIGNvbnRhaW5lclxuICAgICAgICAgICAgbGF5ZXIuZHJhdygpO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LmFwcGVuZENoaWxkKGxheWVyLmNhbnZhcy5fY2FudmFzKTtcblxuICAgICAgICAgICAgLy8gY2hhaW5hYmxlXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UGFyZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBnZXRMYXllcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJldHVybnMgYSB7QGxpbmsgS29udmEuQ29sbGVjdGlvbn0gb2YgbGF5ZXJzXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGF5ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9iaW5kQ29udGVudEV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGV2ZW50c0xlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICAgICAgYWRkRXZlbnQodGhpcywgRVZFTlRTW25dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX21vdXNlb3ZlcjogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICBpZiAoIUtvbnZhLlVBLm1vYmlsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFBvaW50ZXJQb3NpdGlvbihldnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9NT1VTRU9WRVIsIHtldnQ6IGV2dH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfbW91c2VvdXQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgaWYgKCFLb252YS5VQS5tb2JpbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0U2hhcGUgPSB0aGlzLnRhcmdldFNoYXBlO1xuXG4gICAgICAgICAgICAgICAgaWYodGFyZ2V0U2hhcGUgJiYgIUtvbnZhLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRTaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRU9VVCwge2V2dDogZXZ0fSk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFNoYXBlLl9maXJlQW5kQnViYmxlKE1PVVNFTEVBVkUsIHtldnQ6IGV2dH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFNoYXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyUG9zID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX01PVVNFT1VULCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX21vdXNlbW92ZTogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAvLyB3b3JrYXJvdW5kIGZvciBtb2JpbGUgSUUgdG8gZm9yY2UgdG91Y2ggZXZlbnQgd2hlbiB1bmhhbmRsZWQgcG9pbnRlciBldmVudCBlbGV2YXRlcyBpbnRvIGEgbW91c2UgZXZlbnRcbiAgICAgICAgICAgIGlmIChLb252YS5VQS5pZU1vYmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90b3VjaG1vdmUoZXZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdvcmthcm91bmQgZmFrZSBtb3VzZW1vdmUgZXZlbnQgaW4gY2hyb21lIGJyb3dzZXIgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTE2MTQ2NFxuICAgICAgICAgICAgaWYgKCh0eXBlb2YgZXZ0Lm1vdmVtZW50WCAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGV2dC5tb3ZlbWVudFkgIT09ICd1bmRlZmluZWQnKSAmJiBldnQubW92ZW1lbnRZID09PSAwICYmIGV2dC5tb3ZlbWVudFggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChLb252YS5VQS5tb2JpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldFBvaW50ZXJQb3NpdGlvbihldnQpO1xuICAgICAgICAgICAgdmFyIHNoYXBlO1xuXG4gICAgICAgICAgICBpZiAoIUtvbnZhLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgICAgIHNoYXBlID0gdGhpcy5nZXRJbnRlcnNlY3Rpb24odGhpcy5nZXRQb2ludGVyUG9zaXRpb24oKSk7XG4gICAgICAgICAgICAgICAgaWYoc2hhcGUgJiYgc2hhcGUuaXNMaXN0ZW5pbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZighS29udmEuaXNEcmFnZ2luZygpICYmICghdGhpcy50YXJnZXRTaGFwZSB8fCB0aGlzLnRhcmdldFNoYXBlLl9pZCAhPT0gc2hhcGUuX2lkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy50YXJnZXRTaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0U2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VPVVQsIHtldnQ6IGV2dH0sIHNoYXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFNoYXBlLl9maXJlQW5kQnViYmxlKE1PVVNFTEVBVkUsIHtldnQ6IGV2dH0sIHNoYXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKE1PVVNFT1ZFUiwge2V2dDogZXZ0fSwgdGhpcy50YXJnZXRTaGFwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRUVOVEVSLCB7ZXZ0OiBldnR9LCB0aGlzLnRhcmdldFNoYXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0U2hhcGUgPSBzaGFwZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKE1PVVNFTU9WRSwge2V2dDogZXZ0fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBpZiBubyBzaGFwZSB3YXMgZGV0ZWN0ZWQsIGNsZWFyIHRhcmdldCBzaGFwZSBhbmQgdHJ5XG4gICAgICAgICAgICAgICAgICogdG8gcnVuIG1vdXNlb3V0IGZyb20gcHJldmlvdXMgdGFyZ2V0IHNoYXBlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMudGFyZ2V0U2hhcGUgJiYgIUtvbnZhLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXRTaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRU9VVCwge2V2dDogZXZ0fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFNoYXBlLl9maXJlQW5kQnViYmxlKE1PVVNFTEVBVkUsIHtldnQ6IGV2dH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXRTaGFwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNvbnRlbnQgZXZlbnRcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfTU9VU0VNT1ZFLCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWx3YXlzIGNhbGwgcHJldmVudERlZmF1bHQgZm9yIGRlc2t0b3AgZXZlbnRzIGJlY2F1c2Ugc29tZSBicm93c2Vyc1xuICAgICAgICAgICAgLy8gdHJ5IHRvIGRyYWcgYW5kIGRyb3AgdGhlIGNhbnZhcyBlbGVtZW50XG4gICAgICAgICAgICBpZiAoZXZ0LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9tb3VzZWRvd246IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgbW9iaWxlIElFIHRvIGZvcmNlIHRvdWNoIGV2ZW50IHdoZW4gdW5oYW5kbGVkIHBvaW50ZXIgZXZlbnQgZWxldmF0ZXMgaW50byBhIG1vdXNlIGV2ZW50XG4gICAgICAgICAgICBpZiAoS29udmEuVUEuaWVNb2JpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdG91Y2hzdGFydChldnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFLb252YS5VQS5tb2JpbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLmdldEludGVyc2VjdGlvbih0aGlzLmdldFBvaW50ZXJQb3NpdGlvbigpKTtcblxuICAgICAgICAgICAgICAgIEtvbnZhLmxpc3RlbkNsaWNrVGFwID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5pc0xpc3RlbmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpY2tTdGFydFNoYXBlID0gc2hhcGU7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKE1PVVNFRE9XTiwge2V2dDogZXZ0fSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY29udGVudCBldmVudFxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9NT1VTRURPV04sIHtldnQ6IGV2dH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhbHdheXMgY2FsbCBwcmV2ZW50RGVmYXVsdCBmb3IgZGVza3RvcCBldmVudHMgYmVjYXVzZSBzb21lIGJyb3dzZXJzXG4gICAgICAgICAgICAvLyB0cnkgdG8gZHJhZyBhbmQgZHJvcCB0aGUgY2FudmFzIGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChldnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX21vdXNldXA6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgICAgICAvLyB3b3JrYXJvdW5kIGZvciBtb2JpbGUgSUUgdG8gZm9yY2UgdG91Y2ggZXZlbnQgd2hlbiB1bmhhbmRsZWQgcG9pbnRlciBldmVudCBlbGV2YXRlcyBpbnRvIGEgbW91c2UgZXZlbnRcbiAgICAgICAgICAgIGlmIChLb252YS5VQS5pZU1vYmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90b3VjaGVuZChldnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFLb252YS5VQS5tb2JpbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLmdldEludGVyc2VjdGlvbih0aGlzLmdldFBvaW50ZXJQb3NpdGlvbigpKSxcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tTdGFydFNoYXBlID0gdGhpcy5jbGlja1N0YXJ0U2hhcGUsXG4gICAgICAgICAgICAgICAgICAgIGZpcmVEYmxDbGljayA9IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkZCA9IEtvbnZhLkREO1xuXG4gICAgICAgICAgICAgICAgaWYoS29udmEuaW5EYmxDbGlja1dpbmRvdykge1xuICAgICAgICAgICAgICAgICAgICBmaXJlRGJsQ2xpY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBLb252YS5pbkRibENsaWNrV2luZG93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRvbid0IHNldCBpbkRibENsaWNrV2luZG93IGFmdGVyIGRyYWdnaW5nXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRkIHx8ICFkZC5qdXN0RHJhZ2dlZCkge1xuICAgICAgICAgICAgICAgICAgICBLb252YS5pbkRibENsaWNrV2luZG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRkLmp1c3REcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgS29udmEuaW5EYmxDbGlja1dpbmRvdyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIEtvbnZhLmRibENsaWNrV2luZG93KTtcblxuICAgICAgICAgICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5pc0xpc3RlbmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKE1PVVNFVVAsIHtldnQ6IGV2dH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRldGVjdCBpZiBjbGljayBvciBkb3VibGUgY2xpY2sgb2NjdXJyZWRcbiAgICAgICAgICAgICAgICAgICAgaWYoS29udmEubGlzdGVuQ2xpY2tUYXAgJiYgY2xpY2tTdGFydFNoYXBlICYmIGNsaWNrU3RhcnRTaGFwZS5faWQgPT09IHNoYXBlLl9pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoQ0xJQ0ssIHtldnQ6IGV2dH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihmaXJlRGJsQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShEQkxfQ0xJQ0ssIHtldnQ6IGV2dH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvbnRlbnQgZXZlbnRzXG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX01PVVNFVVAsIHtldnQ6IGV2dH0pO1xuICAgICAgICAgICAgICAgIGlmIChLb252YS5saXN0ZW5DbGlja1RhcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfQ0xJQ0ssIHtldnQ6IGV2dH0pO1xuICAgICAgICAgICAgICAgICAgICBpZihmaXJlRGJsQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9EQkxfQ0xJQ0ssIHtldnQ6IGV2dH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgS29udmEubGlzdGVuQ2xpY2tUYXAgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWx3YXlzIGNhbGwgcHJldmVudERlZmF1bHQgZm9yIGRlc2t0b3AgZXZlbnRzIGJlY2F1c2Ugc29tZSBicm93c2Vyc1xuICAgICAgICAgICAgLy8gdHJ5IHRvIGRyYWcgYW5kIGRyb3AgdGhlIGNhbnZhcyBlbGVtZW50XG4gICAgICAgICAgICBpZiAoZXZ0LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF90b3VjaHN0YXJ0OiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFBvaW50ZXJQb3NpdGlvbihldnQpO1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5nZXRJbnRlcnNlY3Rpb24odGhpcy5nZXRQb2ludGVyUG9zaXRpb24oKSk7XG5cbiAgICAgICAgICAgIEtvbnZhLmxpc3RlbkNsaWNrVGFwID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLmlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcFN0YXJ0U2hhcGUgPSBzaGFwZTtcbiAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShUT1VDSFNUQVJULCB7ZXZ0OiBldnR9KTtcblxuICAgICAgICAgICAgICAgIC8vIG9ubHkgY2FsbCBwcmV2ZW50RGVmYXVsdCBpZiB0aGUgc2hhcGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUuaXNMaXN0ZW5pbmcoKSAmJiBldnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29udGVudCBldmVudFxuICAgICAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX1RPVUNIU1RBUlQsIHtldnQ6IGV2dH0pO1xuICAgICAgICB9LFxuICAgICAgICBfdG91Y2hlbmQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLmdldEludGVyc2VjdGlvbih0aGlzLmdldFBvaW50ZXJQb3NpdGlvbigpKSxcbiAgICAgICAgICAgICAgICBmaXJlRGJsQ2xpY2sgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYoS29udmEuaW5EYmxDbGlja1dpbmRvdykge1xuICAgICAgICAgICAgICAgIGZpcmVEYmxDbGljayA9IHRydWU7XG4gICAgICAgICAgICAgICAgS29udmEuaW5EYmxDbGlja1dpbmRvdyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgS29udmEuaW5EYmxDbGlja1dpbmRvdyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgS29udmEuaW5EYmxDbGlja1dpbmRvdyA9IGZhbHNlO1xuICAgICAgICAgICAgfSwgS29udmEuZGJsQ2xpY2tXaW5kb3cpO1xuXG4gICAgICAgICAgICBpZiAoc2hhcGUgJiYgc2hhcGUuaXNMaXN0ZW5pbmcoKSkge1xuICAgICAgICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKFRPVUNIRU5ELCB7ZXZ0OiBldnR9KTtcblxuICAgICAgICAgICAgICAgIC8vIGRldGVjdCBpZiB0YXAgb3IgZG91YmxlIHRhcCBvY2N1cnJlZFxuICAgICAgICAgICAgICAgIGlmKEtvbnZhLmxpc3RlbkNsaWNrVGFwICYmIHNoYXBlLl9pZCA9PT0gdGhpcy50YXBTdGFydFNoYXBlLl9pZCkge1xuICAgICAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShUQVAsIHtldnQ6IGV2dH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKGZpcmVEYmxDbGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoREJMX1RBUCwge2V2dDogZXZ0fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb25seSBjYWxsIHByZXZlbnREZWZhdWx0IGlmIHRoZSBzaGFwZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmIChzaGFwZS5pc0xpc3RlbmluZygpICYmIGV2dC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb250ZW50IGV2ZW50c1xuICAgICAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX1RPVUNIRU5ELCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgICAgIGlmIChLb252YS5saXN0ZW5DbGlja1RhcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9UQVAsIHtldnQ6IGV2dH0pO1xuICAgICAgICAgICAgICAgIGlmKGZpcmVEYmxDbGljaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfREJMX1RBUCwge2V2dDogZXZ0fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBLb252YS5saXN0ZW5DbGlja1RhcCA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBfdG91Y2htb3ZlOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFBvaW50ZXJQb3NpdGlvbihldnQpO1xuICAgICAgICAgICAgdmFyIGRkID0gS29udmEuREQsXG4gICAgICAgICAgICAgICAgc2hhcGU7XG4gICAgICAgICAgICBpZiAoIUtvbnZhLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgICAgIHNoYXBlID0gdGhpcy5nZXRJbnRlcnNlY3Rpb24odGhpcy5nZXRQb2ludGVyUG9zaXRpb24oKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLmlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoVE9VQ0hNT1ZFLCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBjYWxsIHByZXZlbnREZWZhdWx0IGlmIHRoZSBzaGFwZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcGUuaXNMaXN0ZW5pbmcoKSAmJiBldnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9UT1VDSE1PVkUsIHtldnQ6IGV2dH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoS29udmEuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX0RPTU1vdXNlU2Nyb2xsOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIHRoaXMuX21vdXNld2hlZWwoZXZ0KTtcbiAgICAgICAgfSxcbiAgICAgICAgX21vdXNld2hlZWw6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLmdldEludGVyc2VjdGlvbih0aGlzLmdldFBvaW50ZXJQb3NpdGlvbigpKTtcblxuICAgICAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLmlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRVdIRUVMLCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX3doZWVsOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIHRoaXMuX21vdXNld2hlZWwoZXZ0KTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NldFBvaW50ZXJQb3NpdGlvbjogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICB2YXIgY29udGVudFBvc2l0aW9uID0gdGhpcy5fZ2V0Q29udGVudFBvc2l0aW9uKCksXG4gICAgICAgICAgICAgICAgeCA9IG51bGwsXG4gICAgICAgICAgICAgICAgeSA9IG51bGw7XG4gICAgICAgICAgICBldnQgPSBldnQgPyBldnQgOiB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgICAgICAgIC8vIHRvdWNoIGV2ZW50c1xuICAgICAgICAgICAgaWYoZXZ0LnRvdWNoZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnRseSwgb25seSBoYW5kbGUgb25lIGZpbmdlclxuICAgICAgICAgICAgICAgIGlmIChldnQudG91Y2hlcy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvdWNoID0gZXZ0LnRvdWNoZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgaW5mb3JtYXRpb24gZm9yIGZpbmdlciAjMVxuICAgICAgICAgICAgICAgICAgICB4ID0gdG91Y2guY2xpZW50WCAtIGNvbnRlbnRQb3NpdGlvbi5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICB5ID0gdG91Y2guY2xpZW50WSAtIGNvbnRlbnRQb3NpdGlvbi50b3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbW91c2UgZXZlbnRzXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gZXZ0LmNsaWVudFggLSBjb250ZW50UG9zaXRpb24ubGVmdDtcbiAgICAgICAgICAgICAgICB5ID0gZXZ0LmNsaWVudFkgLSBjb250ZW50UG9zaXRpb24udG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHggIT09IG51bGwgJiYgeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlclBvcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRDb250ZW50UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID8gdGhpcy5jb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogeyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9wOiByZWN0LnRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIF9idWlsZERPTTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXRDb250YWluZXIoKTtcbiAgICAgICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKEtvbnZhLlV0aWwuaXNCcm93c2VyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ1N0YWdlIGhhcyBubyBjb250YWluZXIuIEEgY29udGFpbmVyIGlzIHJlcXVpcmVkLic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSBjcmVhdGUgZWxlbWVudCBmb3IganNkb20gaW4gbm9kZWpzIGVudlxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgPSBLb252YS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KERJVik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2xlYXIgY29udGVudCBpbnNpZGUgY29udGFpbmVyXG4gICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gRU1QVFlfU1RSSU5HO1xuXG4gICAgICAgICAgICAvLyBjb250ZW50XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSBLb252YS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KERJVik7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuc3R5bGUucG9zaXRpb24gPSBSRUxBVElWRTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5jbGFzc05hbWUgPSBLT05WQV9DT05URU5UO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnQpO1xuXG4gICAgICAgICAgICAvLyB0aGUgYnVmZmVyIGNhbnZhcyBwaXhlbCByYXRpbyBtdXN0IGJlIDEgYmVjYXVzZSBpdCBpcyB1c2VkIGFzIGFuXG4gICAgICAgICAgICAvLyBpbnRlcm1lZGlhdGUgY2FudmFzIGJlZm9yZSBjb3B5aW5nIHRoZSByZXN1bHQgb250byBhIHNjZW5lIGNhbnZhcy5cbiAgICAgICAgICAgIC8vIG5vdCBzZXR0aW5nIGl0IHRvIDEgd2lsbCByZXN1bHQgaW4gYW4gb3ZlciBjb21wZW5zYXRpb25cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyQ2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKHtcbiAgICAgICAgICAgICAgICBwaXhlbFJhdGlvOiAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVySGl0Q2FudmFzID0gbmV3IEtvbnZhLkhpdENhbnZhcygpO1xuXG4gICAgICAgICAgICB0aGlzLl9yZXNpemVET00oKTtcbiAgICAgICAgfSxcbiAgICAgICAgX29uQ29udGVudDogZnVuY3Rpb24odHlwZXNTdHIsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHZhciB0eXBlcyA9IHR5cGVzU3RyLnNwbGl0KFNQQUNFKSxcbiAgICAgICAgICAgICAgICBsZW4gPSB0eXBlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbiwgYmFzZUV2ZW50O1xuXG4gICAgICAgICAgICBmb3IobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgIGJhc2VFdmVudCA9IHR5cGVzW25dO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5hZGRFdmVudExpc3RlbmVyKGJhc2VFdmVudCwgaGFuZGxlciwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBjdXJyZW50bHkgY2FjaGUgZnVuY3Rpb24gaXMgbm93IHdvcmtpbmcgZm9yIHN0YWdlLCBiZWNhdXNlIHN0YWdlIGhhcyBubyBpdHMgb3duIGNhbnZhcyBlbGVtZW50XG4gICAgICAgIC8vIFRPRE86IG1heSBiZSBpdCBpcyBiZXR0ZXIgdG8gY2FjaGUgYWxsIGNoaWxkcmVuIGxheWVycz9cbiAgICAgICAgY2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdDYWNoZSBmdW5jdGlvbiBpcyBub3QgYWxsb3dlZCBmb3Igc3RhZ2UuIFlvdSBtYXkgdXNlIGNhY2hlIG9ubHkgZm9yIGxheWVycywgZ3JvdXBzIGFuZCBzaGFwZXMuJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFyQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuU3RhZ2UsIEtvbnZhLkNvbnRhaW5lcik7XG5cbiAgICAvLyBhZGQgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyKEtvbnZhLlN0YWdlLCAnY29udGFpbmVyJyk7XG4gICAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLlN0YWdlLCAnY29udGFpbmVyJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQgY29udGFpbmVyIERPTSBlbGVtZW50XG4gICAgICogQG5hbWUgY29udGFpbmVyXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7RG9tRWxlbWVudH0gY29udGFpbmVyXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY29udGFpbmVyXG4gICAgICogdmFyIGNvbnRhaW5lciA9IHN0YWdlLmNvbnRhaW5lcigpO1xuICAgICAqIC8vIHNldCBjb250YWluZXJcbiAgICAgKiB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICogYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAqIHN0YWdlLmNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAqL1xuXG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qKlxuICAgICAqIEJhc2VMYXllciBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYXVnbWVudHMgS29udmEuQ29udGFpbmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5jbGVhckJlZm9yZURyYXddIHNldCB0aGlzIHByb3BlcnR5IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50XG4gICAgICogdG8gY2xlYXIgdGhlIGNhbnZhcyBiZWZvcmUgZWFjaCBsYXllciBkcmF3LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuY2xpcF0gc2V0IGNsaXBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWF0gc2V0IGNsaXAgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBZXSBzZXQgY2xpcCB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFdpZHRoXSBzZXQgY2xpcCB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBIZWlnaHRdIHNldCBjbGlwIGhlaWdodFxuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgbGF5ZXIgPSBuZXcgS29udmEuTGF5ZXIoKTtcbiAgICAgKi9cbiAgICBLb252YS5CYXNlTGF5ZXIgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLlV0aWwuYWRkTWV0aG9kcyhLb252YS5CYXNlTGF5ZXIsIHtcbiAgICAgICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVUeXBlID0gJ0xheWVyJztcbiAgICAgICAgICAgIEtvbnZhLkNvbnRhaW5lci5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZVBOR1N0cmVhbTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMuX2NhbnZhcy5jcmVhdGVQTkdTdHJlYW0oKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBsYXllciBjYW52YXNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbnZhcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBsYXllciBoaXQgY2FudmFzXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGdldEhpdENhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oaXRDYW52YXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgbGF5ZXIgY2FudmFzIGNvbnRleHRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29udGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDYW52YXMoKS5nZXRDb250ZXh0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjbGVhciBzY2VuZSBhbmQgaGl0IGNhbnZhcyBjb250ZXh0cyB0aWVkIHRvIHRoZSBsYXllclxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbYm91bmRzXVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy54XVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy55XVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy53aWR0aF1cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMuaGVpZ2h0XVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBsYXllci5jbGVhcigpO1xuICAgICAgICAgKiBsYXllci5jbGVhcih7XG4gICAgICAgICAqICAgeCA6IDAsXG4gICAgICAgICAqICAgeSA6IDAsXG4gICAgICAgICAqICAgd2lkdGggOiAxMDAsXG4gICAgICAgICAqICAgaGVpZ2h0IDogMTAwXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uKGJvdW5kcykge1xuICAgICAgICAgICAgdGhpcy5nZXRDb250ZXh0KCkuY2xlYXIoYm91bmRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhckhpdENhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpdEltYWdlRGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZXh0ZW5kIE5vZGUucHJvdG90eXBlLnNldFpJbmRleFxuICAgICAgICBzZXRaSW5kZXg6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRaSW5kZXguY2FsbCh0aGlzLCBpbmRleCk7XG4gICAgICAgICAgICB2YXIgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XG4gICAgICAgICAgICBpZihzdGFnZSkge1xuICAgICAgICAgICAgICAgIHN0YWdlLmNvbnRlbnQucmVtb3ZlQ2hpbGQodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzKTtcblxuICAgICAgICAgICAgICAgIGlmKGluZGV4IDwgc3RhZ2UuZ2V0Q2hpbGRyZW4oKS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWdlLmNvbnRlbnQuaW5zZXJ0QmVmb3JlKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcywgc3RhZ2UuZ2V0Q2hpbGRyZW4oKVtpbmRleCArIDFdLmdldENhbnZhcygpLl9jYW52YXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhZ2UuY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmdldENhbnZhcygpLl9jYW52YXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBleHRlbmQgTm9kZS5wcm90b3R5cGUubW92ZVRvVG9wXG4gICAgICAgIG1vdmVUb1RvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5tb3ZlVG9Ub3AuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcbiAgICAgICAgICAgIGlmKHN0YWdlKSB7XG4gICAgICAgICAgICAgICAgc3RhZ2UuY29udGVudC5yZW1vdmVDaGlsZCh0aGlzLmdldENhbnZhcygpLl9jYW52YXMpO1xuICAgICAgICAgICAgICAgIHN0YWdlLmNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBleHRlbmQgTm9kZS5wcm90b3R5cGUubW92ZVVwXG4gICAgICAgIG1vdmVVcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbW92ZWQgPSBLb252YS5Ob2RlLnByb3RvdHlwZS5tb3ZlVXAuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICghbW92ZWQpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpO1xuICAgICAgICAgICAgaWYoIXN0YWdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFnZS5jb250ZW50LnJlbW92ZUNoaWxkKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuaW5kZXggPCBzdGFnZS5nZXRDaGlsZHJlbigpLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBzdGFnZS5jb250ZW50Lmluc2VydEJlZm9yZSh0aGlzLmdldENhbnZhcygpLl9jYW52YXMsIHN0YWdlLmdldENoaWxkcmVuKClbdGhpcy5pbmRleCArIDFdLmdldENhbnZhcygpLl9jYW52YXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFnZS5jb250ZW50LmFwcGVuZENoaWxkKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZXh0ZW5kIE5vZGUucHJvdG90eXBlLm1vdmVEb3duXG4gICAgICAgIG1vdmVEb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKEtvbnZhLk5vZGUucHJvdG90eXBlLm1vdmVEb3duLmNhbGwodGhpcykpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XG4gICAgICAgICAgICAgICAgaWYoc3RhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gc3RhZ2UuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhZ2UuY29udGVudC5yZW1vdmVDaGlsZCh0aGlzLmdldENhbnZhcygpLl9jYW52YXMpO1xuICAgICAgICAgICAgICAgICAgICBzdGFnZS5jb250ZW50Lmluc2VydEJlZm9yZSh0aGlzLmdldENhbnZhcygpLl9jYW52YXMsIGNoaWxkcmVuW3RoaXMuaW5kZXggKyAxXS5nZXRDYW52YXMoKS5fY2FudmFzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZXh0ZW5kIE5vZGUucHJvdG90eXBlLm1vdmVUb0JvdHRvbVxuICAgICAgICBtb3ZlVG9Cb3R0b206IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYoS29udmEuTm9kZS5wcm90b3R5cGUubW92ZVRvQm90dG9tLmNhbGwodGhpcykpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XG4gICAgICAgICAgICAgICAgaWYoc3RhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gc3RhZ2UuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhZ2UuY29udGVudC5yZW1vdmVDaGlsZCh0aGlzLmdldENhbnZhcygpLl9jYW52YXMpO1xuICAgICAgICAgICAgICAgICAgICBzdGFnZS5jb250ZW50Lmluc2VydEJlZm9yZSh0aGlzLmdldENhbnZhcygpLl9jYW52YXMsIGNoaWxkcmVuWzFdLmdldENhbnZhcygpLl9jYW52YXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBnZXRMYXllcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBfY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKS5fY2FudmFzO1xuXG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgaWYoX2NhbnZhcyAmJiBfY2FudmFzLnBhcmVudE5vZGUgJiYgS29udmEuVXRpbC5faXNJbkRvY3VtZW50KF9jYW52YXMpKSB7XG4gICAgICAgICAgICAgICAgX2NhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKF9jYW52YXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFN0YWdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0U2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0L3NldCB3aWR0aCBvZiBsYXllci5nZXR0ZXIgcmV0dXJuIHdpZHRoIG9mIHN0YWdlLiBzZXR0ZXIgZG9pbmcgbm90aGluZy5cbiAgICAgICAgICogaWYgeW91IHdhbnQgY2hhbmdlIHdpZHRoIHVzZSBgc3RhZ2Uud2lkdGgodmFsdWUpO2BcbiAgICAgICAgICogQG5hbWUgd2lkdGhcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiB2YXIgd2lkdGggPSBsYXllci53aWR0aCgpO1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldFdpZHRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEtvbnZhLlV0aWwud2FybignQ2FuIG5vdCBjaGFuZ2Ugd2lkdGggb2YgbGF5ZXIuIFVzZSBcInN0YWdlLndpZHRoKHZhbHVlKVwiIGZ1bmN0aW9uIGluc3RlYWQuJyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQvc2V0IGhlaWdodCBvZiBsYXllci5nZXR0ZXIgcmV0dXJuIGhlaWdodCBvZiBzdGFnZS4gc2V0dGVyIGRvaW5nIG5vdGhpbmcuXG4gICAgICAgICAqIGlmIHlvdSB3YW50IGNoYW5nZSBoZWlnaHQgdXNlIGBzdGFnZS5oZWlnaHQodmFsdWUpO2BcbiAgICAgICAgICogQG5hbWUgaGVpZ2h0XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogdmFyIGhlaWdodCA9IGxheWVyLmhlaWdodCgpO1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEtvbnZhLlV0aWwud2FybignQ2FuIG5vdCBjaGFuZ2UgaGVpZ2h0IG9mIGxheWVyLiBVc2UgXCJzdGFnZS5oZWlnaHQodmFsdWUpXCIgZnVuY3Rpb24gaW5zdGVhZC4nKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gdGhlIGFwcGx5IHRyYW5zZm9ybSBtZXRob2QgaXMgaGFuZGxlZCBieSB0aGUgTGF5ZXIgYW5kIEZhc3RMYXllciBjbGFzc1xuICAgICAgICAvLyBiZWNhdXNlIGl0IGlzIHVwIHRvIHRoZSBsYXllciB0byBkZWNpZGUgaWYgYW4gYWJzb2x1dGUgb3IgcmVsYXRpdmUgdHJhbnNmb3JtXG4gICAgICAgIC8vIHNob3VsZCBiZSB1c2VkXG4gICAgICAgIF9hcHBseVRyYW5zZm9ybTogZnVuY3Rpb24oc2hhcGUsIGNvbnRleHQsIHRvcCkge1xuICAgICAgICAgICAgdmFyIG0gPSBzaGFwZS5nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApLmdldE1hdHJpeCgpO1xuICAgICAgICAgICAgY29udGV4dC50cmFuc2Zvcm0obVswXSwgbVsxXSwgbVsyXSwgbVszXSwgbVs0XSwgbVs1XSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5CYXNlTGF5ZXIsIEtvbnZhLkNvbnRhaW5lcik7XG5cbiAgICAvLyBhZGQgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkJhc2VMYXllciwgJ2NsZWFyQmVmb3JlRHJhdycsIHRydWUpO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgY2xlYXJCZWZvcmVEcmF3IGZsYWcgd2hpY2ggZGV0ZXJtaW5lcyBpZiB0aGUgbGF5ZXIgaXMgY2xlYXJlZCBvciBub3RcbiAgICAgKiAgYmVmb3JlIGRyYXdpbmdcbiAgICAgKiBAbmFtZSBjbGVhckJlZm9yZURyYXdcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNsZWFyQmVmb3JlRHJhd1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNsZWFyQmVmb3JlRHJhdyBmbGFnXG4gICAgICogdmFyIGNsZWFyQmVmb3JlRHJhdyA9IGxheWVyLmNsZWFyQmVmb3JlRHJhdygpO1xuICAgICAqXG4gICAgICogLy8gZGlzYWJsZSBjbGVhciBiZWZvcmUgZHJhd1xuICAgICAqIGxheWVyLmNsZWFyQmVmb3JlRHJhdyhmYWxzZSk7XG4gICAgICpcbiAgICAgKiAvLyBlbmFibGUgY2xlYXIgYmVmb3JlIGRyYXdcbiAgICAgKiBsYXllci5jbGVhckJlZm9yZURyYXcodHJ1ZSk7XG4gICAgICovXG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuQmFzZUxheWVyKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gY29uc3RhbnRzXG4gICAgdmFyIEhBU0ggPSAnIycsXG4gICAgICAgIEJFRk9SRV9EUkFXID0gJ2JlZm9yZURyYXcnLFxuICAgICAgICBEUkFXID0gJ2RyYXcnLFxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIDIgLSAzIC0gNFxuICAgICAgICAgKiB8ICAgICAgIHxcbiAgICAgICAgICogMSAtIDAgICA1XG4gICAgICAgICAqICAgICAgICAgfFxuICAgICAgICAgKiA4IC0gNyAtIDZcbiAgICAgICAgICovXG4gICAgICAgIElOVEVSU0VDVElPTl9PRkZTRVRTID0gW1xuICAgICAgICAgICAge3g6IDAsIHk6IDB9LCAgLy8gMFxuICAgICAgICAgICAge3g6IC0xLCB5OiAwfSwgLy8gMVxuICAgICAgICAgICAge3g6IC0xLCB5OiAtMX0sIC8vIDJcbiAgICAgICAgICAgIHt4OiAwLCB5OiAtMX0sIC8vIDNcbiAgICAgICAgICAgIHt4OiAxLCB5OiAtMX0sIC8vIDRcbiAgICAgICAgICAgIHt4OiAxLCB5OiAwfSwgLy8gNVxuICAgICAgICAgICAge3g6IDEsIHk6IDF9LCAvLyA2XG4gICAgICAgICAgICB7eDogMCwgeTogMX0sIC8vIDdcbiAgICAgICAgICAgIHt4OiAtMSwgeTogMX0gIC8vIDhcbiAgICAgICAgXSxcbiAgICAgICAgSU5URVJTRUNUSU9OX09GRlNFVFNfTEVOID0gSU5URVJTRUNUSU9OX09GRlNFVFMubGVuZ3RoO1xuXG4gICAgLyoqXG4gICAgICogTGF5ZXIgY29uc3RydWN0b3IuICBMYXllcnMgYXJlIHRpZWQgdG8gdGhlaXIgb3duIGNhbnZhcyBlbGVtZW50IGFuZCBhcmUgdXNlZFxuICAgICAqIHRvIGNvbnRhaW4gZ3JvdXBzIG9yIHNoYXBlcy5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYXVnbWVudHMgS29udmEuQmFzZUxheWVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5jbGVhckJlZm9yZURyYXddIHNldCB0aGlzIHByb3BlcnR5IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50XG4gICAgICogdG8gY2xlYXIgdGhlIGNhbnZhcyBiZWZvcmUgZWFjaCBsYXllciBkcmF3LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuY2xpcF0gc2V0IGNsaXBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWF0gc2V0IGNsaXAgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBZXSBzZXQgY2xpcCB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFdpZHRoXSBzZXQgY2xpcCB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBIZWlnaHRdIHNldCBjbGlwIGhlaWdodFxuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgbGF5ZXIgPSBuZXcgS29udmEuTGF5ZXIoKTtcbiAgICAgKi9cbiAgICBLb252YS5MYXllciA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLlV0aWwuYWRkTWV0aG9kcyhLb252YS5MYXllciwge1xuICAgICAgICBfX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVUeXBlID0gJ0xheWVyJztcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKCk7XG4gICAgICAgICAgICB0aGlzLmhpdENhbnZhcyA9IG5ldyBLb252YS5IaXRDYW52YXMoe1xuICAgICAgICAgICAgICAgIHBpeGVsUmF0aW86IDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgS29udmEuQmFzZUxheWVyLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NldENhbnZhc1NpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLmhpdENhbnZhcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9LFxuICAgICAgICBfdmFsaWRhdGVBZGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGNoaWxkLmdldFR5cGUoKTtcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSAnR3JvdXAnICYmIHR5cGUgIT09ICdTaGFwZScpIHtcbiAgICAgICAgICAgICAgICBLb252YS5VdGlsLnRocm93KCdZb3UgbWF5IG9ubHkgYWRkIGdyb3VwcyBhbmQgc2hhcGVzIHRvIGEgbGF5ZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgdmlzaWJsZSBpbnRlcnNlY3Rpb24gc2hhcGUuIFRoaXMgaXMgdGhlIHByZWZlcnJlZFxuICAgICAgICAgKiBtZXRob2QgZm9yIGRldGVybWluaW5nIGlmIGEgcG9pbnQgaW50ZXJzZWN0cyBhIHNoYXBlIG9yIG5vdFxuICAgICAgICAgKiBhbHNvIHlvdSBtYXkgcGFzcyBvcHRpb25hbCBzZWxlY3RvciBwYXJhbWV0ciB0byByZXR1cm4gYW5jZXN0b3Igb2YgaW50ZXJzZWN0ZWQgc2hhcGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTGF5ZXIucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy54XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbGVjdG9yXVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogdmFyIHNoYXBlID0gbGF5ZXIuZ2V0SW50ZXJzZWN0aW9uKHt4OiA1MCwgeTogNTB9KTtcbiAgICAgICAgICogLy8gb3IgaWYgeW91IGludGVyZXN0ZWQgaW4gc2hhcGUgcGFyZW50OlxuICAgICAgICAgKiB2YXIgZ3JvdXAgPSBsYXllci5nZXRJbnRlcnNlY3Rpb24oe3g6IDUwLCB5OiA1MH0sICdHcm91cCcpO1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SW50ZXJzZWN0aW9uOiBmdW5jdGlvbihwb3MsIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgb2JqLCBpLCBpbnRlcnNlY3Rpb25PZmZzZXQsIHNoYXBlO1xuXG4gICAgICAgICAgICBpZighdGhpcy5oaXRHcmFwaEVuYWJsZWQoKSB8fCAhdGhpcy5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW4gc29tZSBjYXNlcyBhbnRpYWxpYXNlZCBhcmVhIG1heSBiZSBiaWdnZXIgdGhhbiAxcHhcbiAgICAgICAgICAgIC8vIGl0IGlzIHBvc3NpYmxlIGlmIHdlIHdpbGwgY2FjaGUgbm9kZSwgdGhlbiBzY2FsZSBpdCBhIGxvdFxuICAgICAgICAgICAgLy8gVE9ETzogY2hlY2sgeyAwOyAwIH0gcG9pbnQgYmVmb3JlIGxvb3AsIGFuZCByZW1vdmUgaXQgZnJvbSBJTlRFUlNFQ1RJT05fT0ZGU0VUUy5cbiAgICAgICAgICAgIHZhciBzcGlyYWxTZWFyY2hEaXN0YW5jZSA9IDE7XG4gICAgICAgICAgICB2YXIgY29udGludWVTZWFyY2ggPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IElOVEVSU0VDVElPTl9PRkZTRVRTX0xFTjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbk9mZnNldCA9IElOVEVSU0VDVElPTl9PRkZTRVRTW2ldO1xuICAgICAgICAgICAgICAgICAgICBvYmogPSB0aGlzLl9nZXRJbnRlcnNlY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogcG9zLnggKyBpbnRlcnNlY3Rpb25PZmZzZXQueCAqIHNwaXJhbFNlYXJjaERpc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogcG9zLnkgKyBpbnRlcnNlY3Rpb25PZmZzZXQueSAqIHNwaXJhbFNlYXJjaERpc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzaGFwZSA9IG9iai5zaGFwZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlICYmIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hhcGUuZmluZEFuY2VzdG9yKHNlbGVjdG9yLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHNob3VsZCBjb250aW51ZSBzZWFyY2ggaWYgd2UgZm91bmQgYW50aWFsaWFzZWQgcGl4ZWxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBtZWFucyBvdXIgbm9kZSBzb21ld2hlcmUgdmVyeSBjbG9zZVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVNlYXJjaCA9ICEhb2JqLmFudGlhbGlhc2VkO1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9wIHNlYXJjaCBpZiBmb3VuZCBlbXB0eSBwaXhlbFxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9iai5hbnRpYWxpYXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gc2hhcGUsIGFuZCBubyBhbnRpYWxpYXNlZCBwaXhlbCwgd2Ugc2hvdWxkIGVuZCBzZWFyY2hpbmdcbiAgICAgICAgICAgICAgICBpZiAoY29udGludWVTZWFyY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgc3BpcmFsU2VhcmNoRGlzdGFuY2UgKz0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRJbWFnZURhdGE6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuaGl0Q2FudmFzLndpZHRoIHx8IDEsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5oaXRDYW52YXMuaGVpZ2h0IHx8IDEsXG4gICAgICAgICAgICAgICAgaW5kZXggPSAoTWF0aC5yb3VuZCh5KSAqIHdpZHRoICkgKyBNYXRoLnJvdW5kKHgpO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2hpdEltYWdlRGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hpdEltYWdlRGF0YSA9IHRoaXMuaGl0Q2FudmFzLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHRoaXMuX2hpdEltYWdlRGF0YS5kYXRhWzQgKiBpbmRleCArIDBdLCAvLyBSZWRcbiAgICAgICAgICAgICAgICB0aGlzLl9oaXRJbWFnZURhdGEuZGF0YVs0ICogaW5kZXggKyAxXSwgLy8gR3JlZW5cbiAgICAgICAgICAgICAgICB0aGlzLl9oaXRJbWFnZURhdGEuZGF0YVs0ICogaW5kZXggKyAyXSwgLy8gQmx1ZVxuICAgICAgICAgICAgICAgIHRoaXMuX2hpdEltYWdlRGF0YS5kYXRhWzQgKiBpbmRleCArIDNdIC8vIEFscGhhXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0SW50ZXJzZWN0aW9uOiBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgICAgIHZhciByYXRpbyA9IHRoaXMuaGl0Q2FudmFzLnBpeGVsUmF0aW87XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMuaGl0Q2FudmFzLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKE1hdGgucm91bmQocG9zLnggKiByYXRpbyksIE1hdGgucm91bmQocG9zLnkgKiByYXRpbyksIDEsIDEpLmRhdGEsXG4gICAgICAgICAgICAgICAgcDMgPSBwWzNdLFxuICAgICAgICAgICAgICAgIGNvbG9yS2V5LCBzaGFwZTtcbiAgICAgICAgICAgIC8vIGZ1bGx5IG9wYXF1ZSBwaXhlbFxuICAgICAgICAgICAgaWYocDMgPT09IDI1NSkge1xuICAgICAgICAgICAgICAgIGNvbG9yS2V5ID0gS29udmEuVXRpbC5fcmdiVG9IZXgocFswXSwgcFsxXSwgcFsyXSk7XG4gICAgICAgICAgICAgICAgc2hhcGUgPSBLb252YS5zaGFwZXNbSEFTSCArIGNvbG9yS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlOiBzaGFwZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhbnRpYWxpYXNlZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbnRpYWxpYXNlZCBwaXhlbFxuICAgICAgICAgICAgZWxzZSBpZihwMyA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhbnRpYWxpYXNlZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbXB0eSBwaXhlbFxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9LFxuICAgICAgICBkcmF3U2NlbmU6IGZ1bmN0aW9uKGNhbiwgdG9wKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksXG4gICAgICAgICAgICAgICAgY2FudmFzID0gY2FuIHx8IChsYXllciAmJiBsYXllci5nZXRDYW52YXMoKSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoQkVGT1JFX0RSQVcsIHtcbiAgICAgICAgICAgICAgICBub2RlOiB0aGlzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYodGhpcy5nZXRDbGVhckJlZm9yZURyYXcoKSkge1xuICAgICAgICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCkuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZS5kcmF3U2NlbmUuY2FsbCh0aGlzLCBjYW52YXMsIHRvcCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoRFJBVywge1xuICAgICAgICAgICAgICAgIG5vZGU6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZHJhd0hpdDogZnVuY3Rpb24oY2FuLCB0b3ApIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKSxcbiAgICAgICAgICAgICAgICBjYW52YXMgPSBjYW4gfHwgKGxheWVyICYmIGxheWVyLmhpdENhbnZhcyk7XG5cbiAgICAgICAgICAgIGlmKGxheWVyICYmIGxheWVyLmdldENsZWFyQmVmb3JlRHJhdygpKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIuZ2V0SGl0Q2FudmFzKCkuZ2V0Q29udGV4dCgpLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuZHJhd0hpdC5jYWxsKHRoaXMsIGNhbnZhcywgdG9wKTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VEYXRhID0gbnVsbDsgLy8gQ2xlYXIgaW1hZ2VEYXRhIGNhY2hlXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uKGJvdW5kcykge1xuICAgICAgICAgICAgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZS5jbGVhci5jYWxsKHRoaXMsIGJvdW5kcyk7XG4gICAgICAgICAgICB0aGlzLmdldEhpdENhbnZhcygpLmdldENvbnRleHQoKS5jbGVhcihib3VuZHMpO1xuICAgICAgICAgICAgdGhpcy5pbWFnZURhdGEgPSBudWxsOyAvLyBDbGVhciBnZXRJbWFnZURhdGEgY2FjaGVcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBleHRlbmQgTm9kZS5wcm90b3R5cGUuc2V0VmlzaWJsZVxuICAgICAgICBzZXRWaXNpYmxlOiBmdW5jdGlvbih2aXNpYmxlKSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRWaXNpYmxlLmNhbGwodGhpcywgdmlzaWJsZSk7XG4gICAgICAgICAgICBpZih2aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRDYW52YXMoKS5fY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgIHRoaXMuaGl0Q2FudmFzLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldENhbnZhcygpLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICB0aGlzLmhpdENhbnZhcy5fY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGVuYWJsZSBoaXQgZ3JhcGhcbiAgICAgICAgICogQG5hbWUgZW5hYmxlSGl0R3JhcGhcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTGF5ZXIucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtMYXllcn1cbiAgICAgICAgICovXG4gICAgICAgIGVuYWJsZUhpdEdyYXBoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SGl0R3JhcGhFbmFibGVkKHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkaXNhYmxlIGhpdCBncmFwaFxuICAgICAgICAgKiBAbmFtZSBkaXNhYmxlSGl0R3JhcGhcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTGF5ZXIucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtMYXllcn1cbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVIaXRHcmFwaDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnNldEhpdEdyYXBoRW5hYmxlZChmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0U2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZS5zZXRTaXplLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLmhpdENhbnZhcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5MYXllciwgS29udmEuQmFzZUxheWVyKTtcblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkxheWVyLCAnaGl0R3JhcGhFbmFibGVkJywgdHJ1ZSk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBoaXRHcmFwaEVuYWJsZWQgZmxhZy4gIERpc2FibGluZyB0aGUgaGl0IGdyYXBoIHdpbGwgZ3JlYXRseSBpbmNyZWFzZVxuICAgICAqICBkcmF3IHBlcmZvcm1hbmNlIGJlY2F1c2UgdGhlIGhpdCBncmFwaCB3aWxsIG5vdCBiZSByZWRyYXduIGVhY2ggdGltZSB0aGUgbGF5ZXIgaXNcbiAgICAgKiAgZHJhd24uICBUaGlzLCBob3dldmVyLCBhbHNvIGRpc2FibGVzIG1vdXNlL3RvdWNoIGV2ZW50IGRldGVjdGlvblxuICAgICAqIEBuYW1lIGhpdEdyYXBoRW5hYmxlZFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTGF5ZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgaGl0R3JhcGhFbmFibGVkIGZsYWdcbiAgICAgKiB2YXIgaGl0R3JhcGhFbmFibGVkID0gbGF5ZXIuaGl0R3JhcGhFbmFibGVkKCk7XG4gICAgICpcbiAgICAgKiAvLyBkaXNhYmxlIGhpdCBncmFwaFxuICAgICAqIGxheWVyLmhpdEdyYXBoRW5hYmxlZChmYWxzZSk7XG4gICAgICpcbiAgICAgKiAvLyBlbmFibGUgaGl0IGdyYXBoXG4gICAgICogbGF5ZXIuaGl0R3JhcGhFbmFibGVkKHRydWUpO1xuICAgICAqL1xuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5MYXllcik7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qKlxuICAgICAqIEZhc3RMYXllciBjb25zdHJ1Y3Rvci4gTGF5ZXJzIGFyZSB0aWVkIHRvIHRoZWlyIG93biBjYW52YXMgZWxlbWVudCBhbmQgYXJlIHVzZWRcbiAgICAgKiB0byBjb250YWluIHNoYXBlcyBvbmx5LiAgSWYgeW91IGRvbid0IG5lZWQgbm9kZSBuZXN0aW5nLCBtb3VzZSBhbmQgdG91Y2ggaW50ZXJhY3Rpb25zLFxuICAgICAqIG9yIGV2ZW50IHB1Yi9zdWIsIHlvdSBzaG91bGQgdXNlIEZhc3RMYXllciBpbnN0ZWFkIG9mIExheWVyIHRvIGNyZWF0ZSB5b3VyIGxheWVycy5cbiAgICAgKiBJdCByZW5kZXJzIGFib3V0IDJ4IGZhc3RlciB0aGFuIG5vcm1hbCBsYXllcnMuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLkJhc2VMYXllclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuY2xlYXJCZWZvcmVEcmF3XSBzZXQgdGhpcyBwcm9wZXJ0eSB0byBmYWxzZSBpZiB5b3UgZG9uJ3Qgd2FudFxuICAgICAqIHRvIGNsZWFyIHRoZSBjYW52YXMgYmVmb3JlIGVhY2ggbGF5ZXIgZHJhdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5jbGlwXSBzZXQgY2xpcFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBYXSBzZXQgY2xpcCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFldIHNldCBjbGlwIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwV2lkdGhdIHNldCBjbGlwIHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcEhlaWdodF0gc2V0IGNsaXAgaGVpZ2h0XG5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBsYXllciA9IG5ldyBLb252YS5GYXN0TGF5ZXIoKTtcbiAgICAgKi9cbiAgICBLb252YS5GYXN0TGF5ZXIgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5VdGlsLmFkZE1ldGhvZHMoS29udmEuRmFzdExheWVyLCB7XG4gICAgICAgIF9fX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZVR5cGUgPSAnTGF5ZXInO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBuZXcgS29udmEuU2NlbmVDYW52YXMoKTtcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLkJhc2VMYXllci5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIH0sXG4gICAgICAgIF92YWxpZGF0ZUFkZDogZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gY2hpbGQuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdTaGFwZScpIHtcbiAgICAgICAgICAgICAgICBLb252YS5VdGlsLnRocm93KCdZb3UgbWF5IG9ubHkgYWRkIHNoYXBlcyB0byBhIGZhc3QgbGF5ZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9zZXRDYW52YXNTaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9LFxuICAgICAgICBoaXRHcmFwaEVuYWJsZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJbnRlcnNlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYXdTY2VuZTogZnVuY3Rpb24oY2FuKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksXG4gICAgICAgICAgICAgICAgY2FudmFzID0gY2FuIHx8IChsYXllciAmJiBsYXllci5nZXRDYW52YXMoKSk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuZ2V0Q2xlYXJCZWZvcmVEcmF3KCkpIHtcbiAgICAgICAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgpLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuZHJhd1NjZW5lLmNhbGwodGhpcywgY2FudmFzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3U2NlbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBleHRlbmQgTm9kZS5wcm90b3R5cGUuc2V0VmlzaWJsZVxuICAgICAgICBzZXRWaXNpYmxlOiBmdW5jdGlvbih2aXNpYmxlKSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRWaXNpYmxlLmNhbGwodGhpcywgdmlzaWJsZSk7XG4gICAgICAgICAgICBpZih2aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRDYW52YXMoKS5fY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRDYW52YXMoKS5fY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkZhc3RMYXllciwgS29udmEuQmFzZUxheWVyKTtcblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5GYXN0TGF5ZXIpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBHcm91cCBjb25zdHJ1Y3Rvci4gIEdyb3VwcyBhcmUgdXNlZCB0byBjb250YWluIHNoYXBlcyBvciBvdGhlciBncm91cHMuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLkNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuY2xpcF0gc2V0IGNsaXBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWF0gc2V0IGNsaXAgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBZXSBzZXQgY2xpcCB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFdpZHRoXSBzZXQgY2xpcCB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBIZWlnaHRdIHNldCBjbGlwIGhlaWdodFxuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgZ3JvdXAgPSBuZXcgS29udmEuR3JvdXAoKTtcbiAgICAgKi9cbiAgICBLb252YS5Hcm91cCA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgICB9O1xuXG4gICAgS29udmEuVXRpbC5hZGRNZXRob2RzKEtvbnZhLkdyb3VwLCB7XG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5ub2RlVHlwZSA9ICdHcm91cCc7XG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICBLb252YS5Db250YWluZXIuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgICB9LFxuICAgICAgICBfdmFsaWRhdGVBZGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGNoaWxkLmdldFR5cGUoKTtcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSAnR3JvdXAnICYmIHR5cGUgIT09ICdTaGFwZScpIHtcbiAgICAgICAgICAgICAgICBLb252YS5VdGlsLnRocm93KCdZb3UgbWF5IG9ubHkgYWRkIGdyb3VwcyBhbmQgc2hhcGVzIHRvIGdyb3Vwcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkdyb3VwLCBLb252YS5Db250YWluZXIpO1xuXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLkdyb3VwKTtcbn0pKCk7XG5cbihmdW5jdGlvbihLb252YSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgQkFUQ0hfRFJBV19TVE9QX1RJTUVfRElGRiA9IDUwMDtcblxuICAgIHZhciBub3cgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChLb252YS5nbG9iYWwucGVyZm9ybWFuY2UgJiYgS29udmEuZ2xvYmFsLnBlcmZvcm1hbmNlLm5vdykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBLb252YS5nbG9iYWwucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG5cbiAgICBmdW5jdGlvbiBGUkFGKGNhbGxiYWNrKSB7XG4gICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgfVxuXG4gICAgdmFyIFJBRiA9IChmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gS29udmEuZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgfHwgS29udmEuZ2xvYmFsLndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgfHwgS29udmEuZ2xvYmFsLm1velJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgfHwgS29udmEuZ2xvYmFsLm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgIHx8IEtvbnZhLmdsb2JhbC5tc1JlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgfHwgRlJBRjtcbiAgICB9KSgpO1xuXG5cblxuICAgIGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoKSB7XG4gICAgICAgIHJldHVybiBSQUYuYXBwbHkoS29udmEuZ2xvYmFsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGlvbiBjb25zdHJ1Y3Rvci4gIEEgc3RhZ2UgaXMgdXNlZCB0byBjb250YWluIG11bHRpcGxlIGxheWVycyBhbmQgaGFuZGxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBmdW5jdGlvbiBleGVjdXRlZCBvbiBlYWNoIGFuaW1hdGlvbiBmcmFtZS4gIFRoZSBmdW5jdGlvbiBpcyBwYXNzZWQgYSBmcmFtZSBvYmplY3QsIHdoaWNoIGNvbnRhaW5zXG4gICAgICogIHRpbWVEaWZmLCBsYXN0VGltZSwgdGltZSwgYW5kIGZyYW1lUmF0ZSBwcm9wZXJ0aWVzLiAgVGhlIHRpbWVEaWZmIHByb3BlcnR5IGlzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBwYXNzZWRcbiAgICAgKiAgc2luY2UgdGhlIGxhc3QgYW5pbWF0aW9uIGZyYW1lLiAgVGhlIGxhc3RUaW1lIHByb3BlcnR5IGlzIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRoYXQgZWxhcHNlZCBmcm9tIHRoZSBtb21lbnQgdGhlIGFuaW1hdGlvbiBzdGFydGVkXG4gICAgICogIHRvIHRoZSBsYXN0IGFuaW1hdGlvbiBmcmFtZS4gIFRoZSB0aW1lIHByb3BlcnR5IGlzIHRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0aGF0IGVsbGFwc2VkIGZyb20gdGhlIG1vbWVudCB0aGUgYW5pbWF0aW9uIHN0YXJ0ZWRcbiAgICAgKiAgdG8gdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGZyYW1lLiAgVGhlIGZyYW1lUmF0ZSBwcm9wZXJ0eSBpcyB0aGUgY3VycmVudCBmcmFtZSByYXRlIGluIGZyYW1lcyAvIHNlY29uZC4gUmV0dXJuIGZhbHNlIGZyb20gZnVuY3Rpb24sXG4gICAgICogIGlmIHlvdSBkb24ndCBuZWVkIHRvIHJlZHJhdyBsYXllci9sYXllcnMgb24gc29tZSBmcmFtZXMuXG4gICAgICogQHBhcmFtIHtLb252YS5MYXllcnxBcnJheX0gW2xheWVyc10gbGF5ZXIocykgdG8gYmUgcmVkcmF3biBvbiBlYWNoIGFuaW1hdGlvbiBmcmFtZS4gQ2FuIGJlIGEgbGF5ZXIsIGFuIGFycmF5IG9mIGxheWVycywgb3IgbnVsbC5cbiAgICAgKiAgTm90IHNwZWNpZnlpbmcgYSBub2RlIHdpbGwgcmVzdWx0IGluIG5vIHJlZHJhdy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIG1vdmUgYSBub2RlIHRvIHRoZSByaWdodCBhdCA1MCBwaXhlbHMgLyBzZWNvbmRcbiAgICAgKiB2YXIgdmVsb2NpdHkgPSA1MDtcbiAgICAgKlxuICAgICAqIHZhciBhbmltID0gbmV3IEtvbnZhLkFuaW1hdGlvbihmdW5jdGlvbihmcmFtZSkge1xuICAgICAqICAgdmFyIGRpc3QgPSB2ZWxvY2l0eSAqIChmcmFtZS50aW1lRGlmZiAvIDEwMDApO1xuICAgICAqICAgbm9kZS5tb3ZlKGRpc3QsIDApO1xuICAgICAqIH0sIGxheWVyKTtcbiAgICAgKlxuICAgICAqIGFuaW0uc3RhcnQoKTtcbiAgICAgKi9cbiAgICBLb252YS5BbmltYXRpb24gPSBmdW5jdGlvbihmdW5jLCBsYXllcnMpIHtcbiAgICAgICAgdmFyIEFuaW0gPSBLb252YS5BbmltYXRpb247XG4gICAgICAgIHRoaXMuZnVuYyA9IGZ1bmM7XG4gICAgICAgIHRoaXMuc2V0TGF5ZXJzKGxheWVycyk7XG4gICAgICAgIHRoaXMuaWQgPSBBbmltLmFuaW1JZENvdW50ZXIrKztcbiAgICAgICAgdGhpcy5mcmFtZSA9IHtcbiAgICAgICAgICAgIHRpbWU6IDAsXG4gICAgICAgICAgICB0aW1lRGlmZjogMCxcbiAgICAgICAgICAgIGxhc3RUaW1lOiBub3coKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLypcbiAgICAgKiBBbmltYXRpb24gbWV0aG9kc1xuICAgICAqL1xuICAgIEtvbnZhLkFuaW1hdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgbGF5ZXJzIHRvIGJlIHJlZHJhd24gb24gZWFjaCBhbmltYXRpb24gZnJhbWVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0tvbnZhLkxheWVyfEFycmF5fSBbbGF5ZXJzXSBsYXllcihzKSB0byBiZSByZWRyYXduLiZuYnNwOyBDYW4gYmUgYSBsYXllciwgYW4gYXJyYXkgb2YgbGF5ZXJzLCBvciBudWxsLiAgTm90IHNwZWNpZnlpbmcgYSBub2RlIHdpbGwgcmVzdWx0IGluIG5vIHJlZHJhdy5cbiAgICAgICAgICogQHJldHVybiB7S29udmEuQW5pbWF0aW9ufSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBzZXRMYXllcnM6IGZ1bmN0aW9uKGxheWVycykge1xuICAgICAgICAgICAgdmFyIGxheXMgPSBbXTtcbiAgICAgICAgICAgIC8vIGlmIHBhc3NpbmcgaW4gbm8gbGF5ZXJzXG4gICAgICAgICAgICBpZiAoIWxheWVycykge1xuICAgICAgICAgICAgICAgIGxheXMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHBhc3NpbmcgaW4gYW4gYXJyYXkgb2YgTGF5ZXJzXG4gICAgICAgICAgICAvLyBOT1RFOiBsYXllcnMgY291bGQgYmUgYW4gYXJyYXkgb3IgS29udmEuQ29sbGVjdGlvbi4gIGZvciBzaW1wbGljaXR5LCBJJ20ganVzdCBpbnNwZWN0aW5nXG4gICAgICAgICAgICAvLyB0aGUgbGVuZ3RoIHByb3BlcnR5IHRvIGNoZWNrIGZvciBib3RoIGNhc2VzXG4gICAgICAgICAgICBlbHNlIGlmIChsYXllcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxheXMgPSBsYXllcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBwYXNzaW5nIGluIGEgTGF5ZXJcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxheXMgPSBbbGF5ZXJzXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5sYXllcnMgPSBsYXlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgbGF5ZXJzXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkFuaW1hdGlvbi5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIEtvbnZhLkxheWVyXG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYXllcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogYWRkIGxheWVyLiAgUmV0dXJucyB0cnVlIGlmIHRoZSBsYXllciB3YXMgYWRkZWQsIGFuZCBmYWxzZSBpZiBpdCB3YXMgbm90XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkFuaW1hdGlvbi5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtLb252YS5MYXllcn0gbGF5ZXIgdG8gYWRkXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2x9IHRydWUgaWYgbGF5ZXIgaXMgYWRkZWQgdG8gYW5pbWF0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGFkZExheWVyOiBmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgdmFyIGxheWVycyA9IHRoaXMubGF5ZXJzLFxuICAgICAgICAgICAgICAgIGxlbiA9IGxheWVycy5sZW5ndGgsIG47XG5cbiAgICAgICAgICAgIC8vIGRvbid0IGFkZCB0aGUgbGF5ZXIgaWYgaXQgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgIGlmIChsYXllcnNbbl0uX2lkID09PSBsYXllci5faWQpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmxheWVycy5wdXNoKGxheWVyKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZGV0ZXJtaW5lIGlmIGFuaW1hdGlvbiBpcyBydW5uaW5nIG9yIG5vdC4gIHJldHVybnMgdHJ1ZSBvciBmYWxzZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5BbmltYXRpb24ucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2x9IGlzIGFuaW1hdGlvbiBydW5uaW5nP1xuICAgICAgICAgKi9cbiAgICAgICAgaXNSdW5uaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gS29udmEuQW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnMgPSBhLmFuaW1hdGlvbnMsXG4gICAgICAgICAgICAgICAgbGVuID0gYW5pbWF0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbjtcblxuICAgICAgICAgICAgZm9yKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICBpZihhbmltYXRpb25zW25dLmlkID09PSB0aGlzLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHN0YXJ0IGFuaW1hdGlvblxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5BbmltYXRpb24ucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm4ge0tvbnZhLkFuaW1hdGlvbn0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIEFuaW0gPSBLb252YS5BbmltYXRpb247XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMuZnJhbWUudGltZURpZmYgPSAwO1xuICAgICAgICAgICAgdGhpcy5mcmFtZS5sYXN0VGltZSA9IG5vdygpO1xuICAgICAgICAgICAgQW5pbS5fYWRkQW5pbWF0aW9uKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzdG9wIGFuaW1hdGlvblxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5BbmltYXRpb24ucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm4ge0tvbnZhLkFuaW1hdGlvbn0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBLb252YS5BbmltYXRpb24uX3JlbW92ZUFuaW1hdGlvbih0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBfdXBkYXRlRnJhbWVPYmplY3Q6IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuZnJhbWUudGltZURpZmYgPSB0aW1lIC0gdGhpcy5mcmFtZS5sYXN0VGltZTtcbiAgICAgICAgICAgIHRoaXMuZnJhbWUubGFzdFRpbWUgPSB0aW1lO1xuICAgICAgICAgICAgdGhpcy5mcmFtZS50aW1lICs9IHRoaXMuZnJhbWUudGltZURpZmY7XG4gICAgICAgICAgICB0aGlzLmZyYW1lLmZyYW1lUmF0ZSA9IDEwMDAgLyB0aGlzLmZyYW1lLnRpbWVEaWZmO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBLb252YS5BbmltYXRpb24uYW5pbWF0aW9ucyA9IFtdO1xuICAgIEtvbnZhLkFuaW1hdGlvbi5hbmltSWRDb3VudGVyID0gMDtcbiAgICBLb252YS5BbmltYXRpb24uYW5pbVJ1bm5pbmcgPSBmYWxzZTtcblxuICAgIEtvbnZhLkFuaW1hdGlvbi5fYWRkQW5pbWF0aW9uID0gZnVuY3Rpb24oYW5pbSkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMucHVzaChhbmltKTtcbiAgICAgICAgdGhpcy5faGFuZGxlQW5pbWF0aW9uKCk7XG4gICAgfTtcbiAgICBLb252YS5BbmltYXRpb24uX3JlbW92ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uKGFuaW0pIHtcbiAgICAgICAgdmFyIGlkID0gYW5pbS5pZCxcbiAgICAgICAgICAgIGFuaW1hdGlvbnMgPSB0aGlzLmFuaW1hdGlvbnMsXG4gICAgICAgICAgICBsZW4gPSBhbmltYXRpb25zLmxlbmd0aCxcbiAgICAgICAgICAgIG47XG5cbiAgICAgICAgZm9yKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgIGlmKGFuaW1hdGlvbnNbbl0uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zLnNwbGljZShuLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBLb252YS5BbmltYXRpb24uX3J1bkZyYW1lcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGF5ZXJIYXNoID0ge30sXG4gICAgICAgICAgICBhbmltYXRpb25zID0gdGhpcy5hbmltYXRpb25zLFxuICAgICAgICAgICAgYW5pbSwgbGF5ZXJzLCBmdW5jLCBuLCBpLCBsYXllcnNMZW4sIGxheWVyLCBrZXksIG5lZWRSZWRyYXc7XG4gICAgICAgIC8qXG4gICAgICAgICAqIGxvb3AgdGhyb3VnaCBhbGwgYW5pbWF0aW9ucyBhbmQgZXhlY3V0ZSBhbmltYXRpb25cbiAgICAgICAgICogIGZ1bmN0aW9uLiAgaWYgdGhlIGFuaW1hdGlvbiBvYmplY3QgaGFzIHNwZWNpZmllZCBub2RlLFxuICAgICAgICAgKiAgd2UgY2FuIGFkZCB0aGUgbm9kZSB0byB0aGUgbm9kZXMgaGFzaCB0byBlbGltaW5hdGVcbiAgICAgICAgICogIGRyYXdpbmcgdGhlIHNhbWUgbm9kZSBtdWx0aXBsZSB0aW1lcy4gIFRoZSBub2RlIHByb3BlcnR5XG4gICAgICAgICAqICBjYW4gYmUgdGhlIHN0YWdlIGl0c2VsZiBvciBhIGxheWVyXG4gICAgICAgICAqL1xuICAgICAgICAvKlxuICAgICAgICAgKiBXQVJOSU5HOiBkb24ndCBjYWNoZSBhbmltYXRpb25zLmxlbmd0aCBiZWNhdXNlIGl0IGNvdWxkIGNoYW5nZSB3aGlsZVxuICAgICAgICAgKiB0aGUgZm9yIGxvb3AgaXMgcnVubmluZywgY2F1c2luZyBhIEpTIGVycm9yXG4gICAgICAgICAqL1xuXG4gICAgICAgIGZvcihuID0gMDsgbiA8IGFuaW1hdGlvbnMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIGFuaW0gPSBhbmltYXRpb25zW25dO1xuICAgICAgICAgICAgbGF5ZXJzID0gYW5pbS5sYXllcnM7XG4gICAgICAgICAgICBmdW5jID0gYW5pbS5mdW5jO1xuXG5cbiAgICAgICAgICAgIGFuaW0uX3VwZGF0ZUZyYW1lT2JqZWN0KG5vdygpKTtcbiAgICAgICAgICAgIGxheWVyc0xlbiA9IGxheWVycy5sZW5ndGg7XG5cbiAgICAgICAgICAgIC8vIGlmIGFuaW1hdGlvbiBvYmplY3QgaGFzIGEgZnVuY3Rpb24sIGV4ZWN1dGUgaXRcbiAgICAgICAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgLy8gYWxsb3cgYW5pbSBieXBhc3NpbmcgZHJhd2luZ1xuICAgICAgICAgICAgICAgIG5lZWRSZWRyYXcgPSAoZnVuYy5jYWxsKGFuaW0sIGFuaW0uZnJhbWUpICE9PSBmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5lZWRSZWRyYXcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZWVkUmVkcmF3KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGF5ZXJzTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsYXllciA9IGxheWVyc1tpXTtcblxuICAgICAgICAgICAgICAgIGlmIChsYXllci5faWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBsYXllckhhc2hbbGF5ZXIuX2lkXSA9IGxheWVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoa2V5IGluIGxheWVySGFzaCkge1xuICAgICAgICAgICAgaWYgKCFsYXllckhhc2guaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGF5ZXJIYXNoW2tleV0uZHJhdygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBLb252YS5BbmltYXRpb24uX2FuaW1hdGlvbkxvb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIEFuaW0gPSBLb252YS5BbmltYXRpb247XG4gICAgICAgIGlmKEFuaW0uYW5pbWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltRnJhbWUoQW5pbS5fYW5pbWF0aW9uTG9vcCk7XG4gICAgICAgICAgICBBbmltLl9ydW5GcmFtZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIEFuaW0uYW5pbVJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgS29udmEuQW5pbWF0aW9uLl9oYW5kbGVBbmltYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYoIXRoaXMuYW5pbVJ1bm5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbVJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uTG9vcCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGJhdGNoIGRyYXdcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHJldHVybiB7S29udmEuTGF5ZXJ9IHRoaXNcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQmFzZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlLmJhdGNoRHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICBBbmltID0gS29udmEuQW5pbWF0aW9uO1xuXG4gICAgICAgIGlmICghdGhpcy5iYXRjaEFuaW0pIHtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hBbmltID0gbmV3IEFuaW0oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoYXQubGFzdEJhdGNoRHJhd1RpbWUgJiYgbm93KCkgLSB0aGF0Lmxhc3RCYXRjaERyYXdUaW1lID4gQkFUQ0hfRFJBV19TVE9QX1RJTUVfRElGRikge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmJhdGNoQW5pbS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3RCYXRjaERyYXdUaW1lID0gbm93KCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmJhdGNoQW5pbS5pc1J1bm5pbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICAgICAgICB0aGlzLmJhdGNoQW5pbS5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBiYXRjaCBkcmF3XG4gICAgICogQG1ldGhvZFxuICAgICAqIEByZXR1cm4ge0tvbnZhLlN0YWdlfSB0aGlzXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIEtvbnZhLlN0YWdlLnByb3RvdHlwZS5iYXRjaERyYXcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5nZXRDaGlsZHJlbigpLmVhY2goZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyLmJhdGNoRHJhdygpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbn0pKEtvbnZhKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgYmxhY2tsaXN0ID0ge1xuICAgICAgICBub2RlOiAxLFxuICAgICAgICBkdXJhdGlvbjogMSxcbiAgICAgICAgZWFzaW5nOiAxLFxuICAgICAgICBvbkZpbmlzaDogMSxcbiAgICAgICAgeW95bzogMVxuICAgIH0sXG5cbiAgICBQQVVTRUQgPSAxLFxuICAgIFBMQVlJTkcgPSAyLFxuICAgIFJFVkVSU0lORyA9IDMsXG5cbiAgICBpZENvdW50ZXIgPSAwLFxuICAgIGNvbG9yQXR0cnMgPSBbJ2ZpbGwnLCAnc3Ryb2tlJywgJ3NoYWRvd0NvbG9yJ107XG5cbiAgICB2YXIgVHdlZW4gPSBmdW5jdGlvbihwcm9wLCBwcm9wRnVuYywgZnVuYywgYmVnaW4sIGZpbmlzaCwgZHVyYXRpb24sIHlveW8pIHtcbiAgICAgICAgdGhpcy5wcm9wID0gcHJvcDtcbiAgICAgICAgdGhpcy5wcm9wRnVuYyA9IHByb3BGdW5jO1xuICAgICAgICB0aGlzLmJlZ2luID0gYmVnaW47XG4gICAgICAgIHRoaXMuX3BvcyA9IGJlZ2luO1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIHRoaXMuX2NoYW5nZSA9IDA7XG4gICAgICAgIHRoaXMucHJldlBvcyA9IDA7XG4gICAgICAgIHRoaXMueW95byA9IHlveW87XG4gICAgICAgIHRoaXMuX3RpbWUgPSAwO1xuICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IDA7XG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IDA7XG4gICAgICAgIHRoaXMuX2ZpbmlzaCA9IDA7XG4gICAgICAgIHRoaXMuZnVuYyA9IGZ1bmM7XG4gICAgICAgIHRoaXMuX2NoYW5nZSA9IGZpbmlzaCAtIHRoaXMuYmVnaW47XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICB9O1xuICAgIC8qXG4gICAgICogVHdlZW4gbWV0aG9kc1xuICAgICAqL1xuICAgIFR3ZWVuLnByb3RvdHlwZSA9IHtcbiAgICAgICAgZmlyZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXNbc3RyXTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRUaW1lOiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICBpZih0ID4gdGhpcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmKHRoaXMueW95bykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lID0gdGhpcy5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYodCA8IDApIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnlveW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWUgPSB0O1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldFRpbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZQb3MgPSB0aGlzLl9wb3M7XG4gICAgICAgICAgICB0aGlzLnByb3BGdW5jKHApO1xuICAgICAgICAgICAgdGhpcy5fcG9zID0gcDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UG9zaXRpb246IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIGlmKHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHQgPSB0aGlzLl90aW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyh0LCB0aGlzLmJlZ2luLCB0aGlzLl9jaGFuZ2UsIHRoaXMuZHVyYXRpb24pO1xuICAgICAgICB9LFxuICAgICAgICBwbGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBQTEFZSU5HO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gdGhpcy5nZXRUaW1lcigpIC0gdGhpcy5fdGltZTtcbiAgICAgICAgICAgIHRoaXMub25FbnRlckZyYW1lKCk7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ29uUGxheScpO1xuICAgICAgICB9LFxuICAgICAgICByZXZlcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBSRVZFUlNJTkc7XG4gICAgICAgICAgICB0aGlzLl90aW1lID0gdGhpcy5kdXJhdGlvbiAtIHRoaXMuX3RpbWU7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSB0aGlzLmdldFRpbWVyKCkgLSB0aGlzLl90aW1lO1xuICAgICAgICAgICAgdGhpcy5vbkVudGVyRnJhbWUoKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnb25SZXZlcnNlJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNlZWs6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWUgPSB0O1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnb25TZWVrJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWUgPSAwO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnb25SZXNldCcpO1xuICAgICAgICB9LFxuICAgICAgICBmaW5pc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgdGhpcy5fdGltZSA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdvbkZpbmlzaCcpO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbih0aGlzLmdldFBvc2l0aW9uKHRoaXMuX3RpbWUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FbnRlckZyYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0ID0gdGhpcy5nZXRUaW1lcigpIC0gdGhpcy5fc3RhcnRUaW1lO1xuICAgICAgICAgICAgaWYodGhpcy5zdGF0ZSA9PT0gUExBWUlORykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VGltZSh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFJFVkVSU0lORykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VGltZSh0aGlzLmR1cmF0aW9uIC0gdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBhdXNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBQQVVTRUQ7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ29uUGF1c2UnKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VGltZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFR3ZWVuIGNvbnN0cnVjdG9yLiAgVHdlZW5zIGVuYWJsZSB5b3UgdG8gYW5pbWF0ZSBhIG5vZGUgYmV0d2VlbiB0aGUgY3VycmVudCBzdGF0ZSBhbmQgYSBuZXcgc3RhdGUuXG4gICAgICogIFlvdSBjYW4gcGxheSwgcGF1c2UsIHJldmVyc2UsIHNlZWssIHJlc2V0LCBhbmQgZmluaXNoIHR3ZWVucy4gIEJ5IGRlZmF1bHQsIHR3ZWVucyBhcmUgYW5pbWF0ZWQgdXNpbmdcbiAgICAgKiAgYSBsaW5lYXIgZWFzaW5nLiAgRm9yIG1vcmUgdHdlZW5pbmcgb3B0aW9ucywgY2hlY2sgb3V0IHtAbGluayBLb252YS5FYXNpbmdzfVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gaW5zdGFudGlhdGUgbmV3IHR3ZWVuIHdoaWNoIGZ1bGx5IHJvdGF0ZXMgYSBub2RlIGluIDEgc2Vjb25kXG4gICAgICogdmFyIHR3ZWVuID0gbmV3IEtvbnZhLlR3ZWVuKHtcbiAgICAgKiAgIG5vZGU6IG5vZGUsXG4gICAgICogICByb3RhdGlvbkRlZzogMzYwLFxuICAgICAqICAgZHVyYXRpb246IDEsXG4gICAgICogICBlYXNpbmc6IEtvbnZhLkVhc2luZ3MuRWFzZUluT3V0XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBwbGF5IHR3ZWVuXG4gICAgICogdHdlZW4ucGxheSgpO1xuICAgICAqXG4gICAgICogLy8gcGF1c2UgdHdlZW5cbiAgICAgKiB0d2Vlbi5wYXVzZSgpO1xuICAgICAqL1xuICAgIEtvbnZhLlR3ZWVuID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgIG5vZGUgPSBjb25maWcubm9kZSxcbiAgICAgICAgICAgIG5vZGVJZCA9IG5vZGUuX2lkLFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICBlYXNpbmcgPSBjb25maWcuZWFzaW5nIHx8IEtvbnZhLkVhc2luZ3MuTGluZWFyLFxuICAgICAgICAgICAgeW95byA9ICEhY29uZmlnLnlveW8sXG4gICAgICAgICAgICBrZXk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcuZHVyYXRpb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmR1cmF0aW9uID09PSAwKSB7ICAvLyB6ZXJvIGlzIGJhZCB2YWx1ZSBmb3IgZHVyYXRpb25cbiAgICAgICAgICAgIGR1cmF0aW9uID0gMC4wMDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IGNvbmZpZy5kdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLl9pZCA9IGlkQ291bnRlcisrO1xuXG4gICAgICAgIHRoaXMuYW5pbSA9IG5ldyBLb252YS5BbmltYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGF0LnR3ZWVuLm9uRW50ZXJGcmFtZSgpO1xuICAgICAgICB9LCBub2RlLmdldExheWVyKCkgfHwgKChub2RlIGluc3RhbmNlb2YgS29udmEuU3RhZ2UpID8gbm9kZS5nZXRMYXllcnMoKSA6IG51bGwpKTtcblxuICAgICAgICB0aGlzLnR3ZWVuID0gbmV3IFR3ZWVuKGtleSwgZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgdGhhdC5fdHdlZW5GdW5jKGkpO1xuICAgICAgICB9LCBlYXNpbmcsIDAsIDEsIGR1cmF0aW9uICogMTAwMCwgeW95byk7XG5cbiAgICAgICAgdGhpcy5fYWRkTGlzdGVuZXJzKCk7XG5cbiAgICAgICAgLy8gaW5pdCBhdHRycyBtYXBcbiAgICAgICAgaWYgKCFLb252YS5Ud2Vlbi5hdHRyc1tub2RlSWRdKSB7XG4gICAgICAgICAgICBLb252YS5Ud2Vlbi5hdHRyc1tub2RlSWRdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFLb252YS5Ud2Vlbi5hdHRyc1tub2RlSWRdW3RoaXMuX2lkXSkge1xuICAgICAgICAgICAgS29udmEuVHdlZW4uYXR0cnNbbm9kZUlkXVt0aGlzLl9pZF0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbml0IHR3ZWVucyBtYXBcbiAgICAgICAgaWYgKCFLb252YS5Ud2Vlbi50d2VlbnNbbm9kZUlkXSkge1xuICAgICAgICAgICAgS29udmEuVHdlZW4udHdlZW5zW25vZGVJZF0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoa2V5IGluIGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKGJsYWNrbGlzdFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRBdHRyKGtleSwgY29uZmlnW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICAgIC8vIGNhbGxiYWNrc1xuICAgICAgICB0aGlzLm9uRmluaXNoID0gY29uZmlnLm9uRmluaXNoO1xuICAgICAgICB0aGlzLm9uUmVzZXQgPSBjb25maWcub25SZXNldDtcbiAgICB9O1xuXG4gICAgLy8gc3RhcnQvZGlmZiBvYmplY3QgPSBhdHRycy5ub2RlSWQudHdlZW5JZC5hdHRyXG4gICAgS29udmEuVHdlZW4uYXR0cnMgPSB7fTtcbiAgICAvLyB0d2VlbklkID0gdHdlZW5zLm5vZGVJZC5hdHRyXG4gICAgS29udmEuVHdlZW4udHdlZW5zID0ge307XG5cbiAgICBLb252YS5Ud2Vlbi5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9hZGRBdHRyOiBmdW5jdGlvbihrZXksIGVuZCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUsXG4gICAgICAgICAgICAgICAgbm9kZUlkID0gbm9kZS5faWQsXG4gICAgICAgICAgICAgICAgc3RhcnQsIGRpZmYsIHR3ZWVuSWQsIG4sIGxlbiwgdHJ1ZUVuZCwgdHJ1ZVN0YXJ0O1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgY29uZmxpY3QgZnJvbSB0d2VlbiBtYXAgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICB0d2VlbklkID0gS29udmEuVHdlZW4udHdlZW5zW25vZGVJZF1ba2V5XTtcblxuICAgICAgICAgICAgaWYgKHR3ZWVuSWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgS29udmEuVHdlZW4uYXR0cnNbbm9kZUlkXVt0d2VlbklkXVtrZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhZGQgdG8gdHdlZW4gbWFwXG4gICAgICAgICAgICBzdGFydCA9IG5vZGUuZ2V0QXR0cihrZXkpO1xuXG4gICAgICAgICAgICBpZiAoS29udmEuVXRpbC5faXNBcnJheShlbmQpKSB7XG4gICAgICAgICAgICAgICAgZGlmZiA9IFtdO1xuICAgICAgICAgICAgICAgIGxlbiA9IE1hdGgubWF4KGVuZC5sZW5ndGgsIHN0YXJ0Lmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAncG9pbnRzJyAmJiBlbmQubGVuZ3RoICE9PSBzdGFydC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVmb3JlIHR3ZWVuaW5nIHBvaW50cyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHN0YXJ0Lmxlbmd0aCA9PT0gZW5kLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAvLyBLb252YS5VdGlsLl9wcmVwYXJlQXJyYXlGb3JUd2VlbiB0aGlua2luZyB0aGF0IGVuZC5sZW5ndGggPiBzdGFydC5sZW5ndGhcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kLmxlbmd0aCA+IHN0YXJ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gaW4gdGhpcyBjYXNlIHdlIHdpbGwgaW5jcmVhc2UgbnVtYmVyIG9mIHN0YXJ0aW5nIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IEtvbnZhLlV0aWwuX3ByZXBhcmVBcnJheUZvclR3ZWVuKHN0YXJ0LCBlbmQsIG5vZGUuY2xvc2VkKCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIHdpbGwgaW5jcmVhc2UgbnVtYmVyIG9mIGVkaW5nIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZUVuZCA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IEtvbnZhLlV0aWwuX3ByZXBhcmVBcnJheUZvclR3ZWVuKGVuZCwgc3RhcnQsIG5vZGUuY2xvc2VkKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZmYucHVzaCgoZW5kW25dKSAtIChzdGFydFtuXSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2xvckF0dHJzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IEtvbnZhLlV0aWwuY29sb3JUb1JHQkEoc3RhcnQpO1xuICAgICAgICAgICAgICAgIHZhciBlbmRSR0JBID0gS29udmEuVXRpbC5jb2xvclRvUkdCQShlbmQpO1xuICAgICAgICAgICAgICAgIGRpZmYgPSB7XG4gICAgICAgICAgICAgICAgICAgIHI6IGVuZFJHQkEuciAtIHN0YXJ0LnIsXG4gICAgICAgICAgICAgICAgICAgIGc6IGVuZFJHQkEuZyAtIHN0YXJ0LmcsXG4gICAgICAgICAgICAgICAgICAgIGI6IGVuZFJHQkEuYiAtIHN0YXJ0LmIsXG4gICAgICAgICAgICAgICAgICAgIGE6IGVuZFJHQkEuYSAtIHN0YXJ0LmFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaWZmID0gZW5kIC0gc3RhcnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEtvbnZhLlR3ZWVuLmF0dHJzW25vZGVJZF1bdGhpcy5faWRdW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGRpZmY6IGRpZmYsXG4gICAgICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICAgICAgdHJ1ZUVuZDogdHJ1ZUVuZCxcbiAgICAgICAgICAgICAgICB0cnVlU3RhcnQ6IHRydWVTdGFydFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEtvbnZhLlR3ZWVuLnR3ZWVuc1tub2RlSWRdW2tleV0gPSB0aGlzLl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgX3R3ZWVuRnVuYzogZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUsXG4gICAgICAgICAgICAgICAgYXR0cnMgPSBLb252YS5Ud2Vlbi5hdHRyc1tub2RlLl9pZF1bdGhpcy5faWRdLFxuICAgICAgICAgICAgICAgIGtleSwgYXR0ciwgc3RhcnQsIGRpZmYsIG5ld1ZhbCwgbiwgbGVuLCBlbmQ7XG5cbiAgICAgICAgICAgIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgYXR0ciA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBhdHRyLnN0YXJ0O1xuICAgICAgICAgICAgICAgIGRpZmYgPSBhdHRyLmRpZmY7XG4gICAgICAgICAgICAgICAgZW5kID0gYXR0ci5lbmQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoS29udmEuVXRpbC5faXNBcnJheShzdGFydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsID0gW107XG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IE1hdGgubWF4KHN0YXJ0Lmxlbmd0aCwgZW5kLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsLnB1c2goKHN0YXJ0W25dIHx8IDApICsgKGRpZmZbbl0gKiBpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbG9yQXR0cnMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWwgPSAncmdiYSgnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKHN0YXJ0LnIgKyBkaWZmLnIgKiBpKSArICcsJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZChzdGFydC5nICsgZGlmZi5nICogaSkgKyAnLCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucm91bmQoc3RhcnQuYiArIGRpZmYuYiAqIGkpICsgJywnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3RhcnQuYSArIGRpZmYuYSAqIGkpICsgJyknO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbCA9IHN0YXJ0ICsgKGRpZmYgKiBpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHIoa2V5LCBuZXdWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfYWRkTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgLy8gc3RhcnQgbGlzdGVuZXJzXG4gICAgICAgICAgICB0aGlzLnR3ZWVuLm9uUGxheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuYW5pbS5zdGFydCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudHdlZW4ub25SZXZlcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5hbmltLnN0YXJ0KCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBzdG9wIGxpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy50d2Vlbi5vblBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5hbmltLnN0b3AoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnR3ZWVuLm9uRmluaXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGF0Lm5vZGU7XG5cbiAgICAgICAgICAgICAgICAvLyBhZnRlciB0d2VlbmluZyAgcG9pbnRzIG9mIGxpbmUgd2UgbmVlZCB0byBzZXQgb3JpZ2luYWwgZW5kXG4gICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gS29udmEuVHdlZW4uYXR0cnNbbm9kZS5faWRdW3RoYXQuX2lkXTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cnMucG9pbnRzICYmIGF0dHJzLnBvaW50cy50cnVlRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucG9pbnRzKGF0dHJzLnBvaW50cy50cnVlRW5kKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhhdC5vbkZpbmlzaCkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0Lm9uRmluaXNoLmNhbGwodGhhdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudHdlZW4ub25SZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhhdC5ub2RlO1xuICAgICAgICAgICAgICAgIC8vIGFmdGVyIHR3ZWVuaW5nICBwb2ludHMgb2YgbGluZSB3ZSBuZWVkIHRvIHNldCBvcmlnaW5hbCBzdGFydFxuICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IEtvbnZhLlR3ZWVuLmF0dHJzW25vZGUuX2lkXVt0aGF0Ll9pZF07XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJzLnBvaW50cyAmJiBhdHRycy5wb2ludHMudHJ1ZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucG9pbnRzKGF0dHJzLnBvaW50cy50cnVlU3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGF0Lm9uUmVzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5vblJlc2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHBsYXlcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHdlZW4ucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtUd2Vlbn1cbiAgICAgICAgICovXG4gICAgICAgIHBsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy50d2Vlbi5wbGF5KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJldmVyc2VcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHdlZW4ucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtUd2Vlbn1cbiAgICAgICAgICovXG4gICAgICAgIHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy50d2Vlbi5yZXZlcnNlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlc2V0XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlR3ZWVuLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7VHdlZW59XG4gICAgICAgICAqL1xuICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnR3ZWVuLnJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNlZWtcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHdlZW4ucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gdCB0aW1lIGluIHNlY29uZHMgYmV0d2VlbiAwIGFuZCB0aGUgZHVyYXRpb25cbiAgICAgICAgICogQHJldHVybnMge1R3ZWVufVxuICAgICAgICAgKi9cbiAgICAgICAgc2VlazogZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgdGhpcy50d2Vlbi5zZWVrKHQgKiAxMDAwKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogcGF1c2VcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHdlZW4ucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtUd2Vlbn1cbiAgICAgICAgICovXG4gICAgICAgIHBhdXNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMudHdlZW4ucGF1c2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZmluaXNoXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlR3ZWVuLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7VHdlZW59XG4gICAgICAgICAqL1xuICAgICAgICBmaW5pc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy50d2Vlbi5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZGVzdHJveVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ud2Vlbi5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG5vZGVJZCA9IHRoaXMubm9kZS5faWQsXG4gICAgICAgICAgICAgICAgdGhpc0lkID0gdGhpcy5faWQsXG4gICAgICAgICAgICAgICAgYXR0cnMgPSBLb252YS5Ud2Vlbi50d2VlbnNbbm9kZUlkXSxcbiAgICAgICAgICAgICAgICBrZXk7XG5cbiAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcblxuICAgICAgICAgICAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgS29udmEuVHdlZW4udHdlZW5zW25vZGVJZF1ba2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIEtvbnZhLlR3ZWVuLmF0dHJzW25vZGVJZF1bdGhpc0lkXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUd2VlbiBub2RlIHByb3BlcnRpZXMuIFNob3J0ZXIgdXNhZ2Ugb2Yge0BsaW5rIEtvbnZhLlR3ZWVufSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIEtvbnZhLk5vZGUjdG9cbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSB0d2VlbiBwYXJhbXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogY2lyY2xlLnRvKHtcbiAgICAgKiAgeCA6IDUwLFxuICAgICAqICBkdXJhdGlvbiA6IDAuNVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnRvID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBvbkZpbmlzaCA9IHBhcmFtcy5vbkZpbmlzaDtcbiAgICAgICAgcGFyYW1zLm5vZGUgPSB0aGlzO1xuICAgICAgICBwYXJhbXMub25GaW5pc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgICAgaWYgKG9uRmluaXNoKSB7XG4gICAgICAgICAgICAgICAgb25GaW5pc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHR3ZWVuID0gbmV3IEtvbnZhLlR3ZWVuKHBhcmFtcyk7XG4gICAgICAgIHR3ZWVuLnBsYXkoKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAqIFRoZXNlIGVhc2VzIHdlcmUgcG9ydGVkIGZyb20gYW4gQWRvYmUgRmxhc2ggdHdlZW5pbmcgbGlicmFyeSB0byBKYXZhU2NyaXB0XG4gICAgKiBieSBYYXJpY1xuICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlIEVhc2luZ3NcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKi9cbiAgICBLb252YS5FYXNpbmdzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgKiBiYWNrIGVhc2UgaW5cbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgICAgICAnQmFja0Vhc2VJbic6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogKChzICsgMSkgKiB0IC0gcykgKyBiO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBiYWNrIGVhc2Ugb3V0XG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICAgICAgJ0JhY2tFYXNlT3V0JzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgICAgICAgICAgcmV0dXJuIGMgKiAoKCB0ID0gdCAvIGQgLSAxKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDEpICsgYjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogYmFjayBlYXNlIGluIG91dFxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgICAgICdCYWNrRWFzZUluT3V0JzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgICAgICAgICAgaWYoKHQgLz0gZCAvIDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjIC8gMiAqICh0ICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgLSBzKSkgKyBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGMgLyAyICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpICsgYjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogZWxhc3RpYyBlYXNlIGluXG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICAgICAgJ0VsYXN0aWNFYXNlSW4nOiBmdW5jdGlvbih0LCBiLCBjLCBkLCBhLCBwKSB7XG4gICAgICAgICAgICAvLyBhZGRlZCBzID0gMFxuICAgICAgICAgICAgdmFyIHMgPSAwO1xuICAgICAgICAgICAgaWYodCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoKHQgLz0gZCkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYiArIGM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZighcCkge1xuICAgICAgICAgICAgICAgIHAgPSBkICogMC4zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIWEgfHwgYSA8IE1hdGguYWJzKGMpKSB7XG4gICAgICAgICAgICAgICAgYSA9IGM7XG4gICAgICAgICAgICAgICAgcyA9IHAgLyA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKGMgLyBhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtKGEgKiBNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0ICogZCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKSArIGI7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIGVsYXN0aWMgZWFzZSBvdXRcbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgICAgICAnRWxhc3RpY0Vhc2VPdXQnOiBmdW5jdGlvbih0LCBiLCBjLCBkLCBhLCBwKSB7XG4gICAgICAgICAgICAvLyBhZGRlZCBzID0gMFxuICAgICAgICAgICAgdmFyIHMgPSAwO1xuICAgICAgICAgICAgaWYodCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoKHQgLz0gZCkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYiArIGM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZighcCkge1xuICAgICAgICAgICAgICAgIHAgPSBkICogMC4zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIWEgfHwgYSA8IE1hdGguYWJzKGMpKSB7XG4gICAgICAgICAgICAgICAgYSA9IGM7XG4gICAgICAgICAgICAgICAgcyA9IHAgLyA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKGMgLyBhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgKiBkIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKyBjICsgYik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIGVsYXN0aWMgZWFzZSBpbiBvdXRcbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgICAgICAnRWxhc3RpY0Vhc2VJbk91dCc6IGZ1bmN0aW9uKHQsIGIsIGMsIGQsIGEsIHApIHtcbiAgICAgICAgICAgIC8vIGFkZGVkIHMgPSAwXG4gICAgICAgICAgICB2YXIgcyA9IDA7XG4gICAgICAgICAgICBpZih0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZigodCAvPSBkIC8gMikgPT09IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYiArIGM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZighcCkge1xuICAgICAgICAgICAgICAgIHAgPSBkICogKDAuMyAqIDEuNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZighYSB8fCBhIDwgTWF0aC5hYnMoYykpIHtcbiAgICAgICAgICAgICAgICBhID0gYztcbiAgICAgICAgICAgICAgICBzID0gcCAvIDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oYyAvIGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodCA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTAuNSAqIChhICogTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAqIGQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSkgKyBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAqIGQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSAqIDAuNSArIGMgKyBiO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBib3VuY2UgZWFzZSBvdXRcbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgICAgICAnQm91bmNlRWFzZU91dCc6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgICAgIGlmKCh0IC89IGQpIDwgKDEgLyAyLjc1KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjICogKDcuNTYyNSAqIHQgKiB0KSArIGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHQgPCAoMiAvIDIuNzUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gKDEuNSAvIDIuNzUpKSAqIHQgKyAwLjc1KSArIGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHQgPCAoMi41IC8gMi43NSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAoMi4yNSAvIDIuNzUpKSAqIHQgKyAwLjkzNzUpICsgYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjICogKDcuNTYyNSAqICh0IC09ICgyLjYyNSAvIDIuNzUpKSAqIHQgKyAwLjk4NDM3NSkgKyBiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBib3VuY2UgZWFzZSBpblxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgICAgICdCb3VuY2VFYXNlSW4nOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgICByZXR1cm4gYyAtIEtvbnZhLkVhc2luZ3MuQm91bmNlRWFzZU91dChkIC0gdCwgMCwgYywgZCkgKyBiO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBib3VuY2UgZWFzZSBpbiBvdXRcbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgICAgICAnQm91bmNlRWFzZUluT3V0JzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgaWYodCA8IGQgLyAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEtvbnZhLkVhc2luZ3MuQm91bmNlRWFzZUluKHQgKiAyLCAwLCBjLCBkKSAqIDAuNSArIGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gS29udmEuRWFzaW5ncy5Cb3VuY2VFYXNlT3V0KHQgKiAyIC0gZCwgMCwgYywgZCkgKiAwLjUgKyBjICogMC41ICsgYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogZWFzZSBpblxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgICAgICdFYXNlSW4nOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCArIGI7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIGVhc2Ugb3V0XG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICAgICAgJ0Vhc2VPdXQnOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgICByZXR1cm4gLWMgKiAodCAvPSBkKSAqICh0IC0gMikgKyBiO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBlYXNlIGluIG91dFxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgICAgICdFYXNlSW5PdXQnOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgICBpZigodCAvPSBkIC8gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKyBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC1jIC8gMiAqICgoLS10KSAqICh0IC0gMikgLSAxKSArIGI7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIHN0cm9uZyBlYXNlIGluXG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICAgICAgJ1N0cm9uZ0Vhc2VJbic6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCAqIHQgKiB0ICsgYjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogc3Ryb25nIGVhc2Ugb3V0XG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICAgICAgJ1N0cm9uZ0Vhc2VPdXQnOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgICByZXR1cm4gYyAqICgoIHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKiB0ICogdCArIDEpICsgYjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogc3Ryb25nIGVhc2UgaW4gb3V0XG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICAgICAgJ1N0cm9uZ0Vhc2VJbk91dCc6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgICAgIGlmKCh0IC89IGQgLyAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYyAvIDIgKiB0ICogdCAqIHQgKiB0ICogdCArIGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMikgKyBiO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBsaW5lYXJcbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgICAgICAnTGluZWFyJzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgcmV0dXJuIGMgKiB0IC8gZCArIGI7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBLb252YS5ERCA9IHtcbiAgICAgICAgLy8gcHJvcGVydGllc1xuICAgICAgICBhbmltOiBuZXcgS29udmEuQW5pbWF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmRpcnR5O1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH0pLFxuICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAganVzdERyYWdnZWQ6IGZhbHNlLFxuICAgICAgICBvZmZzZXQ6IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgIH0sXG4gICAgICAgIG5vZGU6IG51bGwsXG5cbiAgICAgICAgLy8gbWV0aG9kc1xuICAgICAgICBfZHJhZzogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICB2YXIgZGQgPSBLb252YS5ERCxcbiAgICAgICAgICAgICAgICBub2RlID0gZGQubm9kZTtcblxuICAgICAgICAgICAgaWYobm9kZSkge1xuICAgICAgICAgICAgICAgaWYoIWRkLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IG5vZGUuZ2V0U3RhZ2UoKS5nZXRQb2ludGVyUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYWdEaXN0YW5jZSA9IG5vZGUuZHJhZ0Rpc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMocG9zLnggLSBkZC5zdGFydFBvaW50ZXJQb3MueCksXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhwb3MueSAtIGRkLnN0YXJ0UG9pbnRlclBvcy55KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBkcmFnRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgbm9kZS5nZXRTdGFnZSgpLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgICAgICAgICAgICBub2RlLl9zZXREcmFnUG9zaXRpb24oZXZ0KTtcbiAgICAgICAgICAgICAgICBpZighZGQuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgICAgICBkZC5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5maXJlKCdkcmFnc3RhcnQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZHJhZ3N0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2dDogZXZ0XG4gICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGV4ZWN1dGUgb25kcmFnbW92ZSBpZiBkZWZpbmVkXG4gICAgICAgICAgICAgICAgbm9kZS5maXJlKCdkcmFnbW92ZScsIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RyYWdtb3ZlJyxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBub2RlLFxuICAgICAgICAgICAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfZW5kRHJhZ0JlZm9yZTogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICB2YXIgZGQgPSBLb252YS5ERCxcbiAgICAgICAgICAgICAgICBub2RlID0gZGQubm9kZSxcbiAgICAgICAgICAgICAgICBsYXllcjtcblxuICAgICAgICAgICAgaWYobm9kZSkge1xuICAgICAgICAgICAgICAgIGxheWVyID0gbm9kZS5nZXRMYXllcigpO1xuICAgICAgICAgICAgICAgIGRkLmFuaW0uc3RvcCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gb25seSBmaXJlIGRyYWdlbmQgZXZlbnQgaWYgdGhlIGRyYWcgYW5kIGRyb3BcbiAgICAgICAgICAgICAgICAvLyBvcGVyYXRpb24gYWN0dWFsbHkgc3RhcnRlZC5cbiAgICAgICAgICAgICAgICBpZihkZC5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRkLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZGQuanVzdERyYWdnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBLb252YS5saXN0ZW5DbGlja1RhcCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2dC5kcmFnRW5kTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgZGQubm9kZTtcblxuICAgICAgICAgICAgICAgIChsYXllciB8fCBub2RlKS5kcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9lbmREcmFnQWZ0ZXI6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgZXZ0ID0gZXZ0IHx8IHt9O1xuICAgICAgICAgICAgdmFyIGRyYWdFbmROb2RlID0gZXZ0LmRyYWdFbmROb2RlO1xuXG4gICAgICAgICAgICBpZiAoZXZ0ICYmIGRyYWdFbmROb2RlKSB7XG4gICAgICAgICAgICAgICAgZHJhZ0VuZE5vZGUuZmlyZSgnZHJhZ2VuZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RyYWdlbmQnLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGRyYWdFbmROb2RlLFxuICAgICAgICAgICAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIE5vZGUgZXh0ZW5kZXJzXG5cbiAgICAvKipcbiAgICAgKiBpbml0aWF0ZSBkcmFnIGFuZCBkcm9wXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnN0YXJ0RHJhZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGQgPSBLb252YS5ERCxcbiAgICAgICAgICAgIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpLFxuICAgICAgICAgICAgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksXG4gICAgICAgICAgICBwb3MgPSBzdGFnZS5nZXRQb2ludGVyUG9zaXRpb24oKSxcbiAgICAgICAgICAgIGFwID0gdGhpcy5nZXRBYnNvbHV0ZVBvc2l0aW9uKCk7XG5cbiAgICAgICAgaWYocG9zKSB7XG4gICAgICAgICAgICBpZiAoZGQubm9kZSkge1xuICAgICAgICAgICAgICAgIGRkLm5vZGUuc3RvcERyYWcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGQubm9kZSA9IHRoaXM7XG4gICAgICAgICAgICBkZC5zdGFydFBvaW50ZXJQb3MgPSBwb3M7XG4gICAgICAgICAgICBkZC5vZmZzZXQueCA9IHBvcy54IC0gYXAueDtcbiAgICAgICAgICAgIGRkLm9mZnNldC55ID0gcG9zLnkgLSBhcC55O1xuICAgICAgICAgICAgZGQuYW5pbS5zZXRMYXllcnMobGF5ZXIgfHwgdGhpcy5nZXRMYXllcnMoKSk7XG4gICAgICAgICAgICBkZC5hbmltLnN0YXJ0KCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3NldERyYWdQb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLl9zZXREcmFnUG9zaXRpb24gPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdmFyIGRkID0gS29udmEuREQsXG4gICAgICAgICAgICBwb3MgPSB0aGlzLmdldFN0YWdlKCkuZ2V0UG9pbnRlclBvc2l0aW9uKCksXG4gICAgICAgICAgICBkYmYgPSB0aGlzLmdldERyYWdCb3VuZEZ1bmMoKTtcbiAgICAgICAgaWYgKCFwb3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3Tm9kZVBvcyA9IHtcbiAgICAgICAgICAgIHg6IHBvcy54IC0gZGQub2Zmc2V0LngsXG4gICAgICAgICAgICB5OiBwb3MueSAtIGRkLm9mZnNldC55XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoZGJmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld05vZGVQb3MgPSBkYmYuY2FsbCh0aGlzLCBuZXdOb2RlUG9zLCBldnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0QWJzb2x1dGVQb3NpdGlvbihuZXdOb2RlUG9zKTtcblxuICAgICAgICBpZiAoIXRoaXMuX2xhc3RQb3MgfHwgdGhpcy5fbGFzdFBvcy54ICE9PSBuZXdOb2RlUG9zLnggfHxcbiAgICAgICAgICAgIHRoaXMuX2xhc3RQb3MueSAhPT0gbmV3Tm9kZVBvcy55KSB7XG4gICAgICAgICAgICBkZC5hbmltLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xhc3RQb3MgPSBuZXdOb2RlUG9zO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzdG9wIGRyYWcgYW5kIGRyb3BcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICovXG4gICAgS29udmEuTm9kZS5wcm90b3R5cGUuc3RvcERyYWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRkID0gS29udmEuREQsXG4gICAgICAgICAgICBldnQgPSB7fTtcbiAgICAgICAgZGQuX2VuZERyYWdCZWZvcmUoZXZ0KTtcbiAgICAgICAgZGQuX2VuZERyYWdBZnRlcihldnQpO1xuICAgIH07XG5cbiAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXREcmFnZ2FibGUgPSBmdW5jdGlvbihkcmFnZ2FibGUpIHtcbiAgICAgICAgdGhpcy5fc2V0QXR0cignZHJhZ2dhYmxlJywgZHJhZ2dhYmxlKTtcbiAgICAgICAgdGhpcy5fZHJhZ0NoYW5nZSgpO1xuICAgIH07XG5cbiAgICB2YXIgb3JpZ0Rlc3Ryb3kgPSBLb252YS5Ob2RlLnByb3RvdHlwZS5kZXN0cm95O1xuXG4gICAgS29udmEuTm9kZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGQgPSBLb252YS5ERDtcblxuICAgICAgICAvLyBzdG9wIEREXG4gICAgICAgIGlmKGRkLm5vZGUgJiYgZGQubm9kZS5faWQgPT09IHRoaXMuX2lkKSB7XG5cbiAgICAgICAgICAgIHRoaXMuc3RvcERyYWcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9yaWdEZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGRldGVybWluZSBpZiBub2RlIGlzIGN1cnJlbnRseSBpbiBkcmFnIGFuZCBkcm9wIG1vZGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICovXG4gICAgS29udmEuTm9kZS5wcm90b3R5cGUuaXNEcmFnZ2luZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGQgPSBLb252YS5ERDtcbiAgICAgICAgcmV0dXJuICEhKGRkLm5vZGUgJiYgZGQubm9kZS5faWQgPT09IHRoaXMuX2lkICYmIGRkLmlzRHJhZ2dpbmcpO1xuICAgIH07XG5cbiAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5fbGlzdGVuRHJhZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5fZHJhZ0NsZWFudXAoKTtcblxuICAgICAgICBpZiAodGhpcy5nZXRDbGFzc05hbWUoKSA9PT0gJ1N0YWdlJykge1xuICAgICAgICAgICAgdGhpcy5vbignY29udGVudE1vdXNlZG93bi5rb252YSBjb250ZW50VG91Y2hzdGFydC5rb252YScsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgIGlmKCFLb252YS5ERC5ub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc3RhcnREcmFnKGV2dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uKCdtb3VzZWRvd24ua29udmEgdG91Y2hzdGFydC5rb252YScsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSByaWdodCBhbmQgbWlkZGxlIGJ1dHRvbnNcbiAgICAgICAgICAgICAgICBpZiAoZXZ0LmV2dC5idXR0b24gPT09IDEgfHwgZXZ0LmV2dC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZighS29udmEuREQubm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnN0YXJ0RHJhZyhldnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGlzdGVuaW5nIGlzIHJlcXVpcmVkIGZvciBkcmFnIGFuZCBkcm9wXG4gICAgICAgIC8qXG4gICAgICAgIHRoaXMuX2xpc3RlbmluZ0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jbGVhclNlbGZBbmRBbmNlc3RvckNhY2hlKCdsaXN0ZW5pbmdFbmFibGVkJyk7XG4gICAgICAgICovXG4gICAgfTtcblxuICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLl9kcmFnQ2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKHRoaXMuYXR0cnMuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5EcmFnKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICB0aGlzLl9kcmFnQ2xlYW51cCgpO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogZm9yY2UgZHJhZyBhbmQgZHJvcCB0byBlbmRcbiAgICAgICAgICAgICAqIGlmIHRoaXMgbm9kZSBpcyBjdXJyZW50bHkgaW5cbiAgICAgICAgICAgICAqIGRyYWcgYW5kIGRyb3AgbW9kZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XG4gICAgICAgICAgICB2YXIgZGQgPSBLb252YS5ERDtcbiAgICAgICAgICAgIGlmKHN0YWdlICYmIGRkLm5vZGUgJiYgZGQubm9kZS5faWQgPT09IHRoaXMuX2lkKSB7XG4gICAgICAgICAgICAgICAgZGQubm9kZS5zdG9wRHJhZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLl9kcmFnQ2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5nZXRDbGFzc05hbWUoKSA9PT0gJ1N0YWdlJykge1xuICAgICAgICAgICAgdGhpcy5vZmYoJ2NvbnRlbnRNb3VzZWRvd24ua29udmEnKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdjb250ZW50VG91Y2hzdGFydC5rb252YScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vZmYoJ21vdXNlZG93bi5rb252YScpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ3RvdWNoc3RhcnQua29udmEnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZHJhZ0JvdW5kRnVuYycpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBkcmFnIGJvdW5kIGZ1bmN0aW9uLiAgVGhpcyBpcyB1c2VkIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0XG4gICAgICogIGRyYWcgYW5kIGRyb3AgcG9zaXRpb25cbiAgICAgKiBAbmFtZSBkcmFnQm91bmRGdW5jXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYWdCb3VuZEZ1bmNcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZHJhZyBib3VuZCBmdW5jdGlvblxuICAgICAqIHZhciBkcmFnQm91bmRGdW5jID0gbm9kZS5kcmFnQm91bmRGdW5jKCk7XG4gICAgICpcbiAgICAgKiAvLyBjcmVhdGUgdmVydGljYWwgZHJhZyBhbmQgZHJvcFxuICAgICAqIG5vZGUuZHJhZ0JvdW5kRnVuYyhmdW5jdGlvbihwb3Mpe1xuICAgICAqICAgcmV0dXJuIHtcbiAgICAgKiAgICAgeDogdGhpcy5nZXRBYnNvbHV0ZVBvc2l0aW9uKCkueCxcbiAgICAgKiAgICAgeTogcG9zLnlcbiAgICAgKiAgIH07XG4gICAgICogfSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlcihLb252YS5Ob2RlLCAnZHJhZ2dhYmxlJywgZmFsc2UpO1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZHJhZ2dhYmxlJyk7XG5cbiAgICAgLyoqXG4gICAgICogZ2V0L3NldCBkcmFnZ2FibGUgZmxhZ1xuICAgICAqIEBuYW1lIGRyYWdnYWJsZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRyYWdnYWJsZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGRyYWdnYWJsZSBmbGFnXG4gICAgICogdmFyIGRyYWdnYWJsZSA9IG5vZGUuZHJhZ2dhYmxlKCk7XG4gICAgICpcbiAgICAgKiAvLyBlbmFibGUgZHJhZyBhbmQgZHJvcFxuICAgICAqIG5vZGUuZHJhZ2dhYmxlKHRydWUpO1xuICAgICAqXG4gICAgICogLy8gZGlzYWJsZSBkcmFnIGFuZCBkcm9wXG4gICAgICogbm9kZS5kcmFnZ2FibGUoZmFsc2UpO1xuICAgICAqL1xuXG4gICAgdmFyIGh0bWwgPSBLb252YS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgS29udmEuREQuX2VuZERyYWdCZWZvcmUsIHRydWUpO1xuICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBLb252YS5ERC5fZW5kRHJhZ0JlZm9yZSwgdHJ1ZSk7XG5cbiAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIEtvbnZhLkRELl9kcmFnKTtcbiAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIEtvbnZhLkRELl9kcmFnKTtcblxuICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIEtvbnZhLkRELl9lbmREcmFnQWZ0ZXIsIGZhbHNlKTtcbiAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgS29udmEuREQuX2VuZERyYWdBZnRlciwgZmFsc2UpO1xuXG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qKlxuICAgICAqIFJlY3QgY29uc3RydWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY29ybmVyUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcmVjdCA9IG5ldyBLb252YS5SZWN0KHtcbiAgICAgKiAgIHdpZHRoOiAxMDAsXG4gICAgICogICBoZWlnaHQ6IDUwLFxuICAgICAqICAgZmlsbDogJ3JlZCcsXG4gICAgICogICBzdHJva2U6ICdibGFjaycsXG4gICAgICogICBzdHJva2VXaWR0aDogNVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIEtvbnZhLlJlY3QgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLlJlY3QucHJvdG90eXBlID0ge1xuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1JlY3QnO1xuICAgICAgICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGNvcm5lclJhZGl1cyA9IHRoaXMuZ2V0Q29ybmVyUmFkaXVzKCksXG4gICAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLmdldFdpZHRoKCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcblxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgaWYoIWNvcm5lclJhZGl1cykge1xuICAgICAgICAgICAgICAgIC8vIHNpbXBsZSByZWN0IC0gZG9uJ3QgYm90aGVyIGRvaW5nIGFsbCB0aGF0IGNvbXBsaWNhdGVkIG1hdGhzIHN0dWZmLlxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYXJjVG8gd291bGQgYmUgbmljZXIsIGJ1dCBicm93c2VyIHN1cHBvcnQgaXMgcGF0Y2h5IChPcGVyYSlcbiAgICAgICAgICAgICAgICBjb3JuZXJSYWRpdXMgPSBNYXRoLm1pbihjb3JuZXJSYWRpdXMsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oY29ybmVyUmFkaXVzLCAwKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCAtIGNvcm5lclJhZGl1cywgMCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5hcmMod2lkdGggLSBjb3JuZXJSYWRpdXMsIGNvcm5lclJhZGl1cywgY29ybmVyUmFkaXVzLCBNYXRoLlBJICogMyAvIDIsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCwgaGVpZ2h0IC0gY29ybmVyUmFkaXVzKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFyYyh3aWR0aCAtIGNvcm5lclJhZGl1cywgaGVpZ2h0IC0gY29ybmVyUmFkaXVzLCBjb3JuZXJSYWRpdXMsIDAsIE1hdGguUEkgLyAyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oY29ybmVyUmFkaXVzLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYXJjKGNvcm5lclJhZGl1cywgaGVpZ2h0IC0gY29ybmVyUmFkaXVzLCBjb3JuZXJSYWRpdXMsIE1hdGguUEkgLyAyLCBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oMCwgY29ybmVyUmFkaXVzKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFyYyhjb3JuZXJSYWRpdXMsIGNvcm5lclJhZGl1cywgY29ybmVyUmFkaXVzLCBNYXRoLlBJLCBNYXRoLlBJICogMyAvIDIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5SZWN0LCBLb252YS5TaGFwZSk7XG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5SZWN0LCAnY29ybmVyUmFkaXVzJywgMCk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBjb3JuZXIgcmFkaXVzXG4gICAgICogQG5hbWUgY29ybmVyUmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5SZWN0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3JuZXJSYWRpdXNcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNvcm5lciByYWRpdXNcbiAgICAgKiB2YXIgY29ybmVyUmFkaXVzID0gcmVjdC5jb3JuZXJSYWRpdXMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBjb3JuZXIgcmFkaXVzXG4gICAgICogcmVjdC5jb3JuZXJSYWRpdXMoMTApO1xuICAgICAqL1xuXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlJlY3QpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyB0aGUgMC4wMDAxIG9mZnNldCBmaXhlcyBhIGJ1ZyBpbiBDaHJvbWUgMjdcbiAgICB2YXIgUEl4MiA9IChNYXRoLlBJICogMikgLSAwLjAwMDEsXG4gICAgICAgIENJUkNMRSA9ICdDaXJjbGUnO1xuXG4gICAgLyoqXG4gICAgICogQ2lyY2xlIGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcucmFkaXVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGNyZWF0ZSBjaXJjbGVcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IEtvbnZhLkNpcmNsZSh7XG4gICAgICogICByYWRpdXM6IDQwLFxuICAgICAqICAgZmlsbDogJ3JlZCcsXG4gICAgICogICBzdHJva2U6ICdibGFjaydcbiAgICAgKiAgIHN0cm9rZVdpZHRoOiA1XG4gICAgICogfSk7XG4gICAgICovXG4gICAgS29udmEuQ2lyY2xlID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5DaXJjbGUucHJvdG90eXBlID0ge1xuICAgICAgICBfY2VudHJvaWQ6IHRydWUsXG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBDSVJDTEU7XG4gICAgICAgICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgICAgICB9LFxuICAgICAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgdGhpcy5nZXRSYWRpdXMoKSwgMCwgUEl4MiwgZmFsc2UpO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRXaWR0aCgpXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJhZGl1cygpICogMjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0SGVpZ2h0KClcbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJhZGl1cygpICogMjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0V2lkdGgoKVxuICAgICAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmFkaXVzKCkgIT09IHdpZHRoIC8gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmFkaXVzKHdpZHRoIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldEhlaWdodCgpXG4gICAgICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRIZWlnaHQuY2FsbCh0aGlzLCBoZWlnaHQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmFkaXVzKCkgIT09IGhlaWdodCAvIDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJhZGl1cyhoZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuQ2lyY2xlLCBLb252YS5TaGFwZSk7XG5cbiAgICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQ2lyY2xlLCAncmFkaXVzJywgMCk7XG4gICAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLkNpcmNsZSwgJ3JhZGl1cycpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCByYWRpdXNcbiAgICAgKiBAbmFtZSByYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNpcmNsZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCByYWRpdXNcbiAgICAgKiB2YXIgcmFkaXVzID0gY2lyY2xlLnJhZGl1cygpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHJhZGl1c1xuICAgICAqIGNpcmNsZS5yYWRpdXMoMTApO1xuICAgICAqL1xuXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLkNpcmNsZSk7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIHRoZSAwLjAwMDEgb2Zmc2V0IGZpeGVzIGEgYnVnIGluIENocm9tZSAyN1xuICAgIHZhciBQSXgyID0gKE1hdGguUEkgKiAyKSAtIDAuMDAwMSxcbiAgICAgICAgRUxMSVBTRSA9ICdFbGxpcHNlJztcblxuICAgIC8qKlxuICAgICAqIEVsbGlwc2UgY29uc3RydWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZy5yYWRpdXMgZGVmaW5lcyB4IGFuZCB5IHJhZGl1c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgZWxsaXBzZSA9IG5ldyBLb252YS5FbGxpcHNlKHtcbiAgICAgKiAgIHJhZGl1cyA6IHtcbiAgICAgKiAgICAgeCA6IDUwLFxuICAgICAqICAgICB5IDogNTBcbiAgICAgKiAgIH0sXG4gICAgICogICBmaWxsOiAncmVkJ1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIEtvbnZhLkVsbGlwc2UgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLkVsbGlwc2UucHJvdG90eXBlID0ge1xuICAgICAgICBfY2VudHJvaWQ6IHRydWUsXG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBFTExJUFNFO1xuICAgICAgICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHJ4ID0gdGhpcy5nZXRSYWRpdXNYKCksXG4gICAgICAgICAgICAgICAgcnkgPSB0aGlzLmdldFJhZGl1c1koKTtcblxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgaWYocnggIT09IHJ5KSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zY2FsZSgxLCByeSAvIHJ4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHJ4LCAwLCBQSXgyLCBmYWxzZSk7XG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0V2lkdGgoKVxuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSYWRpdXNYKCkgKiAyO1xuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRIZWlnaHQoKVxuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFkaXVzWSgpICogMjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0V2lkdGgoKVxuICAgICAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xuICAgICAgICAgICAgdGhpcy5zZXRSYWRpdXMoe1xuICAgICAgICAgICAgICAgIHg6IHdpZHRoIC8gMlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldEhlaWdodCgpXG4gICAgICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRIZWlnaHQuY2FsbCh0aGlzLCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5zZXRSYWRpdXMoe1xuICAgICAgICAgICAgICAgIHk6IGhlaWdodCAvIDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5FbGxpcHNlLCBLb252YS5TaGFwZSk7XG5cbiAgICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gICAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLkVsbGlwc2UsICdyYWRpdXMnLCBbJ3gnLCAneSddKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgcmFkaXVzXG4gICAgICogQG5hbWUgcmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5FbGxpcHNlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByYWRpdXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzLnhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzLnlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHJhZGl1c1xuICAgICAqIHZhciByYWRpdXMgPSBlbGxpcHNlLnJhZGl1cygpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHJhZGl1c1xuICAgICAqIGVsbGlwc2UucmFkaXVzKHtcbiAgICAgKiAgIHg6IDIwMCxcbiAgICAgKiAgIHk6IDEwMFxuICAgICAqIH0pO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuRWxsaXBzZSwgJ3JhZGl1c1gnLCAwKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHJhZGl1cyB4XG4gICAgICogQG5hbWUgcmFkaXVzWFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRWxsaXBzZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgcmFkaXVzIHhcbiAgICAgKiB2YXIgcmFkaXVzWCA9IGVsbGlwc2UucmFkaXVzWCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHJhZGl1cyB4XG4gICAgICogZWxsaXBzZS5yYWRpdXNYKDIwMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5FbGxpcHNlLCAncmFkaXVzWScsIDApO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgcmFkaXVzIHlcbiAgICAgKiBAbmFtZSByYWRpdXNZXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5FbGxpcHNlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCByYWRpdXMgeVxuICAgICAqIHZhciByYWRpdXNZID0gZWxsaXBzZS5yYWRpdXNZKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgcmFkaXVzIHlcbiAgICAgKiBlbGxpcHNlLnJhZGl1c1koMjAwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5FbGxpcHNlKTtcblxufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyB0aGUgMC4wMDAxIG9mZnNldCBmaXhlcyBhIGJ1ZyBpbiBDaHJvbWUgMjdcbiAgICB2YXIgUEl4MiA9IChNYXRoLlBJICogMikgLSAwLjAwMDE7XG4gICAgLyoqXG4gICAgICogUmluZyBjb25zdHJ1Y3RvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLmlubmVyUmFkaXVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5vdXRlclJhZGl1c1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5jbG9ja3dpc2VdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciByaW5nID0gbmV3IEtvbnZhLlJpbmcoe1xuICAgICAqICAgaW5uZXJSYWRpdXM6IDQwLFxuICAgICAqICAgb3V0ZXJSYWRpdXM6IDgwLFxuICAgICAqICAgZmlsbDogJ3JlZCcsXG4gICAgICogICBzdHJva2U6ICdibGFjaycsXG4gICAgICogICBzdHJva2VXaWR0aDogNVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIEtvbnZhLlJpbmcgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLlJpbmcucHJvdG90eXBlID0ge1xuICAgICAgICBfY2VudHJvaWQ6IHRydWUsXG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAnUmluZyc7XG4gICAgICAgICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgICAgICB9LFxuICAgICAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgdGhpcy5nZXRJbm5lclJhZGl1cygpLCAwLCBQSXgyLCBmYWxzZSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh0aGlzLmdldE91dGVyUmFkaXVzKCksIDApO1xuICAgICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgdGhpcy5nZXRPdXRlclJhZGl1cygpLCBQSXgyLCAwLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0V2lkdGgoKVxuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPdXRlclJhZGl1cygpICogMjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0SGVpZ2h0KClcbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE91dGVyUmFkaXVzKCkgKiAyO1xuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRXaWR0aCgpXG4gICAgICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0V2lkdGguY2FsbCh0aGlzLCB3aWR0aCk7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRlclJhZGl1cygpICE9PSB3aWR0aCAvIDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE91dGVyUmFkaXVzKHdpZHRoIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldEhlaWdodCgpXG4gICAgICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRIZWlnaHQuY2FsbCh0aGlzLCBoZWlnaHQpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0ZXJSYWRpdXMoKSAhPT0gaGVpZ2h0IC8gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0T3V0ZXJSYWRpdXMoaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldE91dGVyUmFkaXVzOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEF0dHIoJ291dGVyUmFkaXVzJywgdmFsKTtcbiAgICAgICAgICAgIHRoaXMuc2V0V2lkdGgodmFsICogMik7XG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodCh2YWwgKiAyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuUmluZywgS29udmEuU2hhcGUpO1xuXG4gICAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlJpbmcsICdpbm5lclJhZGl1cycsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBpbm5lclJhZGl1c1xuICAgICAqIEBuYW1lIGlubmVyUmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5SaW5nLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbm5lclJhZGl1c1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgaW5uZXIgcmFkaXVzXG4gICAgICogdmFyIGlubmVyUmFkaXVzID0gcmluZy5pbm5lclJhZGl1cygpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGlubmVyIHJhZGl1c1xuICAgICAqIHJpbmcuaW5uZXJSYWRpdXMoMjApO1xuICAgICAqL1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyKEtvbnZhLlJpbmcsICdvdXRlclJhZGl1cycsIDApO1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5SaW5nLCAnb3V0ZXJSYWRpdXMnKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgb3V0ZXJSYWRpdXNcbiAgICAgKiBAbmFtZSBvdXRlclJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuUmluZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3V0ZXJSYWRpdXNcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IG91dGVyIHJhZGl1c1xuICAgICAqIHZhciBvdXRlclJhZGl1cyA9IHJpbmcub3V0ZXJSYWRpdXMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBvdXRlciByYWRpdXNcbiAgICAgKiByaW5nLm91dGVyUmFkaXVzKDIwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5SaW5nKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogV2VkZ2UgY29uc3RydWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5hbmdsZSBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5yYWRpdXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuY2xvY2t3aXNlXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBkcmF3IGEgd2VkZ2UgdGhhdCdzIHBvaW50aW5nIGRvd253YXJkc1xuICAgICAqIHZhciB3ZWRnZSA9IG5ldyBLb252YS5XZWRnZSh7XG4gICAgICogICByYWRpdXM6IDQwLFxuICAgICAqICAgZmlsbDogJ3JlZCcsXG4gICAgICogICBzdHJva2U6ICdibGFjaydcbiAgICAgKiAgIHN0cm9rZVdpZHRoOiA1LFxuICAgICAqICAgYW5nbGVEZWc6IDYwLFxuICAgICAqICAgcm90YXRpb25EZWc6IC0xMjBcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBLb252YS5XZWRnZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgICB9O1xuXG4gICAgS29udmEuV2VkZ2UucHJvdG90eXBlID0ge1xuICAgICAgICBfY2VudHJvaWQ6IHRydWUsXG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAnV2VkZ2UnO1xuICAgICAgICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHRoaXMuZ2V0UmFkaXVzKCksIDAsIEtvbnZhLmdldEFuZ2xlKHRoaXMuZ2V0QW5nbGUoKSksIHRoaXMuZ2V0Q2xvY2t3aXNlKCkpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oMCwgMCk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldFdpZHRoKClcbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFkaXVzKCkgKiAyO1xuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRIZWlnaHQoKVxuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFkaXVzKCkgKiAyO1xuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRXaWR0aCgpXG4gICAgICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0V2lkdGguY2FsbCh0aGlzLCB3aWR0aCk7XG4gICAgICAgICAgICBpZiAodGhpcy5yYWRpdXMoKSAhPT0gd2lkdGggLyAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYWRpdXMod2lkdGggLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0SGVpZ2h0KClcbiAgICAgICAgc2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldEhlaWdodC5jYWxsKHRoaXMsIGhlaWdodCk7XG4gICAgICAgICAgICBpZiAodGhpcy5yYWRpdXMoKSAhPT0gaGVpZ2h0IC8gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmFkaXVzKGhlaWdodCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5XZWRnZSwgS29udmEuU2hhcGUpO1xuXG4gICAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLldlZGdlLCAncmFkaXVzJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHJhZGl1c1xuICAgICAqIEBuYW1lIHJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuV2VkZ2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgcmFkaXVzXG4gICAgICogdmFyIHJhZGl1cyA9IHdlZGdlLnJhZGl1cygpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHJhZGl1c1xuICAgICAqIHdlZGdlLnJhZGl1cygxMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5XZWRnZSwgJ2FuZ2xlJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGFuZ2xlIGluIGRlZ3JlZXNcbiAgICAgKiBAbmFtZSBhbmdsZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuV2VkZ2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBhbmdsZVxuICAgICAqIHZhciBhbmdsZSA9IHdlZGdlLmFuZ2xlKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgYW5nbGVcbiAgICAgKiB3ZWRnZS5hbmdsZSgyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5XZWRnZSwgJ2Nsb2Nrd2lzZScsIGZhbHNlKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgY2xvY2t3aXNlIGZsYWdcbiAgICAgKiBAbmFtZSBjbG9ja3dpc2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLldlZGdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjbG9ja3dpc2VcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNsb2Nrd2lzZSBmbGFnXG4gICAgICogdmFyIGNsb2Nrd2lzZSA9IHdlZGdlLmNsb2Nrd2lzZSgpO1xuICAgICAqXG4gICAgICogLy8gZHJhdyB3ZWRnZSBjb3VudGVyLWNsb2Nrd2lzZVxuICAgICAqIHdlZGdlLmNsb2Nrd2lzZShmYWxzZSk7XG4gICAgICpcbiAgICAgKiAvLyBkcmF3IHdlZGdlIGNsb2Nrd2lzZVxuICAgICAqIHdlZGdlLmNsb2Nrd2lzZSh0cnVlKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYmFja0NvbXBhdChLb252YS5XZWRnZSwge1xuICAgICAgICBhbmdsZURlZzogJ2FuZ2xlJyxcbiAgICAgICAgZ2V0QW5nbGVEZWc6ICdnZXRBbmdsZScsXG4gICAgICAgIHNldEFuZ2xlRGVnOiAnc2V0QW5nbGUnXG4gICAgfSk7XG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuV2VkZ2UpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBBcmMgY29uc3RydWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5hbmdsZSBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5pbm5lclJhZGl1c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcub3V0ZXJSYWRpdXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuY2xvY2t3aXNlXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBkcmF3IGEgQXJjIHRoYXQncyBwb2ludGluZyBkb3dud2FyZHNcbiAgICAgKiB2YXIgYXJjID0gbmV3IEtvbnZhLkFyYyh7XG4gICAgICogICBpbm5lclJhZGl1czogNDAsXG4gICAgICogICBvdXRlclJhZGl1czogODAsXG4gICAgICogICBmaWxsOiAncmVkJyxcbiAgICAgKiAgIHN0cm9rZTogJ2JsYWNrJ1xuICAgICAqICAgc3Ryb2tlV2lkdGg6IDUsXG4gICAgICogICBhbmdsZTogNjAsXG4gICAgICogICByb3RhdGlvbkRlZzogLTEyMFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIEtvbnZhLkFyYyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgICB9O1xuXG4gICAgS29udmEuQXJjLnByb3RvdHlwZSA9IHtcbiAgICAgICAgX2NlbnRyb2lkOiB0cnVlLFxuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ0FyYyc7XG4gICAgICAgICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgICAgICB9LFxuICAgICAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgYW5nbGUgPSBLb252YS5nZXRBbmdsZSh0aGlzLmFuZ2xlKCkpLFxuICAgICAgICAgICAgICAgIGNsb2Nrd2lzZSA9IHRoaXMuY2xvY2t3aXNlKCk7XG5cbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCB0aGlzLmdldE91dGVyUmFkaXVzKCksIDAsIGFuZ2xlLCBjbG9ja3dpc2UpO1xuICAgICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgdGhpcy5nZXRJbm5lclJhZGl1cygpLCBhbmdsZSwgMCwgIWNsb2Nrd2lzZSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldFdpZHRoKClcbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldEhlaWdodCgpXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPdXRlclJhZGl1cygpICogMjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0V2lkdGgoKVxuICAgICAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAhPT0gd2lkdGggLyAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRlclJhZGl1cyh3aWR0aCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRIZWlnaHQoKVxuICAgICAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0LmNhbGwodGhpcywgaGVpZ2h0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldE91dGVyUmFkaXVzKCkgIT09IGhlaWdodCAvIDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE91dGVyUmFkaXVzKGhlaWdodCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5BcmMsIEtvbnZhLlNoYXBlKTtcblxuICAgIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5BcmMsICdpbm5lclJhZGl1cycsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBpbm5lclJhZGl1c1xuICAgICAqIEBuYW1lIGlubmVyUmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5BcmMucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlubmVyUmFkaXVzXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBpbm5lciByYWRpdXNcbiAgICAgKiB2YXIgaW5uZXJSYWRpdXMgPSBhcmMuaW5uZXJSYWRpdXMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBpbm5lciByYWRpdXNcbiAgICAgKiBhcmMuaW5uZXJSYWRpdXMoMjApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQXJjLCAnb3V0ZXJSYWRpdXMnLCAwKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgb3V0ZXJSYWRpdXNcbiAgICAgKiBAbmFtZSBvdXRlclJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQXJjLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvdXRlclJhZGl1c1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgb3V0ZXIgcmFkaXVzXG4gICAgICogdmFyIG91dGVyUmFkaXVzID0gYXJjLm91dGVyUmFkaXVzKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgb3V0ZXIgcmFkaXVzXG4gICAgICogYXJjLm91dGVyUmFkaXVzKDIwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkFyYywgJ2FuZ2xlJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGFuZ2xlIGluIGRlZ3JlZXNcbiAgICAgKiBAbmFtZSBhbmdsZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQXJjLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgYW5nbGVcbiAgICAgKiB2YXIgYW5nbGUgPSBhcmMuYW5nbGUoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBhbmdsZVxuICAgICAqIGFyYy5hbmdsZSgyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5BcmMsICdjbG9ja3dpc2UnLCBmYWxzZSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGNsb2Nrd2lzZSBmbGFnXG4gICAgICogQG5hbWUgY2xvY2t3aXNlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5BcmMucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjbG9ja3dpc2VcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjbG9ja3dpc2UgZmxhZ1xuICAgICAqIHZhciBjbG9ja3dpc2UgPSBhcmMuY2xvY2t3aXNlKCk7XG4gICAgICpcbiAgICAgKiAvLyBkcmF3IGFyYyBjb3VudGVyLWNsb2Nrd2lzZVxuICAgICAqIGFyYy5jbG9ja3dpc2UoZmFsc2UpO1xuICAgICAqXG4gICAgICogLy8gZHJhdyBhcmMgY2xvY2t3aXNlXG4gICAgICogYXJjLmNsb2Nrd2lzZSh0cnVlKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5BcmMpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBDT05TVEFOVFNcbiAgICB2YXIgSU1BR0UgPSAnSW1hZ2UnO1xuXG4gICAgLyoqXG4gICAgICogSW1hZ2UgY29uc3RydWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtJbWFnZX0gY29uZmlnLmltYWdlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuY3JvcF1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGltYWdlT2JqID0gbmV3IEltYWdlKCk7XG4gICAgICogaW1hZ2VPYmoub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICogICB2YXIgaW1hZ2UgPSBuZXcgS29udmEuSW1hZ2Uoe1xuICAgICAqICAgICB4OiAyMDAsXG4gICAgICogICAgIHk6IDUwLFxuICAgICAqICAgICBpbWFnZTogaW1hZ2VPYmosXG4gICAgICogICAgIHdpZHRoOiAxMDAsXG4gICAgICogICAgIGhlaWdodDogMTAwXG4gICAgICogICB9KTtcbiAgICAgKiB9O1xuICAgICAqIGltYWdlT2JqLnNyYyA9ICcvcGF0aC90by9pbWFnZS5qcGcnXG4gICAgICovXG4gICAgS29udmEuSW1hZ2UgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLkltYWdlLnByb3RvdHlwZSA9IHtcbiAgICAgICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IElNQUdFO1xuICAgICAgICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICAgICAgICAgIHRoaXMuaGl0RnVuYyh0aGlzLl9oaXRGdW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3VzZUJ1ZmZlckNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuaGFzU2hhZG93KCkgfHwgdGhpcy5nZXRBYnNvbHV0ZU9wYWNpdHkoKSAhPT0gMSkgJiYgdGhpcy5oYXNTdHJva2UoKSAmJiB0aGlzLmdldFN0YWdlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpLFxuICAgICAgICAgICAgICAgIGltYWdlID0gdGhpcy5nZXRJbWFnZSgpLFxuICAgICAgICAgICAgICAgIGNyb3BXaWR0aCwgY3JvcEhlaWdodCwgcGFyYW1zO1xuXG4gICAgICAgICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICBjcm9wV2lkdGggPSB0aGlzLmdldENyb3BXaWR0aCgpO1xuICAgICAgICAgICAgICAgIGNyb3BIZWlnaHQgPSB0aGlzLmdldENyb3BIZWlnaHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoY3JvcFdpZHRoICYmIGNyb3BIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gW2ltYWdlLCB0aGlzLmdldENyb3BYKCksIHRoaXMuZ2V0Q3JvcFkoKSwgY3JvcFdpZHRoLCBjcm9wSGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBbaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzRmlsbCgpIHx8IHRoaXMuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZS5hcHBseShjb250ZXh0LCBwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfaGl0RnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IHRoaXMuZ2V0SW1hZ2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJzLndpZHRoIHx8IChpbWFnZSA/IGltYWdlLndpZHRoIDogMCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmdldEltYWdlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRycy5oZWlnaHQgfHwgKGltYWdlID8gaW1hZ2UuaGVpZ2h0IDogMCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkltYWdlLCBLb252YS5TaGFwZSk7XG5cbiAgICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuSW1hZ2UsICdpbWFnZScpO1xuXG4gICAgLyoqXG4gICAgICogc2V0IGltYWdlXG4gICAgICogQG5hbWUgc2V0SW1hZ2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBnZXQgaW1hZ2VcbiAgICAgKiBAbmFtZSBnZXRJbWFnZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuSW1hZ2UucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0ltYWdlfVxuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLkltYWdlLCAnY3JvcCcsIFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCddKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGNyb3BcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG5hbWUgY3JvcFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5JbWFnZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY3JvcFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjcm9wLnhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY3JvcC55XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNyb3Aud2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY3JvcC5oZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNyb3BcbiAgICAgKiB2YXIgY3JvcCA9IGltYWdlLmNyb3AoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBjcm9wXG4gICAgICogaW1hZ2UuY3JvcCh7XG4gICAgICogICB4OiAyMCxcbiAgICAgKiAgIHk6IDIwLFxuICAgICAqICAgd2lkdGg6IDIwLFxuICAgICAqICAgaGVpZ2h0OiAyMFxuICAgICAqIH0pO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuSW1hZ2UsICdjcm9wWCcsIDApO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgY3JvcCB4XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBuYW1lIGNyb3BYXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjcm9wIHhcbiAgICAgKiB2YXIgY3JvcFggPSBpbWFnZS5jcm9wWCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGNyb3AgeFxuICAgICAqIGltYWdlLmNyb3BYKDIwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkltYWdlLCAnY3JvcFknLCAwKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGNyb3AgeVxuICAgICAqIEBuYW1lIGNyb3BZXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5JbWFnZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY3JvcCB5XG4gICAgICogdmFyIGNyb3BZID0gaW1hZ2UuY3JvcFkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBjcm9wIHlcbiAgICAgKiBpbWFnZS5jcm9wWSgyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5JbWFnZSwgJ2Nyb3BXaWR0aCcsIDApO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgY3JvcCB3aWR0aFxuICAgICAqIEBuYW1lIGNyb3BXaWR0aFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuSW1hZ2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjcm9wIHdpZHRoXG4gICAgICogdmFyIGNyb3BXaWR0aCA9IGltYWdlLmNyb3BXaWR0aCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGNyb3Agd2lkdGhcbiAgICAgKiBpbWFnZS5jcm9wV2lkdGgoMjApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuSW1hZ2UsICdjcm9wSGVpZ2h0JywgMCk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBjcm9wIGhlaWdodFxuICAgICAqIEBuYW1lIGNyb3BIZWlnaHRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNyb3AgaGVpZ2h0XG4gICAgICogdmFyIGNyb3BIZWlnaHQgPSBpbWFnZS5jcm9wSGVpZ2h0KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgY3JvcCBoZWlnaHRcbiAgICAgKiBpbWFnZS5jcm9wSGVpZ2h0KDIwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5JbWFnZSk7XG5cbiAgICAvKipcbiAgICAgKiBsb2FkIGltYWdlIGZyb20gZ2l2ZW4gdXJsIGFuZCBjcmVhdGUgYEtvbnZhLkltYWdlYCBpbnN0YW5jZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuSW1hZ2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIGltYWdlIHNvdXJjZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHdpdGggS29udmEuSW1hZ2UgaW5zdGFuY2UgYXMgZmlyc3QgYXJndW1lbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICBLb252YS5JbWFnZS5mcm9tVVJMKGltYWdlVVJMLCBmdW5jdGlvbihpbWFnZSl7XG4gICAgICogICAgLy8gaW1hZ2UgaXMgS29udmEuSW1hZ2UgaW5zdGFuY2VcbiAgICAgKiAgICBsYXllci5hZGQoaW1hZ2UpO1xuICAgICAqICAgIGxheWVyLmRyYXcoKTtcbiAgICAgKiAgfSk7XG4gICAgICovXG4gICAgS29udmEuSW1hZ2UuZnJvbVVSTCA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGltYWdlID0gbmV3IEtvbnZhLkltYWdlKHtcbiAgICAgICAgICAgIGltYWdlOiBpbWdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjYWxsYmFjayhpbWFnZSk7XG4gICAgICAgIH07XG4gICAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgfTtcbn0pKCk7XG5cbi8qZXNsaW50LWRpc2FibGUgbWF4LWRlcHRoICovXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIGNvbnN0YW50c1xuICAgIHZhciBBVVRPID0gJ2F1dG8nLFxuICAgICAgICAvL0NBTlZBUyA9ICdjYW52YXMnLFxuICAgICAgICBDRU5URVIgPSAnY2VudGVyJyxcbiAgICAgICAgQ0hBTkdFX0tPTlZBID0gJ0NoYW5nZS5rb252YScsXG4gICAgICAgIENPTlRFWFRfMkQgPSAnMmQnLFxuICAgICAgICBEQVNIID0gJy0nLFxuICAgICAgICBFTVBUWV9TVFJJTkcgPSAnJyxcbiAgICAgICAgTEVGVCA9ICdsZWZ0JyxcbiAgICAgICAgVEVYVCA9ICd0ZXh0JyxcbiAgICAgICAgVEVYVF9VUFBFUiA9ICdUZXh0JyxcbiAgICAgICAgTUlERExFID0gJ21pZGRsZScsXG4gICAgICAgIE5PUk1BTCA9ICdub3JtYWwnLFxuICAgICAgICBQWF9TUEFDRSA9ICdweCAnLFxuICAgICAgICBTUEFDRSA9ICcgJyxcbiAgICAgICAgUklHSFQgPSAncmlnaHQnLFxuICAgICAgICBXT1JEID0gJ3dvcmQnLFxuICAgICAgICBDSEFSID0gJ2NoYXInLFxuICAgICAgICBOT05FID0gJ25vbmUnLFxuICAgICAgICBBVFRSX0NIQU5HRV9MSVNUID0gWydmb250RmFtaWx5JywgJ2ZvbnRTaXplJywgJ2ZvbnRTdHlsZScsICdmb250VmFyaWFudCcsICdwYWRkaW5nJywgJ2FsaWduJywgJ2xpbmVIZWlnaHQnLCAndGV4dCcsICd3aWR0aCcsICdoZWlnaHQnLCAnd3JhcCddLFxuXG4gICAgICAgIC8vIGNhY2hlZCB2YXJpYWJsZXNcbiAgICAgICAgYXR0ckNoYW5nZUxpc3RMZW4gPSBBVFRSX0NIQU5HRV9MSVNULmxlbmd0aCxcbiAgICAgICAgZHVtbXlDb250ZXh0ID0gS29udmEuVXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCkuZ2V0Q29udGV4dChDT05URVhUXzJEKTtcblxuICAgIC8qKlxuICAgICAqIFRleHQgY29uc3RydWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZm9udEZhbWlseV0gZGVmYXVsdCBpcyBBcmlhbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZvbnRTaXplXSBpbiBwaXhlbHMuICBEZWZhdWx0IGlzIDEyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZm9udFN0eWxlXSBjYW4gYmUgbm9ybWFsLCBib2xkLCBvciBpdGFsaWMuICBEZWZhdWx0IGlzIG5vcm1hbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZvbnRWYXJpYW50XSBjYW4gYmUgbm9ybWFsIG9yIHNtYWxsLWNhcHMuICBEZWZhdWx0IGlzIG5vcm1hbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcudGV4dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmFsaWduXSBjYW4gYmUgbGVmdCwgY2VudGVyLCBvciByaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnBhZGRpbmddXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdIGRlZmF1bHQgaXMgYXV0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF0gZGVmYXVsdCBpcyBhdXRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcubGluZUhlaWdodF0gZGVmYXVsdCBpcyAxXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcud3JhcF0gY2FuIGJlIHdvcmQsIGNoYXIsIG9yIG5vbmUuIERlZmF1bHQgaXMgd29yZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgdGV4dCA9IG5ldyBLb252YS5UZXh0KHtcbiAgICAgKiAgIHg6IDEwLFxuICAgICAqICAgeTogMTUsXG4gICAgICogICB0ZXh0OiAnU2ltcGxlIFRleHQnLFxuICAgICAqICAgZm9udFNpemU6IDMwLFxuICAgICAqICAgZm9udEZhbWlseTogJ0NhbGlicmknLFxuICAgICAqICAgZmlsbDogJ2dyZWVuJ1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIEtvbnZhLlRleHQgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBfZmlsbEZ1bmMoY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHRoaXMucGFydGlhbFRleHQsIDAsIDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfc3Ryb2tlRnVuYyhjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dCh0aGlzLnBhcnRpYWxUZXh0LCAwLCAwKTtcbiAgICB9XG5cbiAgICBLb252YS5UZXh0LnByb3RvdHlwZSA9IHtcbiAgICAgICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG5cbiAgICAgICAgICAgIC8vIHNldCBkZWZhdWx0IGNvbG9yIHRvIGJsYWNrXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzICYmICFjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wcykge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5maWxsID0gY29uZmlnLmZpbGwgfHwgJ2JsYWNrJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbmZpZy53aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLndpZHRoID0gQVVUTztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcuaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuaGVpZ2h0ID0gQVVUTztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuXG4gICAgICAgICAgICB0aGlzLl9maWxsRnVuYyA9IF9maWxsRnVuYztcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZUZ1bmMgPSBfc3Ryb2tlRnVuYztcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gVEVYVF9VUFBFUjtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHRleHQgZGF0YSBmb3IgY2VydGFpbiBhdHRyIGNoYW5nZXNcbiAgICAgICAgICAgIGZvcih2YXIgbiA9IDA7IG4gPCBhdHRyQ2hhbmdlTGlzdExlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbihBVFRSX0NIQU5HRV9MSVNUW25dICsgQ0hBTkdFX0tPTlZBLCB0aGlzLl9zZXRUZXh0RGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3NldFRleHREYXRhKCk7XG4gICAgICAgICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgICAgICAgICAgdGhpcy5oaXRGdW5jKHRoaXMuX2hpdEZ1bmMpO1xuICAgICAgICB9LFxuICAgICAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMuZ2V0UGFkZGluZygpLFxuICAgICAgICAgICAgICAgIHRleHRIZWlnaHQgPSB0aGlzLmdldFRleHRIZWlnaHQoKSxcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0UHggPSB0aGlzLmdldExpbmVIZWlnaHQoKSAqIHRleHRIZWlnaHQsXG4gICAgICAgICAgICAgICAgdGV4dEFyciA9IHRoaXMudGV4dEFycixcbiAgICAgICAgICAgICAgICB0ZXh0QXJyTGVuID0gdGV4dEFyci5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdG90YWxXaWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICBuO1xuXG4gICAgICAgICAgICBjb250ZXh0LnNldEF0dHIoJ2ZvbnQnLCB0aGlzLl9nZXRDb250ZXh0Rm9udCgpKTtcblxuICAgICAgICAgICAgY29udGV4dC5zZXRBdHRyKCd0ZXh0QmFzZWxpbmUnLCBNSURETEUpO1xuICAgICAgICAgICAgY29udGV4dC5zZXRBdHRyKCd0ZXh0QWxpZ24nLCBMRUZUKTtcbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShwLCAwKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgwLCBwICsgdGV4dEhlaWdodCAvIDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgwLCB0ZXh0SGVpZ2h0IC8gMik7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLy8gZHJhdyB0ZXh0IGxpbmVzXG4gICAgICAgICAgICBmb3IobiA9IDA7IG4gPCB0ZXh0QXJyTGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gdGV4dEFycltuXSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IG9iai50ZXh0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IG9iai53aWR0aDtcblxuICAgICAgICAgICAgICAgIC8vIGhvcml6b250YWwgYWxpZ25tZW50XG4gICAgICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5nZXRBbGlnbigpID09PSBSSUdIVCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSh0b3RhbFdpZHRoIC0gd2lkdGggLSBwICogMiwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYodGhpcy5nZXRBbGlnbigpID09PSBDRU5URVIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoKHRvdGFsV2lkdGggLSB3aWR0aCAtIHAgKiAyKSAvIDIsIDApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucGFydGlhbFRleHQgPSB0ZXh0O1xuXG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoMCwgbGluZUhlaWdodFB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9LFxuICAgICAgICBfaGl0RnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSBLb252YS5VdGlsLl9pc1N0cmluZyh0ZXh0KSA/IHRleHQgOiB0ZXh0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLl9zZXRBdHRyKFRFWFQsIHN0cik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCB3aWR0aCBvZiB0ZXh0IGFyZWEsIHdoaWNoIGluY2x1ZGVzIHBhZGRpbmdcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJzLndpZHRoID09PSBBVVRPID8gdGhpcy5nZXRUZXh0V2lkdGgoKSArIHRoaXMuZ2V0UGFkZGluZygpICogMiA6IHRoaXMuYXR0cnMud2lkdGg7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgdGhlIGhlaWdodCBvZiB0aGUgdGV4dCBhcmVhLCB3aGljaCB0YWtlcyBpbnRvIGFjY291bnQgbXVsdGktbGluZSB0ZXh0LCBsaW5lIGhlaWdodHMsIGFuZCBwYWRkaW5nXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cnMuaGVpZ2h0ID09PSBBVVRPID8gKHRoaXMuZ2V0VGV4dEhlaWdodCgpICogdGhpcy50ZXh0QXJyLmxlbmd0aCAqIHRoaXMuZ2V0TGluZUhlaWdodCgpKSArIHRoaXMuZ2V0UGFkZGluZygpICogMiA6IHRoaXMuYXR0cnMuaGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IHRleHQgd2lkdGhcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRleHRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0V2lkdGg7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgdGV4dCBoZWlnaHRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRleHRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dEhlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldFRleHRTaXplOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICB2YXIgX2NvbnRleHQgPSBkdW1teUNvbnRleHQsXG4gICAgICAgICAgICAgICAgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCksXG4gICAgICAgICAgICAgICAgbWV0cmljcztcblxuICAgICAgICAgICAgX2NvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgX2NvbnRleHQuZm9udCA9IHRoaXMuX2dldENvbnRleHRGb250KCk7XG5cbiAgICAgICAgICAgIG1ldHJpY3MgPSBfY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICAgICAgICAgIF9jb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IG1ldHJpY3Mud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBwYXJzZUludChmb250U2l6ZSwgMTApXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0Q29udGV4dEZvbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rm9udFN0eWxlKCkgKyBTUEFDRSArIHRoaXMuZ2V0Rm9udFZhcmlhbnQoKSArIFNQQUNFICsgdGhpcy5nZXRGb250U2l6ZSgpICsgUFhfU1BBQ0UgKyB0aGlzLmdldEZvbnRGYW1pbHkoKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2FkZFRleHRMaW5lOiBmdW5jdGlvbiAobGluZSwgd2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHRBcnIucHVzaCh7dGV4dDogbGluZSwgd2lkdGg6IHdpZHRofSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRUZXh0V2lkdGg6IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZHVtbXlDb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgICAgICB9LFxuICAgICAgICBfc2V0VGV4dERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IHRoaXMuZ2V0VGV4dCgpLnNwbGl0KCdcXG4nKSxcbiAgICAgICAgICAgICAgICBmb250U2l6ZSA9ICt0aGlzLmdldEZvbnRTaXplKCksXG4gICAgICAgICAgICAgICAgdGV4dFdpZHRoID0gMCxcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0UHggPSB0aGlzLmdldExpbmVIZWlnaHQoKSAqIGZvbnRTaXplLFxuICAgICAgICAgICAgICAgIHdpZHRoID0gdGhpcy5hdHRycy53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmF0dHJzLmhlaWdodCxcbiAgICAgICAgICAgICAgICBmaXhlZFdpZHRoID0gd2lkdGggIT09IEFVVE8sXG4gICAgICAgICAgICAgICAgZml4ZWRIZWlnaHQgPSBoZWlnaHQgIT09IEFVVE8sXG4gICAgICAgICAgICAgICAgcGFkZGluZyA9IHRoaXMuZ2V0UGFkZGluZygpLFxuICAgICAgICAgICAgICAgIG1heFdpZHRoID0gd2lkdGggLSBwYWRkaW5nICogMixcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHRQeCA9IGhlaWdodCAtIHBhZGRpbmcgKiAyLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRIZWlnaHRQeCA9IDAsXG4gICAgICAgICAgICAgICAgd3JhcCA9IHRoaXMuZ2V0V3JhcCgpLFxuICAgICAgICAgICAgICAgIHNob3VsZFdyYXAgPSB3cmFwICE9PSBOT05FLFxuICAgICAgICAgICAgICAgIHdyYXBBdFdvcmQgPSB3cmFwICE9PSBDSEFSICYmIHNob3VsZFdyYXA7XG5cbiAgICAgICAgICAgIHRoaXMudGV4dEFyciA9IFtdO1xuICAgICAgICAgICAgZHVtbXlDb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIGR1bW15Q29udGV4dC5mb250ID0gdGhpcy5fZ2V0Q29udGV4dEZvbnQoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBtYXggPSBsaW5lcy5sZW5ndGg7IGkgPCBtYXg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gbGluZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCA9IHRoaXMuX2dldFRleHRXaWR0aChsaW5lKTtcbiAgICAgICAgICAgICAgICBpZiAoZml4ZWRXaWR0aCAmJiBsaW5lV2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiBpZiB3aWR0aCBpcyBmaXhlZCBhbmQgbGluZSBkb2VzIG5vdCBmaXQgZW50aXJlbHlcbiAgICAgICAgICAgICAgICAgICAgICogYnJlYWsgdGhlIGxpbmUgaW50byBtdWx0aXBsZSBmaXR0aW5nIGxpbmVzXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobGluZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogdXNlIGJpbmFyeSBzZWFyY2ggdG8gZmluZCB0aGUgbG9uZ2VzdCBzdWJzdHJpbmcgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICogdGhhdCB3b3VsZCBmaXQgaW4gdGhlIHNwZWNpZmllZCB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGxpbmUubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gJycsIG1hdGNoV2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzdHIgPSBsaW5lLnNsaWNlKDAsIG1pZCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzdHJXaWR0aCA9IHRoaXMuX2dldFRleHRXaWR0aChzdWJzdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJzdHJXaWR0aCA8PSBtYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHN1YnN0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hXaWR0aCA9IHN1YnN0cldpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICdsb3cnIGlzIG5vdyB0aGUgaW5kZXggb2YgdGhlIHN1YnN0cmluZyBlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICdtYXRjaCcgaXMgdGhlIHN1YnN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICogJ21hdGNoV2lkdGgnIGlzIHRoZSBzdWJzdHJpbmcgd2lkdGggaW4gcHhcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBmaXR0aW5nIHN1YnN0cmluZyB3YXMgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod3JhcEF0V29yZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdG8gZmluZCBhIHNwYWNlIG9yIGRhc2ggd2hlcmUgd3JhcHBpbmcgY291bGQgYmUgZG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcEluZGV4ID0gTWF0aC5tYXgobWF0Y2gubGFzdEluZGV4T2YoU1BBQ0UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLmxhc3RJbmRleE9mKERBU0gpKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3cmFwSW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZS1jdXQgdGhlIHN1YnN0cmluZyBmb3VuZCBhdCB0aGUgc3BhY2UvZGFzaCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ID0gd3JhcEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaC5zbGljZSgwLCBsb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hXaWR0aCA9IHRoaXMuX2dldFRleHRXaWR0aChtYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVGV4dExpbmUobWF0Y2gsIG1hdGNoV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRXaWR0aCA9IE1hdGgubWF4KHRleHRXaWR0aCwgbWF0Y2hXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEhlaWdodFB4ICs9IGxpbmVIZWlnaHRQeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFdyYXAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZpeGVkSGVpZ2h0ICYmIGN1cnJlbnRIZWlnaHRQeCArIGxpbmVIZWlnaHRQeCA+IG1heEhlaWdodFB4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBzdG9wIHdyYXBwaW5nIGlmIHdyYXBwaW5nIGlzIGRpc2FibGVkIG9yIGlmIGFkZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBvbmUgbW9yZSBsaW5lIHdvdWxkIG92ZXJmbG93IHRoZSBmaXhlZCBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZShsb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJlbWFpbmluZyB0ZXh0IHdvdWxkIGZpdCBvbiBvbmUgbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSB0aGlzLl9nZXRUZXh0V2lkdGgobGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPD0gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0IGRvZXMsIGFkZCB0aGUgbGluZSBhbmQgYnJlYWsgb3V0IG9mIHRoZSBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRUZXh0TGluZShsaW5lLCBsaW5lV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEhlaWdodFB4ICs9IGxpbmVIZWlnaHRQeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRXaWR0aCA9IE1hdGgubWF4KHRleHRXaWR0aCwgbGluZVdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3QgZXZlbiBvbmUgY2hhcmFjdGVyIGNvdWxkIGZpdCBpbiB0aGUgZWxlbWVudCwgYWJvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgd2lkdGggaXMgYXV0b21hdGljYWxseSBhZGp1c3RlZCB0byBtYXggbGluZSB3aWR0aFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRUZXh0TGluZShsaW5lLCBsaW5lV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50SGVpZ2h0UHggKz0gbGluZUhlaWdodFB4O1xuICAgICAgICAgICAgICAgICAgICB0ZXh0V2lkdGggPSBNYXRoLm1heCh0ZXh0V2lkdGgsIGxpbmVXaWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIGVsZW1lbnQgaGVpZ2h0IGlzIGZpeGVkLCBhYm9ydCBpZiBhZGRpbmcgb25lIG1vcmUgbGluZSB3b3VsZCBvdmVyZmxvd1xuICAgICAgICAgICAgICAgIGlmIChmaXhlZEhlaWdodCAmJiBjdXJyZW50SGVpZ2h0UHggKyBsaW5lSGVpZ2h0UHggPiBtYXhIZWlnaHRQeCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkdW1teUNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgdGhpcy50ZXh0SGVpZ2h0ID0gZm9udFNpemU7XG4gICAgICAgICAgICB0aGlzLnRleHRXaWR0aCA9IHRleHRXaWR0aDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuVGV4dCwgS29udmEuU2hhcGUpO1xuXG4gICAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICdmb250RmFtaWx5JywgJ0FyaWFsJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZvbnQgZmFtaWx5XG4gICAgICogQG5hbWUgZm9udEZhbWlseVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZm9udEZhbWlseVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZm9udCBmYW1pbHlcbiAgICAgKiB2YXIgZm9udEZhbWlseSA9IHRleHQuZm9udEZhbWlseSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZvbnQgZmFtaWx5XG4gICAgICogdGV4dC5mb250RmFtaWx5KCdBcmlhbCcpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ2ZvbnRTaXplJywgMTIpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmb250IHNpemUgaW4gcGl4ZWxzXG4gICAgICogQG5hbWUgZm9udFNpemVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZvbnRTaXplXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmb250IHNpemVcbiAgICAgKiB2YXIgZm9udFNpemUgPSB0ZXh0LmZvbnRTaXplKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZm9udCBzaXplIHRvIDIycHhcbiAgICAgKiB0ZXh0LmZvbnRTaXplKDIyKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICdmb250U3R5bGUnLCBOT1JNQUwpO1xuXG4gICAgLyoqXG4gICAgICogc2V0IGZvbnQgc3R5bGUuICBDYW4gYmUgJ25vcm1hbCcsICdpdGFsaWMnLCBvciAnYm9sZCcuICAnbm9ybWFsJyBpcyB0aGUgZGVmYXVsdC5cbiAgICAgKiBAbmFtZSBmb250U3R5bGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvbnRTdHlsZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZm9udCBzdHlsZVxuICAgICAqIHZhciBmb250U3R5bGUgPSB0ZXh0LmZvbnRTdHlsZSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZvbnQgc3R5bGVcbiAgICAgKiB0ZXh0LmZvbnRTdHlsZSgnYm9sZCcpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ2ZvbnRWYXJpYW50JywgTk9STUFMKTtcblxuICAgIC8qKlxuICAgICAqIHNldCBmb250IHZhcmlhbnQuICBDYW4gYmUgJ25vcm1hbCcgb3IgJ3NtYWxsLWNhcHMnLiAgJ25vcm1hbCcgaXMgdGhlIGRlZmF1bHQuXG4gICAgICogQG5hbWUgZm9udFZhcmlhbnRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvbnRWYXJpYW50XG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmb250IHZhcmlhbnRcbiAgICAgKiB2YXIgZm9udFZhcmlhbnQgPSB0ZXh0LmZvbnRWYXJpYW50KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZm9udCB2YXJpYW50XG4gICAgICogdGV4dC5mb250VmFyaWFudCgnc21hbGwtY2FwcycpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ3BhZGRpbmcnLCAwKTtcblxuICAgIC8qKlxuICAgICAqIHNldCBwYWRkaW5nXG4gICAgICogQG5hbWUgcGFkZGluZ1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcGFkZGluZ1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgcGFkZGluZ1xuICAgICAqIHZhciBwYWRkaW5nID0gdGV4dC5wYWRkaW5nKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgcGFkZGluZyB0byAxMCBwaXhlbHNcbiAgICAgKiB0ZXh0LnBhZGRpbmcoMTApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ2FsaWduJywgTEVGVCk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGhvcml6b250YWwgYWxpZ24gb2YgdGV4dC4gIENhbiBiZSAnbGVmdCcsICdjZW50ZXInLCBvciAncmlnaHQnXG4gICAgICogQG5hbWUgYWxpZ25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFsaWduXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCB0ZXh0IGFsaWduXG4gICAgICogdmFyIGFsaWduID0gdGV4dC5hbGlnbigpO1xuICAgICAqXG4gICAgICogLy8gY2VudGVyIHRleHRcbiAgICAgKiB0ZXh0LmFsaWduKCdjZW50ZXInKTtcbiAgICAgKlxuICAgICAqIC8vIGFsaWduIHRleHQgdG8gcmlnaHRcbiAgICAgKiB0ZXh0LmFsaWduKCdyaWdodCcpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ2xpbmVIZWlnaHQnLCAxKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgbGluZSBoZWlnaHQuICBUaGUgZGVmYXVsdCBpcyAxLlxuICAgICAqIEBuYW1lIGxpbmVIZWlnaHRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVIZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGxpbmUgaGVpZ2h0XG4gICAgICogdmFyIGxpbmVIZWlnaHQgPSB0ZXh0LmxpbmVIZWlnaHQoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCB0aGUgbGluZSBoZWlnaHRcbiAgICAgKiB0ZXh0LmxpbmVIZWlnaHQoMik7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0LCAnd3JhcCcsIFdPUkQpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCB3cmFwLiAgQ2FuIGJlIHdvcmQsIGNoYXIsIG9yIG5vbmUuIERlZmF1bHQgaXMgd29yZC5cbiAgICAgKiBAbmFtZSB3cmFwXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB3cmFwXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCB3cmFwXG4gICAgICogdmFyIHdyYXAgPSB0ZXh0LndyYXAoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCB3cmFwXG4gICAgICogdGV4dC53cmFwKCd3b3JkJyk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlcihLb252YS5UZXh0LCAndGV4dCcsIEVNUFRZX1NUUklORyk7XG4gICAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICd0ZXh0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHRleHRcbiAgICAgKiBAbmFtZSBnZXRUZXh0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCB0ZXh0XG4gICAgICogdmFyIHRleHQgPSB0ZXh0LnRleHQoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCB0ZXh0XG4gICAgICogdGV4dC50ZXh0KCdIZWxsbyB3b3JsZCEnKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5UZXh0KTtcbn0pKCk7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qKlxuICAgICAqIExpbmUgY29uc3RydWN0b3IuJm5ic3A7IExpbmVzIGFyZSBkZWZpbmVkIGJ5IGFuIGFycmF5IG9mIHBvaW50cyBhbmRcbiAgICAgKiAgYSB0ZW5zaW9uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZy5wb2ludHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy50ZW5zaW9uXSBIaWdoZXIgdmFsdWVzIHdpbGwgcmVzdWx0IGluIGEgbW9yZSBjdXJ2eSBsaW5lLiAgQSB2YWx1ZSBvZiAwIHdpbGwgcmVzdWx0IGluIG5vIGludGVycG9sYXRpb24uXG4gICAgICogICBUaGUgZGVmYXVsdCBpcyAwXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmNsb3NlZF0gZGVmaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgbGluZSBzaGFwZSBpcyBjbG9zZWQsIGNyZWF0aW5nIGEgcG9seWdvbiBvciBibG9iXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBsaW5lID0gbmV3IEtvbnZhLkxpbmUoe1xuICAgICAqICAgeDogMTAwLFxuICAgICAqICAgeTogNTAsXG4gICAgICogICBwb2ludHM6IFs3MywgNzAsIDM0MCwgMjMsIDQ1MCwgNjAsIDUwMCwgMjBdLFxuICAgICAqICAgc3Ryb2tlOiAncmVkJyxcbiAgICAgKiAgIHRlbnNpb246IDFcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBLb252YS5MaW5lID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgICB9O1xuXG4gICAgS29udmEuTGluZS5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ0xpbmUnO1xuXG4gICAgICAgICAgICB0aGlzLm9uKCdwb2ludHNDaGFuZ2Uua29udmEgdGVuc2lvbkNoYW5nZS5rb252YSBjbG9zZWRDaGFuZ2Uua29udmEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJDYWNoZSgndGVuc2lvblBvaW50cycpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5nZXRQb2ludHMoKSxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBwb2ludHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHRlbnNpb24gPSB0aGlzLmdldFRlbnNpb24oKSxcbiAgICAgICAgICAgICAgICBjbG9zZWQgPSB0aGlzLmdldENsb3NlZCgpLFxuICAgICAgICAgICAgICAgIHRwLCBsZW4sIG47XG5cbiAgICAgICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuXG4gICAgICAgICAgICAvLyB0ZW5zaW9uXG4gICAgICAgICAgICBpZiAodGVuc2lvbiAhPT0gMCAmJiBsZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAgICAgdHAgPSB0aGlzLmdldFRlbnNpb25Qb2ludHMoKTtcbiAgICAgICAgICAgICAgICBsZW4gPSB0cC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbiA9IGNsb3NlZCA/IDAgOiA0O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHRwWzBdLCB0cFsxXSwgdHBbMl0sIHRwWzNdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAobiA8IGxlbiAtIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHRwW24rK10sIHRwW24rK10sIHRwW24rK10sIHRwW24rK10sIHRwW24rK10sIHRwW24rK10pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh0cFtsZW4gLSAyXSwgdHBbbGVuIC0gMV0sIHBvaW50c1tsZW5ndGggLSAyXSwgcG9pbnRzW2xlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBubyB0ZW5zaW9uXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKG4gPSAyOyBuIDwgbGVuZ3RoOyBuICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRzW25dLCBwb2ludHNbbiArIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNsb3NlZCBlLmcuIHBvbHlnb25zIGFuZCBibG9ic1xuICAgICAgICAgICAgaWYgKGNsb3NlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvcGVuIGUuZy4gbGluZXMgYW5kIHNwbGluZXNcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldFRlbnNpb25Qb2ludHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZSgndGVuc2lvblBvaW50cycsIHRoaXMuX2dldFRlbnNpb25Qb2ludHMpO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0VGVuc2lvblBvaW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Q2xvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VGVuc2lvblBvaW50c0Nsb3NlZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gS29udmEuVXRpbC5fZXhwYW5kUG9pbnRzKHRoaXMuZ2V0UG9pbnRzKCksIHRoaXMuZ2V0VGVuc2lvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2dldFRlbnNpb25Qb2ludHNDbG9zZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5nZXRQb2ludHMoKSxcbiAgICAgICAgICAgICAgICBsZW4gPSBwLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB0ZW5zaW9uID0gdGhpcy5nZXRUZW5zaW9uKCksXG4gICAgICAgICAgICAgICAgdXRpbCA9IEtvbnZhLlV0aWwsXG4gICAgICAgICAgICAgICAgZmlyc3RDb250cm9sUG9pbnRzID0gdXRpbC5fZ2V0Q29udHJvbFBvaW50cyhcbiAgICAgICAgICAgICAgICAgICAgcFtsZW4gLSAyXSxcbiAgICAgICAgICAgICAgICAgICAgcFtsZW4gLSAxXSxcbiAgICAgICAgICAgICAgICAgICAgcFswXSxcbiAgICAgICAgICAgICAgICAgICAgcFsxXSxcbiAgICAgICAgICAgICAgICAgICAgcFsyXSxcbiAgICAgICAgICAgICAgICAgICAgcFszXSxcbiAgICAgICAgICAgICAgICAgICAgdGVuc2lvblxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbGFzdENvbnRyb2xQb2ludHMgPSB1dGlsLl9nZXRDb250cm9sUG9pbnRzKFxuICAgICAgICAgICAgICAgICAgICBwW2xlbiAtIDRdLFxuICAgICAgICAgICAgICAgICAgICBwW2xlbiAtIDNdLFxuICAgICAgICAgICAgICAgICAgICBwW2xlbiAtIDJdLFxuICAgICAgICAgICAgICAgICAgICBwW2xlbiAtIDFdLFxuICAgICAgICAgICAgICAgICAgICBwWzBdLFxuICAgICAgICAgICAgICAgICAgICBwWzFdLFxuICAgICAgICAgICAgICAgICAgICB0ZW5zaW9uXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBtaWRkbGUgPSBLb252YS5VdGlsLl9leHBhbmRQb2ludHMocCwgdGVuc2lvbiksXG4gICAgICAgICAgICAgICAgdHAgPSBbXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Q29udHJvbFBvaW50c1syXSxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RDb250cm9sUG9pbnRzWzNdXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIC5jb25jYXQobWlkZGxlKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoW1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q29udHJvbFBvaW50c1swXSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbnRyb2xQb2ludHNbMV0sXG4gICAgICAgICAgICAgICAgICAgIHBbbGVuIC0gMl0sXG4gICAgICAgICAgICAgICAgICAgIHBbbGVuIC0gMV0sXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250cm9sUG9pbnRzWzJdLFxuICAgICAgICAgICAgICAgICAgICBsYXN0Q29udHJvbFBvaW50c1szXSxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RDb250cm9sUG9pbnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICBmaXJzdENvbnRyb2xQb2ludHNbMV0sXG4gICAgICAgICAgICAgICAgICAgIHBbMF0sXG4gICAgICAgICAgICAgICAgICAgIHBbMV1cbiAgICAgICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRwO1xuICAgICAgICB9LFxuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VsZlJlY3QoKS53aWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWxmUmVjdCgpLmhlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gb3ZlcmxvYWQgc2l6ZSBkZXRlY3Rpb25cbiAgICAgICAgZ2V0U2VsZlJlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwb2ludHM7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRUZW5zaW9uKCkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBwb2ludHMgPSB0aGlzLl9nZXRUZW5zaW9uUG9pbnRzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWluWCA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIHZhciBtYXhYID0gcG9pbnRzWzBdO1xuICAgICAgICAgICAgdmFyIG1pblkgPSBwb2ludHNbMV07XG4gICAgICAgICAgICB2YXIgbWF4WSA9IHBvaW50c1sxXTtcbiAgICAgICAgICAgIHZhciB4LCB5O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeCA9IHBvaW50c1tpICogMl07XG4gICAgICAgICAgICAgICAgeSA9IHBvaW50c1tpICogMiArIDFdO1xuICAgICAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcbiAgICAgICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XG4gICAgICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuICAgICAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogTWF0aC5yb3VuZChtaW5YKSxcbiAgICAgICAgICAgICAgICB5OiBNYXRoLnJvdW5kKG1pblkpLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKG1heFggLSBtaW5YKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQobWF4WSAtIG1pblkpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5MaW5lLCBLb252YS5TaGFwZSk7XG5cbiAgICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTGluZSwgJ2Nsb3NlZCcsIGZhbHNlKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgY2xvc2VkIGZsYWcuICBUaGUgZGVmYXVsdCBpcyBmYWxzZVxuICAgICAqIEBuYW1lIGNsb3NlZFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTGluZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNsb3NlZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNsb3NlZCBmbGFnXG4gICAgICogdmFyIGNsb3NlZCA9IGxpbmUuY2xvc2VkKCk7XG4gICAgICpcbiAgICAgKiAvLyBjbG9zZSB0aGUgc2hhcGVcbiAgICAgKiBsaW5lLmNsb3NlZCh0cnVlKTtcbiAgICAgKlxuICAgICAqIC8vIG9wZW4gdGhlIHNoYXBlXG4gICAgICogbGluZS5jbG9zZWQoZmFsc2UpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTGluZSwgJ3RlbnNpb24nLCAwKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgdGVuc2lvblxuICAgICAqIEBuYW1lIHRlbnNpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkxpbmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IEhpZ2hlciB2YWx1ZXMgd2lsbCByZXN1bHQgaW4gYSBtb3JlIGN1cnZ5IGxpbmUuICBBIHZhbHVlIG9mIDAgd2lsbCByZXN1bHQgaW4gbm8gaW50ZXJwb2xhdGlvbi5cbiAgICAgKiAgIFRoZSBkZWZhdWx0IGlzIDBcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHRlbnNpb25cbiAgICAgKiB2YXIgdGVuc2lvbiA9IGxpbmUudGVuc2lvbigpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHRlbnNpb25cbiAgICAgKiBsaW5lLnRlbnNpb24oMyk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5MaW5lLCAncG9pbnRzJywgW10pO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgcG9pbnRzIGFycmF5XG4gICAgICogQG5hbWUgcG9pbnRzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5MaW5lLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50c1xuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBwb2ludHNcbiAgICAgKiB2YXIgcG9pbnRzID0gbGluZS5wb2ludHMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBwb2ludHNcbiAgICAgKiBsaW5lLnBvaW50cyhbMTAsIDIwLCAzMCwgNDAsIDUwLCA2MF0pO1xuICAgICAqXG4gICAgICogLy8gcHVzaCBhIG5ldyBwb2ludFxuICAgICAqIGxpbmUucG9pbnRzKGxpbmUucG9pbnRzKCkuY29uY2F0KFs3MCwgODBdKSk7XG4gICAgICovXG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuTGluZSk7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qKlxuICAgICAqIFNwcml0ZSBjb25zdHJ1Y3RvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmFuaW1hdGlvbiBhbmltYXRpb24ga2V5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZy5hbmltYXRpb25zIGFuaW1hdGlvbiBtYXBcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IFtjb25maWcuZnJhbWVJbmRleF0gYW5pbWF0aW9uIGZyYW1lIGluZGV4XG4gICAgICogQHBhcmFtIHtJbWFnZX0gY29uZmlnLmltYWdlIGltYWdlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgaW1hZ2VPYmogPSBuZXcgSW1hZ2UoKTtcbiAgICAgKiBpbWFnZU9iai5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgKiAgIHZhciBzcHJpdGUgPSBuZXcgS29udmEuU3ByaXRlKHtcbiAgICAgKiAgICAgeDogMjAwLFxuICAgICAqICAgICB5OiAxMDAsXG4gICAgICogICAgIGltYWdlOiBpbWFnZU9iaixcbiAgICAgKiAgICAgYW5pbWF0aW9uOiAnc3RhbmRpbmcnLFxuICAgICAqICAgICBhbmltYXRpb25zOiB7XG4gICAgICogICAgICAgc3RhbmRpbmc6IFtcbiAgICAgKiAgICAgICAgIC8vIHgsIHksIHdpZHRoLCBoZWlnaHQgKDYgZnJhbWVzKVxuICAgICAqICAgICAgICAgMCwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgICAgIDUyLCAwLCA0OSwgMTA5LFxuICAgICAqICAgICAgICAgMTA1LCAwLCA0OSwgMTA5LFxuICAgICAqICAgICAgICAgMTU4LCAwLCA0OSwgMTA5LFxuICAgICAqICAgICAgICAgMjEwLCAwLCA0OSwgMTA5LFxuICAgICAqICAgICAgICAgMjYyLCAwLCA0OSwgMTA5XG4gICAgICogICAgICAgXSxcbiAgICAgKiAgICAgICBraWNraW5nOiBbXG4gICAgICogICAgICAgICAvLyB4LCB5LCB3aWR0aCwgaGVpZ2h0ICg2IGZyYW1lcylcbiAgICAgKiAgICAgICAgIDAsIDEwOSwgNDUsIDk4LFxuICAgICAqICAgICAgICAgNDUsIDEwOSwgNDUsIDk4LFxuICAgICAqICAgICAgICAgOTUsIDEwOSwgNjMsIDk4LFxuICAgICAqICAgICAgICAgMTU2LCAxMDksIDcwLCA5OCxcbiAgICAgKiAgICAgICAgIDIyOSwgMTA5LCA2MCwgOTgsXG4gICAgICogICAgICAgICAyODcsIDEwOSwgNDEsIDk4XG4gICAgICogICAgICAgXVxuICAgICAqICAgICB9LFxuICAgICAqICAgICBmcmFtZVJhdGU6IDcsXG4gICAgICogICAgIGZyYW1lSW5kZXg6IDBcbiAgICAgKiAgIH0pO1xuICAgICAqIH07XG4gICAgICogaW1hZ2VPYmouc3JjID0gJy9wYXRoL3RvL2ltYWdlLmpwZydcbiAgICAgKi9cbiAgICBLb252YS5TcHJpdGUgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLlNwcml0ZS5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAnU3ByaXRlJztcblxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmFuaW0gPSBuZXcgS29udmEuQW5pbWF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGRvbid0IG5lZWQgdG8gcmVkcmF3IGxheWVyIHdlIHNob3VsZCByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlZCA9IHRoYXQuX3VwZGF0ZWQ7XG4gICAgICAgICAgICAgICAgdGhhdC5fdXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm9uKCdhbmltYXRpb25DaGFuZ2Uua29udmEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyByZXNldCBpbmRleCB3aGVuIGFuaW1hdGlvbiBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZUluZGV4KDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm9uKCdmcmFtZUluZGV4Q2hhbmdlLmtvbnZhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHNtb290aCBjaGFuZ2UgZm9yIGZyYW1lUmF0ZVxuICAgICAgICAgICAgdGhpcy5vbignZnJhbWVSYXRlQ2hhbmdlLmtvbnZhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFuaW0uaXNSdW5uaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEludGVydmFsKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICAgICAgICAgIHRoaXMuaGl0RnVuYyh0aGlzLl9oaXRGdW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGFuaW0gPSB0aGlzLmdldEFuaW1hdGlvbigpLFxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5mcmFtZUluZGV4KCksXG4gICAgICAgICAgICAgICAgaXg0ID0gaW5kZXggKiA0LFxuICAgICAgICAgICAgICAgIHNldCA9IHRoaXMuZ2V0QW5pbWF0aW9ucygpW2FuaW1dLFxuICAgICAgICAgICAgICAgIG9mZnNldHMgPSB0aGlzLmZyYW1lT2Zmc2V0cygpLFxuICAgICAgICAgICAgICAgIHggPSBzZXRbaXg0ICsgMF0sXG4gICAgICAgICAgICAgICAgeSA9IHNldFtpeDQgKyAxXSxcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHNldFtpeDQgKyAyXSxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBzZXRbaXg0ICsgM10sXG4gICAgICAgICAgICAgICAgaW1hZ2UgPSB0aGlzLmdldEltYWdlKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0ZpbGwoKSB8fCB0aGlzLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0c1thbmltXSxcbiAgICAgICAgICAgICAgICAgICAgaXgyID0gaW5kZXggKiAyO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgb2Zmc2V0W2l4MiArIDBdLCBvZmZzZXRbaXgyICsgMV0sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9oaXRGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgYW5pbSA9IHRoaXMuZ2V0QW5pbWF0aW9uKCksXG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLmZyYW1lSW5kZXgoKSxcbiAgICAgICAgICAgICAgICBpeDQgPSBpbmRleCAqIDQsXG4gICAgICAgICAgICAgICAgc2V0ID0gdGhpcy5nZXRBbmltYXRpb25zKClbYW5pbV0sXG4gICAgICAgICAgICAgICAgb2Zmc2V0cyA9IHRoaXMuZnJhbWVPZmZzZXRzKCksXG4gICAgICAgICAgICAgICAgd2lkdGggPSBzZXRbaXg0ICsgMl0sXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gc2V0W2l4NCArIDNdO1xuXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgaWYgKG9mZnNldHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0c1thbmltXTtcbiAgICAgICAgICAgICAgICB2YXIgaXgyID0gaW5kZXggKiAyO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVjdChvZmZzZXRbaXgyICsgMF0sIG9mZnNldFtpeDIgKyAxXSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTaGFwZSh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3VzZUJ1ZmZlckNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuaGFzU2hhZG93KCkgfHwgdGhpcy5nZXRBYnNvbHV0ZU9wYWNpdHkoKSAhPT0gMSkgJiYgdGhpcy5oYXNTdHJva2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NldEludGVydmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll91cGRhdGVJbmRleCgpO1xuICAgICAgICAgICAgfSwgMTAwMCAvIHRoaXMuZ2V0RnJhbWVSYXRlKCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogc3RhcnQgc3ByaXRlIGFuaW1hdGlvblxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TcHJpdGUucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBhbmltYXRpb24gb2JqZWN0IGhhcyBubyBleGVjdXRhYmxlIGZ1bmN0aW9uIGJlY2F1c2VcbiAgICAgICAgICAgICAqICB0aGUgdXBkYXRlcyBhcmUgZG9uZSB3aXRoIGEgZml4ZWQgRlBTIHdpdGggdGhlIHNldEludGVydmFsXG4gICAgICAgICAgICAgKiAgYmVsb3cuICBUaGUgYW5pbSBvYmplY3Qgb25seSBuZWVkcyB0aGUgbGF5ZXIgcmVmZXJlbmNlIGZvclxuICAgICAgICAgICAgICogIHJlZHJhd1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmFuaW0uc2V0TGF5ZXJzKGxheWVyKTtcbiAgICAgICAgICAgIHRoaXMuX3NldEludGVydmFsKCk7XG4gICAgICAgICAgICB0aGlzLmFuaW0uc3RhcnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHN0b3Agc3ByaXRlIGFuaW1hdGlvblxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TcHJpdGUucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbS5zdG9wKCk7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZGV0ZXJtaW5lIGlmIGFuaW1hdGlvbiBvZiBzcHJpdGUgaXMgcnVubmluZyBvciBub3QuICByZXR1cm5zIHRydWUgb3IgZmFsc2VcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGlzUnVubmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltLmlzUnVubmluZygpO1xuICAgICAgICB9LFxuICAgICAgICBfdXBkYXRlSW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5mcmFtZUluZGV4KCksXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uID0gdGhpcy5nZXRBbmltYXRpb24oKSxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zID0gdGhpcy5nZXRBbmltYXRpb25zKCksXG4gICAgICAgICAgICAgICAgYW5pbSA9IGFuaW1hdGlvbnNbYW5pbWF0aW9uXSxcbiAgICAgICAgICAgICAgICBsZW4gPSBhbmltLmxlbmd0aCAvIDQ7XG5cbiAgICAgICAgICAgIGlmKGluZGV4IDwgbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVJbmRleChpbmRleCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZUluZGV4KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5TcHJpdGUsIEtvbnZhLlNoYXBlKTtcblxuICAgIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TcHJpdGUsICdhbmltYXRpb24nKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgYW5pbWF0aW9uIGtleVxuICAgICAqIEBuYW1lIGFuaW1hdGlvblxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3ByaXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhbmltIGFuaW1hdGlvbiBrZXlcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGFuaW1hdGlvbiBrZXlcbiAgICAgKiB2YXIgYW5pbWF0aW9uID0gc3ByaXRlLmFuaW1hdGlvbigpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGFuaW1hdGlvbiBrZXlcbiAgICAgKiBzcHJpdGUuYW5pbWF0aW9uKCdraWNraW5nJyk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TcHJpdGUsICdhbmltYXRpb25zJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGFuaW1hdGlvbnMgbWFwXG4gICAgICogQG5hbWUgYW5pbWF0aW9uc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3ByaXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhbmltYXRpb25zXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBhbmltYXRpb25zIG1hcFxuICAgICAqIHZhciBhbmltYXRpb25zID0gc3ByaXRlLmFuaW1hdGlvbnMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBhbmltYXRpb25zIG1hcFxuICAgICAqIHNwcml0ZS5hbmltYXRpb25zKHtcbiAgICAgKiAgIHN0YW5kaW5nOiBbXG4gICAgICogICAgIC8vIHgsIHksIHdpZHRoLCBoZWlnaHQgKDYgZnJhbWVzKVxuICAgICAqICAgICAwLCAwLCA0OSwgMTA5LFxuICAgICAqICAgICA1MiwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgMTA1LCAwLCA0OSwgMTA5LFxuICAgICAqICAgICAxNTgsIDAsIDQ5LCAxMDksXG4gICAgICogICAgIDIxMCwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgMjYyLCAwLCA0OSwgMTA5XG4gICAgICogICBdLFxuICAgICAqICAga2lja2luZzogW1xuICAgICAqICAgICAvLyB4LCB5LCB3aWR0aCwgaGVpZ2h0ICg2IGZyYW1lcylcbiAgICAgKiAgICAgMCwgMTA5LCA0NSwgOTgsXG4gICAgICogICAgIDQ1LCAxMDksIDQ1LCA5OCxcbiAgICAgKiAgICAgOTUsIDEwOSwgNjMsIDk4LFxuICAgICAqICAgICAxNTYsIDEwOSwgNzAsIDk4LFxuICAgICAqICAgICAyMjksIDEwOSwgNjAsIDk4LFxuICAgICAqICAgICAyODcsIDEwOSwgNDEsIDk4XG4gICAgICogICBdXG4gICAgICogfSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TcHJpdGUsICdmcmFtZU9mZnNldHMnKTtcblxuICAgIC8qKlxuICAgICogZ2V0L3NldCBvZmZzZXRzIG1hcFxuICAgICogQG5hbWUgb2Zmc2V0c1xuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLlNwcml0ZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvZmZzZXRzXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICogQGV4YW1wbGVcbiAgICAqIC8vIGdldCBvZmZzZXRzIG1hcFxuICAgICogdmFyIG9mZnNldHMgPSBzcHJpdGUub2Zmc2V0cygpO1xuICAgICpcbiAgICAqIC8vIHNldCBvZmZzZXRzIG1hcFxuICAgICogc3ByaXRlLm9mZnNldHMoe1xuICAgICogICBzdGFuZGluZzogW1xuICAgICogICAgIC8vIHgsIHkgKDYgZnJhbWVzKVxuICAgICogICAgIDAsIDAsXG4gICAgKiAgICAgMCwgMCxcbiAgICAqICAgICA1LCAwLFxuICAgICogICAgIDAsIDAsXG4gICAgKiAgICAgMCwgMyxcbiAgICAqICAgICAyLCAwXG4gICAgKiAgIF0sXG4gICAgKiAgIGtpY2tpbmc6IFtcbiAgICAqICAgICAvLyB4LCB5ICg2IGZyYW1lcylcbiAgICAqICAgICAwLCA1LFxuICAgICogICAgIDUsIDAsXG4gICAgKiAgICAgMTAsIDAsXG4gICAgKiAgICAgMCwgMCxcbiAgICAqICAgICAyLCAxLFxuICAgICogICAgIDAsIDBcbiAgICAqICAgXVxuICAgICogfSk7XG4gICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNwcml0ZSwgJ2ltYWdlJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGltYWdlXG4gICAgICogQG5hbWUgaW1hZ2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNwcml0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVxuICAgICAqIEByZXR1cm5zIHtJbWFnZX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBpbWFnZVxuICAgICAqIHZhciBpbWFnZSA9IHNwcml0ZS5pbWFnZSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGltYWdlXG4gICAgICogc3ByaXRlLmltYWdlKGltYWdlT2JqKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNwcml0ZSwgJ2ZyYW1lSW5kZXgnLCAwKTtcblxuICAgIC8qKlxuICAgICAqIHNldC9zZXQgYW5pbWF0aW9uIGZyYW1lIGluZGV4XG4gICAgICogQG5hbWUgZnJhbWVJbmRleFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3ByaXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gZnJhbWVJbmRleFxuICAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGFuaW1hdGlvbiBmcmFtZSBpbmRleFxuICAgICAqIHZhciBmcmFtZUluZGV4ID0gc3ByaXRlLmZyYW1lSW5kZXgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBhbmltYXRpb24gZnJhbWUgaW5kZXhcbiAgICAgKiBzcHJpdGUuZnJhbWVJbmRleCgzKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNwcml0ZSwgJ2ZyYW1lUmF0ZScsIDE3KTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZnJhbWUgcmF0ZSBpbiBmcmFtZXMgcGVyIHNlY29uZC4gIEluY3JlYXNlIHRoaXMgbnVtYmVyIHRvIG1ha2UgdGhlIHNwcml0ZVxuICAgICAqICBhbmltYXRpb24gcnVuIGZhc3RlciwgYW5kIGRlY3JlYXNlIHRoZSBudW1iZXIgdG8gbWFrZSB0aGUgc3ByaXRlIGFuaW1hdGlvbiBydW4gc2xvd2VyXG4gICAgICogIFRoZSBkZWZhdWx0IGlzIDE3IGZyYW1lcyBwZXIgc2Vjb25kXG4gICAgICogQG5hbWUgZnJhbWVSYXRlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TcHJpdGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBmcmFtZVJhdGVcbiAgICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmcmFtZSByYXRlXG4gICAgICogdmFyIGZyYW1lUmF0ZSA9IHNwcml0ZS5mcmFtZVJhdGUoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmcmFtZSByYXRlIHRvIDIgZnJhbWVzIHBlciBzZWNvbmRcbiAgICAgKiBzcHJpdGUuZnJhbWVSYXRlKDIpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5iYWNrQ29tcGF0KEtvbnZhLlNwcml0ZSwge1xuICAgICAgICBpbmRleDogJ2ZyYW1lSW5kZXgnLFxuICAgICAgICBnZXRJbmRleDogJ2dldEZyYW1lSW5kZXgnLFxuICAgICAgICBzZXRJbmRleDogJ3NldEZyYW1lSW5kZXgnXG4gICAgfSk7XG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuU3ByaXRlKTtcbn0pKCk7XG5cbi8qZXNsaW50LWRpc2FibGUgIG5vLXNoYWRvdywgbWF4LWxlbiwgbWF4LWRlcHRoICovXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBQYXRoIGNvbnN0cnVjdG9yLlxuICAgICAqIEBhdXRob3IgSmFzb24gRm9sbGFzXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZGF0YSBTVkcgZGF0YSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHBhdGggPSBuZXcgS29udmEuUGF0aCh7XG4gICAgICogICB4OiAyNDAsXG4gICAgICogICB5OiA0MCxcbiAgICAgKiAgIGRhdGE6ICdNMTIuNTgyLDkuNTUxQzMuMjUxLDE2LjIzNywwLjkyMSwyOS4wMjEsNy4wOCwzOC41NjRsLTIuMzYsMS42ODlsNC44OTMsMi4yNjJsNC44OTMsMi4yNjJsLTAuNTY4LTUuMzZsLTAuNTY3LTUuMzU5bC0yLjM2NSwxLjY5NGMtNC42NTctNy4zNzUtMi44My0xNy4xODUsNC4zNTItMjIuMzNjNy40NTEtNS4zMzgsMTcuODE3LTMuNjI1LDIzLjE1NiwzLjgyNGM1LjMzNyw3LjQ0OSwzLjYyNSwxNy44MTMtMy44MjEsMjMuMTUybDIuODU3LDMuOTg4YzkuNjE3LTYuODkzLDExLjgyNy0yMC4yNzcsNC45MzUtMjkuODk2QzM1LjU5MSw0Ljg3LDIyLjIwNCwyLjY1OCwxMi41ODIsOS41NTF6JyxcbiAgICAgKiAgIGZpbGw6ICdncmVlbicsXG4gICAgICogICBzY2FsZTogMlxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIEtvbnZhLlBhdGggPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5QYXRoLnByb3RvdHlwZSA9IHtcbiAgICAgICAgX19faW5pdDogZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5kYXRhQXJyYXkgPSBbXTtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAnUGF0aCc7XG5cbiAgICAgICAgICAgIHRoaXMuZGF0YUFycmF5ID0gS29udmEuUGF0aC5wYXJzZVBhdGhEYXRhKHRoaXMuZ2V0RGF0YSgpKTtcbiAgICAgICAgICAgIHRoaXMub24oJ2RhdGFDaGFuZ2Uua29udmEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5kYXRhQXJyYXkgPSBLb252YS5QYXRoLnBhcnNlUGF0aERhdGEodGhpcy5nZXREYXRhKCkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBjYSA9IHRoaXMuZGF0YUFycmF5LFxuICAgICAgICAgICAgICAgIGNsb3NlZFBhdGggPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gY29udGV4dCBwb3NpdGlvblxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgY2EubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGNhW25dLmNvbW1hbmQ7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBjYVtuXS5wb2ludHM7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocFswXSwgcFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhwWzBdLCBwWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhwWzBdLCBwWzFdLCBwWzJdLCBwWzNdLCBwWzRdLCBwWzVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhwWzBdLCBwWzFdLCBwWzJdLCBwWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjeCA9IHBbMF0sIGN5ID0gcFsxXSwgcnggPSBwWzJdLCByeSA9IHBbM10sIHRoZXRhID0gcFs0XSwgZFRoZXRhID0gcFs1XSwgcHNpID0gcFs2XSwgZnMgPSBwWzddO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IChyeCA+IHJ5KSA/IHJ4IDogcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVYID0gKHJ4ID4gcnkpID8gMSA6IHJ4IC8gcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVZID0gKHJ4ID4gcnkpID8gcnkgLyByeCA6IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJvdGF0ZShwc2kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByLCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIDEgLSBmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yb3RhdGUoLXBzaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZWRQYXRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNsb3NlZFBhdGgpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldFNlbGZSZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZGF0YUFycmF5LmZvckVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHBvaW50cyA9IHBvaW50cy5jb25jYXQoZGF0YS5wb2ludHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbWluWCA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIHZhciBtYXhYID0gcG9pbnRzWzBdO1xuICAgICAgICAgICAgdmFyIG1pblkgPSBwb2ludHNbMF07XG4gICAgICAgICAgICB2YXIgbWF4WSA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIHZhciB4LCB5O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeCA9IHBvaW50c1tpICogMl07IHkgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCk7XG4gICAgICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xuICAgICAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcbiAgICAgICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IE1hdGgucm91bmQobWluWCksXG4gICAgICAgICAgICAgICAgeTogTWF0aC5yb3VuZChtaW5ZKSxcbiAgICAgICAgICAgICAgICB3aWR0aDogTWF0aC5yb3VuZChtYXhYIC0gbWluWCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKG1heFkgLSBtaW5ZKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuUGF0aCwgS29udmEuU2hhcGUpO1xuXG4gICAgS29udmEuUGF0aC5nZXRMaW5lTGVuZ3RoID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCgoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkpO1xuICAgIH07XG4gICAgS29udmEuUGF0aC5nZXRQb2ludE9uTGluZSA9IGZ1bmN0aW9uKGRpc3QsIFAxeCwgUDF5LCBQMngsIFAyeSwgZnJvbVgsIGZyb21ZKSB7XG4gICAgICAgIGlmKGZyb21YID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZyb21YID0gUDF4O1xuICAgICAgICB9XG4gICAgICAgIGlmKGZyb21ZID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZyb21ZID0gUDF5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG0gPSAoUDJ5IC0gUDF5KSAvICgoUDJ4IC0gUDF4KSArIDAuMDAwMDAwMDEpO1xuICAgICAgICB2YXIgcnVuID0gTWF0aC5zcXJ0KGRpc3QgKiBkaXN0IC8gKDEgKyBtICogbSkpO1xuICAgICAgICBpZihQMnggPCBQMXgpIHtcbiAgICAgICAgICAgIHJ1biAqPSAtMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmlzZSA9IG0gKiBydW47XG4gICAgICAgIHZhciBwdDtcblxuICAgICAgICBpZiAoUDJ4ID09PSBQMXgpIHsgLy8gdmVydGljYWwgbGluZVxuICAgICAgICAgICAgcHQgPSB7XG4gICAgICAgICAgICAgICAgeDogZnJvbVgsXG4gICAgICAgICAgICAgICAgeTogZnJvbVkgKyByaXNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYoKGZyb21ZIC0gUDF5KSAvICgoZnJvbVggLSBQMXgpICsgMC4wMDAwMDAwMSkgPT09IG0pIHtcbiAgICAgICAgICAgIHB0ID0ge1xuICAgICAgICAgICAgICAgIHg6IGZyb21YICsgcnVuLFxuICAgICAgICAgICAgICAgIHk6IGZyb21ZICsgcmlzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpeCwgaXk7XG5cbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLmdldExpbmVMZW5ndGgoUDF4LCBQMXksIFAyeCwgUDJ5KTtcbiAgICAgICAgICAgIGlmKGxlbiA8IDAuMDAwMDAwMDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHUgPSAoKChmcm9tWCAtIFAxeCkgKiAoUDJ4IC0gUDF4KSkgKyAoKGZyb21ZIC0gUDF5KSAqIChQMnkgLSBQMXkpKSk7XG4gICAgICAgICAgICB1ID0gdSAvIChsZW4gKiBsZW4pO1xuICAgICAgICAgICAgaXggPSBQMXggKyB1ICogKFAyeCAtIFAxeCk7XG4gICAgICAgICAgICBpeSA9IFAxeSArIHUgKiAoUDJ5IC0gUDF5KTtcblxuICAgICAgICAgICAgdmFyIHBSaXNlID0gdGhpcy5nZXRMaW5lTGVuZ3RoKGZyb21YLCBmcm9tWSwgaXgsIGl5KTtcbiAgICAgICAgICAgIHZhciBwUnVuID0gTWF0aC5zcXJ0KGRpc3QgKiBkaXN0IC0gcFJpc2UgKiBwUmlzZSk7XG4gICAgICAgICAgICBydW4gPSBNYXRoLnNxcnQocFJ1biAqIHBSdW4gLyAoMSArIG0gKiBtKSk7XG4gICAgICAgICAgICBpZihQMnggPCBQMXgpIHtcbiAgICAgICAgICAgICAgICBydW4gKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByaXNlID0gbSAqIHJ1bjtcbiAgICAgICAgICAgIHB0ID0ge1xuICAgICAgICAgICAgICAgIHg6IGl4ICsgcnVuLFxuICAgICAgICAgICAgICAgIHk6IGl5ICsgcmlzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwdDtcbiAgICB9O1xuXG4gICAgS29udmEuUGF0aC5nZXRQb2ludE9uQ3ViaWNCZXppZXIgPSBmdW5jdGlvbihwY3QsIFAxeCwgUDF5LCBQMngsIFAyeSwgUDN4LCBQM3ksIFA0eCwgUDR5KSB7XG4gICAgICAgIGZ1bmN0aW9uIENCMSh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdCAqIHQgKiB0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIENCMih0KSB7XG4gICAgICAgICAgICByZXR1cm4gMyAqIHQgKiB0ICogKDEgLSB0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBDQjModCkge1xuICAgICAgICAgICAgcmV0dXJuIDMgKiB0ICogKDEgLSB0KSAqICgxIC0gdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gQ0I0KHQpIHtcbiAgICAgICAgICAgIHJldHVybiAoMSAtIHQpICogKDEgLSB0KSAqICgxIC0gdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHggPSBQNHggKiBDQjEocGN0KSArIFAzeCAqIENCMihwY3QpICsgUDJ4ICogQ0IzKHBjdCkgKyBQMXggKiBDQjQocGN0KTtcbiAgICAgICAgdmFyIHkgPSBQNHkgKiBDQjEocGN0KSArIFAzeSAqIENCMihwY3QpICsgUDJ5ICogQ0IzKHBjdCkgKyBQMXkgKiBDQjQocGN0KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEtvbnZhLlBhdGguZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllciA9IGZ1bmN0aW9uKHBjdCwgUDF4LCBQMXksIFAyeCwgUDJ5LCBQM3gsIFAzeSkge1xuICAgICAgICBmdW5jdGlvbiBRQjEodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQgKiB0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIFFCMih0KSB7XG4gICAgICAgICAgICByZXR1cm4gMiAqIHQgKiAoMSAtIHQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIFFCMyh0KSB7XG4gICAgICAgICAgICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHggPSBQM3ggKiBRQjEocGN0KSArIFAyeCAqIFFCMihwY3QpICsgUDF4ICogUUIzKHBjdCk7XG4gICAgICAgIHZhciB5ID0gUDN5ICogUUIxKHBjdCkgKyBQMnkgKiBRQjIocGN0KSArIFAxeSAqIFFCMyhwY3QpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeVxuICAgICAgICB9O1xuICAgIH07XG4gICAgS29udmEuUGF0aC5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyA9IGZ1bmN0aW9uKGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgcHNpKSB7XG4gICAgICAgIHZhciBjb3NQc2kgPSBNYXRoLmNvcyhwc2kpLCBzaW5Qc2kgPSBNYXRoLnNpbihwc2kpO1xuICAgICAgICB2YXIgcHQgPSB7XG4gICAgICAgICAgICB4OiByeCAqIE1hdGguY29zKHRoZXRhKSxcbiAgICAgICAgICAgIHk6IHJ5ICogTWF0aC5zaW4odGhldGEpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBjeCArIChwdC54ICogY29zUHNpIC0gcHQueSAqIHNpblBzaSksXG4gICAgICAgICAgICB5OiBjeSArIChwdC54ICogc2luUHNpICsgcHQueSAqIGNvc1BzaSlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qXG4gICAgICogZ2V0IHBhcnNlZCBkYXRhIGFycmF5IGZyb20gdGhlIGRhdGFcbiAgICAgKiAgc3RyaW5nLiAgViwgdiwgSCwgaCwgYW5kIGwgZGF0YSBhcmUgY29udmVydGVkIHRvXG4gICAgICogIEwgZGF0YSBmb3IgdGhlIHB1cnBvc2Ugb2YgaGlnaCBwZXJmb3JtYW5jZSBQYXRoXG4gICAgICogIHJlbmRlcmluZ1xuICAgICAqL1xuICAgIEtvbnZhLlBhdGgucGFyc2VQYXRoRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgLy8gUGF0aCBEYXRhIFNlZ21lbnQgbXVzdCBiZWdpbiB3aXRoIGEgbW92ZVRvXG4gICAgICAgIC8vbSAoeCB5KSsgIFJlbGF0aXZlIG1vdmVUbyAoc3Vic2VxdWVudCBwb2ludHMgYXJlIHRyZWF0ZWQgYXMgbGluZVRvKVxuICAgICAgICAvL00gKHggeSkrICBBYnNvbHV0ZSBtb3ZlVG8gKHN1YnNlcXVlbnQgcG9pbnRzIGFyZSB0cmVhdGVkIGFzIGxpbmVUbylcbiAgICAgICAgLy9sICh4IHkpKyAgUmVsYXRpdmUgbGluZVRvXG4gICAgICAgIC8vTCAoeCB5KSsgIEFic29sdXRlIExpbmVUb1xuICAgICAgICAvL2ggKHgpKyAgICBSZWxhdGl2ZSBob3Jpem9udGFsIGxpbmVUb1xuICAgICAgICAvL0ggKHgpKyAgICBBYnNvbHV0ZSBob3Jpem9udGFsIGxpbmVUb1xuICAgICAgICAvL3YgKHkpKyAgICBSZWxhdGl2ZSB2ZXJ0aWNhbCBsaW5lVG9cbiAgICAgICAgLy9WICh5KSsgICAgQWJzb2x1dGUgdmVydGljYWwgbGluZVRvXG4gICAgICAgIC8veiAoY2xvc2VwYXRoKVxuICAgICAgICAvL1ogKGNsb3NlcGF0aClcbiAgICAgICAgLy9jICh4MSB5MSB4MiB5MiB4IHkpKyBSZWxhdGl2ZSBCZXppZXIgY3VydmVcbiAgICAgICAgLy9DICh4MSB5MSB4MiB5MiB4IHkpKyBBYnNvbHV0ZSBCZXppZXIgY3VydmVcbiAgICAgICAgLy9xICh4MSB5MSB4IHkpKyAgICAgICBSZWxhdGl2ZSBRdWFkcmF0aWMgQmV6aWVyXG4gICAgICAgIC8vUSAoeDEgeTEgeCB5KSsgICAgICAgQWJzb2x1dGUgUXVhZHJhdGljIEJlemllclxuICAgICAgICAvL3QgKHggeSkrICAgIFNob3J0aGFuZC9TbW9vdGggUmVsYXRpdmUgUXVhZHJhdGljIEJlemllclxuICAgICAgICAvL1QgKHggeSkrICAgIFNob3J0aGFuZC9TbW9vdGggQWJzb2x1dGUgUXVhZHJhdGljIEJlemllclxuICAgICAgICAvL3MgKHgyIHkyIHggeSkrICAgICAgIFNob3J0aGFuZC9TbW9vdGggUmVsYXRpdmUgQmV6aWVyIGN1cnZlXG4gICAgICAgIC8vUyAoeDIgeTIgeCB5KSsgICAgICAgU2hvcnRoYW5kL1Ntb290aCBBYnNvbHV0ZSBCZXppZXIgY3VydmVcbiAgICAgICAgLy9hIChyeCByeSB4LWF4aXMtcm90YXRpb24gbGFyZ2UtYXJjLWZsYWcgc3dlZXAtZmxhZyB4IHkpKyAgICAgUmVsYXRpdmUgRWxsaXB0aWNhbCBBcmNcbiAgICAgICAgLy9BIChyeCByeSB4LWF4aXMtcm90YXRpb24gbGFyZ2UtYXJjLWZsYWcgc3dlZXAtZmxhZyB4IHkpKyAgQWJzb2x1dGUgRWxsaXB0aWNhbCBBcmNcblxuICAgICAgICAvLyByZXR1cm4gZWFybHkgaWYgZGF0YSBpcyBub3QgZGVmaW5lZFxuICAgICAgICBpZighZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29tbWFuZCBzdHJpbmdcbiAgICAgICAgdmFyIGNzID0gZGF0YTtcblxuICAgICAgICAvLyBjb21tYW5kIGNoYXJzXG4gICAgICAgIHZhciBjYyA9IFsnbScsICdNJywgJ2wnLCAnTCcsICd2JywgJ1YnLCAnaCcsICdIJywgJ3onLCAnWicsICdjJywgJ0MnLCAncScsICdRJywgJ3QnLCAnVCcsICdzJywgJ1MnLCAnYScsICdBJ107XG4gICAgICAgIC8vIGNvbnZlcnQgd2hpdGUgc3BhY2VzIHRvIGNvbW1hc1xuICAgICAgICBjcyA9IGNzLnJlcGxhY2UobmV3IFJlZ0V4cCgnICcsICdnJyksICcsJyk7XG4gICAgICAgIC8vIGNyZWF0ZSBwaXBlcyBzbyB0aGF0IHdlIGNhbiBzcGxpdCB0aGUgZGF0YVxuICAgICAgICBmb3IodmFyIG4gPSAwOyBuIDwgY2MubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIGNzID0gY3MucmVwbGFjZShuZXcgUmVnRXhwKGNjW25dLCAnZycpLCAnfCcgKyBjY1tuXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlIGFycmF5XG4gICAgICAgIHZhciBhcnIgPSBjcy5zcGxpdCgnfCcpO1xuICAgICAgICB2YXIgY2EgPSBbXTtcbiAgICAgICAgLy8gaW5pdCBjb250ZXh0IHBvaW50XG4gICAgICAgIHZhciBjcHggPSAwO1xuICAgICAgICB2YXIgY3B5ID0gMDtcbiAgICAgICAgZm9yKCBuID0gMTsgbiA8IGFyci5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgdmFyIHN0ciA9IGFycltuXTtcbiAgICAgICAgICAgIHZhciBjID0gc3RyLmNoYXJBdCgwKTtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgxKTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSAsLSBmb3IgY29uc2lzdGVuY3lcbiAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoJywtJywgJ2cnKSwgJy0nKTtcbiAgICAgICAgICAgIC8vIGFkZCBjb21tYXMgc28gdGhhdCBpdCdzIGVhc3kgdG8gc3BsaXRcbiAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoJy0nLCAnZycpLCAnLC0nKTtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoJ2UsLScsICdnJyksICdlLScpO1xuICAgICAgICAgICAgdmFyIHAgPSBzdHIuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIGlmKHAubGVuZ3RoID4gMCAmJiBwWzBdID09PSAnJykge1xuICAgICAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnZlcnQgc3RyaW5ncyB0byBmbG9hdHNcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcFtpXSA9IHBhcnNlRmxvYXQocFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZShwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZihpc05hTihwWzBdKSkgey8vIGNhc2UgZm9yIGEgdHJhaWxpbmcgY29tbWEgYmVmb3JlIG5leHQgY29tbWFuZFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY21kID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0WCA9IGNweCwgc3RhcnRZID0gY3B5O1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgdmFyIGZyb20gd2l0aGluIHRoZSBzd2l0Y2ggdG8gdXAgaGVyZSAoanNoaW50KVxuICAgICAgICAgICAgICAgIHZhciBwcmV2Q21kLCBjdGxQdHgsIGN0bFB0eTsgICAgIC8vIFNzLCBUdFxuICAgICAgICAgICAgICAgIHZhciByeCwgcnksIHBzaSwgZmEsIGZzLCB4MSwgeTE7IC8vIEFhXG5cblxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgbCwgSCwgaCwgViwgYW5kIHYgdG8gTFxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYykge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IEtlZXAgdGhlIGxpbmVUbydzIGFib3ZlIHRoZSBtb3ZlVG8ncyBpbiB0aGlzIHN3aXRjaFxuICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ0wnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogbGluZVRvIGhhbmRsZXJzIG5lZWQgdG8gYmUgYWJvdmUgdGhpcyBwb2ludFxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBkeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdNJztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFmdGVyIGNsb3NpbmcgdGhlIHBhdGggbW92ZSB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gdGhlIHRoZSBmaXJzdCBwb2ludCBvZiB0aGUgcGF0aCAoaWYgYW55KS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNhLmxlbmd0aCA+IDIgJiYgY2FbY2EubGVuZ3RoIC0gMV0uY29tbWFuZCA9PT0gJ3onKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGlkeCA9IGNhLmxlbmd0aCAtIDI7IGlkeCA+PSAwOyBpZHgtLSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNhW2lkeF0uY29tbWFuZCA9PT0gJ00nKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IGNhW2lkeF0ucG9pbnRzWzBdICsgZHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBjYVtpZHhdLnBvaW50c1sxXSArIGR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gJ2wnO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Vic2VxdWVudCBwb2ludHMgYXJlIHRyZWF0ZWQgYXMgcmVsYXRpdmUgbGluZVRvXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnTSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gJ0wnO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Vic2VxdWVudCBwb2ludHMgYXJlIHRyZWF0ZWQgYXMgYWJzb2x1dGUgbGluZVRvXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnTCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnTCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ0wnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ0wnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocC5zaGlmdCgpLCBwLnNoaWZ0KCksIHAuc2hpZnQoKSwgcC5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCArIHAuc2hpZnQoKSwgY3B5ICsgcC5zaGlmdCgpLCBjcHggKyBwLnNoaWZ0KCksIGNweSArIHAuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdDJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZDbWQgPSBjYVtjYS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHByZXZDbWQuY29tbWFuZCA9PT0gJ0MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4ICsgKGNweCAtIHByZXZDbWQucG9pbnRzWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHkgKyAoY3B5IC0gcHJldkNtZC5wb2ludHNbM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3RsUHR4LCBjdGxQdHksIHAuc2hpZnQoKSwgcC5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdDJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZDbWQgPSBjYVtjYS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHByZXZDbWQuY29tbWFuZCA9PT0gJ0MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4ICsgKGNweCAtIHByZXZDbWQucG9pbnRzWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHkgKyAoY3B5IC0gcHJldkNtZC5wb2ludHNbM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3RsUHR4LCBjdGxQdHksIGNweCArIHAuc2hpZnQoKSwgY3B5ICsgcC5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ0MnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocC5zaGlmdCgpLCBwLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4ICsgcC5zaGlmdCgpLCBjcHkgKyBwLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnUSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Q21kID0gY2FbY2EubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwcmV2Q21kLmNvbW1hbmQgPT09ICdRJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweCArIChjcHggLSBwcmV2Q21kLnBvaW50c1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5ICsgKGNweSAtIHByZXZDbWQucG9pbnRzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdRJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGN0bFB0eCwgY3RsUHR5LCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Q21kID0gY2FbY2EubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwcmV2Q21kLmNvbW1hbmQgPT09ICdRJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweCArIChjcHggLSBwcmV2Q21kLnBvaW50c1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5ICsgKGNweSAtIHByZXZDbWQucG9pbnRzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ1EnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3RsUHR4LCBjdGxQdHksIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwc2kgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdBJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IHRoaXMuY29udmVydEVuZHBvaW50VG9DZW50ZXJQYXJhbWV0ZXJpemF0aW9uKHgxLCB5MSwgY3B4LCBjcHksIGZhLCBmcywgcngsIHJ5LCBwc2kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcnggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByeSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBzaSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnMgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gY3B5OyBjcHggKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdBJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IHRoaXMuY29udmVydEVuZHBvaW50VG9DZW50ZXJQYXJhbWV0ZXJpemF0aW9uKHgxLCB5MSwgY3B4LCBjcHksIGZhLCBmcywgcngsIHJ5LCBwc2kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2EucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IGNtZCB8fCBjLFxuICAgICAgICAgICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHN0YXJ0WCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHN0YXJ0WVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXRoTGVuZ3RoOiB0aGlzLmNhbGNMZW5ndGgoc3RhcnRYLCBzdGFydFksIGNtZCB8fCBjLCBwb2ludHMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGMgPT09ICd6JyB8fCBjID09PSAnWicpIHtcbiAgICAgICAgICAgICAgICBjYS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogJ3onLFxuICAgICAgICAgICAgICAgICAgICBwb2ludHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBwYXRoTGVuZ3RoOiAwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2E7XG4gICAgfTtcbiAgICBLb252YS5QYXRoLmNhbGNMZW5ndGggPSBmdW5jdGlvbih4LCB5LCBjbWQsIHBvaW50cykge1xuICAgICAgICB2YXIgbGVuLCBwMSwgcDIsIHQ7XG4gICAgICAgIHZhciBwYXRoID0gS29udmEuUGF0aDtcblxuICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGguZ2V0TGluZUxlbmd0aCh4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICAvLyBBcHByb3hpbWF0ZXMgYnkgYnJlYWtpbmcgY3VydmUgaW50byAxMDAgbGluZSBzZWdtZW50c1xuICAgICAgICAgICAgICAgIGxlbiA9IDAuMDtcbiAgICAgICAgICAgICAgICBwMSA9IHBhdGguZ2V0UG9pbnRPbkN1YmljQmV6aWVyKDAsIHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgcG9pbnRzWzRdLCBwb2ludHNbNV0pO1xuICAgICAgICAgICAgICAgIGZvciggdCA9IDAuMDE7IHQgPD0gMTsgdCArPSAwLjAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHAyID0gcGF0aC5nZXRQb2ludE9uQ3ViaWNCZXppZXIodCwgeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBwb2ludHNbNF0sIHBvaW50c1s1XSk7XG4gICAgICAgICAgICAgICAgICAgIGxlbiArPSBwYXRoLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgICAgICAgICAgICAgICAgIHAxID0gcDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsZW47XG4gICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICAvLyBBcHByb3hpbWF0ZXMgYnkgYnJlYWtpbmcgY3VydmUgaW50byAxMDAgbGluZSBzZWdtZW50c1xuICAgICAgICAgICAgICAgIGxlbiA9IDAuMDtcbiAgICAgICAgICAgICAgICBwMSA9IHBhdGguZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllcigwLCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuICAgICAgICAgICAgICAgIGZvciggdCA9IDAuMDE7IHQgPD0gMTsgdCArPSAwLjAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHAyID0gcGF0aC5nZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyKHQsIHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSk7XG4gICAgICAgICAgICAgICAgICAgIGxlbiArPSBwYXRoLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgICAgICAgICAgICAgICAgIHAxID0gcDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsZW47XG4gICAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgICAgICAvLyBBcHByb3hpbWF0ZXMgYnkgYnJlYWtpbmcgY3VydmUgaW50byBsaW5lIHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgbGVuID0gMC4wO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHBvaW50c1s0XTtcbiAgICAgICAgICAgICAgICAvLyA0ID0gdGhldGFcbiAgICAgICAgICAgICAgICB2YXIgZFRoZXRhID0gcG9pbnRzWzVdO1xuICAgICAgICAgICAgICAgIC8vIDUgPSBkVGhldGFcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gcG9pbnRzWzRdICsgZFRoZXRhO1xuICAgICAgICAgICAgICAgIHZhciBpbmMgPSBNYXRoLlBJIC8gMTgwLjA7XG4gICAgICAgICAgICAgICAgLy8gMSBkZWdyZWUgcmVzb2x1dGlvblxuICAgICAgICAgICAgICAgIGlmKE1hdGguYWJzKHN0YXJ0IC0gZW5kKSA8IGluYykge1xuICAgICAgICAgICAgICAgICAgICBpbmMgPSBNYXRoLmFicyhzdGFydCAtIGVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IGZvciBwdXJwb3NlIG9mIGNhbGN1bGF0aW5nIGFyYyBsZW5ndGgsIG5vdCBnb2luZyB0byB3b3JyeSBhYm91dCByb3RhdGluZyBYLWF4aXMgYnkgYW5nbGUgcHNpXG4gICAgICAgICAgICAgICAgcDEgPSBwYXRoLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgc3RhcnQsIDApO1xuICAgICAgICAgICAgICAgIGlmKGRUaGV0YSA8IDApIHsvLyBjbG9ja3dpc2VcbiAgICAgICAgICAgICAgICAgICAgZm9yKCB0ID0gc3RhcnQgLSBpbmM7IHQgPiBlbmQ7IHQgLT0gaW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwMiA9IHBhdGguZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCB0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbiArPSBwYXRoLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Ugey8vIGNvdW50ZXItY2xvY2t3aXNlXG4gICAgICAgICAgICAgICAgICAgIGZvciggdCA9IHN0YXJ0ICsgaW5jOyB0IDwgZW5kOyB0ICs9IGluYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcDIgPSBwYXRoLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgdCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4gKz0gcGF0aC5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwMiA9IHBhdGguZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBlbmQsIDApO1xuICAgICAgICAgICAgICAgIGxlbiArPSBwYXRoLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBLb252YS5QYXRoLmNvbnZlcnRFbmRwb2ludFRvQ2VudGVyUGFyYW1ldGVyaXphdGlvbiA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCBmYSwgZnMsIHJ4LCByeSwgcHNpRGVnKSB7XG4gICAgICAgIC8vIERlcml2ZWQgZnJvbTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xuICAgICAgICB2YXIgcHNpID0gcHNpRGVnICogKE1hdGguUEkgLyAxODAuMCk7XG4gICAgICAgIHZhciB4cCA9IE1hdGguY29zKHBzaSkgKiAoeDEgLSB4MikgLyAyLjAgKyBNYXRoLnNpbihwc2kpICogKHkxIC0geTIpIC8gMi4wO1xuICAgICAgICB2YXIgeXAgPSAtMSAqIE1hdGguc2luKHBzaSkgKiAoeDEgLSB4MikgLyAyLjAgKyBNYXRoLmNvcyhwc2kpICogKHkxIC0geTIpIC8gMi4wO1xuXG4gICAgICAgIHZhciBsYW1iZGEgPSAoeHAgKiB4cCkgLyAocnggKiByeCkgKyAoeXAgKiB5cCkgLyAocnkgKiByeSk7XG5cbiAgICAgICAgaWYobGFtYmRhID4gMSkge1xuICAgICAgICAgICAgcnggKj0gTWF0aC5zcXJ0KGxhbWJkYSk7XG4gICAgICAgICAgICByeSAqPSBNYXRoLnNxcnQobGFtYmRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmID0gTWF0aC5zcXJ0KCgoKHJ4ICogcngpICogKHJ5ICogcnkpKSAtICgocnggKiByeCkgKiAoeXAgKiB5cCkpIC0gKChyeSAqIHJ5KSAqICh4cCAqIHhwKSkpIC8gKChyeCAqIHJ4KSAqICh5cCAqIHlwKSArIChyeSAqIHJ5KSAqICh4cCAqIHhwKSkpO1xuXG4gICAgICAgIGlmKGZhID09PSBmcykge1xuICAgICAgICAgICAgZiAqPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZihpc05hTihmKSkge1xuICAgICAgICAgICAgZiA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3hwID0gZiAqIHJ4ICogeXAgLyByeTtcbiAgICAgICAgdmFyIGN5cCA9IGYgKiAtcnkgKiB4cCAvIHJ4O1xuXG4gICAgICAgIHZhciBjeCA9ICh4MSArIHgyKSAvIDIuMCArIE1hdGguY29zKHBzaSkgKiBjeHAgLSBNYXRoLnNpbihwc2kpICogY3lwO1xuICAgICAgICB2YXIgY3kgPSAoeTEgKyB5MikgLyAyLjAgKyBNYXRoLnNpbihwc2kpICogY3hwICsgTWF0aC5jb3MocHNpKSAqIGN5cDtcblxuICAgICAgICB2YXIgdk1hZyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQodlswXSAqIHZbMF0gKyB2WzFdICogdlsxXSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB2UmF0aW8gPSBmdW5jdGlvbih1LCB2KSB7XG4gICAgICAgICAgICByZXR1cm4gKHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV0pIC8gKHZNYWcodSkgKiB2TWFnKHYpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHZBbmdsZSA9IGZ1bmN0aW9uKHUsIHYpIHtcbiAgICAgICAgICAgIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSkgKiBNYXRoLmFjb3ModlJhdGlvKHUsIHYpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoZXRhID0gdkFuZ2xlKFsxLCAwXSwgWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XSk7XG4gICAgICAgIHZhciB1ID0gWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XTtcbiAgICAgICAgdmFyIHYgPSBbKC0xICogeHAgLSBjeHApIC8gcngsICgtMSAqIHlwIC0gY3lwKSAvIHJ5XTtcbiAgICAgICAgdmFyIGRUaGV0YSA9IHZBbmdsZSh1LCB2KTtcblxuICAgICAgICBpZih2UmF0aW8odSwgdikgPD0gLTEpIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodlJhdGlvKHUsIHYpID49IDEpIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZnMgPT09IDAgJiYgZFRoZXRhID4gMCkge1xuICAgICAgICAgICAgZFRoZXRhID0gZFRoZXRhIC0gMiAqIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZnMgPT09IDEgJiYgZFRoZXRhIDwgMCkge1xuICAgICAgICAgICAgZFRoZXRhID0gZFRoZXRhICsgMiAqIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtjeCwgY3ksIHJ4LCByeSwgdGhldGEsIGRUaGV0YSwgcHNpLCBmc107XG4gICAgfTtcbiAgICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuUGF0aCwgJ2RhdGEnKTtcblxuICAgIC8qKlxuICAgICAqIHNldCBTVkcgcGF0aCBkYXRhIHN0cmluZy4gIFRoaXMgbWV0aG9kXG4gICAgICogIGFsc28gYXV0b21hdGljYWxseSBwYXJzZXMgdGhlIGRhdGEgc3RyaW5nXG4gICAgICogIGludG8gYSBkYXRhIGFycmF5LiAgQ3VycmVudGx5IHN1cHBvcnRlZCBTVkcgZGF0YTpcbiAgICAgKiAgTSwgbSwgTCwgbCwgSCwgaCwgViwgdiwgUSwgcSwgVCwgdCwgQywgYywgUywgcywgQSwgYSwgWiwgelxuICAgICAqIEBuYW1lIHNldERhdGFcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlBhdGgucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFNWRyBwYXRoIGNvbW1hbmQgc3RyaW5nXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBnZXQgU1ZHIHBhdGggZGF0YSBzdHJpbmdcbiAgICAgKiBAbmFtZSBnZXREYXRhXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5QYXRoLnByb3RvdHlwZVxuICAgICAqL1xuXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlBhdGgpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgRU1QVFlfU1RSSU5HID0gJycsXG4gICAgICAgIC8vQ0FMSUJSSSA9ICdDYWxpYnJpJyxcbiAgICAgICAgTk9STUFMID0gJ25vcm1hbCc7XG5cbiAgICAvKipcbiAgICAgKiBQYXRoIGNvbnN0cnVjdG9yLlxuICAgICAqIEBhdXRob3IgSmFzb24gRm9sbGFzXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZvbnRGYW1pbHldIGRlZmF1bHQgaXMgQ2FsaWJyaVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZvbnRTaXplXSBkZWZhdWx0IGlzIDEyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZm9udFN0eWxlXSBjYW4gYmUgbm9ybWFsLCBib2xkLCBvciBpdGFsaWMuICBEZWZhdWx0IGlzIG5vcm1hbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZvbnRWYXJpYW50XSBjYW4gYmUgbm9ybWFsIG9yIHNtYWxsLWNhcHMuICBEZWZhdWx0IGlzIG5vcm1hbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcudGV4dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZGF0YSBTVkcgZGF0YSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHRleHRwYXRoID0gbmV3IEtvbnZhLlRleHRQYXRoKHtcbiAgICAgKiAgIHg6IDEwMCxcbiAgICAgKiAgIHk6IDUwLFxuICAgICAqICAgZmlsbDogJyMzMzMnLFxuICAgICAqICAgZm9udFNpemU6ICcyNCcsXG4gICAgICogICBmb250RmFtaWx5OiAnQXJpYWwnLFxuICAgICAqICAgdGV4dDogJ0FsbCB0aGUgd29ybGRcXCdzIGEgc3RhZ2UsIGFuZCBhbGwgdGhlIG1lbiBhbmQgd29tZW4gbWVyZWx5IHBsYXllcnMuJyxcbiAgICAgKiAgIGRhdGE6ICdNMTAsMTAgQzAsMCAxMCwxNTAgMTAwLDEwMCBTMzAwLDE1MCA0MDAsNTAnXG4gICAgICogfSk7XG4gICAgICovXG4gICAgS29udmEuVGV4dFBhdGggPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9maWxsRnVuYyhjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQodGhpcy5wYXJ0aWFsVGV4dCwgMCwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9zdHJva2VGdW5jKGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KHRoaXMucGFydGlhbFRleHQsIDAsIDApO1xuICAgIH1cblxuICAgIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZSA9IHtcbiAgICAgICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmR1bW15Q2FudmFzID0gS29udmEuVXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICAgICAgICB0aGlzLmRhdGFBcnJheSA9IFtdO1xuXG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG5cbiAgICAgICAgICAgIC8vIG92ZXJyaWRlc1xuICAgICAgICAgICAgLy8gVE9ETzogc2hvdWxkbid0IHRoaXMgYmUgb24gdGhlIHByb3RvdHlwZT9cbiAgICAgICAgICAgIHRoaXMuX2ZpbGxGdW5jID0gX2ZpbGxGdW5jO1xuICAgICAgICAgICAgdGhpcy5fc3Ryb2tlRnVuYyA9IF9zdHJva2VGdW5jO1xuICAgICAgICAgICAgdGhpcy5fZmlsbEZ1bmNIaXQgPSBfZmlsbEZ1bmM7XG4gICAgICAgICAgICB0aGlzLl9zdHJva2VGdW5jSGl0ID0gX3N0cm9rZUZ1bmM7XG5cbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1RleHRQYXRoJztcblxuICAgICAgICAgICAgdGhpcy5kYXRhQXJyYXkgPSBLb252YS5QYXRoLnBhcnNlUGF0aERhdGEodGhpcy5hdHRycy5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMub24oJ2RhdGFDaGFuZ2Uua29udmEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmRhdGFBcnJheSA9IEtvbnZhLlBhdGgucGFyc2VQYXRoRGF0YSh0aGlzLmF0dHJzLmRhdGEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0ZXh0IGRhdGEgZm9yIGNlcnRhaW4gYXR0ciBjaGFuZ2VzXG4gICAgICAgICAgICB0aGlzLm9uKCd0ZXh0Q2hhbmdlLmtvbnZhIHRleHRTdHJva2Uua29udmEgdGV4dFN0cm9rZVdpZHRoLmtvbnZhJywgdGhhdC5fc2V0VGV4dERhdGEpO1xuICAgICAgICAgICAgdGhhdC5fc2V0VGV4dERhdGEoKTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2V0QXR0cignZm9udCcsIHRoaXMuX2dldENvbnRleHRGb250KCkpO1xuICAgICAgICAgICAgY29udGV4dC5zZXRBdHRyKCd0ZXh0QmFzZWxpbmUnLCAnbWlkZGxlJyk7XG4gICAgICAgICAgICBjb250ZXh0LnNldEF0dHIoJ3RleHRBbGlnbicsICdsZWZ0Jyk7XG4gICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgICAgICAgICAgdmFyIGdseXBoSW5mbyA9IHRoaXMuZ2x5cGhJbmZvO1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGdseXBoSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHAwID0gZ2x5cGhJbmZvW2ldLnAwO1xuXG4gICAgICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUocDAueCwgcDAueSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yb3RhdGUoZ2x5cGhJbmZvW2ldLnJvdGF0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpYWxUZXh0ID0gZ2x5cGhJbmZvW2ldLnRleHQ7XG5cbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcblxuICAgICAgICAgICAgICAgIC8vLy8gVG8gYXNzaXN0IHdpdGggZGVidWdnaW5nIHZpc3VhbGx5LCB1bmNvbW1lbnQgZm9sbG93aW5nXG4gICAgICAgICAgICAgICAgLy8gY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAvLyBpZiAoaSAlIDIpXG4gICAgICAgICAgICAgICAgLy8gY29udGV4dC5zdHJva2VTdHlsZSA9ICdjeWFuJztcbiAgICAgICAgICAgICAgICAvLyBlbHNlXG4gICAgICAgICAgICAgICAgLy8gY29udGV4dC5zdHJva2VTdHlsZSA9ICdncmVlbic7XG4gICAgICAgICAgICAgICAgLy8gdmFyIHAxID0gZ2x5cGhJbmZvW2ldLnAxO1xuICAgICAgICAgICAgICAgIC8vIGNvbnRleHQubW92ZVRvKHAwLngsIHAwLnkpO1xuICAgICAgICAgICAgICAgIC8vIGNvbnRleHQubGluZVRvKHAxLngsIHAxLnkpO1xuICAgICAgICAgICAgICAgIC8vIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCB0ZXh0IHdpZHRoIGluIHBpeGVsc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGdldFRleHRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0V2lkdGg7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgdGV4dCBoZWlnaHQgaW4gcGl4ZWxzXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGV4dEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0SGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IHRleHRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBzZXRUZXh0OiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICBLb252YS5UZXh0LnByb3RvdHlwZS5zZXRUZXh0LmNhbGwodGhpcywgdGV4dCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRUZXh0U2l6ZTogZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgdmFyIGR1bW15Q2FudmFzID0gdGhpcy5kdW1teUNhbnZhcztcbiAgICAgICAgICAgIHZhciBfY29udGV4dCA9IGR1bW15Q2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIF9jb250ZXh0LnNhdmUoKTtcblxuICAgICAgICAgICAgX2NvbnRleHQuZm9udCA9IHRoaXMuX2dldENvbnRleHRGb250KCk7XG4gICAgICAgICAgICB2YXIgbWV0cmljcyA9IF9jb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpO1xuXG4gICAgICAgICAgICBfY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IG1ldHJpY3Mud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBwYXJzZUludCh0aGlzLmF0dHJzLmZvbnRTaXplLCAxMClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIF9zZXRUZXh0RGF0YTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5fZ2V0VGV4dFNpemUodGhpcy5hdHRycy50ZXh0KTtcbiAgICAgICAgICAgIHRoaXMudGV4dFdpZHRoID0gc2l6ZS53aWR0aDtcbiAgICAgICAgICAgIHRoaXMudGV4dEhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXG4gICAgICAgICAgICB0aGlzLmdseXBoSW5mbyA9IFtdO1xuXG4gICAgICAgICAgICB2YXIgY2hhckFyciA9IHRoaXMuYXR0cnMudGV4dC5zcGxpdCgnJyk7XG5cbiAgICAgICAgICAgIHZhciBwMCwgcDEsIHBhdGhDbWQ7XG5cbiAgICAgICAgICAgIHZhciBwSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50VCA9IDA7XG5cbiAgICAgICAgICAgIHZhciBnZXROZXh0UGF0aFNlZ21lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gdGhhdC5kYXRhQXJyYXk7XG5cbiAgICAgICAgICAgICAgICBmb3IodmFyIGogPSBwSW5kZXggKyAxOyBqIDwgcGF0aERhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYocGF0aERhdGFbal0ucGF0aExlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBJbmRleCA9IGo7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoRGF0YVtqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHBhdGhEYXRhW2pdLmNvbW1hbmQgPT09ICdNJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcDAgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogcGF0aERhdGFbal0ucG9pbnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHBhdGhEYXRhW2pdLnBvaW50c1sxXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZmluZFNlZ21lbnRUb0ZpdENoYXJhY3RlciA9IGZ1bmN0aW9uKGMpIHtcblxuICAgICAgICAgICAgICAgIHZhciBnbHlwaFdpZHRoID0gdGhhdC5fZ2V0VGV4dFNpemUoYykud2lkdGg7XG5cbiAgICAgICAgICAgICAgICB2YXIgY3VyckxlbiA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGF0dGVtcHRzID0gMDtcblxuICAgICAgICAgICAgICAgIHAxID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHdoaWxlKE1hdGguYWJzKGdseXBoV2lkdGggLSBjdXJyTGVuKSAvIGdseXBoV2lkdGggPiAwLjAxICYmIGF0dGVtcHRzIDwgMjUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdHMrKztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1bXVsYXRpdmVQYXRoTGVuZ3RoID0gY3VyckxlbjtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUocGF0aENtZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoQ21kID0gZ2V0TmV4dFBhdGhTZWdtZW50KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHBhdGhDbWQgJiYgY3VtdWxhdGl2ZVBhdGhMZW5ndGggKyBwYXRoQ21kLnBhdGhMZW5ndGggPCBnbHlwaFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VtdWxhdGl2ZVBhdGhMZW5ndGggKz0gcGF0aENtZC5wYXRoTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhDbWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihwYXRoQ21kID09PSB7fSB8fCBwMCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5lZWROZXdTZWdtZW50ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwYXRoQ21kLmNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKEtvbnZhLlBhdGguZ2V0TGluZUxlbmd0aChwMC54LCBwMC55LCBwYXRoQ21kLnBvaW50c1swXSwgcGF0aENtZC5wb2ludHNbMV0pID4gZ2x5cGhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMSA9IEtvbnZhLlBhdGguZ2V0UG9pbnRPbkxpbmUoZ2x5cGhXaWR0aCwgcDAueCwgcDAueSwgcGF0aENtZC5wb2ludHNbMF0sIHBhdGhDbWQucG9pbnRzWzFdLCBwMC54LCBwMC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhDbWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnQSc6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBwYXRoQ21kLnBvaW50c1s0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA0ID0gdGhldGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZFRoZXRhID0gcGF0aENtZC5wb2ludHNbNV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNSA9IGRUaGV0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSBwYXRoQ21kLnBvaW50c1s0XSArIGRUaGV0YTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRUID09PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgPSBzdGFydCArIDAuMDAwMDAwMDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgaW4gY2FzZSBzdGFydCBpcyAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihnbHlwaFdpZHRoID4gY3Vyckxlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCArPSAoTWF0aC5QSSAvIDE4MC4wKSAqIGRUaGV0YSAvIE1hdGguYWJzKGRUaGV0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCAtPSBNYXRoLlBJIC8gMzYwLjAgKiBkVGhldGEgLyBNYXRoLmFicyhkVGhldGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWRpdCBmb3IgYnVnIGZpeDogQHRoZXJ0aCBodHRwczovL2dpdGh1Yi5jb20vZXJpY2Ryb3dlbGwvS29udmFKUy9pc3N1ZXMvMjQ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2xkIGNvZGUgZmFpbGVkIHRvIHJlbmRlciB0ZXh0IGFsb25nIGFyYyBvZiB0aGlzIHBhdGg6IFwiTSA1MCA1MCBhIDE1MCA1MCAwIDAgMSAyNTAgNTAgbCA1MCAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihkVGhldGEgPCAwICYmIGN1cnJlbnRUIDwgZW5kIHx8IGRUaGV0YSA+PSAwICYmIGN1cnJlbnRUID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWVkTmV3U2VnbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAxID0gS29udmEuUGF0aC5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhwYXRoQ21kLnBvaW50c1swXSwgcGF0aENtZC5wb2ludHNbMV0sIHBhdGhDbWQucG9pbnRzWzJdLCBwYXRoQ21kLnBvaW50c1szXSwgY3VycmVudFQsIHBhdGhDbWQucG9pbnRzWzZdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRUID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGdseXBoV2lkdGggPiBwYXRoQ21kLnBhdGhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gMC4wMDAwMDAwMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gZ2x5cGhXaWR0aCAvIHBhdGhDbWQucGF0aExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGdseXBoV2lkdGggPiBjdXJyTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUICs9IChnbHlwaFdpZHRoIC0gY3VyckxlbikgLyBwYXRoQ21kLnBhdGhMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCAtPSAoY3VyckxlbiAtIGdseXBoV2lkdGgpIC8gcGF0aENtZC5wYXRoTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRUID4gMS4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWVkTmV3U2VnbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAxID0gS29udmEuUGF0aC5nZXRQb2ludE9uQ3ViaWNCZXppZXIoY3VycmVudFQsIHBhdGhDbWQuc3RhcnQueCwgcGF0aENtZC5zdGFydC55LCBwYXRoQ21kLnBvaW50c1swXSwgcGF0aENtZC5wb2ludHNbMV0sIHBhdGhDbWQucG9pbnRzWzJdLCBwYXRoQ21kLnBvaW50c1szXSwgcGF0aENtZC5wb2ludHNbNF0sIHBhdGhDbWQucG9pbnRzWzVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRUID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gZ2x5cGhXaWR0aCAvIHBhdGhDbWQucGF0aExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihnbHlwaFdpZHRoID4gY3Vyckxlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCArPSAoZ2x5cGhXaWR0aCAtIGN1cnJMZW4pIC8gcGF0aENtZC5wYXRoTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgLT0gKGN1cnJMZW4gLSBnbHlwaFdpZHRoKSAvIHBhdGhDbWQucGF0aExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50VCA+IDEuMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IDEuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZE5ld1NlZ21lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMSA9IEtvbnZhLlBhdGguZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllcihjdXJyZW50VCwgcGF0aENtZC5zdGFydC54LCBwYXRoQ21kLnN0YXJ0LnksIHBhdGhDbWQucG9pbnRzWzBdLCBwYXRoQ21kLnBvaW50c1sxXSwgcGF0aENtZC5wb2ludHNbMl0sIHBhdGhDbWQucG9pbnRzWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYocDEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyckxlbiA9IEtvbnZhLlBhdGguZ2V0TGluZUxlbmd0aChwMC54LCBwMC55LCBwMS54LCBwMS55KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKG5lZWROZXdTZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkTmV3U2VnbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aENtZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2hhckFyci5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgLy8gRmluZCBwMSBzdWNoIHRoYXQgbGluZSBzZWdtZW50IGJldHdlZW4gcDAgYW5kIHAxIGlzIGFwcHJveC4gd2lkdGggb2YgZ2x5cGhcbiAgICAgICAgICAgICAgICBmaW5kU2VnbWVudFRvRml0Q2hhcmFjdGVyKGNoYXJBcnJbaV0pO1xuXG4gICAgICAgICAgICAgICAgaWYocDAgPT09IHVuZGVmaW5lZCB8fCBwMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IEtvbnZhLlBhdGguZ2V0TGluZUxlbmd0aChwMC54LCBwMC55LCBwMS54LCBwMS55KTtcblxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IFNpbmNlIGdseXBocyBhcmUgcmVuZGVyZWQgb25lIGF0IGEgdGltZSwgYW55IGtlcm5pbmcgcGFpciBkYXRhIGJ1aWx0IGludG8gdGhlIGZvbnQgd2lsbCBub3QgYmUgdXNlZC5cbiAgICAgICAgICAgICAgICAvLyBDYW4gZm9yZXNlZSBoYXZpbmcgYSByb3VnaCBwYWlyIHRhYmxlIGJ1aWx0IGluIHRoYXQgdGhlIGRldmVsb3BlciBjYW4gb3ZlcnJpZGUgYXMgbmVlZGVkLlxuXG4gICAgICAgICAgICAgICAgdmFyIGtlcm4gPSAwO1xuICAgICAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVyIGZvciBmdXR1cmUgaW1wbGVtZW50YXRpb25cblxuICAgICAgICAgICAgICAgIHZhciBtaWRwb2ludCA9IEtvbnZhLlBhdGguZ2V0UG9pbnRPbkxpbmUoa2VybiArIHdpZHRoIC8gMi4wLCBwMC54LCBwMC55LCBwMS54LCBwMS55KTtcblxuICAgICAgICAgICAgICAgIHZhciByb3RhdGlvbiA9IE1hdGguYXRhbjIoKHAxLnkgLSBwMC55KSwgKHAxLnggLSBwMC54KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5nbHlwaEluZm8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9zZVg6IG1pZHBvaW50LngsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9zZVk6IG1pZHBvaW50LnksXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGNoYXJBcnJbaV0sXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiByb3RhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcDA6IHAwLFxuICAgICAgICAgICAgICAgICAgICBwMTogcDFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwMCA9IHAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRTZWxmUmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICAgICAgICB2YXIgZm9udFNpemUgPSB0aGlzLmZvbnRTaXplKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZ2x5cGhJbmZvLmZvckVhY2goZnVuY3Rpb24oaW5mbykge1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGluZm8ucDAueCk7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goaW5mby5wMC55KTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChpbmZvLnAxLngpO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGluZm8ucDEueSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBtaW5YID0gcG9pbnRzWzBdO1xuICAgICAgICAgICAgdmFyIG1heFggPSBwb2ludHNbMF07XG4gICAgICAgICAgICB2YXIgbWluWSA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIHZhciBtYXhZID0gcG9pbnRzWzBdO1xuICAgICAgICAgICAgdmFyIHgsIHk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICB4ID0gcG9pbnRzW2kgKiAyXTsgeSA9IHBvaW50c1tpICogMiArIDFdO1xuICAgICAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcbiAgICAgICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XG4gICAgICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuICAgICAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogTWF0aC5yb3VuZChtaW5YKSAtIGZvbnRTaXplLFxuICAgICAgICAgICAgICAgIHk6IE1hdGgucm91bmQobWluWSkgLSBmb250U2l6ZSxcbiAgICAgICAgICAgICAgICB3aWR0aDogTWF0aC5yb3VuZChtYXhYIC0gbWluWCkgKyBmb250U2l6ZSAqIDIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKG1heFkgLSBtaW5ZKSArIGZvbnRTaXplICogMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBtYXAgVGV4dFBhdGggbWV0aG9kcyB0byBUZXh0XG4gICAgS29udmEuVGV4dFBhdGgucHJvdG90eXBlLl9nZXRDb250ZXh0Rm9udCA9IEtvbnZhLlRleHQucHJvdG90eXBlLl9nZXRDb250ZXh0Rm9udDtcblxuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlRleHRQYXRoLCBLb252YS5TaGFwZSk7XG5cbiAgICAvLyBhZGQgc2V0dGVycyBhbmQgZ2V0dGVyc1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHRQYXRoLCAnZm9udEZhbWlseScsICdBcmlhbCcpO1xuXG4gICAgLyoqXG4gICAgICogc2V0IGZvbnQgZmFtaWx5XG4gICAgICogQG5hbWUgc2V0Rm9udEZhbWlseVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvbnRGYW1pbHlcbiAgICAgKi9cblxuICAgICAvKipcbiAgICAgKiBnZXQgZm9udCBmYW1pbHlcbiAgICAgKiBAbmFtZSBnZXRGb250RmFtaWx5XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHRQYXRoLCAnZm9udFNpemUnLCAxMik7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgZm9udCBzaXplXG4gICAgICogQG5hbWUgc2V0Rm9udFNpemVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7aW50fSBmb250U2l6ZVxuICAgICAqL1xuXG4gICAgIC8qKlxuICAgICAqIGdldCBmb250IHNpemVcbiAgICAgKiBAbmFtZSBnZXRGb250U2l6ZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0UGF0aCwgJ2ZvbnRTdHlsZScsIE5PUk1BTCk7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgZm9udCBzdHlsZS4gIENhbiBiZSAnbm9ybWFsJywgJ2l0YWxpYycsIG9yICdib2xkJy4gICdub3JtYWwnIGlzIHRoZSBkZWZhdWx0LlxuICAgICAqIEBuYW1lIHNldEZvbnRTdHlsZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvbnRTdHlsZVxuICAgICAqL1xuXG4gICAgIC8qKlxuICAgICAqIGdldCBmb250IHN0eWxlXG4gICAgICogQG5hbWUgZ2V0Rm9udFN0eWxlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHRQYXRoLCAnZm9udFZhcmlhbnQnLCBOT1JNQUwpO1xuXG4gICAgLyoqXG4gICAgICogc2V0IGZvbnQgdmFyaWFudC4gIENhbiBiZSAnbm9ybWFsJyBvciAnc21hbGwtY2FwcycuICAnbm9ybWFsJyBpcyB0aGUgZGVmYXVsdC5cbiAgICAgKiBAbmFtZSBzZXRGb250VmFyaWFudFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvbnRWYXJpYW50XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAZ2V0IGZvbnQgdmFyaWFudFxuICAgICAqIEBuYW1lIGdldEZvbnRWYXJpYW50XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyKEtvbnZhLlRleHRQYXRoLCAndGV4dCcsIEVNUFRZX1NUUklORyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGV4dFxuICAgICAqIEBuYW1lIGdldFRleHRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgICAqL1xuXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlRleHRQYXRoKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogUmVndWxhclBvbHlnb24gY29uc3RydWN0b3IuJm5ic3A7IEV4YW1wbGVzIGluY2x1ZGUgdHJpYW5nbGVzLCBzcXVhcmVzLCBwZW50YWdvbnMsIGhleGFnb25zLCBldGMuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuc2lkZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnJhZGl1c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgaGV4YWdvbiA9IG5ldyBLb252YS5SZWd1bGFyUG9seWdvbih7XG4gICAgICogICB4OiAxMDAsXG4gICAgICogICB5OiAyMDAsXG4gICAgICogICBzaWRlczogNixcbiAgICAgKiAgIHJhZGl1czogNzAsXG4gICAgICogICBmaWxsOiAncmVkJyxcbiAgICAgKiAgIHN0cm9rZTogJ2JsYWNrJyxcbiAgICAgKiAgIHN0cm9rZVdpZHRoOiA0XG4gICAgICogfSk7XG4gICAgICovXG4gICAgS29udmEuUmVndWxhclBvbHlnb24gPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLlJlZ3VsYXJQb2x5Z29uLnByb3RvdHlwZSA9IHtcbiAgICAgICAgX2NlbnRyb2lkOiB0cnVlLFxuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1JlZ3VsYXJQb2x5Z29uJztcbiAgICAgICAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBzaWRlcyA9IHRoaXMuYXR0cnMuc2lkZXMsXG4gICAgICAgICAgICAgICAgcmFkaXVzID0gdGhpcy5hdHRycy5yYWRpdXMsXG4gICAgICAgICAgICAgICAgbiwgeCwgeTtcblxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKDAsIDAgLSByYWRpdXMpO1xuXG4gICAgICAgICAgICBmb3IobiA9IDE7IG4gPCBzaWRlczsgbisrKSB7XG4gICAgICAgICAgICAgICAgeCA9IHJhZGl1cyAqIE1hdGguc2luKG4gKiAyICogTWF0aC5QSSAvIHNpZGVzKTtcbiAgICAgICAgICAgICAgICB5ID0gLTEgKiByYWRpdXMgKiBNYXRoLmNvcyhuICogMiAqIE1hdGguUEkgLyBzaWRlcyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJhZGl1cygpICogMjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0SGVpZ2h0KClcbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJhZGl1cygpICogMjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0V2lkdGgoKVxuICAgICAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmFkaXVzKCkgIT09IHdpZHRoIC8gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmFkaXVzKHdpZHRoIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldEhlaWdodCgpXG4gICAgICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRIZWlnaHQuY2FsbCh0aGlzLCBoZWlnaHQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmFkaXVzKCkgIT09IGhlaWdodCAvIDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJhZGl1cyhoZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuUmVndWxhclBvbHlnb24sIEtvbnZhLlNoYXBlKTtcblxuICAgIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5SZWd1bGFyUG9seWdvbiwgJ3JhZGl1cycsIDApO1xuXG4gICAgLyoqXG4gICAgICogc2V0IHJhZGl1c1xuICAgICAqIEBuYW1lIHNldFJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuUmVndWxhclBvbHlnb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgICAqL1xuXG4gICAgIC8qKlxuICAgICAqIGdldCByYWRpdXNcbiAgICAgKiBAbmFtZSBnZXRSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlJlZ3VsYXJQb2x5Z29uLnByb3RvdHlwZVxuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuUmVndWxhclBvbHlnb24sICdzaWRlcycsIDApO1xuXG4gICAgLyoqXG4gICAgICogc2V0IG51bWJlciBvZiBzaWRlc1xuICAgICAqIEBuYW1lIHNldFNpZGVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5SZWd1bGFyUG9seWdvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge2ludH0gc2lkZXNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIGdldCBudW1iZXIgb2Ygc2lkZXNcbiAgICAgKiBAbmFtZSBnZXRTaWRlc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuUmVndWxhclBvbHlnb24ucHJvdG90eXBlXG4gICAgICovXG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuUmVndWxhclBvbHlnb24pO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBTdGFyIGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gY29uZmlnLm51bVBvaW50c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuaW5uZXJSYWRpdXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLm91dGVyUmFkaXVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBzdGFyID0gbmV3IEtvbnZhLlN0YXIoe1xuICAgICAqICAgeDogMTAwLFxuICAgICAqICAgeTogMjAwLFxuICAgICAqICAgbnVtUG9pbnRzOiA1LFxuICAgICAqICAgaW5uZXJSYWRpdXM6IDcwLFxuICAgICAqICAgb3V0ZXJSYWRpdXM6IDcwLFxuICAgICAqICAgZmlsbDogJ3JlZCcsXG4gICAgICogICBzdHJva2U6ICdibGFjaycsXG4gICAgICogICBzdHJva2VXaWR0aDogNFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIEtvbnZhLlN0YXIgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLlN0YXIucHJvdG90eXBlID0ge1xuICAgICAgICBfY2VudHJvaWQ6IHRydWUsXG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAnU3Rhcic7XG4gICAgICAgICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgICAgICB9LFxuICAgICAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgaW5uZXJSYWRpdXMgPSB0aGlzLmlubmVyUmFkaXVzKCksXG4gICAgICAgICAgICAgICAgb3V0ZXJSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzKCksXG4gICAgICAgICAgICAgICAgbnVtUG9pbnRzID0gdGhpcy5udW1Qb2ludHMoKTtcblxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKDAsIDAgLSBvdXRlclJhZGl1cyk7XG5cbiAgICAgICAgICAgIGZvcih2YXIgbiA9IDE7IG4gPCBudW1Qb2ludHMgKiAyOyBuKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFkaXVzID0gbiAlIDIgPT09IDAgPyBvdXRlclJhZGl1cyA6IGlubmVyUmFkaXVzO1xuICAgICAgICAgICAgICAgIHZhciB4ID0gcmFkaXVzICogTWF0aC5zaW4obiAqIE1hdGguUEkgLyBudW1Qb2ludHMpO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gLTEgKiByYWRpdXMgKiBNYXRoLmNvcyhuICogTWF0aC5QSSAvIG51bVBvaW50cyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0V2lkdGgoKVxuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPdXRlclJhZGl1cygpICogMjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0SGVpZ2h0KClcbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE91dGVyUmFkaXVzKCkgKiAyO1xuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRXaWR0aCgpXG4gICAgICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0V2lkdGguY2FsbCh0aGlzLCB3aWR0aCk7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRlclJhZGl1cygpICE9PSB3aWR0aCAvIDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE91dGVyUmFkaXVzKHdpZHRoIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldEhlaWdodCgpXG4gICAgICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRIZWlnaHQuY2FsbCh0aGlzLCBoZWlnaHQpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0ZXJSYWRpdXMoKSAhPT0gaGVpZ2h0IC8gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0T3V0ZXJSYWRpdXMoaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlN0YXIsIEtvbnZhLlNoYXBlKTtcblxuICAgIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TdGFyLCAnbnVtUG9pbnRzJywgNSk7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgbnVtYmVyIG9mIHBvaW50c1xuICAgICAqIEBuYW1lIHNldE51bVBvaW50c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3Rhci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHBvaW50c1xuICAgICAqL1xuXG4gICAgIC8qKlxuICAgICAqIGdldCBudW1iZXIgb2YgcG9pbnRzXG4gICAgICogQG5hbWUgZ2V0TnVtUG9pbnRzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFyLnByb3RvdHlwZVxuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3RhciwgJ2lubmVyUmFkaXVzJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgaW5uZXIgcmFkaXVzXG4gICAgICogQG5hbWUgc2V0SW5uZXJSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgICAqL1xuXG4gICAgIC8qKlxuICAgICAqIGdldCBpbm5lciByYWRpdXNcbiAgICAgKiBAbmFtZSBnZXRJbm5lclJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3Rhci5wcm90b3R5cGVcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlN0YXIsICdvdXRlclJhZGl1cycsIDApO1xuXG4gICAgLyoqXG4gICAgICogc2V0IG91dGVyIHJhZGl1c1xuICAgICAqIEBuYW1lIHNldE91dGVyUmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcbiAgICAgKi9cblxuICAgICAvKipcbiAgICAgKiBnZXQgb3V0ZXIgcmFkaXVzXG4gICAgICogQG5hbWUgZ2V0T3V0ZXJSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YXIucHJvdG90eXBlXG4gICAgICovXG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuU3Rhcik7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIGNvbnN0YW50c1xuICAgIHZhciBBVFRSX0NIQU5HRV9MSVNUID0gWydmb250RmFtaWx5JywgJ2ZvbnRTaXplJywgJ2ZvbnRTdHlsZScsICdwYWRkaW5nJywgJ2xpbmVIZWlnaHQnLCAndGV4dCddLFxuICAgICAgICBDSEFOR0VfS09OVkEgPSAnQ2hhbmdlLmtvbnZhJyxcbiAgICAgICAgTk9ORSA9ICdub25lJyxcbiAgICAgICAgVVAgPSAndXAnLFxuICAgICAgICBSSUdIVCA9ICdyaWdodCcsXG4gICAgICAgIERPV04gPSAnZG93bicsXG4gICAgICAgIExFRlQgPSAnbGVmdCcsXG4gICAgICAgIExBQkVMID0gJ0xhYmVsJyxcblxuICAgICAvLyBjYWNoZWQgdmFyaWFibGVzXG4gICAgIGF0dHJDaGFuZ2VMaXN0TGVuID0gQVRUUl9DSEFOR0VfTElTVC5sZW5ndGg7XG5cbiAgICAvKipcbiAgICAgKiBMYWJlbCBjb25zdHJ1Y3Rvci4mbmJzcDsgTGFiZWxzIGFyZSBncm91cHMgdGhhdCBjb250YWluIGEgVGV4dCBhbmQgVGFnIHNoYXBlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBjcmVhdGUgbGFiZWxcbiAgICAgKiB2YXIgbGFiZWwgPSBuZXcgS29udmEuTGFiZWwoe1xuICAgICAqICAgeDogMTAwLFxuICAgICAqICAgeTogMTAwLFxuICAgICAqICAgZHJhZ2dhYmxlOiB0cnVlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBhZGQgYSB0YWcgdG8gdGhlIGxhYmVsXG4gICAgICogbGFiZWwuYWRkKG5ldyBLb252YS5UYWcoe1xuICAgICAqICAgZmlsbDogJyNiYmInLFxuICAgICAqICAgc3Ryb2tlOiAnIzMzMycsXG4gICAgICogICBzaGFkb3dDb2xvcjogJ2JsYWNrJyxcbiAgICAgKiAgIHNoYWRvd0JsdXI6IDEwLFxuICAgICAqICAgc2hhZG93T2Zmc2V0OiBbMTAsIDEwXSxcbiAgICAgKiAgIHNoYWRvd09wYWNpdHk6IDAuMixcbiAgICAgKiAgIGxpbmVKb2luOiAncm91bmQnLFxuICAgICAqICAgcG9pbnRlckRpcmVjdGlvbjogJ3VwJyxcbiAgICAgKiAgIHBvaW50ZXJXaWR0aDogMjAsXG4gICAgICogICBwb2ludGVySGVpZ2h0OiAyMCxcbiAgICAgKiAgIGNvcm5lclJhZGl1czogNVxuICAgICAqIH0pKTtcbiAgICAgKlxuICAgICAqIC8vIGFkZCB0ZXh0IHRvIHRoZSBsYWJlbFxuICAgICAqIGxhYmVsLmFkZChuZXcgS29udmEuVGV4dCh7XG4gICAgICogICB0ZXh0OiAnSGVsbG8gV29ybGQhJyxcbiAgICAgKiAgIGZvbnRTaXplOiA1MCxcbiAgICAgKiAgIGxpbmVIZWlnaHQ6IDEuMixcbiAgICAgKiAgIHBhZGRpbmc6IDEwLFxuICAgICAqICAgZmlsbDogJ2dyZWVuJ1xuICAgICAqICB9KSk7XG4gICAgICovXG4gICAgS29udmEuTGFiZWwgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5MYWJlbC5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9fX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgS29udmEuR3JvdXAuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBMQUJFTDtcblxuICAgICAgICAgICAgdGhpcy5vbignYWRkLmtvbnZhJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAgICAgdGhhdC5fYWRkTGlzdGVuZXJzKGV2dC5jaGlsZCk7XG4gICAgICAgICAgICAgICAgdGhhdC5fc3luYygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgVGV4dCBzaGFwZSBmb3IgdGhlIGxhYmVsLiAgWW91IG5lZWQgdG8gYWNjZXNzIHRoZSBUZXh0IHNoYXBlIGluIG9yZGVyIHRvIHVwZGF0ZVxuICAgICAgICAgKiB0aGUgdGV4dCBwcm9wZXJ0aWVzXG4gICAgICAgICAqIEBuYW1lIGdldFRleHRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTGFiZWwucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRUZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmQoJ1RleHQnKVswXTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBUYWcgc2hhcGUgZm9yIHRoZSBsYWJlbC4gIFlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgVGFnIHNoYXBlIGluIG9yZGVyIHRvIHVwZGF0ZVxuICAgICAgICAgKiB0aGUgcG9pbnRlciBwcm9wZXJ0aWVzIGFuZCB0aGUgY29ybmVyIHJhZGl1c1xuICAgICAgICAgKiBAbmFtZSBnZXRUYWdcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTGFiZWwucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRUYWc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZCgnVGFnJylbMF07XG4gICAgICAgIH0sXG4gICAgICAgIF9hZGRMaXN0ZW5lcnM6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBuO1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9zeW5jKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHRleHQgZGF0YSBmb3IgY2VydGFpbiBhdHRyIGNoYW5nZXNcbiAgICAgICAgICAgIGZvcihuID0gMDsgbiA8IGF0dHJDaGFuZ2VMaXN0TGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICB0ZXh0Lm9uKEFUVFJfQ0hBTkdFX0xJU1Rbbl0gKyBDSEFOR0VfS09OVkEsIGZ1bmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUZXh0KCkuZ2V0V2lkdGgoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRleHQoKS5nZXRIZWlnaHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3N5bmM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLmdldFRleHQoKSxcbiAgICAgICAgICAgICAgICB0YWcgPSB0aGlzLmdldFRhZygpLFxuICAgICAgICAgICAgICAgIHdpZHRoLCBoZWlnaHQsIHBvaW50ZXJEaXJlY3Rpb24sIHBvaW50ZXJXaWR0aCwgeCwgeSwgcG9pbnRlckhlaWdodDtcblxuICAgICAgICAgICAgaWYgKHRleHQgJiYgdGFnKSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSB0ZXh0LmdldFdpZHRoKCk7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGV4dC5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgICAgICBwb2ludGVyRGlyZWN0aW9uID0gdGFnLmdldFBvaW50ZXJEaXJlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBwb2ludGVyV2lkdGggPSB0YWcuZ2V0UG9pbnRlcldpZHRoKCk7XG4gICAgICAgICAgICAgICAgcG9pbnRlckhlaWdodCA9IHRhZy5nZXRQb2ludGVySGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgICAgICAgeSA9IDA7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2gocG9pbnRlckRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFVQOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSAtMSAqIHBvaW50ZXJIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBSSUdIVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSB3aWR0aCArIHBvaW50ZXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBoZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRE9XTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gaGVpZ2h0ICsgcG9pbnRlckhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExFRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gLTEgKiBwb2ludGVyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRhZy5zZXRBdHRycyh7XG4gICAgICAgICAgICAgICAgICAgIHg6IC0xICogeCxcbiAgICAgICAgICAgICAgICAgICAgeTogLTEgKiB5LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0ZXh0LnNldEF0dHJzKHtcbiAgICAgICAgICAgICAgICAgICAgeDogLTEgKiB4LFxuICAgICAgICAgICAgICAgICAgICB5OiAtMSAqIHlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5MYWJlbCwgS29udmEuR3JvdXApO1xuXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLkxhYmVsKTtcblxuICAgIC8qKlxuICAgICAqIFRhZyBjb25zdHJ1Y3Rvci4mbmJzcDsgQSBUYWcgY2FuIGJlIGNvbmZpZ3VyZWRcbiAgICAgKiAgdG8gaGF2ZSBhIHBvaW50ZXIgZWxlbWVudCB0aGF0IHBvaW50cyB1cCwgcmlnaHQsIGRvd24sIG9yIGxlZnRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcucG9pbnRlckRpcmVjdGlvbl0gY2FuIGJlIHVwLCByaWdodCwgZG93biwgbGVmdCwgb3Igbm9uZTsgdGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbm9uZS4gIFdoZW4gYSBwb2ludGVyIGlzIHByZXNlbnQsIHRoZSBwb3NpdGlvbmluZyBvZiB0aGUgbGFiZWwgaXMgcmVsYXRpdmUgdG8gdGhlIHRpcCBvZiB0aGUgcG9pbnRlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5wb2ludGVyV2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucG9pbnRlckhlaWdodF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jb3JuZXJSYWRpdXNdXG4gICAgICovXG4gICAgS29udmEuVGFnID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5UYWcucHJvdG90eXBlID0ge1xuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1RhZyc7XG4gICAgICAgICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgICAgICB9LFxuICAgICAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKSxcbiAgICAgICAgICAgICAgICBwb2ludGVyRGlyZWN0aW9uID0gdGhpcy5nZXRQb2ludGVyRGlyZWN0aW9uKCksXG4gICAgICAgICAgICAgICAgcG9pbnRlcldpZHRoID0gdGhpcy5nZXRQb2ludGVyV2lkdGgoKSxcbiAgICAgICAgICAgICAgICBwb2ludGVySGVpZ2h0ID0gdGhpcy5nZXRQb2ludGVySGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgY29ybmVyUmFkaXVzID0gTWF0aC5taW4odGhpcy5nZXRDb3JuZXJSYWRpdXMoKSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcblxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGlmICghY29ybmVyUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKGNvcm5lclJhZGl1cywgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb2ludGVyRGlyZWN0aW9uID09PSBVUCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKCh3aWR0aCAtIHBvaW50ZXJXaWR0aCkgLyAyLCAwKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCAvIDIsIC0xICogcG9pbnRlckhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oKHdpZHRoICsgcG9pbnRlcldpZHRoKSAvIDIsIDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZighY29ybmVyUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGgsIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCAtIGNvcm5lclJhZGl1cywgMCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5hcmMod2lkdGggLSBjb3JuZXJSYWRpdXMsIGNvcm5lclJhZGl1cywgY29ybmVyUmFkaXVzLCBNYXRoLlBJICogMyAvIDIsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvaW50ZXJEaXJlY3Rpb24gPT09IFJJR0hUKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGgsIChoZWlnaHQgLSBwb2ludGVySGVpZ2h0KSAvIDIpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoICsgcG9pbnRlcldpZHRoLCBoZWlnaHQgLyAyKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCwgKGhlaWdodCArIHBvaW50ZXJIZWlnaHQpIC8gMik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCFjb3JuZXJSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGgsIGhlaWdodCAtIGNvcm5lclJhZGl1cyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5hcmMod2lkdGggLSBjb3JuZXJSYWRpdXMsIGhlaWdodCAtIGNvcm5lclJhZGl1cywgY29ybmVyUmFkaXVzLCAwLCBNYXRoLlBJIC8gMiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9pbnRlckRpcmVjdGlvbiA9PT0gRE9XTikge1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKCh3aWR0aCArIHBvaW50ZXJXaWR0aCkgLyAyLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoIC8gMiwgaGVpZ2h0ICsgcG9pbnRlckhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oKHdpZHRoIC0gcG9pbnRlcldpZHRoKSAvIDIsIGhlaWdodCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCFjb3JuZXJSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbygwLCBoZWlnaHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhjb3JuZXJSYWRpdXMsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5hcmMoY29ybmVyUmFkaXVzLCBoZWlnaHQgLSBjb3JuZXJSYWRpdXMsIGNvcm5lclJhZGl1cywgTWF0aC5QSSAvIDIsIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvaW50ZXJEaXJlY3Rpb24gPT09IExFRlQpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbygwLCAoaGVpZ2h0ICsgcG9pbnRlckhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbygtMSAqIHBvaW50ZXJXaWR0aCwgaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oMCwgKGhlaWdodCAtIHBvaW50ZXJIZWlnaHQpIC8gMik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGNvcm5lclJhZGl1cykge1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDAsIGNvcm5lclJhZGl1cyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5hcmMoY29ybmVyUmFkaXVzLCBjb3JuZXJSYWRpdXMsIGNvcm5lclJhZGl1cywgTWF0aC5QSSwgTWF0aC5QSSAqIDMgLyAyLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U2VsZlJlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHggPSAwLFxuICAgICAgICAgICAgICAgIHkgPSAwLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJXaWR0aCA9IHRoaXMuZ2V0UG9pbnRlcldpZHRoKCksXG4gICAgICAgICAgICAgICAgcG9pbnRlckhlaWdodCA9IHRoaXMuZ2V0UG9pbnRlckhlaWdodCgpLFxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IHRoaXMucG9pbnRlckRpcmVjdGlvbigpLFxuICAgICAgICAgICAgICAgIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IFVQKSB7XG4gICAgICAgICAgICAgICAgeSAtPSBwb2ludGVySGVpZ2h0O1xuICAgICAgICAgICAgICAgIGhlaWdodCArPSBwb2ludGVySGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IERPV04pIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgKz0gcG9pbnRlckhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBMRUZUKSB7XG4gICAgICAgICAgICAgICAgLy8gQVJHSCEhISBJIGhhdmUgbm8gaWRlYSB3aHkgc2hvdWxkIEkgdXNlZCBtYWdpYyAxLjUhISEhISEhISFcbiAgICAgICAgICAgICAgICB4IC09IHBvaW50ZXJXaWR0aCAqIDEuNTtcbiAgICAgICAgICAgICAgICB3aWR0aCArPSBwb2ludGVyV2lkdGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gUklHSFQpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCArPSBwb2ludGVyV2lkdGggKiAxLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuVGFnLCBLb252YS5TaGFwZSk7XG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGFnLCAncG9pbnRlckRpcmVjdGlvbicsIE5PTkUpO1xuXG4gICAgLyoqXG4gICAgICogc2V0IHBvaW50ZXIgRGlyZWN0aW9uXG4gICAgICogQG5hbWUgc2V0UG9pbnRlckRpcmVjdGlvblxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGFnLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwb2ludGVyRGlyZWN0aW9uIGNhbiBiZSB1cCwgcmlnaHQsIGRvd24sIGxlZnQsIG9yIG5vbmUuICBUaGVcbiAgICAgKiAgZGVmYXVsdCBpcyBub25lXG4gICAgICovXG5cbiAgICAgLyoqXG4gICAgICogZ2V0IHBvaW50ZXIgRGlyZWN0aW9uXG4gICAgICogQG5hbWUgZ2V0UG9pbnRlckRpcmVjdGlvblxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGFnLnByb3RvdHlwZVxuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGFnLCAncG9pbnRlcldpZHRoJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgcG9pbnRlciB3aWR0aFxuICAgICAqIEBuYW1lIHNldFBvaW50ZXJXaWR0aFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGFnLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludGVyV2lkdGhcbiAgICAgKi9cblxuICAgICAvKipcbiAgICAgKiBnZXQgcG9pbnRlciB3aWR0aFxuICAgICAqIEBuYW1lIGdldFBvaW50ZXJXaWR0aFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGFnLnByb3RvdHlwZVxuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGFnLCAncG9pbnRlckhlaWdodCcsIDApO1xuXG4gICAgLyoqXG4gICAgICogc2V0IHBvaW50ZXIgaGVpZ2h0XG4gICAgICogQG5hbWUgc2V0UG9pbnRlckhlaWdodFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGFnLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludGVySGVpZ2h0XG4gICAgICovXG5cbiAgICAgLyoqXG4gICAgICogZ2V0IHBvaW50ZXIgaGVpZ2h0XG4gICAgICogQG5hbWUgZ2V0UG9pbnRlckhlaWdodFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGFnLnByb3RvdHlwZVxuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGFnLCAnY29ybmVyUmFkaXVzJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgY29ybmVyIHJhZGl1c1xuICAgICAqIEBuYW1lIHNldENvcm5lclJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGFnLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3JuZXIgcmFkaXVzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBnZXQgY29ybmVyIHJhZGl1c1xuICAgICAqIEBuYW1lIGdldENvcm5lclJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGFnLnByb3RvdHlwZVxuICAgICAqL1xuXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlRhZyk7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qKlxuICAgICAqIEFycm93IGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZy5wb2ludHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy50ZW5zaW9uXSBIaWdoZXIgdmFsdWVzIHdpbGwgcmVzdWx0IGluIGEgbW9yZSBjdXJ2eSBsaW5lLiAgQSB2YWx1ZSBvZiAwIHdpbGwgcmVzdWx0IGluIG5vIGludGVycG9sYXRpb24uXG4gICAgICogICBUaGUgZGVmYXVsdCBpcyAwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5wb2ludGVyTGVuZ3RoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5wb2ludGVyV2lkdGhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGxpbmUgPSBuZXcgS29udmEuTGluZSh7XG4gICAgICogICBwb2ludHM6IFs3MywgNzAsIDM0MCwgMjMsIDQ1MCwgNjAsIDUwMCwgMjBdLFxuICAgICAqICAgc3Ryb2tlOiAncmVkJyxcbiAgICAgKiAgIHRlbnNpb246IDEsXG4gICAgICogICBwb2ludGVyTGVuZ3RoIDogMTAsXG4gICAgICogICBwb2ludGVyV2lkdGggOiAxMlxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIEtvbnZhLkFycm93ID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19fX2luaXQoY29uZmlnKTtcbiAgICB9O1xuXG4gICAgS29udmEuQXJyb3cucHJvdG90eXBlID0ge1xuICAgICAgICBfX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICBLb252YS5MaW5lLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ0Fycm93JztcbiAgICAgICAgfSxcbiAgICAgICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICBLb252YS5MaW5lLnByb3RvdHlwZS5fc2NlbmVGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMoKTtcbiAgICAgICAgICAgIHZhciBuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBkeCA9IHBvaW50c1tuIC0gMl0gLSBwb2ludHNbbiAtIDRdO1xuICAgICAgICAgICAgdmFyIGR5ID0gcG9pbnRzW24gLSAxXSAtIHBvaW50c1tuIC0gM107XG4gICAgICAgICAgICB2YXIgcmFkaWFucyA9IChNYXRoLmF0YW4yKGR5LCBkeCkgKyBQSTIpICUgUEkyO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMucG9pbnRlckxlbmd0aCgpO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5wb2ludGVyV2lkdGgoKTtcblxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUocG9pbnRzW24gLSAyXSwgcG9pbnRzW24gLSAxXSk7XG4gICAgICAgICAgICBjdHgucm90YXRlKHJhZGlhbnMpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oLWxlbmd0aCwgd2lkdGggLyAyKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oLWxlbmd0aCwgLXdpZHRoIC8gMik7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5wb2ludGVyQXRCZWdpbm5pbmcoKSkge1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgICAgICAgICAgICAgZHggPSBwb2ludHNbMl0gLSBwb2ludHNbMF07XG4gICAgICAgICAgICAgICAgZHkgPSBwb2ludHNbM10gLSBwb2ludHNbMV07XG4gICAgICAgICAgICAgICAgY3R4LnJvdGF0ZSgoTWF0aC5hdGFuMigtZHksIC1keCkgKyBQSTIpICUgUEkyKTtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKDAsIDApO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oLWxlbmd0aCwgd2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKC1sZW5ndGgsIC13aWR0aCAvIDIpO1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5BcnJvdywgS29udmEuTGluZSk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBwb2ludGVyTGVuZ3RoXG4gICAgICogQG5hbWUgcG9pbnRlckxlbmd0aFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQXJyb3cucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IExlbmd0aCBvZiBwb2ludGVyIG9mIGFycm93LlxuICAgICAqICAgVGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCB0ZW5zaW9uXG4gICAgICogdmFyIHBvaW50ZXJMZW5ndGggPSBsaW5lLnBvaW50ZXJMZW5ndGgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCB0ZW5zaW9uXG4gICAgICogbGluZS5wb2ludGVyTGVuZ3RoKDE1KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkFycm93LCAncG9pbnRlckxlbmd0aCcsIDEwKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHBvaW50ZXJXaWR0aFxuICAgICAqIEBuYW1lIHBvaW50ZXJXaWR0aFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQXJyb3cucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFdpZHRoIG9mIHBvaW50ZXIgb2YgYXJyb3cuXG4gICAgICogICBUaGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHRlbnNpb25cbiAgICAgKiB2YXIgcG9pbnRlcldpZHRoID0gbGluZS5wb2ludGVyV2lkdGgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCB0ZW5zaW9uXG4gICAgICogbGluZS5wb2ludGVyV2lkdGgoMTUpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQXJyb3csICdwb2ludGVyV2lkdGgnLCAxMCk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBwb2ludGVyQXRCZWdpbm5pbmdcbiAgICAgKiBAbmFtZSBwb2ludGVyQXRCZWdpbm5pbmdcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkFycm93LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBTaG91bGQgcG9pbnRlciBkaXNwbGF5ZWQgYXQgYmVnaW5uaW5nIG9mIGFycm93LlxuICAgICAqICAgVGhlIGRlZmF1bHQgaXMgZmFsc2UuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgdGVuc2lvblxuICAgICAqIHZhciBwb2ludGVyQXRCZWdpbm5pbmcgPSBsaW5lLnBvaW50ZXJBdEJlZ2lubmluZygpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHRlbnNpb25cbiAgICAgKiBsaW5lLnBvaW50ZXJBdEJlZ2lubmluZyh0cnVlKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkFycm93LCAncG9pbnRlckF0QmVnaW5uaW5nJywgZmFsc2UpO1xuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5BcnJvdyk7XG5cbn0pKCk7XG5cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IDA7XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZW1pdHRlci5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSAxO1xuICBlbHNlXG4gICAgcmV0ID0gZW1pdHRlci5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIl19
