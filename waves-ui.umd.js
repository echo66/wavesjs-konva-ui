(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.wavesUI = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _shapesSegment = require('../shapes/segment');

var _shapesSegment2 = _interopRequireDefault(_shapesSegment);

var _behaviorsBaseBehavior = require('../behaviors/base-behavior');

var _behaviorsBaseBehavior2 = _interopRequireDefault(_behaviorsBaseBehavior);

/**
 * Simplified Layer for Axis. The main difference with a regular layer is that
 * an axis layer use the `Timeline~timeContext` attributes to render it's layout
 * and stay synchronized with the tracks visible area. All getters and setters
 * to the `TimelineTimeContext` attributes are bypassed.
 *
 * It also handle it's own data and its updates. The `_generateData` method is
 * responsible to create some usefull data to visualize
 *
 * [example usage of the layer-axis](./examples/layer-axis.html)
 */

var AxisLayer = (function (_Layer) {
  _inherits(AxisLayer, _Layer);

  /**
   * @param {Function} generator - A function to create data according to
   *    the `Timeline~timeContext`.
   * @param {Object} options - Layer options, cf. Layer for available options.
   */

  function AxisLayer(generator, options) {
    var _this = this;

    _classCallCheck(this, AxisLayer);

    _get(Object.getPrototypeOf(AxisLayer.prototype), 'constructor', this).call(this, 'entity', [], options);
    this._generator = generator;

    this._contextShape = new _shapesSegment2['default']({});
    this._contextShape.install({
      opacity: function opacity() {
        return 1;
      },
      color: function color() {
        return _this.params.context.color;
      },
      width: function width() {
        return _this.timeContext.visibleDuration;
      },
      height: function height() {
        return _this._renderingContext.valueToPixel.domain()[1];
      },
      y: function y() {
        return _this._renderingContext.valueToPixel.domain()[0];
      },
      x: function x() {
        return -_this.timeContext.offset;
      }
    });
    this._contextShape.params.handlerWidth = this.params.context.handlerWidth;
    this._contextShape.render(this._renderingContext);
    this._contextShape.layer = this;
    for (var i = 0; i < this._contextShape.$el.length; i++) {
      this._contextLayer.add(this._contextShape.$el[i]);
    }

    this.setBehavior(new _behaviorsBaseBehavior2['default']());
  }

  /** @private */

  _createClass(AxisLayer, [{
    key: '_generateData',

    /**
     * This method is the main difference with a classical layer. An `AxisLayer`
     * instance generates and maintains it's own data.
     */
    value: function _generateData() {
      var that = this;
      this.contentLayers.forEach(function (l) {
        // Hacked this to make it work.
        l.destroy();
        that.contentLayers['delete'](l);
      });
      var data = this._generator(this.timeContext);
      // this.remove(this.data);
      this.set([data]);
    }

    /**
     * Generates the data and update the layer.
     */
  }, {
    key: 'update',
    value: function update() {
      this._generateData();
      _get(Object.getPrototypeOf(AxisLayer.prototype), 'update', this).call(this);
    }
  }, {
    key: 'updateContainer',
    value: function updateContainer() {
      this._updateRenderingContext();
    }
  }, {
    key: 'updateShapes',
    value: function updateShapes() {
      var changedContentLayers = new _Set();
      var that = this;

      this.allocateShapesToContentLayers(this._stage, this.data, 'datums', true).forEach(function (changedContentLayer) {
        changedContentLayers.add(changedContentLayer);
      });

      changedContentLayers.forEach(function (changedContentLayer) {
        changedContentLayer.y(that.params.top).offsetX(0);
        changedContentLayer.clear();
        changedContentLayer.batchDraw();
      });

      this._contextShape.update(this._renderingContext, this.timeContext);

      this._contextLayer.y(that.params.top).batchDraw().moveToBottom();
    }

    /**
     * Updates the rendering context for the shapes.
     */
  }, {
    key: '_updateRenderingContext',
    value: function _updateRenderingContext() {
      this._renderingContext.timeToPixel = this.timeContext.timeToPixel;
      this._renderingContext.valueToPixel = this._valueToPixel;

      this._renderingContext.height = this.params.height;
      this._renderingContext.width = this.timeContext.timeToPixel(this.timeContext.visibleDuration);

      // for foreign object issue in chrome
      this._renderingContext.offsetX = this.timeContext.timeToPixel(this.timeContext.offset);

      // expose some timeline attributes - allow to improve perf in some cases - cf. Waveform
      this._renderingContext.trackOffsetX = this.timeContext.timeToPixel(this.timeContext.offset);
      this._renderingContext.visibleWidth = this.timeContext.visibleWidth;
    }
  }, {
    key: 'visible_data',
    value: function visible_data(timeContext, data) {
      return undefined;
    }
  }, {
    key: 'sort_data',
    value: function sort_data(data) {}
  }, {
    key: 'stretchRatio',
    set: function set(value) {
      return;
    },

    /** @private */

    /** @private */
    get: function get() {
      return;
    }

    /** @private */
  }, {
    key: 'offset',
    set: function set(value) {
      return;
    },

    /** @private */
    get: function get() {
      return;
    }

    /** @private */
  }, {
    key: 'start',
    set: function set(value) {
      return;
    },

    /** @private */
    get: function get() {
      return;
    }

    /** @private */
  }, {
    key: 'duration',
    set: function set(value) {
      return;
    },
    get: function get() {
      return;
    }

    /**
     * The generator that creates the data to be rendered to display the axis.
     *
     * @type {Function}
     */
  }, {
    key: 'generator',
    set: function set(func) {
      this._generator = func;
    },

    /**
     * The generator that creates the data to be rendered to display the axis.
     *
     * @type {Function}
     */
    get: function get() {
      return this._generator;
    }
  }]);

  return AxisLayer;
})(_coreLayer2['default']);

exports['default'] = AxisLayer;

module.exports = AxisLayer;
module.exports = exports['default'];

},{"../behaviors/base-behavior":4,"../core/layer":17,"../shapes/segment":47,"babel-runtime/core-js/set":77,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],2:[function(require,module,exports){
'use strict';

/**
 * A generator to create data for grid axis according to a `bpm` and a `meter`.
 *
 * [example usage](./examples/layer-axis.html)
 *
 * @param {Number} bpm - The number of beats per minutes.
 * @param {String} signature - The meter of the mesure (`'4/4'`, `'3/8'`, ...).
 * @return {Function} - The configured function returning the data when called.
 */
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = gridAxisGenerator;

function gridAxisGenerator(bpm, signature) {
  var _bps = bpm / 60; // sec
  var _unit = 1 / parseInt(signature.split('/')[1], 10);
  var _nbrUnitsPerMesure = parseInt(signature.split('/')[0], 10);

  return function (timeContext) {
    var duration = timeContext.visibleDuration;
    var offset = timeContext.offset;
    var data = [];

    // const min = Math.min(-offset, 0);
    var min = -offset;
    // remove the timeline's offset to keep the layer centered
    var max = duration - offset;

    // define pixels for 1 second
    var pixelsPerSecond = timeContext.computedPixelsPerSecond;
    // time for one _unit
    var unitTime = 1 / _bps;
    // define the first tick > min
    var modulo = min % unitTime;
    var mult = (min - modulo) / unitTime;
    var firstTickTime = unitTime * mult;
    // track which position of current beat in the mesure
    var positionInMesure = mult % _nbrUnitsPerMesure;

    // remove not focused beats, if zoomed out
    var pixelsPerTick = pixelsPerSecond / _bps;
    var minStep = 5;

    // time should be
    for (var time = firstTickTime; time < max; time += unitTime) {
      // find first beat
      var focused = positionInMesure++ % _nbrUnitsPerMesure === 0;
      // ignore if pixels per ticks is too small
      if (pixelsPerTick <= minStep && !focused) {
        continue;
      }

      data.push({ time: time, focused: focused });
    }

    return data;
  };
}

module.exports = gridAxisGenerator;
module.exports = exports['default'];

},{}],3:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = timeAxisGenerator;

var _utilsFormat = require('../utils/format');

/**
 * A generator to create data for time axis.
 *
 * [example usage](./examples/layer-axis.html)
 *
 * @return {Function} - The configured function returning the data when called.
 */

function timeAxisGenerator() {
  // add factory to share API with bpmGenerator
  return function (timeContext) {
    var duration = timeContext.visibleDuration;
    var offset = timeContext.offset;
    var data = [];

    // const min = Math.min(-offset, 0);
    var min = -offset;
    // remove the timeline's offset to keep the layer centered
    var max = duration - offset;

    // define pixels for 1 second
    var pixelsPerSecond = timeContext.computedPixelsPerSecond;
    var minStep = 7;

    // define all display information according to the pixelsPerSecond ratio
    var step = undefined,
        type = undefined,
        toFixed = undefined,
        markerModulo = undefined,
        includeModulo = undefined;

    if (pixelsPerSecond * 4 > minStep) {
      step = 1; // the step to use to compute time
      toFixed = 0;
      markerModulo = 60; // a timestamp every 5 stepixelsPerSecond
      includeModulo = 5; // a tick every 5 stepixelsPerSecond
      type = '60sec';
    }

    if (pixelsPerSecond * 2 > minStep) {
      step = 1;
      toFixed = 0;
      markerModulo = 30;
      includeModulo = 1;
      type = '30sec';
    }

    if (pixelsPerSecond > minStep) {
      step = 1;
      toFixed = 0;
      markerModulo = 10;
      includeModulo = 1;
      type = 'sec';
    }

    if (pixelsPerSecond / 10 > minStep) {
      step = 1 / 10;
      toFixed = 1;
      markerModulo = 10;
      includeModulo = 1;
      type = 'ds';
    }

    if (pixelsPerSecond / 100 > minStep) {
      step = 1 / 100;
      toFixed = 2;
      markerModulo = 10;
      includeModulo = 1;
      type = 'cs';
    }

    if (pixelsPerSecond / 1000 > minStep) {
      step = 1 / 1000;
      toFixed = 3;
      markerModulo = 10;
      includeModulo = 1;
      type = 'ms';
    }

    for (var time = min; time < max; time += step) {
      var formattedTime = time.toFixed(toFixed);

      if (Math.round(formattedTime / step) % includeModulo !== 0) {
        continue;
      }

      // avoid floating point errors
      var focused = Math.round(formattedTime / step) % markerModulo === 0 ? true : false;

      var datum = { time: formattedTime, focused: focused };

      if (focused === true) {
        var date = new Date(1000 * formattedTime);
        var _min = (0, _utilsFormat.padLeft)(date.getMinutes(), 0, 2);
        var sec = (0, _utilsFormat.padLeft)(date.getSeconds(), 0, 2);
        var milli = (0, _utilsFormat.padLeft)(date.getMilliseconds(), 0, 3);
        var label = _min + ':' + sec + ':' + milli;

        datum.label = label;
      }

      data.push(datum);
    }

    return data;
  };
}

module.exports = timeAxisGenerator;
module.exports = exports['default'];

},{"../utils/format":64}],4:[function(require,module,exports){
'use strict';

/**
 * Is an abstract class or interface to be overriden in order to define the way
 * a given shape should behave when selected or edited by a user. Instances of
 * `BaseBehavior` are internally used by `Layer` instances to modify the data
 * according to a user interaction and a given shape. A single instance of
 * `Behavior` is created in one given shape.
 *
 * By default, the only method to override to define a new behavior for a
 * shape is the `edit` method. However, if needed in special cases, all the
 * selection handling can be overriden too.
 *
 * The flow is the following:
 * `Event`  - (forwarded to) -> `Layer` - (command) -> `Behavior` - (modify) -> `data` - (upates) -> `Shape`
 *
 * The behavior responsability is then to modify the data according to the
 * user interactions, while shapes are always a view of the current state of the
 * data.
 */

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var BaseBehavior = (function () {
  function BaseBehavior() {
    _classCallCheck(this, BaseBehavior);

    this._selectedDatums = new _Set(); // no duplicate in Set
    this._selectedClass = null;
    this._layer = null;
  }

  _createClass(BaseBehavior, [{
    key: 'initialize',
    value: function initialize(layer) {
      this._layer = layer;
      this._selectedClass = layer.params.selectedClassName;
    }

    /**
     * Destroy the references to the selected datums.
     *
     * @type {String}
     * @todo - rename to `clearSelection` (removing the class) ?
     */
  }, {
    key: 'destroy',
    value: function destroy() {
      this._selectedDatums.clear();
    }

    /**
     * The class to add to the shapes when selected.
     *
     * @type {String}
     */
  }, {
    key: 'select',

    /**
     * @param {Object} datum - The datum to select.
     * @todo - Pass the shape object to get the accessors ?
     */
    value: function select(datum) {
      // $item.classList.add(this.selectedClass);
      this._selectedDatums.add(datum);
    }

    /**
     * @param {Object} datum - The datum to unselect.
     * @todo - Pass the shape object to get the accessors ?
     */
  }, {
    key: 'unselect',
    value: function unselect(datum) {
      // $item.classList.remove(this.selectedClass);
      this._selectedDatums['delete'](datum);
    }

    /**
     * @param {Object} datum - The datum to toggle selection.
     * @todo - Pass the shape object to get the accessors ?
     */
  }, {
    key: 'toggleSelection',
    value: function toggleSelection(datum) {
      var method = this._selectedDatums.has(datum) ? 'unselect' : 'select';
      this[method](datum);
    }

    /**
     * Interface method to override in order to define its particular behavior when
     * interacted with.
     *
     * @param {Object} renderingContext - The layer rendering context.
     * @param {BaseShape} shape - The shape object to be edited.
     * @param {Object|Array} datum - The related datum to modify.
     * @param {Number} dx - The value of the interaction in the x axis (in pixels).
     * @param {Number} dy - The value of the interaction in the y axis (in pixels).
     * @param {Element} $target - The target DOM element of the interaction.
     */
  }, {
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, $target) {}
    // must be implemented in children

    /**
     * TODO: possible actions are 'add', 'remove', 'edit', 'minimize', 'highlight', 'select', 'unselect'.
     */

  }, {
    key: 'can',
    value: function can(action, datums) {
      return true;
    }

    /**
     * TODO
     */
  }, {
    key: 'create',
    value: function create(datum) {}

    /**
     * TODO
     */
  }, {
    key: 'remove',
    value: function remove(datum) {}

    /**
     * TODO
     */
  }, {
    key: 'minimize',
    value: function minimize() {}

    /**
     * TODO
     */
  }, {
    key: 'highlight',
    value: function highlight(datum, isHighlighted) {}
  }, {
    key: 'selectedClass',
    set: function set(value) {
      this._selectedClass = value;
    },

    /**
     * The class to add to the shapes when selected.
     *
     * @type {String}
     */
    get: function get() {
      return this._selectedClass;
    }

    /**
     * An array containing all the selected datums of the layer.
     *
     * @type {Array}
     */
  }, {
    key: 'selectedDatums',
    get: function get() {
      return this._selectedDatums;
    }
  }]);

  return BaseBehavior;
})();

exports['default'] = BaseBehavior;
module.exports = exports['default'];

},{"babel-runtime/core-js/set":77,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81}],5:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

var BeatGridSnapSegmentBehavior = (function (_BaseBehavior) {
  _inherits(BeatGridSnapSegmentBehavior, _BaseBehavior);

  function BeatGridSnapSegmentBehavior(beatGrid) {
    _classCallCheck(this, BeatGridSnapSegmentBehavior);

    _get(Object.getPrototypeOf(BeatGridSnapSegmentBehavior.prototype), 'constructor', this).call(this);
    this._beatGrid = beatGrid;
  }

  _createClass(BeatGridSnapSegmentBehavior, [{
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, target) {
      var action = 'move';

      if (target.hasName('handler')) {
        if (target.hasName('left')) action = 'resizeLeft';else if (target.hasName('right')) action = 'resizeRight';else throw new Error('Unexpected konva shape name');
      } else if (target.hasName('segment')) action = 'move';else throw new Error('Unexpected konva shape name');

      this['_' + action](renderingContext, shape, datum, dx, dy, target);
    }
  }, {
    key: '_move',
    value: function _move(renderingContext, shape, datum, dx, dy, target) {
      var timeToPixel = renderingContext.timeToPixel;
      var layerHeight = renderingContext.height;
      // current values
      var x = renderingContext.timeToPixel(shape.x(datum));
      var y = renderingContext.valueToPixel(shape.y(datum));
      var width = renderingContext.timeToPixel(shape.width(datum));
      var height = renderingContext.valueToPixel(shape.height(datum));
      // target values
      var targetX = Math.max(x + dx, 0);
      var targetY = y + dy;

      // lock in layer's y axis
      if (targetY > layerHeight) {
        targetY = layerHeight;
      } else if (targetY - (layerHeight - height) < 0) {
        targetY = layerHeight - height;
      }

      var beat0 = this._beatGrid.beat(timeToPixel.invert(targetX));
      var snapped0 = this._beatGrid.seconds(Math.round(beat0));
      var beat1 = this._beatGrid.beat(timeToPixel.invert(targetX) + shape.width(datum));
      var snapped1 = this._beatGrid.seconds(Math.round(beat1));

      if (snapped0 !== snapped1) {
        shape.x(datum, snapped0);
        shape.width(datum, snapped1 - snapped0);
        shape.y(datum, renderingContext.valueToPixel.invert(targetY));
      }
    }
  }, {
    key: '_resizeLeft',
    value: function _resizeLeft(renderingContext, shape, datum, dx, dy, target) {
      var timeToPixel = renderingContext.timeToPixel;
      // current values
      var x = timeToPixel(shape.x(datum));
      var width = timeToPixel(shape.width(datum));
      // target values
      var maxTargetX = x + width;
      var targetX = x + dx < maxTargetX ? Math.max(x + dx, 0) : x;
      var targetWidth = targetX !== 0 ? Math.max(width - dx, 1) : width;

      var beat0 = this._beatGrid.beat(timeToPixel.invert(targetX));
      var snapped0 = this._beatGrid.seconds(Math.round(beat0));
      var beat1 = this._beatGrid.beat(timeToPixel.invert(targetX) + timeToPixel.invert(targetWidth));
      var snapped1 = this._beatGrid.seconds(Math.round(beat1));

      if (snapped0 !== snapped1) {
        shape.x(datum, snapped0);
        shape.width(datum, snapped1 - snapped0);
      }
    }
  }, {
    key: '_resizeRight',
    value: function _resizeRight(renderingContext, shape, datum, dx, dy, target) {
      // current values
      var width = renderingContext.timeToPixel(shape.width(datum));
      // target values
      var targetWidth = Math.max(width + dx, 1);

      var beat1 = this._beatGrid.beat(shape.x(datum) + renderingContext.timeToPixel.invert(targetWidth));
      var snapped1 = this._beatGrid.seconds(Math.round(beat1));

      if (snapped1 - shape.x(datum)) {
        shape.width(datum, snapped1 - shape.x(datum));
      }
    }
  }, {
    key: 'select',
    value: function select(datum) {
      _get(Object.getPrototypeOf(BeatGridSnapSegmentBehavior.prototype), 'select', this).call(this, datum);
      this.highlight(datum, true);
    }
  }, {
    key: 'unselect',
    value: function unselect(datum) {
      _get(Object.getPrototypeOf(BeatGridSnapSegmentBehavior.prototype), 'unselect', this).call(this, datum);
      this.highlight(datum, false);
    }
  }, {
    key: 'highlight',
    value: function highlight(datum, isHighlighted) {
      var shape = this._layer.getShapeFromDatum(datum);
      if (shape) {
        if (isHighlighted) {
          shape.params.color = 'red';
        } else {
          shape.params.color = 'black';
        }
      } else {
        throw new Error('No shape for this datum in this layer', { datum: datum, layer: this._layer });
      }
    }
  }, {
    key: 'beatGrid',
    set: function set(value) {
      this._beatGrid = value;
    },
    get: function get() {
      return this._beatGrid;
    }
  }]);

  return BeatGridSnapSegmentBehavior;
})(_baseBehavior2['default']);

exports['default'] = BeatGridSnapSegmentBehavior;
module.exports = exports['default'];

},{"./base-behavior":4,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],6:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

var BreakpointBehavior = (function (_BaseBehavior) {
  _inherits(BreakpointBehavior, _BaseBehavior);

  function BreakpointBehavior() {
    _classCallCheck(this, BreakpointBehavior);

    _get(Object.getPrototypeOf(BreakpointBehavior.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(BreakpointBehavior, [{
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, target) {
      var data = this._layer.data;
      var layerHeight = renderingContext.height;
      // current position
      var x = renderingContext.timeToPixel(shape.x(datum));
      var y = renderingContext.valueToPixel(shape.y(datum));
      // target position
      var targetX = x + dx;
      var targetY = y + dy;

      if (data.length > 2) {
        // create a sorted map of all `x` positions
        var xMap = data.map(function (d) {
          return renderingContext.timeToPixel(shape.x(d));
        });
        xMap.sort(function (a, b) {
          return a < b ? -1 : 1;
        });
        // find index of our shape x position
        var index = xMap.indexOf(x);
        // lock to next siblings
        if (targetX < xMap[index - 1] || targetX > xMap[index + 1]) {
          targetX = x;
        }
      }

      if (targetX < 0) targetX = 0;

      // lock in y axis
      if (targetY < 0) {
        targetY = 0;
      } else if (targetY > layerHeight) {
        targetY = layerHeight;
      }

      // update datum with new values
      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
      shape.y(datum, renderingContext.valueToPixel.invert(targetY));
    }
  }, {
    key: 'select',
    value: function select(datum) {
      _get(Object.getPrototypeOf(BreakpointBehavior.prototype), 'select', this).call(this, datum);
      this.highlight(datum, true);
    }
  }, {
    key: 'unselect',
    value: function unselect(datum) {
      _get(Object.getPrototypeOf(BreakpointBehavior.prototype), 'unselect', this).call(this, datum);
      this.highlight(datum, false);
    }
  }, {
    key: 'highlight',
    value: function highlight(datum, isHighlighted) {
      var shape = this._layer.getShapeFromDatum(datum);
      if (shape) {
        if (isHighlighted) {
          shape.params.color = 'red';
        } else {
          shape.params.color = 'black';
        }
      } else {
        throw new Error('No shape for this datum in this layer', { datum: datum, layer: this._layer });
      }
    }
  }]);

  return BreakpointBehavior;
})(_baseBehavior2['default']);

exports['default'] = BreakpointBehavior;
module.exports = exports['default'];

},{"./base-behavior":4,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],7:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

var MarkerBehavior = (function (_BaseBehavior) {
	_inherits(MarkerBehavior, _BaseBehavior);

	function MarkerBehavior() {
		_classCallCheck(this, MarkerBehavior);

		_get(Object.getPrototypeOf(MarkerBehavior.prototype), 'constructor', this).apply(this, arguments);
	}

	_createClass(MarkerBehavior, [{
		key: 'edit',
		value: function edit(renderingContext, shape, datum, dx, dy, target) {
			var x = renderingContext.timeToPixel(shape.x(datum));
			var targetX = x + dx > 0 ? x + dx : 0;

			shape.x(datum, renderingContext.timeToPixel.invert(targetX));
		}
	}, {
		key: 'select',
		value: function select(datum) {
			_get(Object.getPrototypeOf(MarkerBehavior.prototype), 'select', this).call(this, datum);
			this.highlight(datum, true);
		}
	}, {
		key: 'unselect',
		value: function unselect(datum) {
			_get(Object.getPrototypeOf(MarkerBehavior.prototype), 'unselect', this).call(this, datum);
			this.highlight(datum, false);
		}
	}, {
		key: 'highlight',
		value: function highlight(datum, isHighlighted) {
			var shape = this._layer.getShapeFromDatum(datum);
			if (shape) {
				if (isHighlighted) {
					shape.params.color = 'red';
					shape.params.handlerColor = 'red';
				} else {
					var defaults = shape._getDefaults();
					shape.params.color = defaults.color;
					shape.params.handlerColor = defaults.handlerColor;
				}
			} else {
				throw new Error('No shape for this datum in this layer', { datum: datum, layer: this._layer });
			}
		}
	}]);

	return MarkerBehavior;
})(_baseBehavior2['default']);

exports['default'] = MarkerBehavior;
module.exports = exports['default'];

},{"./base-behavior":4,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],8:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

var NoBehavior = (function (_BaseBehavior) {
  _inherits(NoBehavior, _BaseBehavior);

  function NoBehavior() {
    _classCallCheck(this, NoBehavior);

    _get(Object.getPrototypeOf(NoBehavior.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(NoBehavior, [{
    key: 'select',
    value: function select(datum) {}
  }, {
    key: 'unselect',
    value: function unselect(datum) {}
  }, {
    key: 'toggleSelection',
    value: function toggleSelection(datum) {}
  }, {
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, $target) {}
  }, {
    key: 'can',
    value: function can(action, datums) {
      return false;
    }
  }, {
    key: 'create',
    value: function create(datum) {}
  }, {
    key: 'remove',
    value: function remove(datum) {}
  }, {
    key: 'minimize',
    value: function minimize() {}
  }, {
    key: 'highlight',
    value: function highlight(datum, isHighlighted) {}
  }, {
    key: 'selectedClass',
    set: function set(value) {},
    get: function get() {}
  }, {
    key: 'selectedDatums',
    get: function get() {}
  }]);

  return NoBehavior;
})(_baseBehavior2['default']);

exports['default'] = NoBehavior;
module.exports = exports['default'];

},{"./base-behavior":4,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],9:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

var ScrollSegmentBehavior = (function (_BaseBehavior) {
  _inherits(ScrollSegmentBehavior, _BaseBehavior);

  function ScrollSegmentBehavior(targetTimeline) {
    _classCallCheck(this, ScrollSegmentBehavior);

    _get(Object.getPrototypeOf(ScrollSegmentBehavior.prototype), 'constructor', this).call(this);
    this.targetTimeline = targetTimeline;
  }

  _createClass(ScrollSegmentBehavior, [{
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, target) {
      var action = 'move';

      if (target.hasName('handler')) {
        if (target.hasName('left')) action = 'resizeLeft';else if (target.hasName('right')) action = 'resizeRight';else throw new Error('Unexpected konva shape name');
      } else if (target.hasName('segment')) action = 'move';else throw new Error('Unexpected konva shape name');

      this['_' + action](renderingContext, shape, datum, dx, dy, target);
    }
  }, {
    key: '_move',
    value: function _move(renderingContext, shape, datum, dx, dy, target) {
      var layerHeight = renderingContext.height;
      // current values
      var x = renderingContext.timeToPixel(shape.x(datum));
      var y = renderingContext.valueToPixel(shape.y(datum));
      var width = renderingContext.timeToPixel(shape.width(datum));
      var height = renderingContext.valueToPixel(shape.height(datum));
      // target values
      var targetX = Math.max(x + dx, 0);
      var targetY = y + dy;

      // lock in layer's y axis
      if (targetY > layerHeight) {
        targetY = layerHeight;
      } else if (targetY - (layerHeight - height) < 0) {
        targetY = layerHeight - height;
      }

      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
      shape.y(datum, renderingContext.valueToPixel.invert(targetY));

      this.targetTimeline.visibleInterval = { start: shape.x(datum), duration: shape.width(datum) };
      this.targetTimeline.tracks.update();
    }
  }, {
    key: '_resizeLeft',
    value: function _resizeLeft(renderingContext, shape, datum, dx, dy, target) {
      // current values
      var x = renderingContext.timeToPixel(shape.x(datum));
      var width = renderingContext.timeToPixel(shape.width(datum));
      // target values
      var maxTargetX = x + width;
      var targetX = x + dx < maxTargetX ? Math.max(x + dx, 0) : x;
      var targetWidth = targetX !== 0 ? Math.max(width - dx, 1) : width;

      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
      shape.width(datum, renderingContext.timeToPixel.invert(targetWidth));

      this.targetTimeline.visibleInterval = { start: shape.x(datum), duration: shape.width(datum) };
      this.targetTimeline.tracks.update();
    }
  }, {
    key: '_resizeRight',
    value: function _resizeRight(renderingContext, shape, datum, dx, dy, target) {
      // current values
      var width = renderingContext.timeToPixel(shape.width(datum));
      // target values
      var targetWidth = Math.max(width + dx, 1);

      shape.width(datum, renderingContext.timeToPixel.invert(targetWidth));

      this.targetTimeline.visibleInterval = { start: shape.x(datum), duration: shape.width(datum) };
      this.targetTimeline.tracks.update();
    }
  }]);

  return ScrollSegmentBehavior;
})(_baseBehavior2['default']);

exports['default'] = ScrollSegmentBehavior;
module.exports = exports['default'];

},{"./base-behavior":4,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],10:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

var SegmentBehavior = (function (_BaseBehavior) {
  _inherits(SegmentBehavior, _BaseBehavior);

  function SegmentBehavior() {
    _classCallCheck(this, SegmentBehavior);

    _get(Object.getPrototypeOf(SegmentBehavior.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SegmentBehavior, [{
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, target) {
      var action = 'move';

      if (target.hasName('handler')) {
        if (target.hasName('left')) action = 'resizeLeft';else if (target.hasName('right')) action = 'resizeRight';else throw new Error('Unexpected konva shape name');
      } else if (target.hasName('segment')) action = 'move';else throw new Error('Unexpected konva shape name');

      this['_' + action](renderingContext, shape, datum, dx, dy, target);
    }
  }, {
    key: '_move',
    value: function _move(renderingContext, shape, datum, dx, dy, target) {
      var layerHeight = renderingContext.height;
      // current values
      var x = renderingContext.timeToPixel(shape.x(datum));
      var y = renderingContext.valueToPixel(shape.y(datum));
      var width = renderingContext.timeToPixel(shape.width(datum));
      var height = renderingContext.valueToPixel(shape.height(datum));
      // target values
      var targetX = Math.max(x + dx, 0);
      var targetY = y + dy;

      // lock in layer's y axis
      if (targetY > layerHeight) {
        targetY = layerHeight;
      } else if (targetY - (layerHeight - height) < 0) {
        targetY = layerHeight - height;
      }

      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
      shape.y(datum, renderingContext.valueToPixel.invert(targetY));
    }
  }, {
    key: '_resizeLeft',
    value: function _resizeLeft(renderingContext, shape, datum, dx, dy, target) {
      // current values
      var x = renderingContext.timeToPixel(shape.x(datum));
      var width = renderingContext.timeToPixel(shape.width(datum));
      // target values
      var maxTargetX = x + width;
      var targetX = x + dx < maxTargetX ? Math.max(x + dx, 0) : x;
      var targetWidth = targetX !== 0 ? Math.max(width - dx, 1) : width;

      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
      shape.width(datum, renderingContext.timeToPixel.invert(targetWidth));
    }
  }, {
    key: '_resizeRight',
    value: function _resizeRight(renderingContext, shape, datum, dx, dy, target) {
      // current values
      var width = renderingContext.timeToPixel(shape.width(datum));
      // target values
      var targetWidth = Math.max(width + dx, 1);

      shape.width(datum, renderingContext.timeToPixel.invert(targetWidth));
    }
  }, {
    key: 'select',
    value: function select(datum) {
      _get(Object.getPrototypeOf(SegmentBehavior.prototype), 'select', this).call(this, datum);
      this.highlight(datum, true);
    }
  }, {
    key: 'unselect',
    value: function unselect(datum) {
      _get(Object.getPrototypeOf(SegmentBehavior.prototype), 'unselect', this).call(this, datum);
      this.highlight(datum, false);
    }
  }, {
    key: 'highlight',
    value: function highlight(datum, isHighlighted) {
      var shape = this._layer.getShapeFromDatum(datum);
      if (shape) {
        if (isHighlighted) {
          shape.params.color = 'red';
        } else {
          shape.params.color = 'black';
        }
      } else {
        throw new Error('No shape for this datum in this layer', { datum: datum, layer: this._layer });
      }
    }
  }]);

  return SegmentBehavior;
})(_baseBehavior2['default']);

exports['default'] = SegmentBehavior;
module.exports = exports['default'];

},{"./base-behavior":4,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],11:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

var SiblingLockedSegmentBehavior = (function (_BaseBehavior) {
  _inherits(SiblingLockedSegmentBehavior, _BaseBehavior);

  function SiblingLockedSegmentBehavior() {
    _classCallCheck(this, SiblingLockedSegmentBehavior);

    _get(Object.getPrototypeOf(SiblingLockedSegmentBehavior.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SiblingLockedSegmentBehavior, [{
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, target) {
      var data = this._layer.data;
      var layerHeight = renderingContext.height;
      // current position
      var x = renderingContext.timeToPixel(shape.x(datum));
      var y = renderingContext.valueToPixel(shape.y(datum));
      // target position
      var targetX = x + dx;
      var targetY = y + dy;

      if (data.length > 2) {
        // create a sorted map of all `x` positions
        var xMap = data.map(function (d) {
          var x = renderingContext.timeToPixel(shape.x(d));
          var width = renderingContext.timeToPixel(shape.x(d) + shape.width(d));
          return { start: x, end: x + width };
        });
        xMap.sort(function (a, b) {
          return a.start < b.start ? -1 : 1;
        });
        // find index of our shape x position
        var index = xMap.indexOf(x);
        // lock to next siblings
        if (targetX < xMap[index - 1].end || targetX + shape.width(datum) > xMap[index + 1].start) {
          targetX = x;
        }
      }

      if (targetX < 0) targetX = 0;

      // lock in y axis
      if (targetY < 0) {
        targetY = 0;
      } else if (targetY > layerHeight) {
        targetY = layerHeight;
      }

      // update datum with new values
      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
      shape.y(datum, renderingContext.valueToPixel.invert(targetY));
    }
  }, {
    key: 'select',
    value: function select(datum) {
      _get(Object.getPrototypeOf(SiblingLockedSegmentBehavior.prototype), 'select', this).call(this, datum);
      this.highlight(datum, true);
    }
  }, {
    key: 'unselect',
    value: function unselect(datum) {
      _get(Object.getPrototypeOf(SiblingLockedSegmentBehavior.prototype), 'unselect', this).call(this, datum);
      this.highlight(datum, false);
    }
  }, {
    key: 'highlight',
    value: function highlight(datum, isHighlighted) {
      var shape = this._layer.getShapeFromDatum(datum);
      if (shape) {
        if (isHighlighted) {
          shape.params.color = 'red';
        } else {
          shape.params.color = 'black';
        }
      } else {
        throw new Error('No shape for this datum in this layer', { datum: datum, layer: this._layer });
      }
    }
  }]);

  return SiblingLockedSegmentBehavior;
})(_baseBehavior2['default']);

exports['default'] = SiblingLockedSegmentBehavior;
module.exports = exports['default'];

},{"./base-behavior":4,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],12:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

var SimpleSnapSegmentBehavior = (function (_BaseBehavior) {
  _inherits(SimpleSnapSegmentBehavior, _BaseBehavior);

  function SimpleSnapSegmentBehavior() {
    _classCallCheck(this, SimpleSnapSegmentBehavior);

    _get(Object.getPrototypeOf(SimpleSnapSegmentBehavior.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(SimpleSnapSegmentBehavior, [{
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, target) {
      var action = 'move';

      if (target.hasName('handler')) {
        if (target.hasName('left')) action = 'resizeLeft';else if (target.hasName('right')) action = 'resizeRight';else throw new Error('Unexpected konva shape name');
      } else if (target.hasName('segment')) action = 'move';else throw new Error('Unexpected konva shape name');

      this['_' + action](renderingContext, shape, datum, dx, dy, target);
    }
  }, {
    key: '_move',
    value: function _move(renderingContext, shape, datum, dx, dy, target) {
      var layerHeight = renderingContext.height;
      // current values
      var x = renderingContext.timeToPixel(shape.x(datum));
      var y = renderingContext.valueToPixel(shape.y(datum));
      var width = renderingContext.timeToPixel(shape.width(datum));
      var height = renderingContext.valueToPixel(shape.height(datum));
      // target values
      var targetX = Math.max(x + dx, 0);
      var targetY = y + dy;

      // lock in layer's y axis
      if (targetY > layerHeight) {
        targetY = layerHeight;
      } else if (targetY - (layerHeight - height) < 0) {
        targetY = layerHeight - height;
      }

      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
      shape.y(datum, renderingContext.valueToPixel.invert(targetY));

      var snappedX = renderingContext.timeToPixel(Math.round(shape.x(datum)));

      shape.x(datum, renderingContext.timeToPixel.invert(snappedX));
    }
  }, {
    key: '_resizeLeft',
    value: function _resizeLeft(renderingContext, shape, datum, dx, dy, target) {
      // current values
      var x = renderingContext.timeToPixel(shape.x(datum));
      var width = renderingContext.timeToPixel(shape.width(datum));
      // target values
      var maxTargetX = x + width;
      var targetX = x + dx < maxTargetX ? Math.max(x + dx, 0) : x;
      var targetWidth = targetX !== 0 ? Math.max(width - dx, 1) : width;

      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
      shape.width(datum, renderingContext.timeToPixel.invert(targetWidth));
    }
  }, {
    key: '_resizeRight',
    value: function _resizeRight(renderingContext, shape, datum, dx, dy, target) {
      // current values
      var width = renderingContext.timeToPixel(shape.width(datum));
      // target values
      var targetWidth = Math.max(width + dx, 1);

      shape.width(datum, renderingContext.timeToPixel.invert(targetWidth));
    }
  }, {
    key: 'select',
    value: function select(datum) {
      _get(Object.getPrototypeOf(SimpleSnapSegmentBehavior.prototype), 'select', this).call(this, datum);
      this.highlight(datum, true);
    }
  }, {
    key: 'unselect',
    value: function unselect(datum) {
      _get(Object.getPrototypeOf(SimpleSnapSegmentBehavior.prototype), 'unselect', this).call(this, datum);
      this.highlight(datum, false);
    }
  }, {
    key: 'highlight',
    value: function highlight(datum, isHighlighted) {
      var shape = this._layer.getShapeFromDatum(datum);
      if (shape) {
        if (isHighlighted) {
          shape.params.color = 'red';
        } else {
          shape.params.color = 'black';
        }
      } else {
        throw new Error('No shape for this datum in this layer', { datum: datum, layer: this._layer });
      }
    }
  }]);

  return SimpleSnapSegmentBehavior;
})(_baseBehavior2['default']);

exports['default'] = SimpleSnapSegmentBehavior;
module.exports = exports['default'];

},{"./base-behavior":4,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],13:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

/**
* TimeContextBehavior is used internally in Layers to modify their TimeContext.
* This object is different from other Shapes Behaviors and exists mostly to decrease the size of the Layer.
* All the code here could be considered as part of the layer.
*/

var TimeContextBehavior = (function (_BaseBehavior) {
	_inherits(TimeContextBehavior, _BaseBehavior);

	function TimeContextBehavior() {
		_classCallCheck(this, TimeContextBehavior);

		_get(Object.getPrototypeOf(TimeContextBehavior.prototype), 'constructor', this).apply(this, arguments);
	}

	_createClass(TimeContextBehavior, [{
		key: 'edit',
		value: function edit(layer, dx, dy, target) {
			var timeContext = layer.timeContext;

			if (target.hasName('handler')) {
				if (target.hasName('left')) this._editLeft(timeContext, dx);else if (target.hasName('right')) this._editRight(timeContext, dx);else throw new Error('Unexpected konva shape name');
			} else if (target.hasName('segment')) this._move(timeContext, dx);else throw new Error('Unexpected konva shape name');
		}
	}, {
		key: '_editLeft',
		value: function _editLeft(timeContext, dx) {
			// edit `start`, `offset` and `duration`
			var x = timeContext.parent.timeToPixel(timeContext.start);
			var offset = timeContext.timeToPixel(timeContext.offset);
			var width = timeContext.timeToPixel(timeContext.duration);

			var targetX = x + dx;
			var targetOffset = offset - dx;
			var targetWidth = Math.max(width - dx, 1);

			timeContext.start = timeContext.parent.timeToPixel.invert(targetX);
			timeContext.offset = timeContext.timeToPixel.invert(targetOffset);
			timeContext.duration = timeContext.timeToPixel.invert(targetWidth);
		}
	}, {
		key: '_editRight',
		value: function _editRight(timeContext, dx) {
			var width = timeContext.timeToPixel(timeContext.duration);
			var targetWidth = Math.max(width + dx, 1);

			timeContext.duration = timeContext.timeToPixel.invert(targetWidth);
		}
	}, {
		key: '_move',
		value: function _move(timeContext, dx) {
			var x = timeContext.parent.timeToPixel(timeContext.start);
			var targetX = Math.max(x + dx, 0);

			timeContext.start = timeContext.parent.timeToPixel.invert(targetX);
		}
	}, {
		key: 'stretch',
		value: function stretch(layer, dx, dy, target) {
			var timeContext = layer.timeContext;
			var lastDuration = timeContext.duration;
			var lastOffset = timeContext.offset;

			this.edit(layer, dx, dy, target);

			var newDuration = timeContext.duration;
			var ratio = newDuration / lastDuration;

			timeContext.stretchRatio *= ratio;
			timeContext.offset = lastOffset;
			timeContext.duration = lastDuration;
		}
	}]);

	return TimeContextBehavior;
})(_baseBehavior2['default']);

exports['default'] = TimeContextBehavior;
module.exports = exports['default'];

},{"./base-behavior":4,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],14:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

var TraceBehavior = (function (_BaseBehavior) {
  _inherits(TraceBehavior, _BaseBehavior);

  function TraceBehavior() {
    _classCallCheck(this, TraceBehavior);

    _get(Object.getPrototypeOf(TraceBehavior.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(TraceBehavior, [{
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, target) {
      if (target.hasName('min')) {
        this._editRange(renderingContext, shape, datum, dx, -dy, 'min');
      } else if (target.hasName('max')) {
        this._editRange(renderingContext, shape, datum, dx, -dy, 'max');
      } else if (target.hasName('mean')) {
        this._editMean(renderingContext, shape, datum, dx, -dy);
      } else throw new Error('Unexpected konva shape name');
    }
  }, {
    key: '_editMean',
    value: function _editMean(renderingContext, shape, datum, dx, dy) {
      // work in pixel domain
      var x = renderingContext.timeToPixel(shape.x(datum));
      var y = renderingContext.valueToPixel(shape.mean(datum));

      var targetX = x + dx;
      var targetY = y - dy;

      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
      shape.mean(datum, renderingContext.valueToPixel.invert(targetY));
    }
  }, {
    key: '_editRange',
    value: function _editRange(renderingContext, shape, datum, dx, dy, rangeSide) {
      var range = renderingContext.valueToPixel(shape.range(datum));

      var targetRange = rangeSide === 'min' ? range + 2 * dy : range - 2 * dy;
      targetRange = Math.max(targetRange, 0);

      shape.range(datum, Math.max(0, renderingContext.valueToPixel.invert(targetRange)));
    }
  }, {
    key: 'select',
    value: function select(datum) {
      _get(Object.getPrototypeOf(TraceBehavior.prototype), 'select', this).call(this, datum);
      this.highlight(datum, true);
    }
  }, {
    key: 'unselect',
    value: function unselect(datum) {
      _get(Object.getPrototypeOf(TraceBehavior.prototype), 'unselect', this).call(this, datum);
      this.highlight(datum, false);
    }
  }, {
    key: 'highlight',
    value: function highlight(datum, isHighlighted) {
      var shape = this._layer.getShapeFromDatum(datum);
      if (shape) {
        if (isHighlighted) {
          shape.params.meanColor = 'red';
          shape.params.rangeColor = 'red';
        } else {
          var defaults = shape._getDefaults();
          shape.params.meanColor = defaults.meanColor;
          shape.params.rangeColor = defaults.rangeColor;
        }
      } else {
        throw new Error('No shape for this datum in this layer', { datum: datum, layer: this._layer });
      }
    }
  }]);

  return TraceBehavior;
})(_baseBehavior2['default']);

exports['default'] = TraceBehavior;
module.exports = exports['default'];

},{"./base-behavior":4,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],15:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseBehavior = require('./base-behavior');

var _baseBehavior2 = _interopRequireDefault(_baseBehavior);

var WaveformBehavior = (function (_BaseBehavior) {
  _inherits(WaveformBehavior, _BaseBehavior);

  function WaveformBehavior() {
    _classCallCheck(this, WaveformBehavior);

    _get(Object.getPrototypeOf(WaveformBehavior.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(WaveformBehavior, [{
    key: 'edit',
    value: function edit(renderingContext, shape, datum, dx, dy, target) {
      var action = 'move';

      if (target.hasName('handler')) {
        if (target.hasName('left')) action = 'resizeLeft';else if (target.hasName('right')) action = 'resizeRight';else throw new Error('Unexpected konva shape name');
      } else if (target.hasName('body')) {
        action = 'move';
      } else if (target.hasName('header')) {
        // TODO
        return;
      } else throw new Error('Unexpected konva shape name');

      this['_' + action](renderingContext, shape, datum, dx, dy, target);
    }
  }, {
    key: '_move',
    value: function _move(renderingContext, shape, datum, dx, dy, target) {
      var layerHeight = renderingContext.height;
      // current values
      var x = renderingContext.timeToPixel(shape.x(datum));
      // const y = renderingContext.valueToPixel(shape.y(datum));
      var y = 0;
      var width = renderingContext.timeToPixel(shape.width(datum));
      // const height = renderingContext.valueToPixel(shape.height(datum));
      var height = renderingContext.height;
      // target values
      var targetX = Math.max(x + dx, 0);
      var targetY = y + dy;

      // lock in layer's y axis
      if (targetY > layerHeight) {
        targetY = layerHeight;
      } else if (targetY - (layerHeight - height) < 0) {
        targetY = layerHeight - height;
      }

      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
      // shape.y(datum, renderingContext.valueToPixel.invert(targetY));
    }
  }, {
    key: '_resizeLeft',
    value: function _resizeLeft(renderingContext, shape, datum, dx, dy, target) {
      // return; // TODO: update this for the waveform shape
      // current values
      var x = renderingContext.timeToPixel(shape.x(datum));
      var width = renderingContext.timeToPixel(shape.width(datum));
      // target values
      var maxTargetX = x + width;
      var targetX = x + dx < maxTargetX ? Math.max(x + dx, 0) : x;
      var targetWidth = targetX !== 0 ? Math.max(width - dx, 1) : width;

      shape.x(datum, renderingContext.timeToPixel.invert(targetX));
      shape.width(datum, renderingContext.timeToPixel.invert(targetWidth));
    }
  }, {
    key: '_resizeRight',
    value: function _resizeRight(renderingContext, shape, datum, dx, dy, target) {
      // return; // TODO: update this for the waveform shape
      // current values
      var width = renderingContext.timeToPixel(shape.width(datum));
      // target values
      var targetWidth = Math.max(width + dx, 1);

      shape.width(datum, renderingContext.timeToPixel.invert(targetWidth));
    }
  }, {
    key: 'select',
    value: function select(datum) {
      _get(Object.getPrototypeOf(WaveformBehavior.prototype), 'select', this).call(this, datum);
      this.highlight(datum, true);
    }
  }, {
    key: 'unselect',
    value: function unselect(datum) {
      _get(Object.getPrototypeOf(WaveformBehavior.prototype), 'unselect', this).call(this, datum);
      this.highlight(datum, false);
    }
  }, {
    key: 'highlight',
    value: function highlight(datum, isHighlighted) {
      var shape = this._layer.getShapeFromDatum(datum);
      if (shape) {
        // if (isHighlighted) {
        //   shape.params.color = 'red';
        // } else {
        //   shape.params.color = 'black';
        // }
      } else {
          throw new Error('No shape for this datum in this layer', { datum: datum, layer: this._layer });
        }
    }
  }]);

  return WaveformBehavior;
})(_baseBehavior2['default']);

exports['default'] = WaveformBehavior;
module.exports = exports['default'];

},{"./base-behavior":4,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],16:[function(require,module,exports){
'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _utilsScales = require('../utils/scales');

var _utilsScales2 = _interopRequireDefault(_utilsScales);

var LayerTimeContext = (function () {
  /**
   * @param {TimelineTimeContext} parent - The `TimelineTimeContext` instance of the timeline.
   */

  function LayerTimeContext(parent) {
    _classCallCheck(this, LayerTimeContext);

    if (!parent) {
      throw new Error('LayerTimeContext must have a parent');
    }

    /**
     * The `TimelineTimeContext` instance of the timeline.
     *
     * @type {TimelineTimeContext}
     */
    this.parent = parent;
    this._lockedToParentInterval = false;

    this._timeToPixel = null;
    this._start = 0;
    this._duration = parent.visibleDuration;
    this._offset = 0;
    this._stretchRatio = 1;
    // register into the timeline's TimeContext
    this.parent._children.push(this);
  }

  /**
   * Creates a clone of the current time context.
   *
   * @return {LayerTimeContext}
   */

  _createClass(LayerTimeContext, [{
    key: 'clone',
    value: function clone() {
      var ctx = new this();

      ctx.parent = this.parent;
      ctx.start = this.start;
      ctx.duration = this.duration;
      ctx.offset = this.offset;
      ctx.stretchRatio = this.stretchRatio; // creates the local scale if needed

      return ctx;
    }

    /**
     * Returns the start position of the time context (in seconds).
     *
     * @type {Number}
     */
  }, {
    key: 'pixelToTime',

    /**
     * Helper function to convert pixel to time.
     *
     * @param {Number} px
     * @return {Number}
     */
    value: function pixelToTime(px) {
      if (!this._timeToPixel) {
        return this.parent.timeToPixel.invert(px);
      }

      return this._timeToPixel.invert(px);
    }

    /**
     * Returns the time interval of the visible area in the timeline.
     *
     * @type {Object} 
     */
  }, {
    key: 'start',
    get: function get() {
      return !this._lockedToParentInterval ? this._start : -this.parent.offset;
    },

    /**
     * Sets the start position of the time context (in seconds).
     *
     * @type {Number}
     */
    set: function set(value) {
      this._start = value;
    }

    /**
     * Returns the duration of the time context (in seconds).
     *
     * @type {Number}
     */
  }, {
    key: 'duration',
    get: function get() {
      return !this._lockedToParentInterval ? this._duration : this.parent.visibleDuration;
    },

    /**
     * Sets the duration of the time context (in seconds).
     *
     * @type {Number}
     */
    set: function set(value) {
      this._duration = value;
    }

    /**
     * Returns the offset of the time context (in seconds).
     *
     * @type {Number}
     */
  }, {
    key: 'offset',
    get: function get() {
      return !this._lockedToParentInterval ? this._offset : this.parent.offset;
    },

    /**
     * Sets the offset of the time context (in seconds).
     *
     * @type {Number}
     */
    set: function set(value) {
      this._offset = value;
    }

    /**
     * Returns the stretch ratio of the time context.
     *
     * @type {Number}
     */
  }, {
    key: 'stretchRatio',
    get: function get() {
      return this._stretchRatio;
    },

    /**
     * Sets the stretch ratio of the time context.
     *
     * @type {Number}
     */
    set: function set(value) {
      // remove local scale if ratio = 1
      if (value === 1) {
        this._timeToPixel = null;
        return;
      }
      // reuse previsously created local scale if exists
      var timeToPixel = this._timeToPixel ? this._timeToPixel : _utilsScales2['default'].linear().domain([0, 1]);

      timeToPixel.range([0, this.parent.computedPixelsPerSecond * value]);

      this._timeToPixel = timeToPixel;
      this._stretchRatio = value;
    }

    /**
     * Returns the time to pixel transfert function of the time context. If
     * the `stretchRatio` attribute is equal to 1, this function is the global
     * one from the `TimelineTimeContext` instance.
     *
     * @type {Function}
     */
  }, {
    key: 'timeToPixel',
    get: function get() {
      if (!this._timeToPixel) {
        return this.parent.timeToPixel;
      }

      return this._timeToPixel;
    }
  }, {
    key: 'visibleInterval',
    get: function get() {
      var interval = {};
      interval.start = -this.offset;
      interval.duration = this.duration;
      return interval;
    },

    /**
     * Focus the timeline visible area in the provided time interval.
     *
     * @type {Object} 
     */
    set: function set(value) {
      this.offset = -value.start;
      this.duration = value.duration;
    }

    /**
     *  TODO
     */
  }, {
    key: 'lockedToParentInterval',
    get: function get() {
      return this._lockedToParentInterval;
    },
    set: function set(value) {
      this._lockedToParentInterval = value;
    }
  }]);

  return LayerTimeContext;
})();

exports['default'] = LayerTimeContext;
module.exports = exports['default'];

},{"../utils/scales":66,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/interop-require-default":84}],17:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _Map = require('babel-runtime/core-js/map')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _utilsScales = require('../utils/scales');

var _utilsScales2 = _interopRequireDefault(_utilsScales);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _shapesSegment = require('../shapes/segment');

var _shapesSegment2 = _interopRequireDefault(_shapesSegment);

var _behaviorsTimeContextBehavior = require('../behaviors/time-context-behavior');

var _behaviorsTimeContextBehavior2 = _interopRequireDefault(_behaviorsTimeContextBehavior);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var Layer = (function (_events$EventEmitter) {
	_inherits(Layer, _events$EventEmitter);

	function Layer(dataType, data, options) {
		var _this = this;

		_classCallCheck(this, Layer);

		_get(Object.getPrototypeOf(Layer.prototype), 'constructor', this).call(this);

		this.dataType = dataType;

		if (!options) options = {};

		var defaults = {
			height: 100,
			top: 0,
			opacity: 1,
			yDomain: [0, 1],
			className: null, // TODO
			selectedClassName: 'selected',
			context: {
				handlerWidth: 10,
				handlerOpacity: 0.2,
				opacity: 0.5,
				color: '#787878'
			},
			hittable: true };

		// when false the layer is not returned by `BaseState.getHitLayers`
		this._behavior = null;

		/**
  * Parameters of the layers, `defaults` overrided with options.
  * @type {Object}
  */
		this.params = _Object$assign({}, defaults, options);
		this.timeContextBehavior = new _behaviorsTimeContextBehavior2['default']();

		this._shapeConfiguration = null; // { ctor, accessors, options }
		this._commonShapeConfiguration = null; // { ctor, accessors, options }
		this._$datumToShape = new _Map();
		this._$shapeToDatum = new _Map();
		this._commonShape = null;
		this._renderingContext = {};
		this.data = [];

		this._isContextEditable = false;

		this._valueToPixel = _utilsScales2['default'].linear().domain(this.params.yDomain).range([this.params.height, 0]);

		this.contentLayers = new _Set();

		this._dragLayer = new _konva2['default'].Layer({});

		this._commonShapeLayer = new _konva2['default'].FastLayer({});
		this._commonShapeLayer.addName('common-shape-layer');
		this._commonShapeLayer.layer = this;

		this._contextLayer = new _konva2['default'].Layer({});
		this._contextLayer.layer = this;
		this._contextLayer.addName('context-layer');

		this.setContextEditable(this._isContextEditable);

		this._contextShape = new _shapesSegment2['default']({});
		this._contextShape.install({
			opacity: function opacity() {
				return 1;
			},
			color: function color() {
				return _this.params.context.color;
			},
			width: function width() {
				return _this.timeContext.duration;
			},
			height: function height() {
				return _this._renderingContext.valueToPixel.domain()[1];
			},
			y: function y() {
				return _this._renderingContext.valueToPixel.domain()[0];
			},
			x: function x() {
				return _this.timeContext.start / _this.timeContext.stretchRatio;
			}
		});
		this._contextShape.params.handlerWidth = this.params.context.handlerWidth;
		this._contextShape.render(this._renderingContext);
		this._contextShape.layer = this;
		this._contextShape.isContextShape = true;
		for (var i = 0; i < this._contextShape.$el.length; i++) {
			this._contextLayer.add(this._contextShape.$el[i]);
		}

		this._stage = null;
	}

	_createClass(Layer, [{
		key: 'createContainer',
		value: function createContainer(stage) {
			this._stage = stage;

			this._stage.add(this._contextLayer);
			this._stage.add(this._commonShapeLayer);
			this._stage.add(this._dragLayer);
		}
	}, {
		key: '_destroy',
		value: function _destroy(it) {
			var entry = it.next();
			while (!entry.done) {
				var layer = entry.value;
				layer.destroy();
			}
		}
	}, {
		key: 'destroy',
		value: function destroy() {
			this._contextShape.destroy();
			this._destroy(this._$datumToShape.values());
			this._destroy(this.contentLayers.values);
			this.contentLayers.clear();

			this._commonShapeLayer = null;
			this._contextLayer = null;
			this._contextShape = null;
			this._stage = null;
			this.params = null;
			this.timeContextBehavior = null;
			this._shapeConfiguration = null;
			this._commonShapeConfiguration = null;
			this._$datumToShape = null;
			this._$shapeToDatum = null;
			this._commonShape = null;
			this._renderingContext = null;
			this._isContextEditable = null;
			this._behavior = null;
		}

		/**
   * Allows to override default the `TimeContextBehavior` used to edit the layer.
   *
   * @param {Object} ctor
   */
	}, {
		key: 'setBehavior',

		/**
   * Register the behavior to use when interacting with a shape.
   *
   * @param {BaseBehavior} behavior
   */
		value: function setBehavior(behavior) {
			behavior.initialize(this);
			this._behavior = behavior;
		}

		/******************************************************************/
		/******************************************************************/
		/******************************************************************/
		/************************** SELECTION *****************************/
		/******************************************************************/
		/******************************************************************/
		/******************************************************************/

	}, {
		key: 'isSelected',
		value: function isSelected(datum) {
			return this._behavior._selectedDatums.has(datum);
		}
	}, {
		key: 'select',
		value: function select($datums) {
			var _this2 = this;

			if ($datums === undefined || $datums.length === undefined && $datums.size === undefined) $datums = this.data;

			if (!this._behavior || !this._behavior.can('select', $datums)) return false;

			var that = this;
			$datums.forEach(function (datum) {
				var shape = that._$datumToShape.get(datum);
				if (shape) {
					_this2._behavior.select(datum);
					_this2._toFront(datum);
					that.emit('select', datum);
				} else {
					throw new Error('No shape for this datum in this layer', { datum: datum, layer: that });
				}
			});

			return true;
		}
	}, {
		key: 'unselect',
		value: function unselect($datums) {
			var _this3 = this;

			if ($datums === undefined || $datums.length === undefined && $datums.size === undefined) $datums = this.data;

			if (!this._behavior || !this._behavior.can('unselect', $datums)) return false;

			var that = this;
			$datums.forEach(function (datum) {
				var shape = that._$datumToShape.get(datum);
				if (shape) {
					_this3._behavior.unselect(datum);
					that.emit('unselect', datum);
				} else {
					throw new Error('No shape for this datum in this layer', { datum: datum, layer: that });
				}
			});

			return true;
		}
	}, {
		key: '_toFront',
		value: function _toFront($datum) {
			var $shape = this._$datumToShape.get($datum);
			if ($shape) {
				if ($shape.$el instanceof Array || $shape.$el instanceof _Set) {
					$shape.$el.forEach(function (el) {
						return el.moveToTop();
					});
				} else {
					$shape.$el.moveToTop();
				}
			} else {
				throw new Error('No shape for this datum in this layer', { datum: $datum, layer: this });
			}
		}
	}, {
		key: 'toDragLayer',
		value: function toDragLayer($datums) {
			var _this4 = this;

			var that = this;
			$datums.forEach(function ($datum) {
				var $shape = _this4._$datumToShape.get($datum);
				if ($shape) {
					if ($shape.$el instanceof Array || $shape.$el instanceof _Set) {
						$shape.$el.forEach(function (el) {
							return that._dragLayer.add(el);
						});
					} else {
						_this4._dragLayer.add($shape.$el);
					}
				} else {
					throw new Error('No shape for this datum in this layer', { datum: $datum, layer: that });
				}
			});
		}
	}, {
		key: 'toggleSelection',
		value: function toggleSelection($datums) {
			var _this5 = this;

			var that = this;

			// TODO: use the this._behavior.can method.
			$datums.forEach(function (datum) {
				var shape = that._$datumToShape.get(datum);
				if (shape) {
					_this5._behavior.toggleSelection(datum);
					that.emit('toggle-select', datum);
				} else {
					throw new Error('No shape for this datum in this layer', { datum: datum, layer: that });
				}
			});
		}

		/******************************************************************/
		/******************************************************************/
		/******************************************************************/
		/******************************************************************/
		/******************************************************************/
		/******************************************************************/
		/******************************************************************/

		/**
   * Sets the context of the layer, thus defining its `start`, `duration`,
   * `offset` and `stretchRatio`.
   *
   * @param {TimeContext} timeContext - The timeContext in which the layer is displayed.
   */
	}, {
		key: 'setTimeContext',
		value: function setTimeContext(timeContext) {
			this.timeContext = timeContext;
			// create a mixin to pass to the shapes
			this._renderingContext = {};
			this._updateRenderingContext();
		}

		/**
  * Register a shape and its configuration to use in order to render the data.
  *
  * @param {BaseShape} ctor - The constructor of the shape to be used.
  * @param {Object} [accessors={}] - Defines how the shape should adapt to a particular data struture.
  * @param {Object} [options={}] - Global configuration for the shapes, is specific to each `Shape`.
  */
	}, {
		key: 'configureShape',
		value: function configureShape(ctor, accessors, options) {
			if (!accessors) accessors = {};
			if (!options) options = {};
			this._shapeConfiguration = { ctor: ctor, accessors: accessors, options: options };
		}

		/**
  * Optionnaly register a shape to be used accros the entire collection.
  *
  * @param {BaseShape} ctor - The constructor of the shape to be used.
  * @param {Object} [accessors={}] - Defines how the shape should adapt to a particular data struture.
  * @param {Object} [options={}] - Global configuration for the shapes, is specific to each `Shape`.
  */
	}, {
		key: 'configureCommonShape',
		value: function configureCommonShape(Ctor, accessors, options) {
			var _this6 = this;

			if (!accessors) accessors = {};
			if (!options) options = {};
			this._commonShapeConfiguration = { ctor: Ctor, accessors: accessors, options: options };
			this._commonShape = new Ctor(options);
			this._commonShape.install(accessors);
			this._commonShape.render(this._renderingContext);
			if (this._commonShape.$el instanceof Array || this._commonShape.$el instanceof _Set) {
				this._commonShape.$el.forEach(function (el) {
					return _this6._commonShapeLayer.add(el);
				});
			} else {
				this._commonShapeLayer.add(this._commonShape.$el);
			}
		}

		/**
  * Defines if the `Layer`, and thus the `LayerTimeContext` is editable or not.
  *
  * @params {Boolean} [bool=true]
  */
	}, {
		key: 'setContextEditable',
		value: function setContextEditable(editable) {
			if (editable === undefined) editable = true;
			// this._contextLayer.visible(editable);
			this._contextLayer.opacity(editable ? this.params.context.opacity : 0);
			this._contextLayer.listening(editable);
			this._contextLayer.visible(editable);
			this._isContextEditable = editable;
		}

		/**
  * Updates the values stored int the `_renderingContext` passed	to shapes
  * for rendering and updating.
  */
	}, {
		key: '_updateRenderingContext',
		value: function _updateRenderingContext() {

			this._renderingContext.timeToPixel = this.timeContext.timeToPixel;
			this._renderingContext.valueToPixel = this._valueToPixel;

			this._renderingContext.height = this.params.height;
			this._renderingContext.width = this.timeContext.timeToPixel(this.timeContext.duration);
			// for foreign object issue in chrome
			this._renderingContext.offsetX = this.timeContext.timeToPixel(this.timeContext.offset);
			this._renderingContext.startX = this.timeContext.parent.timeToPixel(this.timeContext.start);
			this._renderingContext.pixelsPerSecond = this.timeContext.parent.computedPixelsPerSecond;

			// @todo replace with `minX` and `maxX` representing the visible pixels in which
			// the shapes should be rendered, could allow to not update the DOM of shapes
			// who are not in this area.
			this._renderingContext.trackOffsetX = this.timeContext.parent.timeToPixel(this.timeContext.parent.offset);
			this._renderingContext.visibleWidth = this.timeContext.parent.visibleWidth;
		}

		// --------------------------------------
		// Helpers
		// --------------------------------------

	}, {
		key: 'getDatumFromShape',
		value: function getDatumFromShape($shape) {
			return this._$shapeToDatum.get($shape);
		}
	}, {
		key: 'getShapeFromDatum',
		value: function getShapeFromDatum($datum) {
			return this._$datumToShape.get($datum);
		}

		/**
  * Retrieve all the datums in a given area as defined in the registered `Shape~inArea` method.
  *
  * @param {Object} area - The area in which to find the elements
  * @param {Number} area.top
  * @param {Number} area.left
  * @param {Number} area.width
  * @param {Number} area.height
  * @return {Array} - list of the datums presents in the area
  */
	}, {
		key: 'getDatumsInArea',
		value: function getDatumsInArea(area) {
			var _this7 = this;

			var x1 = area.left;
			var y1 = area.top;
			var x2 = area.left + area.width;
			var y2 = area.top + area.height + this.params.top;

			var $filteredDatums = new _Set();

			var $entries = this._$datumToShape.entries();

			var that = this;

			this.contentLayers.forEach(function (contentLayer) {
				contentLayer.children.forEach(function (konvaShape) {
					var $shape = konvaShape.shape;
					if ($shape) {
						var $datum = that.getDatumFromShape($shape);
						var inArea = $shape.inArea(_this7._renderingContext, $datum, x1, y1, x2, y2);

						if (inArea) {
							$filteredDatums.add($datum);
						}
					}
				});
			});

			return $filteredDatums;
		}
	}, {
		key: 'update',
		value: function update($datums) {

			this.updateContainer();

			this.updateShapes($datums);
		}
	}, {
		key: 'sort_data',
		value: function sort_data(data) {
			throw new Error('The developer must assign a proper function');
		}
	}, {
		key: 'visible_data',
		value: function visible_data(timeContext, data) {
			throw new Error('The developer must assign a proper function');
		}
	}, {
		key: 'updateShapes',
		value: function updateShapes($datums) {
			var that = this;
			var changedContentLayers = new _Set();
			var targetData = null;
			var interval = null;
			var eraseChildren = true;

			if ($datums === undefined || this._commonShape) {
				interval = this.visible_data(this.timeContext, this.data);
			}

			if ($datums === undefined) {
				targetData = this.data.slice(interval[0], Math.min(interval[1] + 1, this.data.length));
			} else {
				targetData = $datums;
				eraseChildren = false;
			}

			// console.log([this._$datumToShape.size, this.data.length]);
			this.allocateShapesToContentLayers(this._stage, targetData, 'datums', eraseChildren).forEach(function (changedContentLayer) {
				changedContentLayers.add(changedContentLayer);
			});

			// console.log('number of changedContentLayers : ' + changedContentLayers.size);

			changedContentLayers.forEach(function (changedContentLayer) {
				changedContentLayer.y(that.params.top).offsetX(-that._renderingContext.startX).x(that._renderingContext.offsetX).clip({
					x: -that._renderingContext.offsetX,
					y: 0,
					width: that._renderingContext.width,
					height: that._renderingContext.height
				});
				changedContentLayer.clear();
				changedContentLayer.batchDraw();
			});

			this._dragLayer.y(that.params.top).offsetX(-that._renderingContext.startX).x(that._renderingContext.offsetX).clip({
				x: -that._renderingContext.offsetX,
				y: 0,
				width: that._renderingContext.width,
				height: that._renderingContext.height
			}).clear().batchDraw();

			if (this._commonShape) {
				this._commonShapeLayer.y(that.params.top).offsetX(-that._renderingContext.startX).x(that._renderingContext.offsetX).clip({
					x: -that._renderingContext.offsetX,
					y: 0,
					width: that._renderingContext.width,
					height: that._renderingContext.height
				});
				this._commonShape.update(this._renderingContext, that.data.slice(interval[0], interval[1] + 1));
				this._commonShapeLayer.batchDraw();
				// this._commonShapeLayer.moveToBottom();
			}

			this._contextShape.update(this._renderingContext, this.timeContext);

			this._contextLayer.y(that.params.top).batchDraw();
			// .moveToBottom();
		}
	}, {
		key: 'updateContainer',
		value: function updateContainer() {
			var _this8 = this;

			this._updateRenderingContext();
			var that = this;

			this.contentLayers.forEach(function (contentLayer) {
				contentLayer.offsetX(-_this8._renderingContext.startX).x(_this8._renderingContext.offsetX).clip({ x: -_this8._renderingContext.offsetX, y: 0, width: _this8._renderingContext.width, height: _this8._renderingContext.height });
			});
		}
	}, {
		key: 'allocateShapesToContentLayers',
		value: function allocateShapesToContentLayers(stage, objs, type, eraseChildren) {
			var LIMIT = 30; // TODO: make the LIMIT a dynamic variable, controlled by a user defined function.

			var changedContentLayers = new _Set();

			var konvaShapes = new _Set();

			/*
    * Of course one could write less code by including the type checking inside the forEach.
    * But that would mean a check for each object. This way, the program checks only one time.
    * This is meant to be a small optimization. Not pretty, of course.
    * Another thing: in order to use just one forEach at updateShapes, I included the shape update in here
    */
			var that = this;
			if (type == 'datums') {
				objs.forEach(function (datum) {
					var shape = that.getShapeFromDatum(datum);
					if (shape === undefined) {
						// throw new Error('Unknown datum', { datum: datum, layer: that });
						that._add(datum);
						shape = that.getShapeFromDatum(datum);
					}
					shape.update(that._renderingContext, datum);
					if (shape.$el instanceof Array || shape.$el instanceof _Set) {
						shape.$el.forEach(function (el) {
							return konvaShapes.add(el);
						});
					} else {
						konvaShapes.add(shape.$el);
					}
				});
			} else if (type == 'shapes') {
				objs.forEach(function (shape) {
					var datum = that.getDatumFromShape(shape);
					if (datum === undefined) {
						throw new Error('Unknown shape', { shape: shape, layer: that });
					}
					shape.update(that._renderingContext, datum);
					if (shape.$el instanceof Array || shape.$el instanceof _Set) {
						shape.$el.forEach(function (el) {
							return konvaShapes.add(el);
						});
					} else {
						konvaShapes.add(shape.$el);
					}
				});
			} else {
				throw new Error('Unknown objects type');
			}

			var ksIt = konvaShapes.entries();

			var clIt = this.contentLayers.entries();

			var cle = clIt.next();
			var kse = ksIt.next();

			var previousShape = null;

			while (!cle.done) {
				var layer = cle.value[1];
				while (!kse.done) {
					var konvaShape = kse.value[1];
					if (layer.children.length >= LIMIT && konvaShape.shape != previousShape) {
						break;
					}
					if (eraseChildren && !changedContentLayers.has(layer)) {
						layer.removeChildren();
					}
					konvaShape.remove();
					layer.add(konvaShape);
					kse = ksIt.next();
					changedContentLayers.add(layer);
				}
				cle = clIt.next();
			}

			while (!kse.done) {
				var layer = new _konva2['default'].Layer({});
				layer.layer = this;
				layer.addName('content-layer');
				layer.clearBeforeDraw(true);
				this.contentLayers.add(layer);
				stage.add(layer);
				while (!kse.done && layer.children.length < LIMIT) {
					var konvaShape = kse.value[1];
					konvaShape.remove();
					layer.add(konvaShape);
					kse = ksIt.next();
				}
				changedContentLayers.add(layer);
			}

			// konvaShapes.forEach((ks) => ks.shape.startDrag());

			return changedContentLayers;
		}
	}, {
		key: 'set',
		value: function set(data) {
			if (!this._behavior || !this._behavior.can('add', data)) return false;

			var that = this;

			this.unselect();

			this.data.forEach(function (datum) {
				return that._$datumToShape.get(datum).destroy();
			});
			this._$datumToShape.clear();
			this._$shapeToDatum.clear();

			this.contentLayers.forEach(function (layer) {
				return layer.destroy();
			});

			this.data.length = 0;

			data.forEach(function (datum) {
				that._add(datum);
			});

			this.data = data;

			this.sort_data(this.data);

			this.emit('set', data);

			return true;
		}
	}, {
		key: '_add',
		value: function _add(datum) {
			var Ctor = this._shapeConfiguration.ctor;
			var accessors = this._shapeConfiguration.accessors;
			var options = this._shapeConfiguration.options;

			var shape = new Ctor(options);
			shape.install(accessors);
			shape.render(this._renderingContext);
			shape.layer = this;
			shape.datum = datum;
			this._$datumToShape.set(datum, shape);
			this._$shapeToDatum.set(shape, datum);
		}
	}, {
		key: 'add',
		value: function add(datum) {
			if (!this._behavior || !this._behavior.can('add', [datum])) return false;

			this._add(datum);
			this.data[this.data.length] = datum;
			this.sort_data(this.data);

			this.emit('add', datum);

			return true;
		}
	}, {
		key: 'remove',
		value: function remove(datum) {
			var _this9 = this;

			if (!this._behavior || !this._behavior.can('remove', [datum])) return false;

			this.unselect(datum);
			var shape = this._$datumToShape.get(datum);
			if (shape) {
				(function () {
					var changedContentLayers = new _Set();
					if (shape.$el instanceof Array || shape.$el instanceof _Set) {
						shape.$el.forEach(function (el) {
							return changedContentLayers.add(el);
						});
					} else {
						changedContentLayers.add(shape.$el);
					}
					shape.layer = null;
					shape.destroy();
					_this9._$datumToShape['delete'](datum);
					_this9._$shapeToDatum['delete'](shape);

					changedContentLayers.forEach(function (layer) {
						if (layer.children === 0) {
							layer.destroy();
							_this9.contentLayers['delete'](layer);
						}
					});
				})();
			}

			this.data.splice(this.data.indexOf(datum), 1);

			this.emit('remove', datum);

			return true;
		}

		/******************************************************************/
		/******************************************************************/
		/******************************************************************/
		/*************************** EDITION ******************************/
		/******************************************************************/
		/******************************************************************/
		/******************************************************************/

		/**
   * Edit datum(s) according to the `edit` defined in the registered `Behavior`.
   *
   * @param {Object[]} $datums - The datum(s) to edit.
   * @param {Number} dx - The modification to apply in the x axis (in pixels).
   * @param {Number} dy - The modification to apply in the y axis (in pixels).
   * @param {Element} $target - The target of the interaction (for example, left
   *    handler DOM element in a segment).
   */
	}, {
		key: 'edit',
		value: function edit($datums, dx, dy, $target) {
			var _this10 = this;

			if (!this._behavior || !this._behavior.can('edit', $datums)) return false;

			var that = this;
			$datums.forEach(function (datum) {
				var shape = that._$datumToShape.get(datum);
				_this10._behavior.edit(_this10._renderingContext, shape, datum, dx, dy, $target);
			});
			this.emit('edit', $datums);

			return true;
		}

		/**
  * Edit the layer and thus its related `LayerTimeContext` attributes.
  *
  * @param {Number} dx - The modification to apply in the x axis (in pixels).
  * @param {Number} dy - The modification to apply in the y axis (in pixels).
  * @param {Element} $target - The target of the event of the interaction.
  */
	}, {
		key: 'editContext',
		value: function editContext(dx, dy, $target) {
			// TODO
			this.timeContextBehavior.edit(this, dx, dy, $target);
			this.emit('edit-context');
		}

		/**
  * Stretch the layer and thus its related `LayerTimeContext` attributes.
  *
  * @param {Number} dx - The modification to apply in the x axis (in pixels).
  * @param {Number} dy - The modification to apply in the y axis (in pixels).
  * @param {Element} $target - The target of the event of the interaction.
  */
	}, {
		key: 'stretchContext',
		value: function stretchContext(dx, dy, $target) {
			// TODO
			this.timeContextBehavior.stretch(this, dx, dy, $target);
			this.emit('stretch-context');
		}
	}, {
		key: 'minimize',
		value: function minimize() {
			// TODO
		}
	}, {
		key: 'visible',
		get: function get() {
			return this._dragLayer.visible();
		},
		set: function set(value) {
			this._contextLayer.visible(value);
			this._commonShapeLayer.visible(value);
			this._dragLayer.visible(value);
			this.contentLayer.forEach(function (l) {
				return l.visible(value);
			});
		}
	}, {
		key: 'zIndex',
		get: function get() {
			return this._contextLayer.getZIndex();
		}
	}, {
		key: 'start',

		/**
   * Returns `LayerTimeContext`'s `start` time domain value.
   *
   * @type {Number}
   */
		get: function get() {
			return this.timeContext.start;
		},

		/**
   * Sets `LayerTimeContext`'s `start` time domain value.
   *
   * @type {Number}
   */
		set: function set(value) {
			this.timeContext.start = value;
		}

		/**
   * Returns `LayerTimeContext`'s `offset` time domain value.
   *
   * @type {Number}
   */
	}, {
		key: 'offset',
		get: function get() {
			return this.timeContext.offset;
		},

		/**
   * Sets `LayerTimeContext`'s `offset` time domain value.
   *
   * @type {Number}
   */
		set: function set(value) {
			this.timeContext.offset = value;
		}

		/**
   * Returns `LayerTimeContext`'s `duration` time domain value.
   *
   * @type {Number}
   */
	}, {
		key: 'duration',
		get: function get() {
			return this.timeContext.duration;
		},

		/**
   * Sets `LayerTimeContext`'s `duration` time domain value.
   *
   * @type {Number}
   */
		set: function set(value) {
			this.timeContext.duration = value;
		}

		/**
   * Returns `LayerTimeContext`'s `stretchRatio` time domain value.
   *
   * @type {Number}
   */
	}, {
		key: 'stretchRatio',
		get: function get() {
			return this.timeContext.stretchRatio;
		},

		/**
   * Sets `LayerTimeContext`'s `stretchRatio` time domain value.
   *
   * @type {Number}
   */
		set: function set(value) {
			this.timeContext.stretchRatio = value;
		}

		/**
   * Set the domain boundaries of the data for the y axis.
   *
   * @type {Array}
   */
	}, {
		key: 'yDomain',
		set: function set(domain) {
			this.params.yDomain = domain;
			this._valueToPixel.domain(domain);
		},

		/**
   * Returns the domain boundaries of the data for the y axis.
   *
   * @type {Array}
   */
		get: function get() {
			return this.params.yDomain;
		}

		/**
   * Sets the opacity of the whole layer.
   *
   * @type {Number}
   */
	}, {
		key: 'opacity',
		set: function set(value) {
			this.params.opacity = value;
		},

		/**
   * Returns the opacity of the whole layer.
   *
   * @type {Number}
   */
		get: function get() {
			return this.params.opacity;
		}

		/**
   * Returns the transfert function used to display the data in the x axis.
   *
   * @type {Number}
   */
	}, {
		key: 'timeToPixel',
		get: function get() {
			return this.timeContext.timeToPixel;
		}

		/**
   * Returns the transfert function used to display the data in the y axis.
   *
   * @type {Number}
   */
	}, {
		key: 'valueToPixel',
		get: function get() {
			return this._valueToPixel;
		}
	}, {
		key: 'selectedDatums',
		get: function get() {
			return this._behavior ? this._behavior.selectedDatums : new _Set();
		}
	}], [{
		key: 'configureTimeContextBehavior',
		value: function configureTimeContextBehavior(ctor) {
			this.timeContextBehaviorCtor = ctor;
		}
	}]);

	return Layer;
})(_events2['default'].EventEmitter);

exports['default'] = Layer;
module.exports = exports['default'];

},{"../behaviors/time-context-behavior":13,"../shapes/segment":47,"../utils/scales":66,"babel-runtime/core-js/map":69,"babel-runtime/core-js/object/assign":70,"babel-runtime/core-js/set":77,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84,"events":174,"konva":172}],18:[function(require,module,exports){
'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _utilsScales = require('../utils/scales');

var _utilsScales2 = _interopRequireDefault(_utilsScales);

var TimelineTimeContext = (function () {
  /**
   * @param {Number} pixelsPerSecond - The number of pixels that should be
   *    used to display one second.
   * @param {Number} visibleWidth - The default with of the visible area
   *    displayed in `tracks` (in pixels).
   */

  function TimelineTimeContext(pixelsPerSecond, visibleWidth) {
    _classCallCheck(this, TimelineTimeContext);

    this._children = [];

    this._timeToPixel = null;
    this._offset = 0;
    this._zoom = 1;
    this._computedPixelsPerSecond = pixelsPerSecond;
    // params
    this._visibleWidth = visibleWidth;
    this._maintainVisibleDuration = false;

    // create the timeToPixel scale
    var scale = _utilsScales2['default'].linear().domain([0, 1]).range([0, pixelsPerSecond]);

    this._timeToPixel = scale;

    this._originalPixelsPerSecond = this._computedPixelsPerSecond;
  }

  /**
   * Returns the number of pixels per seconds ignoring the current zoom value.
   *
   * @type {Number}
   */

  _createClass(TimelineTimeContext, [{
    key: '_updateTimeToPixelRange',
    value: function _updateTimeToPixelRange() {
      this.timeToPixel.range([0, this._computedPixelsPerSecond]);
    }

    /**
     * Returns the time interval of the visible area in the timeline.
     *
     * @type {Object} 
     */
  }, {
    key: 'pixelsPerSecond',
    get: function get() {
      return this._originalPixelsPerSecond;
    },

    /**
     * Updates all the caracteristics of this object according to the new
     * given value of pixels per seconds. Propagates the changes to the
     * `LayerTimeContext` children.
     *
     * @type {Number}
     */
    set: function set(value) {
      this._computedPixelsPerSecond = value * this.zoom;
      this._originalPixelsPerSecond = value;
      this._updateTimeToPixelRange();

      // force children scale update
      this._children.forEach(function (child) {
        if (child.stretchRatio === 1) {
          return;
        }
        child.stretchRatio = child.stretchRatio;
      });
    }

    /**
     * Returns the number of pixels per seconds including the current zoom value.
     *
     * @type {Number}
     */
  }, {
    key: 'computedPixelsPerSecond',
    get: function get() {
      return this._computedPixelsPerSecond;
    }

    /**
     * Returns the current offset applied to the registered `Track` instances
     * from origin (in seconds).
     *
     * @type {Number}
     */
  }, {
    key: 'offset',
    get: function get() {
      return this._offset;
    },

    /**
     * Sets the offset to apply to the registered `Track` instances from origin
     * (in seconds).
     *
     * @type {Number}
     */
    set: function set(value) {
      this._offset = value;
    }

    /**
     * Returns the current zoom level applied to the whole visualization.
     *
     * @type {Number}
     */
  }, {
    key: 'zoom',
    get: function get() {
      return this._zoom;
    },

    /**
     * Sets the zoom ratio for the whole visualization.
     *
     * @type {Number}
     */
    set: function set(value) {
      // Compute change to propagate to children who have their own timeToPixel
      var ratioChange = value / this._zoom;
      this._zoom = value;
      this._computedPixelsPerSecond = this._originalPixelsPerSecond * value;
      this._updateTimeToPixelRange();

      this._children.forEach(function (child) {
        if (child.stretchRatio === 1) {
          return;
        }
        child.stretchRatio = child.stretchRatio * ratioChange;
      });
    }

    /**
     * Returns the visible width of the `Track` instances.
     *
     * @type {Number}
     */
  }, {
    key: 'visibleWidth',
    get: function get() {
      return this._visibleWidth;
    },

    /**
     * Sets the visible width of the `Track` instances.
     *
     * @type {Number}
     */
    set: function set(value) {
      var widthRatio = value / this.visibleWidth;
      this._visibleWidth = value;

      if (this.maintainVisibleDuration) {
        this.pixelsPerSecond = this._computedPixelsPerSecond * widthRatio;
      }
    }

    /**
     * Returns the duration displayed by `Track` instances.
     *
     * @type {Number}
     */
  }, {
    key: 'visibleDuration',
    get: function get() {
      return this.visibleWidth / this._computedPixelsPerSecond;
    }

    /**
     * Returns if the duration displayed by tracks should be maintained when
     * their width is updated.
     *
     * @type {Number}
     */
  }, {
    key: 'maintainVisibleDuration',
    get: function get() {
      return this._maintainVisibleDuration;
    },

    /**
     * Defines if the duration displayed by tracks should be maintained when
     * their width is updated.
     *
     * @type {Boolean}
     */
    set: function set(bool) {
      this._maintainVisibleDuration = bool;
    }

    /**
     * Returns the time to pixel trasfert function.
     *
     * @type {Function}
     */
  }, {
    key: 'timeToPixel',
    get: function get() {
      return this._timeToPixel;
    }
  }, {
    key: 'visibleInterval',
    get: function get() {
      var interval = {};
      interval.start = -this.offset;
      interval.duration = this.visibleDuration;
      return interval;
    },

    /**
     * Focus the timeline visible area in the provided time interval.
     *
     * @type {Object} 
     */
    set: function set(value) {
      this.offset = -value.start;
      this.pixelsPerSecond = this.visibleWidth / value.duration;
    }
  }]);

  return TimelineTimeContext;
})();

exports['default'] = TimelineTimeContext;
module.exports = exports['default'];

},{"../utils/scales":66,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/interop-require-default":84}],19:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Symbol$iterator = require('babel-runtime/core-js/symbol/iterator')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _track = require('./track');

var _track2 = _interopRequireDefault(_track);

var _trackCollection = require('./track-collection');

var _trackCollection2 = _interopRequireDefault(_trackCollection);

var _timelineTimeContext = require('./timeline-time-context');

var _timelineTimeContext2 = _interopRequireDefault(_timelineTimeContext);

var _layerTimeContext = require('./layer-time-context');

var _layerTimeContext2 = _interopRequireDefault(_layerTimeContext);

var _interactionsKonvaSurface = require('../interactions/konva-surface');

var _interactionsKonvaSurface2 = _interopRequireDefault(_interactionsKonvaSurface);

var _interactionsKeyboard = require('../interactions/keyboard');

var _interactionsKeyboard2 = _interopRequireDefault(_interactionsKeyboard);

var Timeline = (function (_events$EventEmitter) {
  _inherits(Timeline, _events$EventEmitter);

  /**
   * @param {Number} [pixelsPerSecond=100] - the default scaling between time and pixels.
   * @param {Number} [visibleWidth=1000] - the default visible area for all registered tracks.
   */

  function Timeline(pixelsPerSecond, visibleWidth, opts) {
    _classCallCheck(this, Timeline);

    _get(Object.getPrototypeOf(Timeline.prototype), 'constructor', this).call(this);

    if (pixelsPerSecond === undefined) pixelsPerSecond = 100;
    if (visibleWidth === undefined) visibleWidth = 1000;
    if (opts === undefined) {
      opts = { registerKeyboard: true };
    } else if (opts.registerKeyboard === undefined) {
      opts.registerKeyboard = true;
    }

    this._tracks = new _trackCollection2['default'](this);
    this._state = null;

    // default interactions
    this._surfaceCtor = _interactionsKonvaSurface2['default'];

    if (opts.registerKeyboard) {
      this.createInteraction(_interactionsKeyboard2['default'], document);
    }

    // stores
    this._trackById = {};
    this._groupedLayers = {};

    /** @type {TimelineTimeContext} - master time context for the visualization. */
    this.timeContext = new _timelineTimeContext2['default'](pixelsPerSecond, visibleWidth);
  }

  /**
   * Returns `TimelineTimeContext`'s `offset` time domain value.
   *
   * @type {Number} [offset=0]
   */

  _createClass(Timeline, [{
    key: 'configureSurface',

    /**
     * Overrides the default `Surface` that is instanciated on each `Track`
     * instance. This methos should be called before adding any `Track` instance
     * to the current `timeline`.
     *
     * @param {EventSource} Ctor - The constructor to use in order to catch mouse
     *    events on each `Track` instances.
     */
    value: function configureSurface(Ctor) {
      this._surfaceCtor = Ctor;
    }

    /**
     * Factory method to add interaction modules the timeline should listen to.
     * By default, the timeline instanciate a global `Keyboard` instance and a
     * `Surface` instance on each container.
     * Should be used to install new interactions implementing the `EventSource` interface.
     *
     * @param {EventSource} Ctor - The contructor of the interaction module to instanciate.
     * @param {Element} $el - The DOM element which will be binded to the `EventSource` module.
     * @param {Object} [options={}] - Options to be applied to the `Ctor`.
     */
  }, {
    key: 'createInteraction',
    value: function createInteraction(Ctor, $el, options) {
      var _this = this;

      if (options === undefined) options = {};
      var interaction = new Ctor($el, options);
      interaction.on('event', function (e) {
        return _this._handleEvent(e);
      });
    }

    /**
     * Returns a list of the layers situated under the position of a `WaveEvent`.
     *
     * @param {WavesEvent} e - An event triggered by a `WaveEvent`
     * @return {Array} - Matched layers
     */
  }, {
    key: 'getHitLayers',
    value: function getHitLayers(e) {
      var x = e.originalEvent.offsetX;
      var y = e.originalEvent.offsetY;

      var layers = [];

      this.layers.forEach(function (layer) {
        var ctxX = layer._contextShape.$segment.getAbsolutePosition().x;
        var ctxY = layer._contextShape.$segment.getAbsolutePosition().y;
        var ctxW = layer._contextShape.$segment.width();
        var ctxH = layer._contextShape.$segment.height();

        if (x >= ctxX && x <= ctxX + ctxW && y >= ctxY && y <= ctxY + ctxH) layers.push(layer);
      });

      return layers;
    }

    /**
     * The callback that is used to listen to interactions modules.
     *
     * @param {WaveEvent} e - An event generated by an interaction modules (`EventSource`).
     */
  }, {
    key: '_handleEvent',
    value: function _handleEvent(e) {
      var hitLayers = e.source === 'surface' ? this.getHitLayers(e) : null;
      // emit event as a middleware
      this.emit('event', e, hitLayers);
      // propagate to the state
      if (!this._state) {
        return;
      }
      this._state.handleEvent(e, hitLayers);
    }

    /**
     * Updates the state of the timeline.
     *
     * @type {BaseState}
     */
  }, {
    key: 'add',

    /**
     * Adds a new track to the timeline.
     *
     * @param {Track} track - The new track to be registered in the timeline.
     * @param {String} [trackId=null] - Optionnal unique id to associate with
     *    the track, this id only exists in timeline's context and should be used
     *    in conjonction with `addLayer` method.
     */
    value: function add(track, trackId) {
      if (trackId === undefined) trackId = null;

      if (this.tracks.indexOf(track) !== -1) {
        throw new Error('track already added to the timeline');
      }

      this._registerTrackId(track, trackId);
      track.configure(this.timeContext);

      this.tracks.push(track);
      this.createInteraction(this._surfaceCtor, track);

      this.emit('add', track, trackId);
    }

    /**
     * Removes a track from the timeline and destroys that track.
     *
     * @param {Track} track - the track to remove from the timeline.
     * @todo not implemented.
     */
  }, {
    key: 'remove',
    value: function remove(track) {
      var index = this.tracks.indexOf(track);
      var trackId;
      if (this.tracks.indexOf(track) !== -1) {
        track.destroy();
        delete this._trackById[track.id];
        trackId = track.id;
        track.id = null;
      }
      this.emit('remove', track, trackId);
    }

    /**
     * Helper to create a new `Track` instance. The `track` is added,
     * rendered and updated before being returned.
     *
     * @param {Element} $el - The DOM element where the track should be inserted.
     * @param {Number} trackHeight - The height of the newly created track.
     * @param {String} [trackId=null] - Optionnal unique id to associate with
     *    the track, this id only exists in timeline's context and should be used in
     *    conjonction with `addLayer` method.
     * @return {Track}
     */
  }, {
    key: 'createTrack',
    value: function createTrack($el, trackHeight, trackId) {
      if (trackHeight === undefined) trackHeight = 100;
      if (trackId === undefined) trackId = null;

      var track = new _track2['default']($el, trackHeight);
      // Add track to the timeline
      this.add(track, trackId);

      track.update();

      return track;
    }

    /**
     * If track id is defined, associate a track with a unique id.
     */
  }, {
    key: '_registerTrackId',
    value: function _registerTrackId(track, trackId) {
      if (trackId !== null) {
        if (this._trackById[trackId] !== undefined) {
          throw new Error('trackId: "' + trackId + '" is already used');
        }
        track.id = trackId;
        this._trackById[trackId] = track;
      }
    }

    /**
     * Helper to add a `Layer` instance into a given `Track`. Is designed to be
     * used in conjonction with the `Timeline~getLayersByGroup` method. The
     * layer is internally rendered and updated.
     *
     * @param {Layer} layer - The `Layer` instance to add into the visualization.
     * @param {(Track|String)} trackOrTrackId - The `Track` instance (or its `id`
     *    as defined in the `createTrack` method) where the `Layer` instance should be inserted.
     * @param {String} [groupId='default'] - An optionnal group id in which the
     *    `Layer` should be inserted.
     * @param {Boolean} [isAxis] - Set to `true` if the added `layer` is an
     *    instance of `AxisLayer` (these layers shares the `TimlineTimeContext` instance
     *    of the timeline).
     */
  }, {
    key: 'addLayer',
    value: function addLayer(layer, trackOrTrackId, groupId, isAxis) {

      if (groupId === undefined) groupId = 'default';
      if (isAxis === undefined) isAxis = false;

      var track = trackOrTrackId;

      if (typeof trackOrTrackId === 'string') {
        track = this.getTrackById(trackOrTrackId);
      }

      // creates the `LayerTimeContext` if not present
      if (!layer.timeContext) {
        var timeContext = isAxis ? this.timeContext : new _layerTimeContext2['default'](this.timeContext);

        layer.setTimeContext(timeContext);
      }

      // we should have a Track instance at this point
      track.add(layer);

      if (!this._groupedLayers[groupId]) {
        this._groupedLayers[groupId] = [];
      }

      this._groupedLayers[groupId].push(layer);

      layer.update();
    }

    /**
     * Removes a layer from its track. The layer is detatched from the DOM but
     * can still be reused later.
     *
     * @param {Layer} layer - The layer to remove.
     */
  }, {
    key: 'removeLayer',
    value: function removeLayer(layer) {
      this.tracks.forEach(function (track) {
        var index = track.layers.indexOf(layer);
        if (index !== -1) {
          track.remove(layer);
        }
      });

      // clean references in helpers
      for (var groupId in this._groupedLayers) {
        var group = this._groupedLayers[groupId];
        var index = group.indexOf(layer);

        if (index !== -1) {
          group.splice(layer, 1);
        }

        if (!group.length) {
          delete this._groupedLayers[groupId];
        }
      }
    }

    /**
     * Returns a `Track` instance from it's given id.
     *
     * @param {String} trackId
     * @return {Track}
     */
  }, {
    key: 'getTrackById',
    value: function getTrackById(trackId) {
      return this._trackById[trackId];
    }

    /**
     * Returns the track containing a given DOM Element, returns null if no match found.
     *
     * @param {Element} $el - The DOM Element to be tested.
     * @return {Track}
     */
  }, {
    key: 'getTrackFromDOMElement',
    value: function getTrackFromDOMElement($el) {

      for (var i = 0; i < this.tracks.length; i++) {
        if (this.tracks[i].$stage.content === $el) return this.tracks[i];
      }

      return undefined;
    }

    /**
     * Returns an array of layers from their given group id.
     *
     * @param {String} groupId - The id of the group as defined in `addLayer`.
     * @return {(Array|undefined)}
     */
  }, {
    key: 'getLayersByGroup',
    value: function getLayersByGroup(groupId) {
      return this._groupedLayers[groupId];
    }

    /**
     * Iterates through the added tracks.
     */
  }, {
    key: _Symbol$iterator,
    value: _regeneratorRuntime.mark(function value() {
      return _regeneratorRuntime.wrap(function value$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            return context$2$0.delegateYield(_getIterator(this.tracks), 't0', 1);

          case 1:
          case 'end':
            return context$2$0.stop();
        }
      }, value, this);
    })
  }, {
    key: 'offset',
    get: function get() {
      return this.timeContext.offset;
    },

    /**
     * Updates `TimelineTimeContext`'s `offset` time domain value.
     *
     * @type {Number} [offset=0]
     */
    set: function set(value) {
      this.timeContext.offset = value;
    }

    /**
     * Returns the `TimelineTimeContext`'s `zoom` value.
     *
     * @type {Number} [offset=0]
     */
  }, {
    key: 'zoom',
    get: function get() {
      return this.timeContext.zoom;
    },

    /**
     * Updates the `TimelineTimeContext`'s `zoom` value.
     *
     * @type {Number} [offset=0]
     */
    set: function set(value) {
      this.timeContext.zoom = value;
    }

    /**
     * Returns the `TimelineTimeContext`'s `pixelsPerSecond` ratio.
     *
     * @type {Number} [offset=0]
     */
  }, {
    key: 'pixelsPerSecond',
    get: function get() {
      return this.timeContext.pixelsPerSecond;
    },

    /**
     * Updates the `TimelineTimeContext`'s `pixelsPerSecond` ratio.
     *
     * @type {Number} [offset=0]
     */
    set: function set(value) {
      this.timeContext.pixelsPerSecond = value;
    }

    /**
     * Returns the time interval of the visible area in the timeline.
     *
     * @type {Object} 
     */
  }, {
    key: 'visibleInterval',
    get: function get() {
      return this.timeContext.visibleInterval;
    },

    /**
     * Focus the timeline visible area in the provided time interval.
     *
     * @type {Object} 
     */
    set: function set(value) {
      this.timeContext.visibleInterval = value;
    }

    /**
     * Returns the `TimelineTimeContext`'s `visibleWidth` pixel domain value.
     *
     * @type {Number} [offset=0]
     */
  }, {
    key: 'visibleWidth',
    get: function get() {
      return this.timeContext.visibleWidth;
    },

    /**
     * Updates the `TimelineTimeContext`'s `visibleWidth` pixel domain value.
     *
     * @type {Number} [offset=0]
     */
    set: function set(value) {
      this.timeContext.visibleWidth = value;
    }

    /**
     * Returns `TimelineTimeContext`'s `timeToPixel` transfert function.
     *
     * @type {Function}
     */
  }, {
    key: 'timeToPixel',
    get: function get() {
      return this.timeContext.timeToPixel;
    }

    /**
     * Returns `TimelineTimeContext`'s `visibleDuration` helper value.
     *
     * @type {Number}
     */
  }, {
    key: 'visibleDuration',
    get: function get() {
      return this.timeContext.visibleDuration;
    }

    /**
     * Updates the `TimelineTimeContext`'s `maintainVisibleDuration` value.
     * Defines if the duration of the visible area should be maintain when
     * the `visibleWidth` attribute is updated.
     *
     * @type {Boolean}
     */
  }, {
    key: 'maintainVisibleDuration',
    set: function set(bool) {
      this.timeContext.maintainVisibleDuration = bool;
    },

    /**
     * Returns `TimelineTimeContext`'s `maintainVisibleDuration` current value.
     *
     * @type {Boolean}
     */
    get: function get() {
      return this.timeContext.maintainVisibleDuration;
    }

    /**
     * Object maintaining arrays of `Layer` instances ordered by their `groupId`.
     * Is used internally by the `TrackCollection` instance.
     *
     * @type {Object}
     */
  }, {
    key: 'groupedLayers',
    get: function get() {
      return this._groupedLayers;
    }
  }, {
    key: 'state',
    set: function set(state) {
      if (this._state) {
        this._state.exit();
      }
      this._state = state;
      if (this._state) {
        this._state.enter();
      }
    },

    /**
     * Returns the current state of the timeline.
     *
     * @type {BaseState}
     */
    get: function get() {
      return this._state;
    }

    /**
     * Returns the `TrackCollection` instance.
     *
     * @type {TrackCollection}
     */
  }, {
    key: 'tracks',
    get: function get() {
      return this._tracks;
    }

    /**
     * Returns the list of all registered layers.
     *
     * @type {Array}
     */
  }, {
    key: 'layers',
    get: function get() {
      return this._tracks.layers;
    }
  }]);

  return Timeline;
})(_events2['default'].EventEmitter);

exports['default'] = Timeline;
module.exports = exports['default'];

},{"../interactions/keyboard":36,"../interactions/konva-surface":37,"./layer-time-context":16,"./timeline-time-context":18,"./track":21,"./track-collection":20,"babel-runtime/core-js/get-iterator":68,"babel-runtime/core-js/symbol/iterator":79,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84,"babel-runtime/regenerator":170,"events":174}],20:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _layer = require('./layer');

var _layer2 = _interopRequireDefault(_layer);

/**
 * Collection hosting all the `Track` instances registered into the timeline.
 * It provides shorcuts to trigger `render` / `update` methods on tracks or
 * layers. Extend built-in Array
 */

var TrackCollection = (function (_Array) {
  _inherits(TrackCollection, _Array);

  function TrackCollection(timeline) {
    _classCallCheck(this, TrackCollection);

    _get(Object.getPrototypeOf(TrackCollection.prototype), 'constructor', this).call(this);

    this._timeline = timeline;
  }

  // @note - should be in the timeline ?
  // @todo - allow to pass an array of layers

  _createClass(TrackCollection, [{
    key: '_getLayersOrGroups',
    value: function _getLayersOrGroups(layerOrGroup) {
      if (layerOrGroup === undefined) layerOrGroup = null;

      var layers = null;

      if (typeof layerOrGroup === 'string') {
        layers = this._timeline.groupedLayers[layerOrGroup];
      } else if (layerOrGroup instanceof _layer2['default']) {
        layers = [layerOrGroup];
      } else {
        layers = this.layers;
      }

      return layers;
    }

    // @NOTE keep this ?
    // could prepare some vertical resizing ability
    // this should be able to modify the layers yScale to be really usefull

    /**
     * @type {Number} - Updates the height of all tracks at once.
     * @todo - Propagate to layers, not usefull for now.
     */
  }, {
    key: 'render',

    /**
     * Render all tracks and layers. When done, the timeline triggers a `render` event.
     */
    value: function render() {
      this.forEach(function (track) {
        return track.render();
      });
      this._timeline.emit('render');
    }

    /**
     * Updates all tracks and layers. When done, the timeline triggers a
     * `update` event.
     *
     * @param {Layer|String} layerOrGroup - Filter the layers to update by
     *    passing the `Layer` instance to update or a `groupId`
     */
  }, {
    key: 'update',
    value: function update(layerOrGroup) {
      var layers = this._getLayersOrGroups(layerOrGroup);
      this.forEach(function (track) {
        return track.update(layers);
      });
      this._timeline.emit('update', layers);
    }

    /**
     * Updates all `Track` containers, layers are not updated with this method.
     * When done, the timeline triggers a `update:containers` event.
     */
  }, {
    key: 'updateContainer',
    value: function updateContainer() /* trackOrTrackIds */{
      this.forEach(function (track) {
        return track.updateContainer();
      });
      this._timeline.emit('update:containers');
    }

    /**
     * Updates all layers. When done, the timeline triggers a `update:layers` event.
     *
     * @param {Layer|String} layerOrGroup - Filter the layers to update by
     *    passing the `Layer` instance to update or a `groupId`
     */
  }, {
    key: 'updateLayers',
    value: function updateLayers(layerOrGroup) {
      var layers = this._getLayersOrGroups(layerOrGroup);
      this.forEach(function (track) {
        return track.updateLayers(layers);
      });
      this._timeline.emit('update:layers', layers);
    }
  }, {
    key: 'height',
    set: function set(value) {
      this.forEach(function (track) {
        return track.height = value;
      });
    },
    get: function get() {
      throw new Error('Not implemented');
    }

    /**
     * An array of all registered layers.
     *
     * @type {Array<Layer>}
     */
  }, {
    key: 'layers',
    get: function get() {
      var layers = new _Set();
      this.forEach(function (track) {
        return track.layers.forEach(function (layer) {
          return layers.add(layer);
        });
      });

      return layers;
    }
  }]);

  return TrackCollection;
})(Array);

exports['default'] = TrackCollection;
module.exports = exports['default'];

},{"./layer":17,"babel-runtime/core-js/set":77,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],21:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Symbol$iterator = require('babel-runtime/core-js/symbol/iterator')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var Track = (function (_events$EventEmitter) {
  _inherits(Track, _events$EventEmitter);

  /**
   * @param {DOMElement} $el
   * @param {Number} [height = 100]
   */

  function Track($el, height) {
    _classCallCheck(this, Track);

    _get(Object.getPrototypeOf(Track.prototype), 'constructor', this).call(this);

    if (!height) height = 100;

    this._height = height;

    /**
     * The DOM element in which the track is created.
     * @type {Element}
     */
    this.$el = $el;

    this.$stage = null;

    this.$dragLayer = null;

    this.$interactionsLayer = null;

    this.$backgroundLayer = null;

    /**
     * A set of all the layers belonging to the track.
     * @type {Set<Layer>}
     */
    this.layers = new _Set();
    /**
     * The context used to maintain the DOM structure of the track.
     * @type {TimelineTimeContext}
     */
    this.renderingContext = null;

    this._createContainer();
  }

  /**
   * Returns the height of the track.
   *
   * @type {Number}
   */

  _createClass(Track, [{
    key: 'configure',

    /**
     * This method is called when the track is added to the timeline. The
     * track cannot be updated without being added to a timeline.
     *
     * @private
     * @param {TimelineTimeContext} renderingContext
     */
    value: function configure(renderingContext) {
      this.renderingContext = renderingContext;
    }

    /**
     * Destroy the track and its layers.
     */
  }, {
    key: 'destroy',
    value: function destroy() {
      this.layers.forEach(function (layer) {
        return layer.destroy();
      });
      this.layers.clear();

      this.$stage.destroy();
      this.$interactionsLayer.destroy();
      this.$backgroundLayer.destroy();

      this._height = null;
      this.$el = null;
      this.$stage = null;
      this.$interactionsLayer = null;
      this.$backgroundLayer = null;
      this.renderingContext = null;
    }

    /**
     * Creates the basic Konva structure of the track.
     */
  }, {
    key: '_createContainer',
    value: function _createContainer() {
      this.$stage = new _konva2['default'].Stage({
        height: this.height,
        container: this.$el
      });
      this.$stage.addName('track-stage');

      this.$interactionsLayer = new _konva2['default'].Layer({});
      this.$interactionsLayer.addName('track-interactions');

      this.$backgroundLayer = new _konva2['default'].Layer({});
      this.$backgroundLayer.addName('track-background');
      this.$backgroundLayer.add(new _konva2['default'].Rect({}));
      // this.$backgroundLayer.children[0].shape = { layer: { track: this } }; // Shame!!! ..... Shame!!! .... Shame!!!

      this.$dragLayer = new _konva2['default'].Layer({});
      this.$dragLayer.addName('track-drag-layer');

      this.$stage.add(this.$dragLayer);
      this.$stage.add(this.$interactionsLayer);
      this.$stage.add(this.$backgroundLayer);
    }

    /**
     * Adds a layer to the track.
     *
     * @param {Layer} layer - the layer to add to the track.
     */
  }, {
    key: 'add',
    value: function add(layer) {
      if (!this.layers.has(layer)) {
        layer.createContainer(this.$stage);
        this.layers.add(layer);
        this.moveToTop(layer);
        this.emit('add', layer);
      }
    }

    /**
     * Removes a layer from the track and destroys that alyer
     *
     * @param {Layer} layer - the layer to remove from the track.
     */
  }, {
    key: 'remove',
    value: function remove(layer) {
      // TODO
      if (this.layers.has(layer)) {
        this.layers['delete'](layer);
        layer.destroy();
        this.emit('remove', layer);
      } else {
        throw new Error('Layer not found');
      }
    }

    /**
     * Tests if a given element belongs to the track.
     *
     * @param {Element} $el
     * @return {bool}
     */
  }, {
    key: 'hasElement',
    value: function hasElement($el) {
      throw new Error("deprecated");

      // do {
      //   if ($el === this.$el) {
      //     return true;
      //   }

      //   $el = $el.parentNode;
      // } while ($el !== null);

      // return false;
    }
  }, {
    key: 'hasLayer',
    value: function hasLayer(layer) {
      return this.layers.has(layer);
    }

    /**
     * Render all the layers added to the track.
     */
  }, {
    key: 'render',
    value: function render() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _getIterator(this), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var layer = _step.value;
          layer.render();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    /**
     * Updates the track Konva structure and updates the layers.
     *
     * @param {Array<Layer>} [layers=null] - if not null, a subset of the layers to update.
     */
  }, {
    key: 'update',
    value: function update(layers) {
      if (layers === undefined) layers = null;

      this.updateContainer();
      this.updateLayers(layers);
    }

    /**
     * Updates the track Konva structure.
     */
  }, {
    key: 'updateContainer',
    value: function updateContainer() {
      // Should be in some update layout
      var renderingContext = this.renderingContext;
      var height = this.height;
      var width = Math.round(renderingContext.visibleWidth);
      var offsetX = -Math.round(renderingContext.timeToPixel(renderingContext.offset));

      this.$stage.width(width).height(this.height).offsetX(offsetX);
      this.$interactionsLayer.offsetX(-offsetX);
      this.$backgroundLayer.offsetX(-offsetX);
      this.$backgroundLayer.children[0].x(0).y(0).width(width).height(this.height).opacity(0).moveToBottom();
      this.$backgroundLayer.batchDraw();

      /*
       * Change the layer stack order according to Layer.zIndex.
       */
      // var zIndexCounter = 0;
      // var maxZIndex = -Infinity;
      // this.$backgroundLayer.setZIndex(zIndexCounter++);
      // this.layers.forEach((layer) => {
      //   layer._contextLayer.setZIndex(layer.zIndex + zIndexCounter++);
      //   layer._commonShapeLayer.setZIndex(layer.zIndex + zIndexCounter++);
      //   layer.contentLayers.forEach((konvaLayer) => konvaLayer.setZIndex(layer.zIndex + zIndexCounter++));
      //   layer._dragLayer.setZIndex(layer.zIndex + zIndexCounter++);
      //   maxZIndex = Math.max(maxZIndex, layer.zIndex);
      // })
      // this.$interactionsLayer.setZIndex(maxZIndex + zIndexCounter);
    }

    /**
     * Updates the layers.
     *
     * @param {Array<Layer>} [layers=null] - if not null, a subset of the layers to update.
     */
  }, {
    key: 'updateLayers',
    value: function updateLayers(layers) {
      var _this = this;

      if (layers === undefined) layers = null;

      layers = layers === null ? this.layers : layers;

      if (!(layers instanceof _Set) && !(layers instanceof Array)) layers = [layers];

      layers.forEach(function (layer) {
        if (!_this.layers.has(layer)) {
          return;
        }
        layer.update();
      });
      this.$backgroundLayer.moveToBottom();
    }
  }, {
    key: 'minimize',
    value: function minimize() {
      // TODO
    }
  }, {
    key: 'maximize',
    value: function maximize() {
      // TODO
    }
  }, {
    key: 'moveToTop',
    value: function moveToTop(layer) {
      layer._contextLayer.moveToTop();
      layer._commonShapeLayer.moveToTop();
      layer.contentLayers.forEach(function (konvaLayer) {
        return konvaLayer.moveToTop();
      });

      this.$interactionsLayer.moveToTop();
      this.$backgroundLayer.moveToBottom();
    }
  }, {
    key: 'moveToBottom',
    value: function moveToBottom(layer) {
      this.$interactionsLayer.moveToTop();

      layer.contentLayers.forEach(function (konvaLayer) {
        return konvaLayer.moveToBottom();
      });
      layer._commonShapeLayer.moveToBottom();
      layer._contextLayer.moveToBottom();

      this.$backgroundLayer.moveToBottom();
    }

    /**
     * Iterates through the added layers.
     */
  }, {
    key: _Symbol$iterator,
    value: _regeneratorRuntime.mark(function value() {
      return _regeneratorRuntime.wrap(function value$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            return context$2$0.delegateYield(_getIterator(this.layers), 't0', 1);

          case 1:
          case 'end':
            return context$2$0.stop();
        }
      }, value, this);
    })
  }, {
    key: 'height',
    get: function get() {
      return this._height;
    },

    /**
     * Sets the height of the track.
     *
     * @todo propagate to layers, keeping ratio? could be handy for vertical
     *    resize. This is why a set/get is implemented here.
     * @type {Number}
     */
    set: function set(value) {
      this._height = value;
    }
  }]);

  return Track;
})(_events2['default'].EventEmitter);

exports['default'] = Track;
module.exports = exports['default'];

},{"babel-runtime/core-js/get-iterator":68,"babel-runtime/core-js/set":77,"babel-runtime/core-js/symbol/iterator":79,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84,"babel-runtime/regenerator":170,"events":174,"konva":172}],22:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _shapesAnnotatedMarker = require('../shapes/annotated-marker');

var _shapesAnnotatedMarker2 = _interopRequireDefault(_shapesAnnotatedMarker);

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _behaviorsMarkerBehavior = require('../behaviors/marker-behavior');

var _behaviorsMarkerBehavior2 = _interopRequireDefault(_behaviorsMarkerBehavior);

var AnnotatedMarkerLayer = (function (_Layer) {
  _inherits(AnnotatedMarkerLayer, _Layer);

  function AnnotatedMarkerLayer(data) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    _classCallCheck(this, AnnotatedMarkerLayer);

    _get(Object.getPrototypeOf(AnnotatedMarkerLayer.prototype), 'constructor', this).call(this, 'collection', data, options);

    this.configureShape(_shapesAnnotatedMarker2['default']);
    this.setBehavior(new _behaviorsMarkerBehavior2['default']());
  }

  return AnnotatedMarkerLayer;
})(_coreLayer2['default']);

exports['default'] = AnnotatedMarkerLayer;
module.exports = exports['default'];

},{"../behaviors/marker-behavior":7,"../core/layer":17,"../shapes/annotated-marker":40,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],23:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _shapesAnnotatedSegment = require('../shapes/annotated-segment');

var _shapesAnnotatedSegment2 = _interopRequireDefault(_shapesAnnotatedSegment);

var _behaviorsSegmentBehavior = require('../behaviors/segment-behavior');

var _behaviorsSegmentBehavior2 = _interopRequireDefault(_behaviorsSegmentBehavior);

var AnnotatedSegmentLayer = (function (_Layer) {
  _inherits(AnnotatedSegmentLayer, _Layer);

  function AnnotatedSegmentLayer(data) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var accessors = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, AnnotatedSegmentLayer);

    _get(Object.getPrototypeOf(AnnotatedSegmentLayer.prototype), 'constructor', this).call(this, 'collection', data, options);

    options = _Object$assign({
      displayHandlers: true,
      opacity: 0.6
    }, options);

    this.configureShape(_shapesAnnotatedSegment2['default'], accessors, {
      displayHandlers: options.displayHandlers,
      opacity: options.opacity
    });

    this.setBehavior(new _behaviorsSegmentBehavior2['default']());
  }

  return AnnotatedSegmentLayer;
})(_coreLayer2['default']);

exports['default'] = AnnotatedSegmentLayer;
module.exports = exports['default'];

},{"../behaviors/segment-behavior":10,"../core/layer":17,"../shapes/annotated-segment":41,"babel-runtime/core-js/object/assign":70,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],24:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _shapesMarker = require('../shapes/marker');

var _shapesMarker2 = _interopRequireDefault(_shapesMarker);

var _behaviorsMarkerBehavior = require('../behaviors/marker-behavior');

var _behaviorsMarkerBehavior2 = _interopRequireDefault(_behaviorsMarkerBehavior);

var BeatGridLayer = (function (_Layer) {
  _inherits(BeatGridLayer, _Layer);

  function BeatGridLayer(data) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var accessors = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, BeatGridLayer);

    _get(Object.getPrototypeOf(BeatGridLayer.prototype), 'constructor', this).call(this, 'collection', data, options);

    this.sort_data = options.sort_data;
    this.visible_data = options.visible_data;

    options = _Object$assign({ displayHandlers: true }, options);
    var color = options.color;
    if (color) {
      accessors.color = function () {
        return color;
      };
    }

    this.configureShape(_shapesMarker2['default'], accessors, {
      displayHandlers: options.displayHandlers
    });

    this.setBehavior(new _behaviorsMarkerBehavior2['default']());
  }

  return BeatGridLayer;
})(_coreLayer2['default']);

exports['default'] = BeatGridLayer;
module.exports = exports['default'];

},{"../behaviors/marker-behavior":7,"../core/layer":17,"../shapes/marker":46,"babel-runtime/core-js/object/assign":70,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],25:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _behaviorsBreakpointBehavior = require('../behaviors/breakpoint-behavior');

var _behaviorsBreakpointBehavior2 = _interopRequireDefault(_behaviorsBreakpointBehavior);

var _shapesDot = require('../shapes/dot');

var _shapesDot2 = _interopRequireDefault(_shapesDot);

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _shapesLine = require('../shapes/line');

var _shapesLine2 = _interopRequireDefault(_shapesLine);

var BreakpointLayer = (function (_Layer) {
  _inherits(BreakpointLayer, _Layer);

  function BreakpointLayer(data) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var accessors = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, BreakpointLayer);

    _get(Object.getPrototypeOf(BreakpointLayer.prototype), 'constructor', this).call(this, 'collection', data, options);

    this.sort_data = options.sort_data;
    this.visible_data = options.visible_data;

    var color = options.color;
    var commonShapeOptions = {};

    if (color) {
      accessors.color = function () {
        return color;
      };
      commonShapeOptions.color = color;
    }

    this.configureCommonShape(_shapesLine2['default'], accessors, commonShapeOptions);
    this.configureShape(_shapesDot2['default'], accessors, {});
    this.setBehavior(new _behaviorsBreakpointBehavior2['default']());
  }

  return BreakpointLayer;
})(_coreLayer2['default']);

exports['default'] = BreakpointLayer;
module.exports = exports['default'];

},{"../behaviors/breakpoint-behavior":6,"../core/layer":17,"../shapes/dot":44,"../shapes/line":45,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],26:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _shapesCursor = require('../shapes/cursor');

var _shapesCursor2 = _interopRequireDefault(_shapesCursor);

var CursorLayer = (function (_Layer) {
  _inherits(CursorLayer, _Layer);

  function CursorLayer() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, CursorLayer);

    var defaults = {
      color: 'red',
      hittable: false };

    // kind of pass through layer
    var data = { currentPosition: 0 };

    options = _Object$assign(defaults, options);
    _get(Object.getPrototypeOf(CursorLayer.prototype), 'constructor', this).call(this, 'entity', data, options);

    this.configureShape(_shapesCursor2['default'], { x: function x(d) {
        return d.currentPosition;
      } }, {
      color: options.color
    });

    this.data[0] = data;
  }

  _createClass(CursorLayer, [{
    key: 'currentPosition',
    set: function set(value) {
      this.data[0].currentPosition = value;
    },
    get: function get() {
      return this.data[0].currentPosition;
    }
  }]);

  return CursorLayer;
})(_coreLayer2['default']);

exports['default'] = CursorLayer;
module.exports = exports['default'];

},{"../core/layer":17,"../shapes/cursor":43,"babel-runtime/core-js/object/assign":70,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],27:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _axisAxisLayer = require('../axis/axis-layer');

var _axisAxisLayer2 = _interopRequireDefault(_axisAxisLayer);

var _shapesTicks = require('../shapes/ticks');

var _shapesTicks2 = _interopRequireDefault(_shapesTicks);

var _axisGridAxisGenerator = require('../axis/grid-axis-generator');

var _axisGridAxisGenerator2 = _interopRequireDefault(_axisGridAxisGenerator);

var GridAxisLayer = (function (_AxisLayer) {
  _inherits(GridAxisLayer, _AxisLayer);

  function GridAxisLayer(options) {
    _classCallCheck(this, GridAxisLayer);

    options = _Object$assign({
      color: 'steelblue',
      bpm: 60,
      signature: '4/4'
    }, options);

    _get(Object.getPrototypeOf(GridAxisLayer.prototype), 'constructor', this).call(this, (0, _axisGridAxisGenerator2['default'])(options.bpm, options.signature), options);

    this.configureShape(_shapesTicks2['default'], {}, {
      color: options.color
    });
  }

  return GridAxisLayer;
})(_axisAxisLayer2['default']);

exports['default'] = GridAxisLayer;
module.exports = exports['default'];

},{"../axis/axis-layer":1,"../axis/grid-axis-generator":2,"../shapes/ticks":48,"babel-runtime/core-js/object/assign":70,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],28:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _shapesMarker = require('../shapes/marker');

var _shapesMarker2 = _interopRequireDefault(_shapesMarker);

var _behaviorsMarkerBehavior = require('../behaviors/marker-behavior');

var _behaviorsMarkerBehavior2 = _interopRequireDefault(_behaviorsMarkerBehavior);

var MarkerLayer = (function (_Layer) {
  _inherits(MarkerLayer, _Layer);

  function MarkerLayer(data) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var accessors = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, MarkerLayer);

    _get(Object.getPrototypeOf(MarkerLayer.prototype), 'constructor', this).call(this, 'collection', data, options);

    this.sort_data = options.sort_data;
    this.visible_data = options.visible_data;

    options = _Object$assign({ displayHandlers: true }, options);
    var color = options.color;
    if (color) {
      accessors.color = function () {
        return color;
      };
    }

    this.configureShape(_shapesMarker2['default'], accessors, {
      displayHandlers: options.displayHandlers
    });

    this.setBehavior(new _behaviorsMarkerBehavior2['default']());
  }

  return MarkerLayer;
})(_coreLayer2['default']);

exports['default'] = MarkerLayer;
module.exports = exports['default'];

},{"../behaviors/marker-behavior":7,"../core/layer":17,"../shapes/marker":46,"babel-runtime/core-js/object/assign":70,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],29:[function(require,module,exports){
'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _coreTimeline = require('../core/timeline');

var _coreTimeline2 = _interopRequireDefault(_coreTimeline);

var _coreTrack = require('../core/track');

var _coreTrack2 = _interopRequireDefault(_coreTrack);

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _coreLayerTimeContext = require('../core/layer-time-context');

var _coreLayerTimeContext2 = _interopRequireDefault(_coreLayerTimeContext);

var _behaviorsScrollSegmentBehavior = require('../behaviors/scroll-segment-behavior');

var _behaviorsScrollSegmentBehavior2 = _interopRequireDefault(_behaviorsScrollSegmentBehavior);

var _shapesSegment = require('../shapes/segment');

var _shapesSegment2 = _interopRequireDefault(_shapesSegment);

var _statesSimpleEditionState = require('../states/simple-edition-state');

var _statesSimpleEditionState2 = _interopRequireDefault(_statesSimpleEditionState);

var Scroller = (function () {
	function Scroller($el, targetTimeline, pixelsPerSecond, width, height) {
		_classCallCheck(this, Scroller);

		this.auxTimeline = new _coreTimeline2['default'](pixelsPerSecond, width);
		var t = document.createElement('div');
		t.classList.add("scroll-div");
		$el.appendChild(t);

		this.auxTrack = new _coreTrack2['default'](t, 20, width);

		this.auxScrollLayer = new _coreLayer2['default']('collection', [], {
			height: height,
			yDomain: [0, 1]
		});
		this.auxScrollLayer.setBehavior(new _behaviorsScrollSegmentBehavior2['default'](targetTimeline));
		this.auxScrollLayer.setTimeContext(new _coreLayerTimeContext2['default'](this.auxTimeline.timeContext));
		this.auxScrollLayer.configureShape(_shapesSegment2['default'], {});
		this.auxScrollLayer.timeContext.lockedToParentInterval = true;

		this.auxScrollLayer.sort_data = function (data) {};
		this.auxScrollLayer.visible_data = function (timeContext, data) {
			return [0, data.length - 1];
		};
		this.auxScrollLayer.timeContext.lockedToParentInterval = true;

		this.scrollDatum = { x: targetTimeline.visibleInterval.start, duration: targetTimeline.visibleInterval.duration };
		this.auxScrollLayer.add(this.scrollDatum);

		console.log(targetTimeline.visibleInterval);
		console.log(this.scrollDatum);

		this.auxTimeline.visibleInterval = targetTimeline.visibleInterval;
		this.auxTrack.add(this.auxScrollLayer);
		this.auxTimeline.add(this.auxTrack);
		this.auxTimeline.tracks.update();

		this.auxScrollLayer.edit([this.scrollDatum], 0, 0, this.auxScrollLayer.getShapeFromDatum(this.scrollDatum).$segment);

		this.auxTimeline.state = new _statesSimpleEditionState2['default'](this.auxTimeline);

		var that = this;
		this.auxTimeline.on('event', function (e) {
			if (e.type == 'click' && e.target && !e.target.shape) {
				var offset = -that.auxTimeline.timeContext.offset;
				var time = that.auxTimeline.timeContext.timeToPixel.invert(e.x);
				var currentTime = offset + time;
				var dx = e.x - that.auxTimeline.timeContext.timeToPixel(that.scrollDatum.x);
				var shape = that.auxScrollLayer.getShapeFromDatum(that.scrollDatum);

				that.auxScrollLayer.edit([that.scrollDatum], dx, 0, shape.$segment);
				that.auxTimeline.tracks.update();
			}
		});
	}

	_createClass(Scroller, [{
		key: 'availableScrollRange',
		set: function set(interval) {
			this.auxTimeline.visibleInterval = interval;
			this.auxTimeline.tracks.update();
		},
		get: function get() {
			return this.auxTimeline.visibleInterval;
		}
	}, {
		key: 'visibleRange',
		set: function set(interval) {
			var targetX = this.auxTimeline.timeContext.timeToPixel(interval.start);
			var x = this.auxTimeline.timeContext.timeToPixel(this.scrollDatum.x);
			var dx = targetX - x;
			this.scrollDatum.width = interval.duration;

			var shape = this.auxScrollLayer.getShapeFromDatum(this.scrollDatum);
			this.auxScrollLayer.edit([this.scrollDatum], dx, 0, shape.$segment);

			this.auxTimeline.tracks.update();
		},
		get: function get() {
			return { start: this.scrollDatum.x, duration: this.scrollDatum.width };
		}
	}, {
		key: 'color',
		set: function set(value) {
			this.auxScrollLayer.getShapeFromDatum(this.scrollDatum).params.color = value;
			this.auxTimeline.tracks.update();
		},
		get: function get() {
			return this.auxScrollLayer.getShapeFromDatum(this.scrollDatum).params.color;
		}
	}]);

	return Scroller;
})();

exports['default'] = Scroller;
module.exports = exports['default'];

},{"../behaviors/scroll-segment-behavior":9,"../core/layer":17,"../core/layer-time-context":16,"../core/timeline":19,"../core/track":21,"../shapes/segment":47,"../states/simple-edition-state":63,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/interop-require-default":84}],30:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _shapesSegment = require('../shapes/segment');

var _shapesSegment2 = _interopRequireDefault(_shapesSegment);

var _behaviorsSegmentBehavior = require('../behaviors/segment-behavior');

var _behaviorsSegmentBehavior2 = _interopRequireDefault(_behaviorsSegmentBehavior);

var SegmentLayer = (function (_Layer) {
  _inherits(SegmentLayer, _Layer);

  function SegmentLayer(data) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var accessors = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, SegmentLayer);

    _get(Object.getPrototypeOf(SegmentLayer.prototype), 'constructor', this).call(this, 'collection', data, options);

    this.sort_data = options.sort_data;
    this.visible_data = options.visible_data;

    options = _Object$assign({
      displayHandlers: true,
      opacity: 0.6
    }, options);

    this.configureShape(_shapesSegment2['default'], accessors, {
      displayHandlers: options.displayHandlers,
      opacity: options.opacity
    });

    this.setBehavior(new _behaviorsSegmentBehavior2['default']());
  }

  return SegmentLayer;
})(_coreLayer2['default']);

exports['default'] = SegmentLayer;
module.exports = exports['default'];

},{"../behaviors/segment-behavior":10,"../core/layer":17,"../shapes/segment":47,"babel-runtime/core-js/object/assign":70,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],31:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _shapesTicks = require('../shapes/ticks');

var _shapesTicks2 = _interopRequireDefault(_shapesTicks);

var TickLayer = (function (_Layer) {
  _inherits(TickLayer, _Layer);

  function TickLayer(data, options, accessors) {
    _classCallCheck(this, TickLayer);

    options = _Object$assign({}, options);

    _get(Object.getPrototypeOf(TickLayer.prototype), 'constructor', this).call(this, 'entity', data, options);

    this.sort_data = options.sort_data;
    this.visible_data = options.visible_data;

    var config = options.color ? { color: options.color } : undefined;
    this.configureShape(_shapesTicks2['default'], accessors, config);
  }

  return TickLayer;
})(_coreLayer2['default']);

exports['default'] = TickLayer;
module.exports = exports['default'];

},{"../core/layer":17,"../shapes/ticks":48,"babel-runtime/core-js/object/assign":70,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],32:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _axisAxisLayer = require('../axis/axis-layer');

var _axisAxisLayer2 = _interopRequireDefault(_axisAxisLayer);

var _shapesTicks = require('../shapes/ticks');

var _shapesTicks2 = _interopRequireDefault(_shapesTicks);

var _axisTimeAxisGenerator = require('../axis/time-axis-generator');

var _axisTimeAxisGenerator2 = _interopRequireDefault(_axisTimeAxisGenerator);

var TimeAxisLayer = (function (_AxisLayer) {
  _inherits(TimeAxisLayer, _AxisLayer);

  function TimeAxisLayer(options) {
    _classCallCheck(this, TimeAxisLayer);

    options = _Object$assign({ color: 'steelblue' }, options);
    _get(Object.getPrototypeOf(TimeAxisLayer.prototype), 'constructor', this).call(this, (0, _axisTimeAxisGenerator2['default'])(), options);

    this.sort_data = options.sort_data;
    this.visible_data = options.visible_data;

    this.configureShape(_shapesTicks2['default'], {}, {
      color: options.color
    });
  }

  return TimeAxisLayer;
})(_axisAxisLayer2['default']);

exports['default'] = TimeAxisLayer;
module.exports = exports['default'];

},{"../axis/axis-layer":1,"../axis/time-axis-generator":3,"../shapes/ticks":48,"babel-runtime/core-js/object/assign":70,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],33:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _shapesTracePath = require('../shapes/trace-path');

var _shapesTracePath2 = _interopRequireDefault(_shapesTracePath);

var _shapesTraceDots = require('../shapes/trace-dots');

var _shapesTraceDots2 = _interopRequireDefault(_shapesTraceDots);

var _behaviorsTraceBehavior = require('../behaviors/trace-behavior');

var _behaviorsTraceBehavior2 = _interopRequireDefault(_behaviorsTraceBehavior);

var TraceLayer = (function (_Layer) {
  _inherits(TraceLayer, _Layer);

  function TraceLayer(data) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var accessors = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, TraceLayer);

    options = _Object$assign({ displayDots: true }, options);
    _get(Object.getPrototypeOf(TraceLayer.prototype), 'constructor', this).call(this, options.displayDots ? 'collection' : 'entity', data, options);

    this.sort_data = options.sort_data;
    this.visible_data = options.visible_data;

    var shapeOptions = {};
    if (options.meanColor !== undefined) {
      shapeOptions.meanColor = options.meanColor;
    }
    if (options.rangeColor !== undefined) {
      shapeOptions.rangeColor = options.rangeColor;
    }
    if (options.displayMean !== undefined) {
      shapeOptions.displayMean = options.displayMean;
    }

    if (options.displayDots) {
      this.configureCommonShape(_shapesTracePath2['default'], accessors, shapeOptions);
      this.configureShape(_shapesTraceDots2['default'], accessors, shapeOptions);
    } else {
      this.configureShape(_shapesTracePath2['default'], accessors, shapeOptions);
    }

    this.setBehavior(new _behaviorsTraceBehavior2['default']());
  }

  return TraceLayer;
})(_coreLayer2['default']);

exports['default'] = TraceLayer;
module.exports = exports['default'];

},{"../behaviors/trace-behavior":14,"../core/layer":17,"../shapes/trace-dots":49,"../shapes/trace-path":50,"babel-runtime/core-js/object/assign":70,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],34:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _coreLayer = require('../core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _shapesWaveform = require('../shapes/waveform');

var _shapesWaveform2 = _interopRequireDefault(_shapesWaveform);

var defaults = {
  yDomain: [-1, 1],
  channel: 0,
  color: 'steelblue',
  renderingStrategy: 'svg'
};

var WaveformLayer = (function (_Layer) {
  _inherits(WaveformLayer, _Layer);

  function WaveformLayer(data, options) {
    _classCallCheck(this, WaveformLayer);

    options = _Object$assign({}, defaults, options);

    _get(Object.getPrototypeOf(WaveformLayer.prototype), 'constructor', this).call(this, 'collection', data, options);

    this.sort_data = options.sort_data;
    this.visible_data = options.visible_data;

    this.configureShape(_shapesWaveform2['default'], {}, {
      sampleRate: buffer.sampleRate,
      color: options.color,
      renderingStrategy: options.renderingStrategy
    });
  }

  return WaveformLayer;
})(_coreLayer2['default']);

exports['default'] = WaveformLayer;
module.exports = exports['default'];

},{"../core/layer":17,"../shapes/waveform":51,"babel-runtime/core-js/object/assign":70,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],35:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

/**
 * Abstract class to extend to create new sources of interactions.
 * A `Surface` and `Keyboard` event sources are provided.
 */

var EventSource = (function (_events$EventEmitter) {
  _inherits(EventSource, _events$EventEmitter);

  function EventSource($el) {
    _classCallCheck(this, EventSource);

    _get(Object.getPrototypeOf(EventSource.prototype), 'constructor', this).call(this);
    /**
     * The element on which the listener is added
     * @type {Element}
     */
    this.$el = $el;

    this._bindEvents();
  }

  _createClass(EventSource, [{
    key: '_createEvent',
    value: function _createEvent(type, e) {}
  }, {
    key: '_bindEvents',
    value: function _bindEvents() {}
  }]);

  return EventSource;
})(_events2['default'].EventEmitter);

exports['default'] = EventSource;
module.exports = exports['default'];

},{"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84,"events":174}],36:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _eventSource = require('./event-source');

var _eventSource2 = _interopRequireDefault(_eventSource);

var _waveEvent = require('./wave-event');

var _waveEvent2 = _interopRequireDefault(_waveEvent);

/**
 * A global event sourve for the keyboard. Only one instance of this source
 * can be created. The first created timeline instanciate the singleton, each
 * subsequent instanciation returns the first created instance.
 */

var Keyboard = (function (_EventSource) {
  _inherits(Keyboard, _EventSource);

  /**
   * @param {Element} $el - The element on which to install the listener.
   */

  function Keyboard($el) {
    _classCallCheck(this, Keyboard);

    // kind of singleton
    if (Keyboard._instance) {
      return Keyboard._instance;
    }

    _get(Object.getPrototypeOf(Keyboard.prototype), 'constructor', this).call(this, $el);
    /**
     * The name of the source
     * @type {String}
     */
    this.sourceName = 'keyboard';

    Keyboard._instance = this;
  }

  _createClass(Keyboard, [{
    key: '_createEvent',
    value: function _createEvent(type, e) {
      var event = new _waveEvent2['default'](this.sourceName, type, e);

      event.shiftKey = e.shiftKey;
      event.ctrlKey = e.ctrlKey;
      event.altKey = e.altKey;
      event.metaKey = e.metaKey;
      event.char = String.fromCharCode(e.keyCode);

      return event;
    }
  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this = this;

      var onKeyDown = function onKeyDown(e) {
        var event = _this._createEvent('keydown', e);
        _this.emit('event', event);
      };

      var onKeyUp = function onKeyUp(e) {
        var event = _this._createEvent('keyup', e);
        _this.emit('event', event);
      };

      this.$el.addEventListener('keydown', onKeyDown, false);
      this.$el.addEventListener('keyup', onKeyUp, false);
    }
  }]);

  return Keyboard;
})(_eventSource2['default']);

exports['default'] = Keyboard;
module.exports = exports['default'];

},{"./event-source":35,"./wave-event":39,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],37:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _eventSource = require('./event-source');

var _eventSource2 = _interopRequireDefault(_eventSource);

var _konvaWaveEvent = require('./konva-wave-event');

var _konvaWaveEvent2 = _interopRequireDefault(_konvaWaveEvent);

/**
 * Normalizes mouse user interactions with the timeline upon the DOM
 * container element of `Track` instances. As soon as a `track` is added to a
 * `timeline`, its attached `Surface` instance will emit the mouse events.
 */

var Surface = (function (_EventSource) {
  _inherits(Surface, _EventSource);

  /**
   * @param {DOMElement} el - The DOM element to listen.
   * @todo - Add some padding to the surface.
   */

  function Surface($el) {
    _classCallCheck(this, Surface);

    _get(Object.getPrototypeOf(Surface.prototype), 'constructor', this).call(this, $el);

    /**
     * The name of the event source.
     * @type {String}
     */
    this.sourceName = 'surface';
    this._mouseDownEvent = null;
    this._lastEvent = null;
  }

  /**
   * Factory method for `Event` class
   */

  _createClass(Surface, [{
    key: '_createEvent',
    value: function _createEvent(type, e) {
      var event = new _konvaWaveEvent2['default'](this.sourceName, type, e);

      var pos = this._getRelativePosition(e);
      event.x = pos.x;
      event.y = pos.y;

      return event;
    }

    /**
     * Returns the x, y coordinates coordinates relative to the surface element.
     *
     * @param {Event} e - Raw event from listener.
     * @return {Object}
     * @todo - handle padding.
     */
  }, {
    key: '_getRelativePosition',
    value: function _getRelativePosition(e) {
      if (e instanceof MouseEvent) {
        var x = e.offsetX;
        var y = e.offsetY;
        return { x: x, y: y };
      } else {
        var x = e.evt.offsetX;
        var y = e.evt.offsetY;
        return { x: x, y: y };
      }
    }
  }, {
    key: '_defineArea',
    value: function _defineArea(e, mouseDownEvent, lastEvent) {
      if (!mouseDownEvent || !lastEvent) {
        return;
      }
      e.dx = e.x - lastEvent.x;
      e.dy = e.y - lastEvent.y;

      var left = mouseDownEvent.x < e.x ? mouseDownEvent.x : e.x;
      var top = mouseDownEvent.y < e.y ? mouseDownEvent.y : e.y;
      var width = Math.abs(Math.round(e.x - mouseDownEvent.x));
      var height = Math.abs(Math.round(e.y - mouseDownEvent.y));

      e.area = { left: left, top: top, width: width, height: height };
    }

    /**
     * Keep this private to avoid double event binding. Main logic of the surface
     * is here. Should be extended with needed events (mouseenter, mouseleave,
     * wheel ...).
     */
  }, {
    key: '_bindEvents',
    value: function _bindEvents() {
      var _this = this;

      var onMouseDrag = function onMouseDrag(e) {

        var event = _this._createEvent('mousemove', e);
        _this._defineArea(event, _this._mouseDownEvent, _this._lastEvent);
        // Update `lastEvent` for next call
        _this._lastEvent = event;

        _this.emit('event', event);
      };

      var onMouseUp = function onMouseUp(e) {

        if (_this._lastEvent.type == 'mousemove') {

          var _event = _this._createEvent('mouseup', e);
          _this._defineArea(_event, _this._mouseDownEvent, _this._lastEvent);

          _this._mouseDownEvent = null;
          _this._lastEvent = null;
          // Remove mousemove and mouseup listeners on window
          window.removeEventListener('mousemove', onMouseDrag);
          window.removeEventListener('mouseup', onMouseUp);

          _this.emit('event', _event);
        } else if (_this._lastEvent.type == 'mousedown') {

          var event1 = _this._createEvent('mouseup', e);
          var event2 = _this._createEvent('click', e);
          event2.target = _this._mouseDownEvent.target;

          _this._mouseDownEvent = null;
          _this._lastEvent = null;

          // Remove mousemove and mouseup listeners on window
          window.removeEventListener('mousemove', onMouseDrag);
          window.removeEventListener('mouseup', onMouseUp);

          _this.emit('event', event1);
          _this.emit('event', event2);
        }
      };

      var onMouseDown = function onMouseDown(e) {
        // By removing the previous selection we prevent bypassing the mousemove events coming from SVG in Firefox.
        window.getSelection().removeAllRanges();
        var event = _this._createEvent('mousedown', e);

        _this._mouseDownEvent = event;
        _this._lastEvent = event;
        // Register mousemove and mouseup listeners on window
        window.addEventListener('mousemove', onMouseDrag, false);
        window.addEventListener('mouseup', onMouseUp, false);

        event.cancelBubble = true;

        _this.emit('event', event);
      };

      var onClick = function onClick(e) {
        var event = _this._createEvent('click', e);
        _this.emit('event', event);
      };

      var onDblClick = function onDblClick(e) {
        var event = _this._createEvent('dblclick', e);
        _this.emit('event', event);
      };

      var onMouseOver = function onMouseOver(e) {
        var event = _this._createEvent('mouseover', e);
        _this.emit('event', event);
      };

      var onMouseOut = function onMouseOut(e) {
        var event = _this._createEvent('mouseout', e);
        _this.emit('event', event);
      };

      var onMouseDownTimeline = function onMouseDownTimeline(e) {
        var event = _this._createEvent('mousedown', e);
        _this.emit('event', event);
      };

      var onDomDragStart = function onDomDragStart(e) {
        var event = _this._createEvent('dragstart', e);
        _this.emit('event', event);
      };

      var onDomDragOver = function onDomDragOver(e) {
        var event = _this._createEvent('dragover', e);
        _this.emit('event', event);
      };

      var onDomDrop = function onDomDrop(e) {
        var event = _this._createEvent('drop', e);
        _this.emit('event', event);
      };

      var onDomDragLeave = function onDomDragLeave(e) {
        var event = _this._createEvent('dragleave', e);
        _this.emit('event', event);
      };

      var onDomDragEnter = function onDomDragEnter(e) {
        var event = _this._createEvent('dragenter', e);
        _this.emit('event', event);
      };

      /*
       * When I listen for the 'click' event, there is the following issue for 'drag' sequences:
       *
       * (1) [mousedown -> mousemove -> click -> mouseup] 
       *  instead of 
       * (2) [mousedown -> mousemove -> mouseup]
       * 
       * For this reason, instead of directly listening for 'click', I adapted the 'mouseup' 
       * listener to enforce the sequence (2) and [mousedown -> mouseup -> click] .
       */

      // Bind callbacks
      // this.$el.$stage.on('contentMousedown', onMouseDownTimeline);
      this.$el.$stage.on('mousedown', onMouseDown);
      // this.$el.$stage.on('click', onClick);
      this.$el.$stage.on('dblclick', onDblClick);
      this.$el.$stage.on('mouseover', onMouseOver);
      this.$el.$stage.on('mouseout', onMouseOut);
      this.$el.$stage.on('mouseover', onMouseOver);
      this.$el.$stage.content.addEventListener('dragstart', onDomDragStart);
      this.$el.$stage.content.addEventListener('dragenter', onDomDragEnter);
      this.$el.$stage.content.addEventListener('drop', onDomDrop);
      this.$el.$stage.content.addEventListener('dragover', onDomDragOver);
      this.$el.$stage.content.addEventListener('dragleave', onDomDragLeave);
    }
  }]);

  return Surface;
})(_eventSource2['default']);

exports['default'] = Surface;
module.exports = exports['default'];

},{"./event-source":35,"./konva-wave-event":38,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],38:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _waveEvent = require('./wave-event');

var _waveEvent2 = _interopRequireDefault(_waveEvent);

/**
 * Object template for all events. Event sources should use this event template
 * in order to keep consistency with existing sources.
 */

var KonvaWaveEvent = (function (_WaveEvent) {
  _inherits(KonvaWaveEvent, _WaveEvent);

  /**
   * @param {String} source - The name of the source (`keyboard`, `surface`, ...).
   * @param {String} type - The type of the source (`mousedown`, `keyup`, ...).
   * @param {Event} originalEvent - The original event as emitted by the browser.
   */

  function KonvaWaveEvent(source, type, originalEvent) {
    _classCallCheck(this, KonvaWaveEvent);

    _get(Object.getPrototypeOf(KonvaWaveEvent.prototype), 'constructor', this).call(this, source, type, originalEvent);
    if (!(originalEvent instanceof MouseEvent)) {
      this.originalEvent = originalEvent.evt;
      this.currentTarget = originalEvent.evt.currentTarget;
    }
  }

  return KonvaWaveEvent;
})(_waveEvent2['default']);

exports['default'] = KonvaWaveEvent;
module.exports = exports['default'];

},{"./wave-event":39,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],39:[function(require,module,exports){
'use strict';

/**
 * Object template for all events. Event sources should use this event template
 * in order to keep consistency with existing sources.
 */

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var WaveEvent =
/**
 * @param {String} source - The name of the source (`keyboard`, `surface`, ...).
 * @param {String} type - The type of the source (`mousedown`, `keyup`, ...).
 * @param {Event} originalEvent - The original event as emitted by the browser.
 */
function WaveEvent(source, type, originalEvent) {
  _classCallCheck(this, WaveEvent);

  this.source = source;
  this.type = type;
  this.originalEvent = originalEvent;

  this.target = originalEvent.target;
  this.currentTarget = originalEvent.currentTarget;
};

exports['default'] = WaveEvent;
module.exports = exports['default'];

},{"babel-runtime/helpers/class-call-check":80}],40:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _marker = require('./marker');

var _marker2 = _interopRequireDefault(_marker);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var AnnotatedMarker = (function (_Marker) {
  _inherits(AnnotatedMarker, _Marker);

  function AnnotatedMarker() {
    _classCallCheck(this, AnnotatedMarker);

    _get(Object.getPrototypeOf(AnnotatedMarker.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(AnnotatedMarker, [{
    key: 'destroy',
    value: function destroy() {
      this.$label.destroy();
      this.$label = null;
      _get(Object.getPrototypeOf(AnnotatedMarker.prototype), 'destroy', this).call(this);
    }
  }, {
    key: 'getClassName',
    value: function getClassName() {
      return 'annotated-segment';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      var list = _get(Object.getPrototypeOf(AnnotatedMarker.prototype), '_getAccessorList', this).call(this);
      list.text = 'default';
      return list;
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      if (this.$el) {
        return this.$el;
      }

      this.$el = _get(Object.getPrototypeOf(AnnotatedMarker.prototype), 'render', this).call(this, renderingContext);

      this.$label = new _konva2['default'].Text({ listening: false });
      this.$label.addName('text');

      this.$el.push(this.$label);

      return this.$el;
    }
  }, {
    key: 'update',
    value: function update(renderingContext, datum) {
      var d = datum || this.datum;

      _get(Object.getPrototypeOf(AnnotatedMarker.prototype), 'update', this).call(this, renderingContext, d);

      var width = renderingContext.timeToPixel(this.width(d));
      var height = Math.abs(renderingContext.valueToPixel(this.y(d) + this.height(d)) - renderingContext.valueToPixel(this.y(d)));
      var x = renderingContext.timeToPixel(this.x(d));
      var y = renderingContext.valueToPixel(this.y(d) + this.height(d));
      var text = this.text(d);

      this.$label.x(x + 3).y(y + 11);
      this.$label.height(y);
      this.$label.fill('#242424');
      this.$label.fontSize(10);
      this.$label.fontFamily('monospace');
      this.$label.text(text);
    }
  }]);

  return AnnotatedMarker;
})(_marker2['default']);

exports['default'] = AnnotatedMarker;
module.exports = exports['default'];

},{"./marker":46,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84,"konva":172}],41:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _segment = require('./segment');

var _segment2 = _interopRequireDefault(_segment);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var AnnotatedSegment = (function (_Segment) {
  _inherits(AnnotatedSegment, _Segment);

  function AnnotatedSegment() {
    _classCallCheck(this, AnnotatedSegment);

    _get(Object.getPrototypeOf(AnnotatedSegment.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(AnnotatedSegment, [{
    key: 'destroy',
    value: function destroy() {
      this.$label.destroy();
      this.$label = null;
      _get(Object.getPrototypeOf(AnnotatedSegment.prototype), 'destroy', this).call(this);
    }
  }, {
    key: 'getClassName',
    value: function getClassName() {
      return 'annotated-segment';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      var list = _get(Object.getPrototypeOf(AnnotatedSegment.prototype), '_getAccessorList', this).call(this);
      list.text = 'default';
      return list;
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      if (this.$el) {
        return this.$el;
      }

      this.$el = _get(Object.getPrototypeOf(AnnotatedSegment.prototype), 'render', this).call(this, renderingContext);

      this.$label = new _konva2['default'].Text({ listening: false });
      this.$label.addName('text');

      this.$el.push(this.$label);

      return this.$el;
    }
  }, {
    key: 'update',
    value: function update(renderingContext, datum) {
      var d = datum || this.datum;

      _get(Object.getPrototypeOf(AnnotatedSegment.prototype), 'update', this).call(this, renderingContext, d);

      var width = renderingContext.timeToPixel(this.width(d));
      var height = Math.abs(renderingContext.valueToPixel(this.y(d) + this.height(d)) - renderingContext.valueToPixel(this.y(d)));
      var x = renderingContext.timeToPixel(this.x(d));
      var y = renderingContext.valueToPixel(this.y(d) + this.height(d));
      var text = this.text(d);

      this.$label.x(x + 3).y(y + 11);
      this.$label.height(y);
      this.$label.fill('#242424');
      this.$label.fontSize(10);
      this.$label.fontFamily('monospace');
      this.$label.text(text);
    }
  }]);

  return AnnotatedSegment;
})(_segment2['default']);

exports['default'] = AnnotatedSegment;
module.exports = exports['default'];

},{"./segment":47,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84,"konva":172}],42:[function(require,module,exports){
'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _Object$defineProperty = require('babel-runtime/core-js/object/define-property')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _segment = require('./segment');

var _segment2 = _interopRequireDefault(_segment);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var BaseShape = (function () {
  /**
   * @param {Object} options - override default configuration
   */

  function BaseShape(options) {
    _classCallCheck(this, BaseShape);

    if (options === undefined) options = {};
    /** @type {Element} - Konva.Group to be returned by the `render` method. */
    this.$el = null;
    /** @type {Object} - Object containing the global parameters of the shape */
    this.params = _Object$assign({}, this._getDefaults(), options);

    this.layer = null;

    this._visible = true;
    this._highlight = false;
    this._datum = null;

    // create accessors methods and set default accessor functions
    var accessors = this._getAccessorList();
    this._createAccessors(accessors);
    this._setDefaultAccessors(accessors);
  }

  /**
   * Destroy the shape and clean references. Interface method called from the `layer`.
   */

  _createClass(BaseShape, [{
    key: 'destroy',
    value: function destroy() {
      if (this.$el instanceof Array) {
        for (var i = 0; i < this.$el.length; i++) {
          this.$el[i].shape = null;
        }
        this.$el.length = 0;
      } else if (this.$el) {
        this.$el.shape = null;
      }
      this.$el = null;
      this.$params = null;
      this._accessors = null;
      this._datum = null;
    }

    /**
     * Interface method to override when extending this base class. The method
     * is called by the `Layer~render` method. Returns the name of the shape,
     * used as a class in the element group (defaults to `'shape'`).
     *
     * @return {String}
     */
  }, {
    key: 'getClassName',
    value: function getClassName() {
      return 'shape';
    }

    /**
     * @todo not implemented
     * allow to install defs in the track svg element. Should be called when
     * adding the `Layer` to the `Track`.
     */
    // setSvgDefinition(defs) {}

    /**
     * Returns the defaults for global configuration of the shape.
     * @protected
     * @return {Object}
     */
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return {};
    }

    /**
     * Returns an object where keys are the accessors methods names to create
     * and values are the default values for each given accessor.
     *
     * @protected
     * @todo rename ?
     * @return {Object}
     */
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return {};
    }

    /**
     * Interface method called by Layer when creating a shape. Install the
     * given accessors on the shape, overriding the default accessors.
     *
     * @param {Object<String, function>} accessors
     */
  }, {
    key: 'install',
    value: function install(accessors) {
      for (var key in accessors) {
        this[key] = accessors[key];
      }
    }

    /**
     * Generic method to create accessors. Adds getters en setters to the
     * prototype if not already present.
     */
  }, {
    key: '_createAccessors',
    value: function _createAccessors(accessors) {
      this._accessors = {};
      // add it to the prototype
      var proto = Object.getPrototypeOf(this);
      // create a getter / setter for each accessors
      // setter : `this.x = callback`
      // getter : `this.x(datum)`
      _Object$keys(accessors).forEach(function (name) {
        if (proto.hasOwnProperty(name)) {
          return;
        }

        _Object$defineProperty(proto, name, {
          get: function get() {
            return this._accessors[name];
          },
          set: function set(func) {
            this._accessors[name] = func;
          }
        });
      });
    }

    /**
     * Create a function to be used as a default accessor for each accesors
     */
  }, {
    key: '_setDefaultAccessors',
    value: function _setDefaultAccessors(accessors) {
      var _this = this;

      _Object$keys(accessors).forEach(function (name) {
        var defaultValue = accessors[name];
        var accessor = function accessor(d, v) {
          if (v === undefined) v = null;
          if (v === null) {
            return d[name] || defaultValue;
          }
          d[name] = v;
        };
        // set accessor as the default one
        _this[name] = accessor;
      });
    }

    /**
     * Interface method called by `Layer~render`. Creates the DOM structure of
     * the shape.
     *
     * @param {Object} renderingContext - the renderingContext of the layer
     *    which owns this shape.
     * @return {Element} - the DOM element to insert in the item's group.
     */
  }, {
    key: 'render',
    value: function render(renderingContext) {}

    /**
     * Interface method called by `Layer~update`. Updates the DOM structure of the shape.
     *
     * @param {Object} renderingContext - The `renderingContext` of the layer
     *    which owns this shape.
     * @param {Object|Array} datum - The datum associated to the shape.
     */
  }, {
    key: 'update',
    value: function update(renderingContext, datum) {}

    /**
     *  TODO
     */
  }, {
    key: 'draw',
    value: function draw() {
      if (this.$el instanceof Array) {
        for (var i = 0; i < this.$el.length; i++) this.$el[i].draw();
      } else {
        this.$el.draw();
      }
    }

    /**
     * Interface method to override called by `Layer~getItemsInArea`. Defines if
     * the shape is considered to be the given area. Arguments are passed in pixel domain.
     *
     * @param {Object} renderingContext - the renderingContext of the layer which
     *    owns this shape.
     * @param {Object|Array} datum - The datum associated to the shape.
     * @param {Number} x1 - The x component of the top-left corner of the area to test.
     * @param {Number} y1 - The y component of the top-left corner of the area to test.
     * @param {Number} x2 - The x component of the bottom-right corner of the area to test.
     * @param {Number} y2 - The y component of the bottom-right corner of the area to test.
     * @return {Boolean} - Returns `true` if the is considered to be in the given area, `false` otherwise.
     */
  }, {
    key: 'inArea',
    value: function inArea(renderingContext, datum, x1, y1, x2, y2) {}

    /*
     * TODO
     */
  }, {
    key: 'minimize',
    value: function minimize() {}
  }, {
    key: 'maximize',
    value: function maximize() {}

    /*
     * TODO
     */
  }, {
    key: 'startDrag',
    value: function startDrag() {
      if (this.$el instanceof Array) {
        this.$el.forEach(function (el) {
          return el.startDrag();
        });
      } else {
        this.$el.startDrag();
      }
    }
  }, {
    key: 'stopDrag',
    value: function stopDrag() {
      if (this.$el instanceof Array) {
        this.$el.forEach(function (el) {
          return el.stopDrag();
        });
      } else {
        this.$el.stopDrag();
      }
    }
  }, {
    key: 'visible',
    get: function get() {
      return this._visible;
    },
    set: function set(isVisible) {
      this._visible = isVisible;
    }

    /*
     * TODO
     */
  }, {
    key: 'datum',
    get: function get() {
      return this._datum;
    },
    set: function set(datum) {
      this._datum = datum;
    }
  }]);

  return BaseShape;
})();

exports['default'] = BaseShape;
module.exports = exports['default'];

},{"./segment":47,"babel-runtime/core-js/object/assign":70,"babel-runtime/core-js/object/define-property":72,"babel-runtime/core-js/object/keys":74,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/interop-require-default":84,"konva":172}],43:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseShape = require('./base-shape');

var _baseShape2 = _interopRequireDefault(_baseShape);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

/**
 * A shape to display a cursor.
 */

var Cursor = (function (_BaseShape) {
  _inherits(Cursor, _BaseShape);

  function Cursor() {
    _classCallCheck(this, Cursor);

    _get(Object.getPrototypeOf(Cursor.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Cursor, [{
    key: 'getClassName',
    value: function getClassName() {
      return 'cursor';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return { x: 0 };
    }
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return {
        color: '#000000',
        opacity: 1,
        width: 2
      };
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      if (this.$el) {
        return this.$el;
      }

      this.$el = new _konva2['default'].Rect({});

      return this.$el;
    }
  }, {
    key: 'update',
    value: function update(renderingContext, datum) {
      // const x = Math.round(renderingContext.timeToPixel(this.x(datum))) + 0.5;
      var x = renderingContext.timeToPixel(this.x(datum));

      this.$el.x(x).y(0).width(this.params.width).height(renderingContext.height).fill(this.params.color).opacity(this.params.opacity);
    }

    /**
     * The cursor cannot be selected.
     * @return {Boolean} false
     */
  }, {
    key: 'inArea',
    value: function inArea() {
      return false;
    }
  }]);

  return Cursor;
})(_baseShape2['default']);

exports['default'] = Cursor;
module.exports = exports['default'];

},{"./base-shape":42,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84,"konva":172}],44:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _baseShape = require('./base-shape');

var _baseShape2 = _interopRequireDefault(_baseShape);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var Dot = (function (_BaseShape) {
	_inherits(Dot, _BaseShape);

	function Dot() {
		_classCallCheck(this, Dot);

		_get(Object.getPrototypeOf(Dot.prototype), 'constructor', this).apply(this, arguments);
	}

	_createClass(Dot, [{
		key: 'destroy',
		value: function destroy() {
			this.$el.destroy();
			_get(Object.getPrototypeOf(Dot.prototype), 'destroy', this).call(this);
		}
	}, {
		key: 'getClassName',
		value: function getClassName() {
			return 'dot';
		}

		// @TODO rename : confusion between accessors and meta-accessors
	}, {
		key: '_getAccessorList',
		value: function _getAccessorList() {
			return { x: 0, y: 0 };
		}
	}, {
		key: '_getDefaults',
		value: function _getDefaults() {
			return {
				color: 'black',
				r: 3
			};
		}
	}, {
		key: 'render',
		value: function render() {
			if (this.$el) {
				return this.$el;
			}

			this.$el = new _konva2['default'].Circle({});
			this.$el.shape = this;
			this.$el.perfectDrawEnabled(false);

			return this.$el;
		}
	}, {
		key: 'update',
		value: function update(renderingContext, datum) {
			var d = datum || this.datum;

			var x = renderingContext.timeToPixel(this.x(d));
			var y = renderingContext.valueToPixel(this.y(d));
			// const r	= this.r(d);
			// const color = this.color(d);
			var r = this.params.r;
			var color = this.params.color;

			this.$el.x(x);
			this.$el.y(y);
			this.$el.radius(r);
			this.$el.fill(color);
		}

		// x1, x2, y1, y2 => in pixel domain
	}, {
		key: 'inArea',
		value: function inArea(renderingContext, datum, x1, y1, x2, y2) {
			var x = this.$el.getAbsolutePosition().x;
			var y = this.$el.getAbsolutePosition().y;

			if (x >= x1 && x <= x2 && (y >= y1 && y <= y2)) {
				return true;
			}

			return false;
		}
	}]);

	return Dot;
})(_baseShape2['default']);

exports['default'] = Dot;
module.exports = exports['default'];

},{"./base-shape":42,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84,"konva":172}],45:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseShape = require('./base-shape');

var _baseShape2 = _interopRequireDefault(_baseShape);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var Line = (function (_BaseShape) {
  _inherits(Line, _BaseShape);

  function Line() {
    _classCallCheck(this, Line);

    _get(Object.getPrototypeOf(Line.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Line, [{
    key: 'destroy',
    value: function destroy() {
      this.$el.destroy();
      _get(Object.getPrototypeOf(Line.prototype), 'destroy', this).call(this);
    }
  }, {
    key: 'getClassName',
    value: function getClassName() {
      return 'line';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return { x: 0, y: 0 };
    }
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return { color: '#000000', strokeWidth: 1 };
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      if (this.$el) {
        return this.$el;
      }

      this.$el = new _konva2['default'].Path({});
      this.$el.perfectDrawEnabled(false);

      return this.$el;
    }
  }, {
    key: 'update',
    value: function update(renderingContext, data) {
      var _this = this;

      data = data.slice(0);
      data.sort(function (a, b) {
        return _this.x(a) < _this.x(b) ? -1 : 1;
      });

      this.$el.data(this._buildLine(renderingContext, data));
      this.$el.stroke(this.params.color);
      this.$el.strokeWidth(this.params.strokeWidth);

      data = null;
    }

    // builds the `path.d` attribute
    // @TODO create some ShapeHelper ?
  }, {
    key: '_buildLine',
    value: function _buildLine(renderingContext, data) {
      var _this2 = this;

      if (!data.length) {
        return '';
      }
      // sort data
      var instructions = data.map(function (datum, index) {
        var x = renderingContext.timeToPixel(_this2.x(datum));
        var y = renderingContext.valueToPixel(_this2.y(datum)) - 0.5;
        return x + ',' + y;
      });

      return 'M' + instructions.join('L');
    }
  }]);

  return Line;
})(_baseShape2['default']);

exports['default'] = Line;
module.exports = exports['default'];

},{"./base-shape":42,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84,"konva":172}],46:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseShape = require('./base-shape');

var _baseShape2 = _interopRequireDefault(_baseShape);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var Marker = (function (_BaseShape) {
  _inherits(Marker, _BaseShape);

  function Marker() {
    _classCallCheck(this, Marker);

    _get(Object.getPrototypeOf(Marker.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Marker, [{
    key: 'destroy',
    value: function destroy() {
      this.$line.destroy();
      this.$line = null;
      this.$handler.destroy();
      this.$handler = null;
      _get(Object.getPrototypeOf(Marker.prototype), 'destroy', this).call(this);
    }
  }, {
    key: 'getClassName',
    value: function getClassName() {
      return 'marker';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return { x: 0 };
    }
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return {
        handlerWidth: 7,
        handlerHeight: 10,
        displayHandlers: true,
        opacity: 1,
        strokeWidth: 2,
        color: 'black',
        handlerColor: 'black'
      };
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      if (this.$el) {
        return this.$el;
      }

      this.$el = [];

      this.$line = new _konva2['default'].Rect({});
      this.$line.addName('marker');
      this.$line.shape = this;

      this.$handler = new _konva2['default'].Rect({});
      this.$handler.addName('handler');
      this.$handler.shape = this;

      this.$el.push(this.$line);
      this.$el.push(this.$handler);

      return this.$el;
    }
  }, {
    key: 'update',
    value: function update(renderingContext, datum) {
      var d = datum || this.datum;

      this.$line.visible(this.visible);
      this.$handler.visible(this.visible && this.params.displayHandlers);

      if (!this.visible) return;

      var x = renderingContext.timeToPixel(this.x(d)) - 0.5;
      var height = renderingContext.height;

      this.$line.x(x).y(0).width(this.params.strokeWidth);
      this.$line.height(height);
      this.$line.fill(this.params.color);

      this.$handler.x(x).y(0).width(this.params.handlerWidth).height(this.params.handlerHeight).fill(this.params.handlerColor);
    }
  }, {
    key: 'inArea',
    value: function inArea(renderingContext, datum, x1, y1, x2, y2) {
      var d = datum || this.datum;

      // handlers only are selectable
      var x = renderingContext.timeToPixel(this.x(d));
      var shapeX1 = x - (this.params.handlerWidth - 1) / 2;
      var shapeX2 = shapeX1 + this.params.handlerWidth;
      var shapeY1 = renderingContext.height - this.params.handlerHeight;
      var shapeY2 = renderingContext.height;

      var xOverlap = Math.max(0, Math.min(x2, shapeX2) - Math.max(x1, shapeX1));
      var yOverlap = Math.max(0, Math.min(y2, shapeY2) - Math.max(y1, shapeY1));
      var area = xOverlap * yOverlap;

      return area > 0;
    }
  }]);

  return Marker;
})(_baseShape2['default']);

exports['default'] = Marker;
module.exports = exports['default'];

},{"./base-shape":42,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84,"konva":172}],47:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _baseShape = require('./base-shape');

var _baseShape2 = _interopRequireDefault(_baseShape);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var Segment = (function (_BaseShape) {
	_inherits(Segment, _BaseShape);

	function Segment() {
		_classCallCheck(this, Segment);

		_get(Object.getPrototypeOf(Segment.prototype), 'constructor', this).apply(this, arguments);
	}

	_createClass(Segment, [{
		key: 'destroy',
		value: function destroy() {
			this.$segment.destroy();
			this.$segment = null;
			this.$leftHandler.destroy();
			this.$leftHandler = null;
			this.$rightHandler.destroy();
			this.$rightHandler = null;
			_get(Object.getPrototypeOf(Segment.prototype), 'destroy', this).call(this);
		}
	}, {
		key: 'getClassName',
		value: function getClassName() {
			return 'segment';
		}
	}, {
		key: '_getAccessorList',
		value: function _getAccessorList() {
			return { x: 0, y: 0, width: 1, height: 1 };
		}
	}, {
		key: '_getDefaults',
		value: function _getDefaults() {
			return {
				displayHandlers: true,
				handlerWidth: 2,
				handlerOpacity: 0.8,
				opacity: 0.6,
				handlerColor: '#000000',
				color: '#000000'
			};
		}
	}, {
		key: 'render',
		value: function render(renderingContext) {
			if (this.$el) {
				return this.$el;
			}

			this.$el = [];

			this.$segment = new _konva2['default'].Rect({});
			this.$segment.name('segment');
			// this.$segment.on('mouseover', function(e) { document.body.style.cursor = 'pointer'; });
			// this.$segment.on('mouseout', function(e) { document.body.style.cursor = 'default'; });
			this.$segment.shape = this;

			this.$el.push(this.$segment);

			this.$leftHandler = new _konva2['default'].Rect({});
			this.$leftHandler.addName('left');
			this.$leftHandler.addName('handler');
			// this.$leftHandler.on('mouseover', function() { document.body.style.cursor = 'ew-resize'; });
			// this.$leftHandler.on('mouseout', function() { document.body.style.cursor = 'default'; });
			this.$leftHandler.shape = this;

			this.$rightHandler = new _konva2['default'].Rect({});
			this.$rightHandler.addName('right');
			this.$rightHandler.addName('handler');
			// this.$rightHandler.on('mouseover', function() { document.body.style.cursor = 'ew-resize'; });
			// this.$rightHandler.on('mouseout', function() { document.body.style.cursor = 'default'; });
			this.$rightHandler.shape = this;

			this.$segment.perfectDrawEnabled(false);
			this.$leftHandler.perfectDrawEnabled(false);
			this.$rightHandler.perfectDrawEnabled(false);

			this.$el.push(this.$leftHandler);
			this.$el.push(this.$rightHandler);

			return this.$el;
		}
	}, {
		key: 'update',
		value: function update(renderingContext, datum) {
			var d = datum || this.datum;

			this.$segment.visible(this.visible);
			this.$leftHandler.visible(this.visible && this.params.displayHandlers);
			this.$rightHandler.visible(this.visible && this.params.displayHandlers);

			if (!this.visible) return;

			var width = renderingContext.timeToPixel(this.width(d));
			var height = Math.abs(renderingContext.valueToPixel(this.y(d) + this.height(d)) - renderingContext.valueToPixel(this.y(d)));
			var x = renderingContext.timeToPixel(this.x(d));
			var y = renderingContext.valueToPixel(this.y(d) + this.height(d));

			this.$segment.x(x).y(y).width(Math.max(width, 0)).height(height).fill(this.params.color).opacity(this.params.opacity);

			this.$leftHandler.x(x).y(y).width(this.params.handlerWidth).height(height).fill(this.params.handlerColor).opacity(this.params.handlerOpacity);

			this.$rightHandler.x(x + width - this.params.handlerWidth).y(y).height(height).width(this.params.handlerWidth).fill(this.params.handlerColor).opacity(this.params.handlerOpacity);
		}
	}, {
		key: 'inArea',
		value: function inArea(renderingContext, datum, x1, y1, x2, y2) {
			var d = datum || this.datum;

			var shapeX1 = this.$segment.getAbsolutePosition().x;
			var shapeY1 = this.$segment.getAbsolutePosition().y;
			var shapeX2 = shapeX1 + this.$segment.width();
			var shapeY2 = shapeY1 + this.$segment.height();

			/*
    *	The segment is entirely within the provided area.
    */
			// if (x1 <= shapeX1 && x2 >= shapeX2 && y1 <= shapeY1 && y2 >= shapeY2)
			// 	return true;
			// else
			// 	return false;

			/*
    *	The segment overlaps the provided area.
    */
			var xOverlap = Math.max(0, Math.min(x2, shapeX2) - Math.max(x1, shapeX1));
			var yOverlap = Math.max(0, Math.min(y2, shapeY2) - Math.max(y1, shapeY1));
			var area = xOverlap * yOverlap;

			return area > 0;
		}
	}]);

	return Segment;
})(_baseShape2['default']);

exports['default'] = Segment;
module.exports = exports['default'];

},{"./base-shape":42,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84,"konva":172}],48:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseShape = require('./base-shape');

var _baseShape2 = _interopRequireDefault(_baseShape);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

/**
 * Kind of Marker for entity oriented data. Useful to display a grid.
 */

var Ticks = (function (_BaseShape) {
  _inherits(Ticks, _BaseShape);

  function Ticks() {
    _classCallCheck(this, Ticks);

    _get(Object.getPrototypeOf(Ticks.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(Ticks, [{
    key: '_getClassName',
    value: function _getClassName() {
      return 'tick';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return { time: 0, label: '', focused: false };
    }
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return {
        'default': {
          color: 'steelblue',
          opacity: 0.3,
          width: 1
        },
        focused: {
          color: 'black',
          opacity: 0.8,
          width: 2
        }
      };
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      this.$el = new _Set();

      this.$currentTicks = new _Set();
      this.$currentLabels = new _Set();

      return this.$el;
    }
  }, {
    key: 'update',
    value: function update(renderingContext, data) {
      var _this = this;

      /*
       * Maintain the same number of ticks and labels in the Shape memory as the number of datums.
       * Destroy the remaining konva nodes.
       */

      if (this.$el.size < data.length * 2) {
        while (this.$el.size < data.length * 2) {
          var r = new _konva2['default'].Rect({ listening: false });
          r.addName('tick');
          var t = new _konva2['default'].Text({ listening: false });
          t.addName('label');
          this.$currentTicks.add(r);
          this.$currentLabels.add(t);
          this.$el.add(r);
          this.$el.add(t);
        }
      } else if (this.$el.size > data.length * 2) {
        var ti1 = this.$currentTicks.values();
        var li2 = this.$currentLabels.values();
        while (this.$el.size > data.length * 2) {
          var tick = ti1.next().value;
          var label = li2.next().value;
          this.$currentTicks['delete'](tick);
          this.$currentLabels['delete'](label);
          this.$el['delete'](tick);
          this.$el['delete'](label);
          tick.destroy();
          label.destroy();
        }
      }

      var that = this;
      var layerHeight = renderingContext.height;
      var ticksIterator = this.$currentTicks.values();
      var labelsIterator = this.$currentLabels.values();

      data.forEach(function (datum) {
        var label = labelsIterator.next().value;
        var tick = ticksIterator.next().value;

        var x = renderingContext.timeToPixel(_this.time(datum));
        var height = layerHeight;
        var isFocused = that.focused(datum);
        var hasLabel = that.label(datum);

        tick.x(x).height(height);

        if (isFocused) {
          tick.width(that.params.focused.width).fill(that.params.focused.color).opacity(that.params.focused.opacity);
        } else {
          tick.width(that.params['default'].width).fill(that.params['default'].color).opacity(that.params['default'].opacity);
        }

        label.x(x + 5).y(5).text(that.label(datum))
        // .height(height)
        .fontFamily('monospace').lineHeight('10px').fontSize('10px').fill('#676767').opacity(0.9);

        if (hasLabel) {
          label.visible(true);
        } else {
          label.visible(false);
        }
      });
    }
  }]);

  return Ticks;
})(_baseShape2['default']);

exports['default'] = Ticks;
module.exports = exports['default'];

},{"./base-shape":42,"babel-runtime/core-js/set":77,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84,"konva":172}],49:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseShape = require('./base-shape');

var _baseShape2 = _interopRequireDefault(_baseShape);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var TraceDots = (function (_BaseShape) {
  _inherits(TraceDots, _BaseShape);

  function TraceDots() {
    _classCallCheck(this, TraceDots);

    _get(Object.getPrototypeOf(TraceDots.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(TraceDots, [{
    key: 'getClassName',
    value: function getClassName() {
      return 'trace-dots';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return { x: 0, mean: 0, range: 0 };
    }
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return {
        meanRadius: 3,
        rangeRadius: 3,
        meanColor: '#232323',
        rangeColor: 'steelblue'
      };
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      if (this.$el) {
        return this.$el;
      }
      // container
      this.$el = [];
      // draw mean dot
      this.$mean = new _konva2['default'].Circle({});
      this.$mean.shape = this;

      // range dots (0 => top, 1 => bottom)
      this.$max = new _konva2['default'].Circle({});
      this.$max.shape = this;

      this.$min = new _konva2['default'].Circle({});
      this.$min.shape = this;

      this.$el.push(this.$mean);
      this.$el.push(this.$max);
      this.$el.push(this.$min);

      return this.$el;
    }

    // @TODO use accessors
  }, {
    key: 'update',
    value: function update(renderingContext, datum) {
      var mean = this.mean(datum);
      var range = this.range(datum);
      var x = this.x(datum);
      var meanPos = renderingContext.valueToPixel(mean);
      var halfRange = range / 2;
      var max = renderingContext.valueToPixel(mean + halfRange);
      var min = renderingContext.valueToPixel(mean - halfRange);
      var xPos = renderingContext.timeToPixel(x);

      this.$mean.x(xPos).y(meanPos).radius(this.params.meanRadius).stroke(this.params.rangeColor).fill('transparent').addName('mean');

      this.$max.x(xPos).y(max).radius(this.params.meanRadius).stroke(this.params.rangeColor).fill('transparent').addName('max');

      this.$min.x(xPos).y(min).radius(this.params.meanRadius).stroke(this.params.rangeColor).fill('transparent').addName('min');
    }
  }, {
    key: 'inArea',
    value: function inArea(renderingContext, datum, x1, y1, x2, y2) {
      var x = renderingContext.timeToPixel(this.x(datum));
      var mean = renderingContext.valueToPixel(this.mean(datum));
      var range = renderingContext.valueToPixel(this.range(datum));
      var min = mean - range / 2;
      var max = mean + range / 2;

      if (x > x1 && x < x2 && (min > y1 || max < y2)) {
        return true;
      }

      return false;
    }
  }]);

  return TraceDots;
})(_baseShape2['default']);

exports['default'] = TraceDots;
module.exports = exports['default'];

},{"./base-shape":42,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84,"konva":172}],50:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseShape = require('./base-shape');

var _baseShape2 = _interopRequireDefault(_baseShape);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

/**
 * A shape to display paths in a trace visualization (mean / range). (entity shape)
 *
 */

var TracePath = (function (_BaseShape) {
  _inherits(TracePath, _BaseShape);

  function TracePath() {
    _classCallCheck(this, TracePath);

    _get(Object.getPrototypeOf(TracePath.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(TracePath, [{
    key: 'getClassName',
    value: function getClassName() {
      return 'trace-common';
    }
  }, {
    key: '_getAccessorList',
    value: function _getAccessorList() {
      return { x: 0, mean: 0, range: 0 };
    }
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      return {
        rangeColor: 'steelblue',
        meanColor: '#232323',
        displayMean: true
      };
    }
  }, {
    key: 'render',
    value: function render(renderingContext) {
      if (this.$el) {
        return this.$el;
      }

      this.$el = [];

      this.$range = new _konva2['default'].Path({});
      this.$range.shape = this;

      this.$mean = new _konva2['default'].Path({});
      this.$mean.shape = this;

      this.$el.push(this.$range);
      this.$el.push(this.$mean);

      return this.$el;
    }
  }, {
    key: 'update',
    value: function update(renderingContext, data) {
      var _this = this;

      // order data by x position
      data = data.slice(0);
      data.sort(function (a, b) {
        return _this.x(a) < _this.x(b) ? -1 : 1;
      });

      if (this.params.displayMean) {
        this.$mean.visible(true).data(this._buildMeanLine(renderingContext, data)).stroke(this.params.meanColor).fill('none');
      } else {
        this.$mean.visible(false);
      }

      this.$range.visible(true).data(this._buildRangeZone(renderingContext, data)).stroke('none').fill(this.params.rangeColor).opacity(0.4);

      data = null;
    }
  }, {
    key: '_buildMeanLine',
    value: function _buildMeanLine(renderingContext, data) {
      var _this2 = this;

      var instructions = data.map(function (datum, index) {
        var x = renderingContext.timeToPixel(_this2.x(datum));
        var y = renderingContext.valueToPixel(_this2.mean(datum));
        return x + ',' + y;
      });

      return 'M' + instructions.join('L');
    }
  }, {
    key: '_buildRangeZone',
    value: function _buildRangeZone(renderingContext, data) {
      var length = data.length;
      // const lastIndex = data
      var instructionsStart = '';
      var instructionsEnd = '';

      for (var i = 0; i < length; i++) {
        var datum = data[i];
        var mean = this.mean(datum);
        var halfRange = this.range(datum) / 2;

        var x = renderingContext.timeToPixel(this.x(datum));
        var y0 = renderingContext.valueToPixel(mean + halfRange);
        var y1 = renderingContext.valueToPixel(mean - halfRange);

        var start = x + ',' + y0;
        var end = x + ',' + y1;

        instructionsStart = instructionsStart === '' ? start : instructionsStart + 'L' + start;

        instructionsEnd = instructionsEnd === '' ? end : end + 'L' + instructionsEnd;
      }

      var instructions = 'M' + instructionsStart + 'L' + instructionsEnd + 'Z';
      return instructions;
    }
  }]);

  return TracePath;
})(_baseShape2['default']);

exports['default'] = TracePath;
module.exports = exports['default'];

},{"./base-shape":42,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84,"konva":172}],51:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _baseShape = require('./base-shape');

var _baseShape2 = _interopRequireDefault(_baseShape);

var _utilsScales = require('../utils/scales');

var _utilsScales2 = _interopRequireDefault(_utilsScales);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var Waveform = (function (_BaseShape) {
	_inherits(Waveform, _BaseShape);

	function Waveform() {
		_classCallCheck(this, Waveform);

		_get(Object.getPrototypeOf(Waveform.prototype), 'constructor', this).apply(this, arguments);
	}

	_createClass(Waveform, [{
		key: 'destroy',
		value: function destroy() {
			this.$label.destroy();
			this.$label = null;

			this.$header.destroy();
			this.$header = null;

			this.$body.destroy();
			this.$body = null;

			this.$leftHandler.destroy();
			this.$leftHandler = null;

			this.$rightHandler.destroy();
			this.$rightHandler = null;

			this.$waveform.destroy();
			this.$waveform = null;

			_get(Object.getPrototypeOf(Waveform.prototype), 'destroy', this).call(this);
		}
	}, {
		key: 'getClassName',
		value: function getClassName() {
			return 'waveform';
		}
	}, {
		key: '_getAccessorList',
		value: function _getAccessorList() {
			// return { y: 0 };
			// TODO: delete all but sampleRate.
			return { data: [], x: 0, width: 10000, bufferStart: 0, bufferEnd: 0, sampleRate: 44100, color: 'black', text: "" };
		}
	}, {
		key: '_getDefaults',
		value: function _getDefaults() {
			return {
				waveformQuality: 2000,
				squaringFactor: 1,
				displayHandlers: true,
				displayBody: true,
				displayLabel: true,
				displayHeader: true,
				headerHeightRatio: 0.1, // 10% of the body height
				waveform: {
					color: '#000000',
					opacity: 1
				},
				header: {
					color: 'green',
					opacity: 0.4
				},
				body: {
					color: 'yellow',
					opacity: 0.1
				},
				handler: {
					width: 2,
					opacity: 1,
					color: 'orange'
				}
			};
		}
	}, {
		key: 'render',
		value: function render(renderingContext) {
			if (this.$el) {
				return this.$el;
			}

			this.$el = [];

			this.$header = new _konva2['default'].Rect({});
			this.$header.addName('header');
			this.$header.shape = this;
			// this.$header.on('mouseover', function() { document.body.style.cursor = 'pointer'; });
			// this.$header.on('mouseout', function() { document.body.style.cursor = 'default'; });		

			this.$body = new _konva2['default'].Rect({});
			this.$body.addName('body');
			this.$body.shape = this;
			// this.$body.on('mouseover', function() { document.body.style.cursor = 'pointer'; });
			// this.$body.on('mouseout', function() { document.body.style.cursor = 'default'; });

			this.$leftHandler = new _konva2['default'].Rect({});
			this.$leftHandler.addName('handler');
			this.$leftHandler.addName('left');
			this.$leftHandler.shape = this;
			// this.$leftHandler.on('mouseover', function() { document.body.style.cursor = 'ew-resize'; });
			// this.$leftHandler.on('mouseout', function() { document.body.style.cursor = 'default'; });

			this.$rightHandler = new _konva2['default'].Rect({});
			this.$rightHandler.addName('handler');
			this.$rightHandler.addName('right');
			this.$rightHandler.shape = this;
			// this.$rightHandler.on('mouseover', function() { document.body.style.cursor = 'ew-resize'; });
			// this.$rightHandler.on('mouseout', function() { document.body.style.cursor = 'default'; });

			this.$label = new _konva2['default'].Text({ listening: false });
			this.$label.shape = this;

			this.$waveform = new _konva2['default'].Path({ listening: false });
			this.$waveform.shape = this;

			this.$el.push(this.$body);
			this.$el.push(this.$waveform);
			this.$el.push(this.$header);
			this.$el.push(this.$label);
			this.$el.push(this.$leftHandler);
			this.$el.push(this.$rightHandler);

			return this.$el;
		}
	}, {
		key: 'update',
		value: function update(renderingContext, datum) {
			var d = datum || this.datum;

			this.$header.visible(this.visible && this.params.displayHeader);
			this.$label.visible(this.visible && this.params.displayLabel);
			this.$body.visible(this.visible && this.params.displayBody);
			this.$leftHandler.visible(this.visible && this.params.displayHandlers);
			this.$rightHandler.visible(this.visible && this.params.displayHandlers);
			this.$waveform.visible(this.visible);

			if (!this.visible) return;

			var x = renderingContext.timeToPixel(this.x(d));
			var width = renderingContext.timeToPixel(this.width(d));
			var height = renderingContext.height;
			var color = this.params.waveform.color;

			for (var i in this.$el) {
				this.$el[i].x(x).y(0);
			}
			this.$el.forEach(function (el) {
				return el.x(x).y(0);
			});

			this.$label.text(this.text(d)).x(x + 10).y(5);

			this.$header.width(Math.max(width, 0)).height(height * this.params.headerHeightRatio).fill(this.params.header.color).opacity(this.params.header.opacity);
			this.$body.width(Math.max(width, 0)).height(height).fill(this.params.body.color).opacity(this.params.body.opacity);

			this.$leftHandler.width(this.params.handler.width).height(height).fill(this.params.handler.color);

			this.$rightHandler.x(x + width - this.params.handler.width).width(this.params.handler.width).height(height).fill(this.params.handler.color);

			this.$waveform.fill(this.params.waveform.color).opacity(this.params.waveform.opacity).y(0);

			this.$waveform.perfectDrawEnabled(true);

			// WAVEFORM PART

			// define nbr of samples per pixels
			var sliceMethod = this.data(d) instanceof Float32Array ? 'subarray' : 'slice';
			var nbrSamples = this.bufferEnd(d) - this.bufferStart(d);
			var duration = nbrSamples / this.sampleRate(d);
			var samplesPerPixel = nbrSamples / width;

			if (!samplesPerPixel || this.data(d).length < samplesPerPixel) {
				return;
			}

			// compute/draw visible area only
			// @TODO refactor this ununderstandable mess
			var minX = Math.max(-renderingContext.offsetX, renderingContext.timeToPixel(this.x(d)));

			var maxX = Math.min(-renderingContext.offsetX + renderingContext.width, renderingContext.timeToPixel(this.x(d) + this.width(d)));

			// get min/max per pixels, clamped to the visible area
			var invert = renderingContext.timeToPixel.invert;
			var sampleRate = this.sampleRate(d);
			var minMax = [];

			for (var px = minX; px < maxX; px++) {
				var startTime = invert(px);
				var startSample = startTime * sampleRate;
				var extract = this.data(d)[sliceMethod](startSample, startSample + samplesPerPixel);

				var min = Infinity;
				var max = -Infinity;

				for (var j = 0, l = extract.length; j < l; j++) {
					var sample = extract[j];
					if (sample < min) {
						min = sample;
					}
					if (sample > max) {
						max = sample;
					}
				}
				// disallow Infinity
				min = !isFinite(min) ? 0 : min;
				max = !isFinite(max) ? 0 : max;
				if (min === 0 && max === 0) {
					continue;
				}

				minMax.push([px, min, max]);
			}

			if (!minMax.length) {
				return;
			}

			// const MID = renderingContext.valueToPixel((renderingContext.valueToPixel.domain()[1] - renderingContext.valueToPixel.domain()[0]) / 2)
			var MID = 0;
			var PIXEL = 0;
			var MIN = 1;
			var MAX = 2;
			var ZERO = renderingContext.valueToPixel(0);
			// rendering strategies
			// if (this.params.renderingStrategy === 'svg') {

			var instructions = minMax.map(function (datum, index) {
				var x = datum[PIXEL];
				var y1 = Math.round(renderingContext.valueToPixel(datum[MIN]));
				var y2 = Math.round(renderingContext.valueToPixel(datum[MAX]));
				// return `${x},${ZERO}L${x},${y1}L${x},${y2}L${x},${ZERO}`;
				return x + ',' + (y1 - MID) + 'L' + x + ',' + (y2 - MID);
			});

			var path = 'M' + instructions.join('L');
			this.$waveform.data('M' + (0 + ',' + height / 2 + 'L') + instructions.join('L') + ('L' + minMax[minMax.length - 1][0] + ',' + height / 2) + 'z');
		}
	}, {
		key: 'inArea',
		value: function inArea(renderingContext, datum, x1, y1, x2, y2) {
			var shapeX1 = renderingContext.timeToPixel(this.x(datum));
			var shapeX2 = renderingContext.timeToPixel(this.x(datum) + this.width(datum));
			var shapeY1 = renderingContext.valueToPixel(0);
			var shapeY2 = renderingContext.valueToPixel(renderingContext.height);

			// http://jsfiddle.net/uthyZ/ - check overlaping area
			var xOverlap = Math.max(0, Math.min(x2, shapeX2) - Math.max(x1, shapeX1));
			var yOverlap = Math.max(0, Math.min(y2, shapeY2) - Math.max(y1, shapeY1));
			var area = xOverlap * yOverlap;

			return area > 0;
		}
	}, {
		key: 'linear_interpolation',
		value: function linear_interpolation(arr, pos) {
			var first = Math.floor(pos);
			var frac = pos - first;
			var second = first + 1 < arr.length ? first + 1 : 0;

			return arr[first] * (1 - frac) + arr[second] * frac;
		}
	}]);

	return Waveform;
})(_baseShape2['default']);

exports['default'] = Waveform;
module.exports = exports['default'];

},{"../utils/scales":66,"./base-shape":42,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84,"konva":172}],52:[function(require,module,exports){
'use strict';

/**
 * `State` instances are used to define the application logic by precising
 * specific user interaction cases, and how they impact the overal temporal
 * representation. The abstractions extending this base class should be
 * considered as the main interface between the visualization and the
 * application logic. All provided states should be seen as simple examples for
 * rapid prototyping,
 *
 * States manage interactions like zooming, browsing, or editing the timeline.
 * Customized states should extend this BaseState.
 */

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var BaseState = (function () {
  /**
   * Returns timeline tracks collection.
   *
   * @type {TrackCollection}
   */

  function BaseState(timeline) {
    _classCallCheck(this, BaseState);

    /**
     * A reference to the timeline on which the state should be installed.
     * @type {Timeline}
     */
    this.timeline = timeline;
  }

  /**
   * Returns timeline tracks collection.
   *
   * @type {TrackCollection<Track>}
   */

  _createClass(BaseState, [{
    key: 'enter',

    /**
     * Called when the timeline is entering the state.
     */
    value: function enter() {}

    /**
     * Called when the timeline is leaving the state.
     */
  }, {
    key: 'exit',
    value: function exit() {}

    /**
     * Main interface method to override when creating a new `State`. Handle event
     * from mouse or keyboard, should define behavior according to the event
     * (aka. mousedown, mouseup, ...).
     *
     * @param {WaveEvent} e - the event to process.
     * @param {Array} hitLayers - the layers hit by the mouse event (if surface
     * event).
     */
  }, {
    key: 'handleEvent',
    value: function handleEvent(e, hitLayers) {}
  }, {
    key: 'tracks',
    get: function get() {
      return this.timeline.tracks;
    }

    /**
     * Returns all registered layers.
     *
     * @type {Array<Layer>}
     */
  }, {
    key: 'layers',
    get: function get() {
      return this.timeline.tracks.layers;
    }
  }]);

  return BaseState;
})();

exports['default'] = BaseState;
module.exports = exports['default'];

},{"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81}],53:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

var BreakpointState = (function (_BaseState) {
  _inherits(BreakpointState, _BaseState);

  function BreakpointState(timeline, datumGenerator) {
    _classCallCheck(this, BreakpointState);

    _get(Object.getPrototypeOf(BreakpointState.prototype), 'constructor', this).call(this, timeline);

    this.datumGenerator = datumGenerator;
    this.currentEditedLayer = null;
    this.currentTarget = null;
  }

  _createClass(BreakpointState, [{
    key: 'enter',
    value: function enter() {}
  }, {
    key: 'exit',
    value: function exit() {}
  }, {
    key: 'handleEvent',
    value: function handleEvent(e, hitLayers) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e, hitLayers);
          break;
        case 'mousemove':
          this.onMouseMove(e, hitLayers);
          break;
        case 'mouseup':
          this.onMouseUp(e, hitLayers);
          break;
      }
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e, hitLayers) {
      var _this = this;

      this.mouseDown = true;
      // keep target consistent with mouse down
      this.currentTarget = e.target;
      var updatedLayer = null;

      var layers = hitLayers;

      layers.forEach(function (layer) {
        layer.unselect();
        var item = e.target;

        if (item === null || item === undefined || layer.getDatumFromShape(item.shape) === undefined) {
          // create an item
          var time = layer.timeToPixel.invert(e.x) - _this.timeline.offset;
          var value = layer.valueToPixel.invert(e.y);
          var datum = _this.datumGenerator(time, value);

          layer.add(datum);
          updatedLayer = layer;
        } else {
          // if shift is pressed, remove the item
          if (e.originalEvent.shiftKey) {
            var datum = layer.getDatumFromShape(item.shape);
            layer.remove(datum);
            updatedLayer = layer;
          } else {
            _this.currentEditedLayer = layer;
            var datum = layer.getDatumFromShape(item.shape);
            layer.select([datum]);
          }
        }

        layer.selectedDatums.forEach(function (datum) {
          layer.getShapeFromDatum(datum).stopDrag();
        });
      });

      if (updatedLayer) {
        this.timeline.tracks.update(updatedLayer);
      }
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e, hitLayers) {
      if (!this.mouseDown || !this.currentEditedLayer) {
        return;
      }

      var layer = this.currentEditedLayer;
      var datums = layer.selectedDatums;
      // the loop should be in layer to match select / unselect API
      layer.edit(datums, e.dx, e.dy, this.currentTarget);

      layer.updateShapes(datums);
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e, hitLayers) {
      var that = this;
      hitLayers.forEach(function (layer) {
        layer.selectedDatums.forEach(function (datum) {
          layer.getShapeFromDatum(datum).stopDrag();
        });
      });
      this.currentEditedLayer = null;
      this.mouseDown = false;
    }
  }]);

  return BreakpointState;
})(_baseState2['default']);

exports['default'] = BreakpointState;
module.exports = exports['default'];

},{"./base-state":52,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],54:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var BrushZoomState = (function (_BaseState) {
	_inherits(BrushZoomState, _BaseState);

	function BrushZoomState(timeline) {
		_classCallCheck(this, BrushZoomState);

		_get(Object.getPrototypeOf(BrushZoomState.prototype), 'constructor', this).call(this, timeline);
	}

	_createClass(BrushZoomState, [{
		key: 'handleEvent',
		value: function handleEvent(e) {
			switch (e.type) {
				case 'mousedown':
					this.onMouseDown(e);
					break;
				case 'mousemove':
					this.onMouseMove(e);
					break;
				case 'mouseup':
					this.onMouseUp(e);
					break;
				case 'keydown':
					this.onKeyDown(e);
					break;
			}
		}
	}, {
		key: 'onMouseDown',
		value: function onMouseDown(e) {
			var _this = this;

			this.brushes = [];
			this.startX = e.x;
			// create brush in each containers
			this.tracks.forEach(function (track) {
				var interactions = track.$interactionsLayer;

				var brush = new _konva2['default'].Rect({});
				brush.height(track.height).y(0).fill('#787878').opacity(0.2);
				brush.track = track;

				interactions.add(brush);

				_this.brushes.push(brush);

				interactions.batchDraw();
				// interactions.moveToTop();
			});
		}
	}, {
		key: 'onMouseMove',
		value: function onMouseMove(e) {
			// update brush
			var width = Math.abs(e.x - this.startX);
			var x = Math.min(e.x, this.startX);

			this.brushes.forEach(function (brush) {
				brush.x(x).width(width);
				brush.track.$interactionsLayer.batchDraw();
			});
		}
	}, {
		key: 'onMouseUp',
		value: function onMouseUp(e) {
			// remove brush
			this.brushes.forEach(function (brush) {
				brush.destroy();
				brush.track.$interactionsLayer.batchDraw();
				brush.track = null;
			});
			this.brushes.length = 0;

			// update timeContext
			var startX = this.startX;
			var endX = e.x;
			// return if no drag
			if (Math.abs(startX - endX) < 1) {
				return;
			}

			var leftX = Math.max(0, Math.min(startX, endX));
			var rightX = Math.max(startX, endX);

			var minTime = this.timeline.timeToPixel.invert(leftX);
			var maxTime = this.timeline.timeToPixel.invert(rightX);

			var deltaDuration = maxTime - minTime;
			var zoom = this.timeline.visibleDuration / deltaDuration;

			this.timeline.offset -= minTime;
			this.timeline.zoom *= zoom;

			this.tracks.update();
		}
	}, {
		key: 'onKeyDown',
		value: function onKeyDown(e) {
			// reset on space bar
			if (e.originalEvent.keyCode === 32) {
				this.timeline.offset = 0;
				this.timeline.zoom = 1;
				this.tracks.update();
			}
		}
	}]);

	return BrushZoomState;
})(_baseState2['default']);

exports['default'] = BrushZoomState;
module.exports = exports['default'];

},{"./base-state":52,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84,"konva":172}],55:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

var CenteredScrollState = (function (_BaseState) {
  _inherits(CenteredScrollState, _BaseState);

  function CenteredScrollState(timeline) {
    _classCallCheck(this, CenteredScrollState);

    _get(Object.getPrototypeOf(CenteredScrollState.prototype), 'constructor', this).call(this, timeline);
    this.currentLayer = null;
    // Set max/min zoom
    // maxZoom: 1px per sample
    // minZoom: 10 000 px per 1 hour
    // with a default to 44.1kHz sample rate
    this.maxZoom = 44100 * 1 / this.timeline.timeContext.pixelsPerSecond;
    this.minZoom = 10000 / 3600 / this.timeline.timeContext.pixelsPerSecond;
  }

  _createClass(CenteredScrollState, [{
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
      }
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {}
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      // prevent annoying text selection when dragging
      e.originalEvent.preventDefault();

      var timeContext = this.timeline.timeContext;
      var lastCenterTime = timeContext.timeToPixel.invert(e.x);

      var newCenterTime = timeContext.timeToPixel.invert(e.x);
      var delta = newCenterTime - lastCenterTime;

      // Apply new offset to keep it centered to the mouse
      timeContext.offset += delta + timeContext.timeToPixel.invert(e.dx);

      // Other possible experiments with centered-zoom-state
      //
      // Example 1: Prevent timeline.offset to be negative
      timeContext.offset = Math.min(timeContext.offset, 0);

      this.timeline.tracks.update();
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {}
  }]);

  return CenteredScrollState;
})(_baseState2['default']);

exports['default'] = CenteredScrollState;
module.exports = exports['default'];

},{"./base-state":52,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],56:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

var _utilsScales = require('../utils/scales');

var _utilsScales2 = _interopRequireDefault(_utilsScales);

var CenteredZoomState = (function (_BaseState) {
  _inherits(CenteredZoomState, _BaseState);

  function CenteredZoomState(timeline) {
    _classCallCheck(this, CenteredZoomState);

    _get(Object.getPrototypeOf(CenteredZoomState.prototype), 'constructor', this).call(this, timeline);
    this.currentLayer = null;
    // Set max/min zoom
    // maxZoom: 1px per sample
    // minZoom: 10 000 px per 1 hour
    // with a default to 44.1kHz sample rate
    this.maxZoom = 44100 * 1 / this.timeline.timeContext.pixelsPerSecond;
    this.minZoom = 10000 / 3600 / this.timeline.timeContext.pixelsPerSecond;
  }

  _createClass(CenteredZoomState, [{
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
      }
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      this.initialZoom = this.timeline.timeContext.zoom;
      this.initialY = e.y;

      this._pixelToExponent = _utilsScales2['default'].linear().domain([0, 100]) // 100px => factor 2
      .range([0, 1]);
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      // prevent annoying text selection when dragging
      e.originalEvent.preventDefault();

      var timeContext = this.timeline.timeContext;
      var lastCenterTime = timeContext.timeToPixel.invert(e.x);
      var exponent = this._pixelToExponent(e.y - this.initialY);
      var targetZoom = this.initialZoom * Math.pow(2, exponent); // -1...1 -> 1/2...2

      timeContext.zoom = Math.min(Math.max(targetZoom, this.minZoom), this.maxZoom);

      var newCenterTime = timeContext.timeToPixel.invert(e.x);
      var delta = newCenterTime - lastCenterTime;

      // Apply new offset to keep it centered to the mouse
      timeContext.offset += delta + timeContext.timeToPixel.invert(e.dx);

      // Other possible experiments with centered-zoom-state
      //
      // Example 1: Prevent timeline.offset to be negative
      // timeContext.offset = Math.min(timeContext.offset, 0);
      //
      // Example 2: Keep in container when zoomed out
      if (timeContext.stretchRatio < 1) {
        var minOffset = timeContext.timeToPixel.invert(0);
        var maxOffset = timeContext.timeToPixel.invert(view.width - timeContext.timeToPixel(timeContext.duration));
        timeContext.offset = Math.max(timeContext.offset, minOffset);
        timeContext.offset = Math.min(timeContext.offset, maxOffset);
      }

      this.timeline.tracks.update();
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {}
  }]);

  return CenteredZoomState;
})(_baseState2['default']);

exports['default'] = CenteredZoomState;
module.exports = exports['default'];

},{"../utils/scales":66,"./base-state":52,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],57:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

var ContextEditionState = (function (_BaseState) {
  _inherits(ContextEditionState, _BaseState);

  function ContextEditionState(timeline) {
    _classCallCheck(this, ContextEditionState);

    _get(Object.getPrototypeOf(ContextEditionState.prototype), 'constructor', this).call(this, timeline);
  }

  _createClass(ContextEditionState, [{
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
      }
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      this.mouseDown = true;
      this.currentTarget = e.target;
      this.currentLayer = this.currentTarget.shape ? this.currentTarget.shape.layer : undefined;
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      if (!this.mouseDown || !this.currentLayer) {
        return;
      }

      var layer = this.currentLayer;
      var target = this.currentTarget;

      // in this example the context is stretched when shift is pressed
      if (!e.originalEvent.shiftKey) {
        layer.editContext(e.dx, e.dy, target);
      } else {
        layer.stretchContext(e.dx, e.dy, target);
      }

      layer.update();
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {
      this.mouseDown = false;
      this.currentTarget = null;
      this.currentLayer = null;
    }
  }]);

  return ContextEditionState;
})(_baseState2['default']);

exports['default'] = ContextEditionState;
module.exports = exports['default'];

},{"./base-state":52,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],58:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Map = require('babel-runtime/core-js/map')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

var DropAndAddState = (function (_BaseState) {
	_inherits(DropAndAddState, _BaseState);

	function DropAndAddState(timeline) {
		_classCallCheck(this, DropAndAddState);

		_get(Object.getPrototypeOf(DropAndAddState.prototype), 'constructor', this).call(this, timeline);
		this.targetLayer = new _Map();
	}

	_createClass(DropAndAddState, [{
		key: 'setTargetLayerForTrack',
		value: function setTargetLayerForTrack(track, layer) {
			this.targetLayer.set(track, layer);
		}
	}, {
		key: 'exit',
		value: function exit() {
			this.targetLayer.clear();
			// TODO: remove track highlight ?
		}
	}, {
		key: 'handleEvent',
		value: function handleEvent(e) {
			switch (e.type) {
				case 'dragstart':
					this.onDragStart(e);
					break;
				case 'dragend':
					this.onDragEnd(e);
					break;
				case 'dragover':
					this.onDragOver(e);
					break;
				case 'drop':
					this.onDrop(e);
					break;
				case 'dragleave':
					this.onDragLeave(e);
					break;
			}
		}
	}, {
		key: 'onDragStart',
		value: function onDragStart(e) {
			// N/A
		}
	}, {
		key: 'onDragEnd',
		value: function onDragEnd(e) {
			// TODO ?
		}
	}, {
		key: 'onDragOver',
		value: function onDragOver(e) {
			// TODO: highlight track ?
		}
	}, {
		key: 'onDragLeave',
		value: function onDragLeave(e) {
			// TODO: remove track highlight ?
		}
	}, {
		key: 'onDrop',
		value: function onDrop(e) {
			var offset = -this.timeline.timeContext.offset;
			var time = this.timeline.timeContext.timeToPixel.invert(e.x);
			var currentTime = offset + time;

			var track = this.timeline.getTrackFromDOMElement(e.currentTarget);
			var layer = this.targetLayer.get(track);

			if (layer) {
				var datum = document.getElementById(e.originalEvent.dataTransfer.getData("Text")).getDatum();
				datum.x = currentTime;
				layer.add(datum);
				layer.getShapeFromDatum(datum).params.color = datum.color;
				layer.update();
			}

			e.originalEvent.dataTransfer.clearData();
		}
	}]);

	return DropAndAddState;
})(_baseState2['default']);

exports['default'] = DropAndAddState;
module.exports = exports['default'];

},{"./base-state":52,"babel-runtime/core-js/map":69,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],59:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

/**
 * A state to edit shapes in the more general way. Interact only with selected shapes.
 */

var EditionState = (function (_BaseState) {
  _inherits(EditionState, _BaseState);

  function EditionState(timeline) {
    _classCallCheck(this, EditionState);

    _get(Object.getPrototypeOf(EditionState.prototype), 'constructor', this).call(this, timeline);

    this.currentEditedLayer = null;
    this.currentTarget = null;
  }

  _createClass(EditionState, [{
    key: 'enter',
    value: function enter() {}
  }, {
    key: 'exit',
    value: function exit() {}
  }, {
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
      }
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      this.currentTarget = e.target;
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      var _this = this;

      this.layers.forEach(function (layer) {
        var datums = layer.selectedDatums;

        layer.edit(datums, e.dx, e.dy, _this.currentTarget);
        layer.update(datums);
      });
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {
      this.currentEditedLayer = null;
      this.mouseDown = false;
    }
  }]);

  return EditionState;
})(_baseState2['default']);

exports['default'] = EditionState;
module.exports = exports['default'];

},{"./base-state":52,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],60:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Map = require('babel-runtime/core-js/map')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var HorizontalSelectionState = (function (_BaseState) {
  _inherits(HorizontalSelectionState, _BaseState);

  function HorizontalSelectionState(timeline /*, options = {} */) {
    _classCallCheck(this, HorizontalSelectionState);

    _get(Object.getPrototypeOf(HorizontalSelectionState.prototype), 'constructor', this).call(this, timeline /*, options */);

    this._layerSelectedItemsMap = new _Map();

    this.shiftKey = false;

    this.wasMoving = false;
  }

  _createClass(HorizontalSelectionState, [{
    key: 'enter',
    value: function enter() {
      // TODO
    }
  }, {
    key: 'exit',
    value: function exit() {
      // TODO
      var containers = this.timeline.containers;

      for (var id in containers) {
        this._removeBrush(containers[id]);
      }
    }
  }, {
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
        case 'click':
          this.onClick(e);
          break;
        case 'keydown':
          this.onKey(e);
          break;
        case 'keyup':
          this.onKey(e);
          break;
      }
    }
  }, {
    key: '_addBrush',
    value: function _addBrush(track) {
      if (track.$brush) {
        return;
      }

      var brush = new _konva2['default'].Rect({});
      brush.fill('#686868').opacity(0.5);

      track.$interactionsLayer.add(brush);
      track.$interactionsLayer.moveToTop();

      track.$brush = brush;

      track.$interactionsLayer.batchDraw();
    }
  }, {
    key: '_removeBrush',
    value: function _removeBrush(track) {
      if (track.$brush === undefined) {
        return;
      }

      this._resetBrush(track);

      track.$brush.destroy();

      track.$interactionsLayer.batchDraw();

      delete track.$brush;
    }
  }, {
    key: '_resetBrush',
    value: function _resetBrush(track) {
      var $brush = track.$brush;
      // reset brush element
      $brush.x(0).y(0).width(0).height(0);
      track.$interactionsLayer.batchDraw();
    }
  }, {
    key: '_updateBrush',
    value: function _updateBrush(e, track) {
      var $brush = track.$brush;

      $brush.x(e.area.left).y(0).width(e.area.width).height(track.height);
      track.$interactionsLayer.batchDraw();
    }
  }, {
    key: 'onKey',
    value: function onKey(e) {
      this.shiftKey = e.shiftKey;
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      var _this = this;

      this._currentTrack = this.timeline.getTrackFromDOMElement(e.currentTarget);

      if (!this._currentTrack) {
        return;
      }

      this._addBrush(this._currentTrack);

      // recreate the map
      this._layerSelectedItemsMap = new _Map();

      this._currentTrack.layers.forEach(function (layer) {

        if (!e.originalEvent.shiftKey) {
          var aux = new _Set(layer.selectedDatums);
          layer.unselect(aux);
          layer.updateShapes(aux);
        }

        _this._layerSelectedItemsMap.set(layer, new _Set(layer.selectedDatums));
      });

      this.mousedown = true;
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      var _this2 = this;

      if (!this.mousedown) return;

      this.wasMoving = true;

      e.area = { left: e.area.left, width: e.area.width, top: 0, height: this._currentTrack.height };

      this._updateBrush(e, this._currentTrack);

      var that = this;

      this._currentTrack.layers.forEach(function (layer) {
        var currentSelection = layer.selectedDatums;
        var datumsInArea = layer.getDatumsInArea(e.area);

        var toSelect;
        var toUnselect;

        // if is not pressed
        if (!e.originalEvent.shiftKey) {

          toUnselect = new _Set(currentSelection);
          toSelect = new _Set(datumsInArea);
        } else {
          (function () {

            toSelect = new _Set();
            toUnselect = new _Set();
            // use the selection from the previous drag
            var previousSelection = _this2._layerSelectedItemsMap.get(layer);

            datumsInArea.forEach(function (datum) {
              if (!previousSelection.has(datum)) {
                toSelect.add(datum);
              } else {
                toUnselect.add(datum);
              }
            });

            currentSelection.forEach(function (datum) {
              if (!datumsInArea.has(datum) && !previousSelection.has(datum)) {
                toUnselect.add(datum);
              }
            });

            previousSelection.forEach(function (datum) {
              if (!datumsInArea.has(datum)) {
                toSelect.add(datum);
              }
            });
          })();
        }

        layer.unselect(toUnselect);
        layer.select(toSelect);

        layer.updateShapes(currentSelection);
        layer.updateShapes(datumsInArea);
      });
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {
      this._removeBrush(this._currentTrack);
      this.mousedown = false;
      this.wasMoving = false;
    }
  }, {
    key: 'onClick',
    value: function onClick(e) {
      // console.log('click');
      if (!this._currentTrack) {
        return;
      }
      var that = this;

      this._currentTrack.layers.forEach(function (layer) {

        var shape = e.target.shape;
        var datum = layer.getDatumFromShape(shape);
        var toUpdate = new _Set();

        //TODO: correct this because it is not working as I expected to. 
        if (!e.originalEvent.shiftKey) {
          toUpdate = new _Set(layer.selectedDatums);
          layer.unselect(layer.selectedDatums);
        }

        if (datum) {
          toUpdate.add(datum);
          layer.toggleSelection([datum]);
        }

        layer.updateShapes(toUpdate);
      });
    }
  }]);

  return HorizontalSelectionState;
})(_baseState2['default']);

exports['default'] = HorizontalSelectionState;
module.exports = exports['default'];

},{"./base-state":52,"babel-runtime/core-js/map":69,"babel-runtime/core-js/set":77,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84,"konva":172}],61:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Map = require('babel-runtime/core-js/map')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var SelectionState = (function (_BaseState) {
  _inherits(SelectionState, _BaseState);

  function SelectionState(timeline /*, options = {} */) {
    _classCallCheck(this, SelectionState);

    _get(Object.getPrototypeOf(SelectionState.prototype), 'constructor', this).call(this, timeline /*, options */);

    this.currentLayer = undefined;
    // need a cached
    this.selectedDatums = undefined;
    this.mouseDown = false;
    this.shiftKey = false;

    this._layerSelectedItemsMap = new _Map();
  }

  _createClass(SelectionState, [{
    key: 'enter',
    value: function enter() {}
  }, {
    key: 'exit',
    value: function exit() {
      var containers = this.timeline.containers;

      for (var id in containers) {
        this._removeBrush(containers[id]);
      }
    }
  }, {
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
        case 'click':
          this.onClick(e);
          break;
        case 'keydown':
          this.onKey(e);
          break;
        case 'keyup':
          this.onKey(e);
          break;
      }
    }
  }, {
    key: '_addBrush',
    value: function _addBrush(track) {
      if (track.$brush) {
        return;
      }

      var brush = new _konva2['default'].Rect({});
      brush.fill('#686868').opacity(0.5);

      track.$interactionsLayer.add(brush);
      track.$interactionsLayer.moveToTop();

      track.$brush = brush;

      track.$interactionsLayer.batchDraw();
    }
  }, {
    key: '_removeBrush',
    value: function _removeBrush(track) {
      if (track.$brush === undefined) {
        return;
      }

      this._resetBrush(track);

      track.$brush.destroy();

      track.$interactionsLayer.batchDraw();

      delete track.$brush;
    }
  }, {
    key: '_resetBrush',
    value: function _resetBrush(track) {
      var $brush = track.$brush;
      // reset brush element
      $brush.x(0).y(0).width(0).height(0);
      track.$interactionsLayer.batchDraw();
    }
  }, {
    key: '_updateBrush',
    value: function _updateBrush(e, track) {
      var $brush = track.$brush;

      $brush.x(e.area.left).y(e.area.top).width(e.area.width).height(e.area.height);
      track.$interactionsLayer.batchDraw();
    }
  }, {
    key: 'onKey',
    value: function onKey(e) {
      this.shiftKey = e.shiftKey;
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      var _this = this;

      this._currentTrack = this.timeline.getTrackFromDOMElement(e.currentTarget);

      if (!this._currentTrack) {
        return;
      }

      this._addBrush(this._currentTrack);

      // recreate the map
      this._layerSelectedItemsMap = new _Map();
      this._currentTrack.layers.forEach(function (layer) {
        var aux = [];
        layer.selectedDatums.forEach(function (datum) {
          aux.push(datum);
        });
        _this._layerSelectedItemsMap.set(layer, aux.slice(0));
      });
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      var _this2 = this;

      console.log(e.area);

      this._updateBrush(e, this._currentTrack);

      this._currentTrack.layers.forEach(function (layer) {
        var currentSelection = layer.selectedDatums;
        var currentItems = layer.getDatumsInArea(e.area);

        // if is not pressed
        if (!e.originalEvent.shiftKey) {
          layer.unselect(currentSelection);
          layer.select(currentItems);
        } else {
          (function () {
            var toSelect = [];
            var toUnselect = [];
            // use the selection from the previous drag
            var previousSelection = _this2._layerSelectedItemsMap.get(layer);
            // toUnselect = toUnselect.concat(previousSelectedItems);

            currentItems.forEach(function (item) {
              if (previousSelection.indexOf(item) === -1) {
                toSelect.push(item);
              } else {
                toUnselect.push(item);
              }
            });

            currentSelection.forEach(function (item) {
              if (currentItems.indexOf(item) === -1 && previousSelection.indexOf(item) === -1) {
                toUnselect.push(item);
              }
            });

            layer.unselect(toUnselect);
            layer.select(toSelect);
          })();
        }
      });
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {
      this._removeBrush(this._currentTrack);
    }
  }, {
    key: 'onClick',
    value: function onClick(e) {
      if (!this._currentTrack) {
        return;
      }

      this._currentTrack.layers.forEach(function (layer) {
        var shape = e.target.shape;
        var datum = layer.getDatumFromShape(shape);

        if (!e.originalEvent.shiftKey) {
          layer.unselect();
        }

        if (datum) {
          layer.toggleSelection([datum]);
        }
      });
    }
  }]);

  return SelectionState;
})(_baseState2['default']);

exports['default'] = SelectionState;
module.exports = exports['default'];

},{"./base-state":52,"babel-runtime/core-js/map":69,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84,"konva":172}],62:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Map = require('babel-runtime/core-js/map')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

var _konva = require('konva');

var _konva2 = _interopRequireDefault(_konva);

var ShapeInsertionState = (function (_BaseState) {
  _inherits(ShapeInsertionState, _BaseState);

  function ShapeInsertionState(timeline /*, options = {} */) {
    _classCallCheck(this, ShapeInsertionState);

    _get(Object.getPrototypeOf(ShapeInsertionState.prototype), 'constructor', this).call(this, timeline /*, options */);

    this._layerSelectedItemsMap = new _Map();

    this.shiftKey = false;

    this.wasMoving = false;
  }

  _createClass(ShapeInsertionState, [{
    key: 'enter',
    value: function enter() {
      // TODO
    }
  }, {
    key: 'exit',
    value: function exit() {
      // TODO
      var containers = this.timeline.containers;

      for (var id in containers) {
        this._removeBrush(containers[id]);
      }
    }
  }, {
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
        case 'click':
          this.onClick(e);
          break;
        case 'keydown':
          this.onKey(e);
          break;
        case 'keyup':
          this.onKey(e);
          break;
      }
    }
  }, {
    key: '_addBrush',
    value: function _addBrush(track) {
      if (track.$brush) {
        return;
      }

      var brush = new _konva2['default'].Rect({});
      brush.fill('#686868').opacity(0.5);

      track.$interactionsLayer.add(brush);
      track.$interactionsLayer.moveToTop();

      track.$brush = brush;

      track.$interactionsLayer.batchDraw();
    }
  }, {
    key: '_removeBrush',
    value: function _removeBrush(track) {
      if (track.$brush === undefined) {
        return;
      }

      this._resetBrush(track);

      track.$brush.destroy();

      track.$interactionsLayer.batchDraw();

      delete track.$brush;
    }
  }, {
    key: '_resetBrush',
    value: function _resetBrush(track) {
      var $brush = track.$brush;
      // reset brush element
      $brush.x(0).y(0).width(0).height(0);
      track.$interactionsLayer.batchDraw();
    }
  }, {
    key: '_updateBrush',
    value: function _updateBrush(e, track) {
      var $brush = track.$brush;

      $brush.x(e.area.left).y(0).width(e.area.width).height(track.height);
      track.$interactionsLayer.batchDraw();
    }
  }, {
    key: 'onKey',
    value: function onKey(e) {
      this.shiftKey = e.shiftKey;
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      var _this = this;

      this._currentTrack = this.timeline.getTrackFromDOMElement(e.currentTarget);

      if (!this._currentTrack) {
        return;
      }

      this._addBrush(this._currentTrack);

      // recreate the map
      this._layerSelectedItemsMap = new _Map();

      this._currentTrack.layers.forEach(function (layer) {

        if (!e.originalEvent.shiftKey) {
          var aux = new _Set(layer.selectedDatums);
          layer.unselect(aux);
          layer.updateShapes(aux);
        }

        _this._layerSelectedItemsMap.set(layer, new _Set(layer.selectedDatums));
      });
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      var _this2 = this;

      this.wasMoving = true;

      e.area = { left: e.area.left, width: e.area.width, top: 0, height: this._currentTrack.height };

      this._updateBrush(e, this._currentTrack);

      var that = this;

      this._currentTrack.layers.forEach(function (layer) {
        var currentSelection = layer.selectedDatums;
        var datumsInArea = layer.getDatumsInArea(e.area);

        var toSelect;
        var toUnselect;

        // if is not pressed
        if (!e.originalEvent.shiftKey) {

          toUnselect = new _Set(currentSelection);
          toSelect = new _Set(datumsInArea);
        } else {
          (function () {

            toSelect = new _Set();
            toUnselect = new _Set();
            // use the selection from the previous drag
            var previousSelection = _this2._layerSelectedItemsMap.get(layer);

            datumsInArea.forEach(function (datum) {
              if (!previousSelection.has(datum)) {
                toSelect.add(datum);
              } else {
                toUnselect.add(datum);
              }
            });

            currentSelection.forEach(function (datum) {
              if (!datumsInArea.has(datum) && !previousSelection.has(datum)) {
                toUnselect.add(datum);
              }
            });

            previousSelection.forEach(function (datum) {
              if (!datumsInArea.has(datum)) {
                toSelect.add(datum);
              }
            });
          })();
        }

        layer.unselect(toUnselect);
        layer.select(toSelect);

        layer.updateShapes(currentSelection);
        layer.updateShapes(datumsInArea);
      });
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {
      this._removeBrush(this._currentTrack);
      if (this.wasMoving) {
        this.wasMoving = false;
      }
    }
  }, {
    key: 'onClick',
    value: function onClick(e) {
      // console.log('click');
      if (!this._currentTrack) {
        return;
      }
      var that = this;

      this._currentTrack.layers.forEach(function (layer) {

        var shape = e.target.shape;
        var datum = layer.getDatumFromShape(shape);
        var toUpdate = new _Set();

        //TODO: correct this because it is not working as I expected to. 
        if (!e.originalEvent.shiftKey) {
          toUpdate = new _Set(layer.selectedDatums);
          layer.unselect(layer.selectedDatums);
        }

        if (datum) {
          toUpdate.add(datum);
          layer.toggleSelection([datum]);
        }

        layer.updateShapes(toUpdate);
      });
    }
  }, {
    key: 'targetLayer',
    set: function set(layer) {
      this._layer = layer;
    },
    get: function get() {
      return this._layer;
    }
  }]);

  return ShapeInsertionState;
})(_baseState2['default']);

exports['default'] = ShapeInsertionState;
module.exports = exports['default'];

},{"./base-state":52,"babel-runtime/core-js/map":69,"babel-runtime/core-js/set":77,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84,"konva":172}],63:[function(require,module,exports){
'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _baseState = require('./base-state');

var _baseState2 = _interopRequireDefault(_baseState);

/**
 * A state to select and edit shapes in a simple way. (kind of plug n play state)
 */

var SimpleEditionState = (function (_BaseState) {
  _inherits(SimpleEditionState, _BaseState);

  function SimpleEditionState(timeline) {
    _classCallCheck(this, SimpleEditionState);

    _get(Object.getPrototypeOf(SimpleEditionState.prototype), 'constructor', this).call(this, timeline);

    this.currentEditedLayer = null;
    this.currentTarget = null;
  }

  _createClass(SimpleEditionState, [{
    key: 'enter',
    value: function enter() {}
  }, {
    key: 'exit',
    value: function exit() {
      this.currentEditedLayer = null;
      this.currentTarget = null;
    }
  }, {
    key: 'handleEvent',
    value: function handleEvent(e) {
      switch (e.type) {
        case 'mousedown':
          this.onMouseDown(e);
          break;
        case 'mousemove':
          this.onMouseMove(e);
          break;
        case 'mouseup':
          this.onMouseUp(e);
          break;
      }
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      // TODO: allow shapes from multiple layers to be edited at the same time.
      // TODO: move target shapes to the drag konva layer of each layer.

      // keep target consistent with mouse down
      this.currentTarget = e.target;

      if (this.currentTarget.shape && this.currentTarget.shape.isContextShape) {
        if (!e.originalEvent.shiftKey) this.timeline.getTrackFromDOMElement(e.currentTarget).layers.forEach(function (layer) {
          var aux = new _Set(layer.selectedDatums);
          layer.unselect(layer.selectedDatums);
          layer.updateShapes(aux);
        });
        return;
      } else if (!this.currentTarget.shape) {
        if (!e.originalEvent.shiftKey) this.timeline.getTrackFromDOMElement(e.currentTarget).layers.forEach(function (layer) {
          var aux = new _Set(layer.selectedDatums);
          layer.unselect(layer.selectedDatums);
          layer.updateShapes(aux);
        });
        return;
      }

      var layer = this.currentTarget.shape.layer;

      var a = new _Set(layer.selectedDatums);
      var that = this;

      if (this.currentTarget.shape.layer) {
        if (!e.originalEvent.shiftKey) {
          this.timeline.getTrackFromDOMElement(e.currentTarget).layers.forEach(function (layer) {
            return layer.unselect(layer.selectedDatums);
          });
        }
        this.currentEditedLayer = layer;
        var datum = layer.getDatumFromShape(this.currentTarget.shape);
        if (datum !== undefined) {
          layer.select([datum]);
          a.add(datum);
        }
        layer.updateShapes(a);
        this.currentEditedLayer.selectedDatums.forEach(function (datum) {
          that.currentEditedLayer.getShapeFromDatum(datum).startDrag();
        });
      } else if (!e.originalEvent.shiftKey) {
        layer.unselect(layer.selectedDatums);
        layer.updateShapes(a);
        this.currentEditedLayer.selectedDatums.forEach(function (datum) {
          that.currentEditedLayer.getShapeFromDatum(datum).startDrag();
        });
      }
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      // TODO: allow shapes from multiple layers to be edited at the same time.
      // TODO: move target shapes to the drag konva layer of each layer.

      if (!this.currentEditedLayer) {
        return;
      }

      var layer = this.currentEditedLayer;
      var datums = layer.selectedDatums;

      layer.edit(datums, e.dx, e.dy, this.currentTarget);
      layer.updateShapes(datums);
    }
  }, {
    key: 'onMouseUp',
    value: function onMouseUp(e) {
      // TODO: allow shapes from multiple layers to be edited at the same time.
      // TODO: use Layer.allocateShapesToContentLayers to move the target shapes from the drag konva layers to a content konva layer.

      var that = this;
      var layer = this.currentEditedLayer;

      if (!layer) return;

      layer.updateShapes(layer.selectedDatums);
      layer.selectedDatums.forEach(function (datum) {
        layer.getShapeFromDatum(datum).stopDrag();
      });
      this.currentEditedLayer = null;
    }
  }]);

  return SimpleEditionState;
})(_baseState2['default']);

exports['default'] = SimpleEditionState;
module.exports = exports['default'];

},{"./base-state":52,"babel-runtime/core-js/set":77,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81,"babel-runtime/helpers/get":82,"babel-runtime/helpers/inherits":83,"babel-runtime/helpers/interop-require-default":84}],64:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = {
  padLeft: function padLeft(input, sign, length) {
    input += '';
    while (input.length < length) {
      input = sign + input;
    }
    return input;
  }
};
module.exports = exports['default'];

},{}],65:[function(require,module,exports){
'use strict';

/**
 * OrthogonalData transforms an object of arrays `{foo: [1, 2], bar: [3, 4]}`
 * to or from an array of objects `[{foo: 1, bar: 3}, {foo: 2, bar: 4}]`
 */

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var OrthogonalData = (function () {
  function OrthogonalData() {
    _classCallCheck(this, OrthogonalData);

    this._cols = null; // Object of arrays
    this._rows = null; // Array of objects
  }

  /**
   * Check the consistency of the data.
   */

  _createClass(OrthogonalData, [{
    key: '_checkConsistency',
    value: function _checkConsistency() {
      var size = null;

      for (var key in this._cols) {
        var col = this._cols[key];
        var colLength = col.length;

        if (size !== null && size !== colLength) {
          throw new Error(this.prototype.constructor.name + ': inconsistent data');
        } else if (size === null) {
          size = colLength;
        }
      }
    }

    /**
     * Updates array of objects from object of arrays.
     */
  }, {
    key: 'updateFromCols',
    value: function updateFromCols() {
      var _this = this;

      var keys = _Object$keys(this._cols);

      keys.forEach(function (key, i) {
        var col = _this._cols[key];

        col.forEach(function (value, index) {
          if (_this._rows[index] === undefined) _this._rows[index] = {};
          _this._rows[index][key] = value;
        });
      });

      this._checkConsistency();
    }

    /**
     * Updates object of arrays from array of objects.
     */
  }, {
    key: 'updateFromRows',
    value: function updateFromRows() {
      var _this2 = this;

      this._rows.forEach(function (obj, index) {
        for (var key in obj) {
          if (index === 0) _this2._cols[key] = [];
          _this2._cols[key].push(obj[key]);
        }
      });

      this._checkConsistency();
    }

    /**
     * Sets an object of arrays.
     *
     * @type {Object<String, Array>}
     */
  }, {
    key: 'cols',
    set: function set(obj) {
      this._cols = obj;
      this._rows = [];

      this.updateFromCols();
    },

    /**
     * Returns an object of arrays.
     *
     * @type {Object<String, Array>}
     */
    get: function get() {
      return this._cols;
    }

    /**
     * Sets an array of objects.
     *
     * @type {Array<Object>}
     */
  }, {
    key: 'rows',
    set: function set(arr) {
      this._rows = arr;
      this._cols = {};

      this.updateFromRows();
    },

    /**
     * Returns an array of objects.
     *
     * @type {Array<Object>}
     */
    get: function get() {
      return this._rows;
    }
  }]);

  return OrthogonalData;
})();

exports['default'] = OrthogonalData;
module.exports = exports['default'];

},{"babel-runtime/core-js/object/keys":74,"babel-runtime/helpers/class-call-check":80,"babel-runtime/helpers/create-class":81}],66:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = {
  linear: function linear() {
    var _domain = [0, 1];
    var _range = [0, 1];

    var _slope = 1;
    var _intercept = 0;

    function _updateCoefs() {
      _slope = (_range[1] - _range[0]) / (_domain[1] - _domain[0]);
      _intercept = _range[0] - _slope * _domain[0];
    }

    function scale(value) {
      return _slope * value + _intercept;
    }

    scale.invert = function (value) {
      return (value - _intercept) / _slope;
    };

    scale.domain = function () {
      var arr = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      if (arr === null) {
        return _domain;
      }

      _domain = arr;
      _updateCoefs();

      return scale;
    };

    scale.range = function () {
      var arr = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      if (arr === null) {
        return _range;
      }

      _range = arr;
      _updateCoefs();

      return scale;
    };

    return scale;
  }
};
module.exports = exports['default'];

},{}],67:[function(require,module,exports){
// axis
'use strict';

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _axisAxisLayer = require('./axis/axis-layer');

var _axisAxisLayer2 = _interopRequireDefault(_axisAxisLayer);

var _axisTimeAxisGenerator = require('./axis/time-axis-generator');

var _axisTimeAxisGenerator2 = _interopRequireDefault(_axisTimeAxisGenerator);

var _axisGridAxisGenerator = require('./axis/grid-axis-generator');

var _axisGridAxisGenerator2 = _interopRequireDefault(_axisGridAxisGenerator);

// behaviors

var _behaviorsBaseBehavior = require('./behaviors/base-behavior');

var _behaviorsBaseBehavior2 = _interopRequireDefault(_behaviorsBaseBehavior);

var _behaviorsBeatGridSnapSegmentBehavior = require('./behaviors/beat-grid-snap-segment-behavior');

var _behaviorsBeatGridSnapSegmentBehavior2 = _interopRequireDefault(_behaviorsBeatGridSnapSegmentBehavior);

var _behaviorsBreakpointBehavior = require('./behaviors/breakpoint-behavior');

var _behaviorsBreakpointBehavior2 = _interopRequireDefault(_behaviorsBreakpointBehavior);

var _behaviorsMarkerBehavior = require('./behaviors/marker-behavior');

var _behaviorsMarkerBehavior2 = _interopRequireDefault(_behaviorsMarkerBehavior);

var _behaviorsScrollSegmentBehavior = require('./behaviors/scroll-segment-behavior');

var _behaviorsScrollSegmentBehavior2 = _interopRequireDefault(_behaviorsScrollSegmentBehavior);

var _behaviorsSegmentBehavior = require('./behaviors/segment-behavior');

var _behaviorsSegmentBehavior2 = _interopRequireDefault(_behaviorsSegmentBehavior);

var _behaviorsSiblingLockedSegmentBehavior = require('./behaviors/sibling-locked-segment-behavior');

var _behaviorsSiblingLockedSegmentBehavior2 = _interopRequireDefault(_behaviorsSiblingLockedSegmentBehavior);

var _behaviorsSimpleSnapSegmentBehavior = require('./behaviors/simple-snap-segment-behavior');

var _behaviorsSimpleSnapSegmentBehavior2 = _interopRequireDefault(_behaviorsSimpleSnapSegmentBehavior);

var _behaviorsTimeContextBehavior = require('./behaviors/time-context-behavior');

var _behaviorsTimeContextBehavior2 = _interopRequireDefault(_behaviorsTimeContextBehavior);

var _behaviorsTraceBehavior = require('./behaviors/trace-behavior');

var _behaviorsTraceBehavior2 = _interopRequireDefault(_behaviorsTraceBehavior);

var _behaviorsWaveformBehavior = require('./behaviors/waveform-behavior');

var _behaviorsWaveformBehavior2 = _interopRequireDefault(_behaviorsWaveformBehavior);

var _behaviorsNoBehavior = require('./behaviors/no-behavior');

var _behaviorsNoBehavior2 = _interopRequireDefault(_behaviorsNoBehavior);

// core

var _coreLayerTimeContext = require('./core/layer-time-context');

var _coreLayerTimeContext2 = _interopRequireDefault(_coreLayerTimeContext);

var _coreLayer = require('./core/layer');

var _coreLayer2 = _interopRequireDefault(_coreLayer);

var _coreTimelineTimeContext = require('./core/timeline-time-context');

var _coreTimelineTimeContext2 = _interopRequireDefault(_coreTimelineTimeContext);

var _coreTimeline = require('./core/timeline');

var _coreTimeline2 = _interopRequireDefault(_coreTimeline);

var _coreTrackCollection = require('./core/track-collection');

var _coreTrackCollection2 = _interopRequireDefault(_coreTrackCollection);

var _coreTrack = require('./core/track');

var _coreTrack2 = _interopRequireDefault(_coreTrack);

// helpers

var _helpersAnnotatedMarkerLayer = require('./helpers/annotated-marker-layer');

var _helpersAnnotatedMarkerLayer2 = _interopRequireDefault(_helpersAnnotatedMarkerLayer);

var _helpersAnnotatedSegmentLayer = require('./helpers/annotated-segment-layer');

var _helpersAnnotatedSegmentLayer2 = _interopRequireDefault(_helpersAnnotatedSegmentLayer);

var _helpersBreakpointLayer = require('./helpers/breakpoint-layer');

var _helpersBreakpointLayer2 = _interopRequireDefault(_helpersBreakpointLayer);

var _helpersCursorLayer = require('./helpers/cursor-layer');

var _helpersCursorLayer2 = _interopRequireDefault(_helpersCursorLayer);

var _helpersGridAxisLayer = require('./helpers/grid-axis-layer');

var _helpersGridAxisLayer2 = _interopRequireDefault(_helpersGridAxisLayer);

var _helpersMarkerLayer = require('./helpers/marker-layer');

var _helpersMarkerLayer2 = _interopRequireDefault(_helpersMarkerLayer);

var _helpersSegmentLayer = require('./helpers/segment-layer');

var _helpersSegmentLayer2 = _interopRequireDefault(_helpersSegmentLayer);

var _helpersTickLayer = require('./helpers/tick-layer');

var _helpersTickLayer2 = _interopRequireDefault(_helpersTickLayer);

var _helpersTimeAxisLayer = require('./helpers/time-axis-layer');

var _helpersTimeAxisLayer2 = _interopRequireDefault(_helpersTimeAxisLayer);

var _helpersTraceLayer = require('./helpers/trace-layer');

var _helpersTraceLayer2 = _interopRequireDefault(_helpersTraceLayer);

var _helpersWaveformLayer = require('./helpers/waveform-layer');

var _helpersWaveformLayer2 = _interopRequireDefault(_helpersWaveformLayer);

var _helpersBeatGridLayer = require('./helpers/beat-grid-layer');

var _helpersBeatGridLayer2 = _interopRequireDefault(_helpersBeatGridLayer);

var _helpersScroller = require('./helpers/scroller');

var _helpersScroller2 = _interopRequireDefault(_helpersScroller);

// interactions

var _interactionsEventSource = require('./interactions/event-source');

var _interactionsEventSource2 = _interopRequireDefault(_interactionsEventSource);

var _interactionsKeyboard = require('./interactions/keyboard');

var _interactionsKeyboard2 = _interopRequireDefault(_interactionsKeyboard);

var _interactionsKonvaSurface = require('./interactions/konva-surface');

var _interactionsKonvaSurface2 = _interopRequireDefault(_interactionsKonvaSurface);

var _interactionsKonvaWaveEvent = require('./interactions/konva-wave-event');

var _interactionsKonvaWaveEvent2 = _interopRequireDefault(_interactionsKonvaWaveEvent);

var _interactionsWaveEvent = require('./interactions/wave-event');

var _interactionsWaveEvent2 = _interopRequireDefault(_interactionsWaveEvent);

// shapes
// import AnnotatedMarker from './shapes/annotated-marker';

var _shapesAnnotatedSegment = require('./shapes/annotated-segment');

var _shapesAnnotatedSegment2 = _interopRequireDefault(_shapesAnnotatedSegment);

var _shapesBaseShape = require('./shapes/base-shape');

var _shapesBaseShape2 = _interopRequireDefault(_shapesBaseShape);

var _shapesCursor = require('./shapes/cursor');

var _shapesCursor2 = _interopRequireDefault(_shapesCursor);

var _shapesDot = require('./shapes/dot');

var _shapesDot2 = _interopRequireDefault(_shapesDot);

var _shapesLine = require('./shapes/line');

var _shapesLine2 = _interopRequireDefault(_shapesLine);

var _shapesMarker = require('./shapes/marker');

var _shapesMarker2 = _interopRequireDefault(_shapesMarker);

var _shapesSegment = require('./shapes/segment');

var _shapesSegment2 = _interopRequireDefault(_shapesSegment);

var _shapesTicks = require('./shapes/ticks');

var _shapesTicks2 = _interopRequireDefault(_shapesTicks);

var _shapesTraceDots = require('./shapes/trace-dots');

var _shapesTraceDots2 = _interopRequireDefault(_shapesTraceDots);

var _shapesTracePath = require('./shapes/trace-path');

var _shapesTracePath2 = _interopRequireDefault(_shapesTracePath);

var _shapesWaveform = require('./shapes/waveform');

var _shapesWaveform2 = _interopRequireDefault(_shapesWaveform);

// states

var _statesBaseState = require('./states/base-state');

var _statesBaseState2 = _interopRequireDefault(_statesBaseState);

var _statesBreakpointState = require('./states/breakpoint-state');

var _statesBreakpointState2 = _interopRequireDefault(_statesBreakpointState);

var _statesBrushZoomState = require('./states/brush-zoom-state');

var _statesBrushZoomState2 = _interopRequireDefault(_statesBrushZoomState);

var _statesCenteredZoomState = require('./states/centered-zoom-state');

var _statesCenteredZoomState2 = _interopRequireDefault(_statesCenteredZoomState);

var _statesCenteredScrollState = require('./states/centered-scroll-state');

var _statesCenteredScrollState2 = _interopRequireDefault(_statesCenteredScrollState);

var _statesContextEditionState = require('./states/context-edition-state');

var _statesContextEditionState2 = _interopRequireDefault(_statesContextEditionState);

var _statesDropAndAddState = require('./states/drop-and-add-state');

var _statesDropAndAddState2 = _interopRequireDefault(_statesDropAndAddState);

var _statesEditionState = require('./states/edition-state');

var _statesEditionState2 = _interopRequireDefault(_statesEditionState);

var _statesHorizontalSelectionState = require('./states/horizontal-selection-state');

var _statesHorizontalSelectionState2 = _interopRequireDefault(_statesHorizontalSelectionState);

var _statesSelectionState = require('./states/selection-state');

var _statesSelectionState2 = _interopRequireDefault(_statesSelectionState);

var _statesShapeInsertionState = require('./states/shape-insertion-state');

var _statesShapeInsertionState2 = _interopRequireDefault(_statesShapeInsertionState);

var _statesSimpleEditionState = require('./states/simple-edition-state');

var _statesSimpleEditionState2 = _interopRequireDefault(_statesSimpleEditionState);

// import BeatGridEditorInteractionsState from './states/beat-grid-interactions-state';

// utils

var _utilsFormat = require('./utils/format');

var _utilsFormat2 = _interopRequireDefault(_utilsFormat);

var _utilsOrthogonalData = require('./utils/orthogonal-data');

var _utilsOrthogonalData2 = _interopRequireDefault(_utilsOrthogonalData);

var _utilsScales = require('./utils/scales');

var _utilsScales2 = _interopRequireDefault(_utilsScales);

exports['default'] = {
  axis: {
    AxisLayer: _axisAxisLayer2['default'], timeAxisGenerator: _axisTimeAxisGenerator2['default'], gridAxisGenerator: _axisGridAxisGenerator2['default']
  },

  behaviors: {
    BaseBehavior: _behaviorsBaseBehavior2['default'], BeatGridSnapSegmentBehavior: _behaviorsBeatGridSnapSegmentBehavior2['default'],
    BreakpointBehavior: _behaviorsBreakpointBehavior2['default'], MarkerBehavior: _behaviorsMarkerBehavior2['default'],
    ScrollSegmentBehavior: _behaviorsScrollSegmentBehavior2['default'], SegmentBehavior: _behaviorsSegmentBehavior2['default'],
    SiblingLockedSegmentBehavior: _behaviorsSiblingLockedSegmentBehavior2['default'], SimpleSnapSegmentBehavior: _behaviorsSimpleSnapSegmentBehavior2['default'],
    TimeContextBehavior: _behaviorsTimeContextBehavior2['default'], TraceBehavior: _behaviorsTraceBehavior2['default'], WaveformBehavior: _behaviorsWaveformBehavior2['default'],
    NoBehavior: _behaviorsNoBehavior2['default']
  },

  core: {
    LayerTimeContext: _coreLayerTimeContext2['default'], Layer: _coreLayer2['default'], TimelineTimeContext: _coreTimelineTimeContext2['default'], Timeline: _coreTimeline2['default'],
    TrackCollection: _coreTrackCollection2['default'], Track: _coreTrack2['default']
  },

  helpers: {
    AnnotatedMarkerLayer: _helpersAnnotatedMarkerLayer2['default'],
    AnnotatedSegmentLayer: _helpersAnnotatedSegmentLayer2['default'],
    BreakpointLayer: _helpersBreakpointLayer2['default'],
    CursorLayer: _helpersCursorLayer2['default'],
    GridAxisLayer: _helpersGridAxisLayer2['default'],
    MarkerLayer: _helpersMarkerLayer2['default'],
    SegmentLayer: _helpersSegmentLayer2['default'],
    TickLayer: _helpersTickLayer2['default'],
    TimeAxisLayer: _helpersTimeAxisLayer2['default'],
    TraceLayer: _helpersTraceLayer2['default'],
    WaveformLayer: _helpersWaveformLayer2['default'],
    BeatGridLayer: _helpersBeatGridLayer2['default'],
    Scroller: _helpersScroller2['default']
  },

  interactions: {
    EventSource: _interactionsEventSource2['default'], Keyboard: _interactionsKeyboard2['default'],
    Surface: _interactionsKonvaSurface2['default'], KonvaWaveEvent: _interactionsKonvaWaveEvent2['default'], WaveEvent: _interactionsWaveEvent2['default']
  },

  shapes: {
    // AnnotatedMarker,
    AnnotatedSegment: _shapesAnnotatedSegment2['default'], BaseShape: _shapesBaseShape2['default'], Cursor: _shapesCursor2['default'],
    Dot: _shapesDot2['default'], Line: _shapesLine2['default'], Marker: _shapesMarker2['default'], Segment: _shapesSegment2['default'],
    Ticks: _shapesTicks2['default'], TraceDots: _shapesTraceDots2['default'], TracePath: _shapesTracePath2['default'], Waveform: _shapesWaveform2['default']
  },

  states: {
    BaseState: _statesBaseState2['default'], BreakpointState: _statesBreakpointState2['default'], BrushZoomState: _statesBrushZoomState2['default'], CenteredZoomState: _statesCenteredZoomState2['default'],
    CenteredScrollState: _statesCenteredScrollState2['default'], ContextEditionState: _statesContextEditionState2['default'], DropAndAddState: _statesDropAndAddState2['default'], EditionState: _statesEditionState2['default'],
    SelectionState: _statesSelectionState2['default'], HorizontalSelectionState: _statesHorizontalSelectionState2['default'], ShapeInsertionState: _statesShapeInsertionState2['default'], SimpleEditionState: _statesSimpleEditionState2['default']
  },

  utils: {
    format: _utilsFormat2['default'], OrthogonalData: _utilsOrthogonalData2['default'], scales: _utilsScales2['default']
  }
};
module.exports = exports['default'];

},{"./axis/axis-layer":1,"./axis/grid-axis-generator":2,"./axis/time-axis-generator":3,"./behaviors/base-behavior":4,"./behaviors/beat-grid-snap-segment-behavior":5,"./behaviors/breakpoint-behavior":6,"./behaviors/marker-behavior":7,"./behaviors/no-behavior":8,"./behaviors/scroll-segment-behavior":9,"./behaviors/segment-behavior":10,"./behaviors/sibling-locked-segment-behavior":11,"./behaviors/simple-snap-segment-behavior":12,"./behaviors/time-context-behavior":13,"./behaviors/trace-behavior":14,"./behaviors/waveform-behavior":15,"./core/layer":17,"./core/layer-time-context":16,"./core/timeline":19,"./core/timeline-time-context":18,"./core/track":21,"./core/track-collection":20,"./helpers/annotated-marker-layer":22,"./helpers/annotated-segment-layer":23,"./helpers/beat-grid-layer":24,"./helpers/breakpoint-layer":25,"./helpers/cursor-layer":26,"./helpers/grid-axis-layer":27,"./helpers/marker-layer":28,"./helpers/scroller":29,"./helpers/segment-layer":30,"./helpers/tick-layer":31,"./helpers/time-axis-layer":32,"./helpers/trace-layer":33,"./helpers/waveform-layer":34,"./interactions/event-source":35,"./interactions/keyboard":36,"./interactions/konva-surface":37,"./interactions/konva-wave-event":38,"./interactions/wave-event":39,"./shapes/annotated-segment":41,"./shapes/base-shape":42,"./shapes/cursor":43,"./shapes/dot":44,"./shapes/line":45,"./shapes/marker":46,"./shapes/segment":47,"./shapes/ticks":48,"./shapes/trace-dots":49,"./shapes/trace-path":50,"./shapes/waveform":51,"./states/base-state":52,"./states/breakpoint-state":53,"./states/brush-zoom-state":54,"./states/centered-scroll-state":55,"./states/centered-zoom-state":56,"./states/context-edition-state":57,"./states/drop-and-add-state":58,"./states/edition-state":59,"./states/horizontal-selection-state":60,"./states/selection-state":61,"./states/shape-insertion-state":62,"./states/simple-edition-state":63,"./utils/format":64,"./utils/orthogonal-data":65,"./utils/scales":66,"babel-runtime/helpers/interop-require-default":84}],68:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/get-iterator"), __esModule: true };
},{"core-js/library/fn/get-iterator":85}],69:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/map"), __esModule: true };
},{"core-js/library/fn/map":86}],70:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":87}],71:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
},{"core-js/library/fn/object/create":88}],72:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
},{"core-js/library/fn/object/define-property":89}],73:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-own-property-descriptor"), __esModule: true };
},{"core-js/library/fn/object/get-own-property-descriptor":90}],74:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/keys"), __esModule: true };
},{"core-js/library/fn/object/keys":91}],75:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/set-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/set-prototype-of":92}],76:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/promise"), __esModule: true };
},{"core-js/library/fn/promise":93}],77:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/set"), __esModule: true };
},{"core-js/library/fn/set":94}],78:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":95}],79:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol/iterator"), __esModule: true };
},{"core-js/library/fn/symbol/iterator":96}],80:[function(require,module,exports){
"use strict";

exports["default"] = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

exports.__esModule = true;
},{}],81:[function(require,module,exports){
"use strict";

var _Object$defineProperty = require("babel-runtime/core-js/object/define-property")["default"];

exports["default"] = (function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;

      _Object$defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
})();

exports.__esModule = true;
},{"babel-runtime/core-js/object/define-property":72}],82:[function(require,module,exports){
"use strict";

var _Object$getOwnPropertyDescriptor = require("babel-runtime/core-js/object/get-own-property-descriptor")["default"];

exports["default"] = function get(_x, _x2, _x3) {
  var _again = true;

  _function: while (_again) {
    var object = _x,
        property = _x2,
        receiver = _x3;
    _again = false;
    if (object === null) object = Function.prototype;

    var desc = _Object$getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        _x = parent;
        _x2 = property;
        _x3 = receiver;
        _again = true;
        desc = parent = undefined;
        continue _function;
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  }
};

exports.__esModule = true;
},{"babel-runtime/core-js/object/get-own-property-descriptor":73}],83:[function(require,module,exports){
"use strict";

var _Object$create = require("babel-runtime/core-js/object/create")["default"];

var _Object$setPrototypeOf = require("babel-runtime/core-js/object/set-prototype-of")["default"];

exports["default"] = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = _Object$create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

exports.__esModule = true;
},{"babel-runtime/core-js/object/create":71,"babel-runtime/core-js/object/set-prototype-of":75}],84:[function(require,module,exports){
"use strict";

exports["default"] = function (obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
};

exports.__esModule = true;
},{}],85:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.get-iterator');
},{"../modules/core.get-iterator":155,"../modules/es6.string.iterator":165,"../modules/web.dom.iterable":169}],86:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.map');
require('../modules/es7.map.to-json');
module.exports = require('../modules/$.core').Map;
},{"../modules/$.core":105,"../modules/es6.map":157,"../modules/es6.object.to-string":162,"../modules/es6.string.iterator":165,"../modules/es7.map.to-json":167,"../modules/web.dom.iterable":169}],87:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/$.core').Object.assign;
},{"../../modules/$.core":105,"../../modules/es6.object.assign":158}],88:[function(require,module,exports){
var $ = require('../../modules/$');
module.exports = function create(P, D){
  return $.create(P, D);
};
},{"../../modules/$":129}],89:[function(require,module,exports){
var $ = require('../../modules/$');
module.exports = function defineProperty(it, key, desc){
  return $.setDesc(it, key, desc);
};
},{"../../modules/$":129}],90:[function(require,module,exports){
var $ = require('../../modules/$');
require('../../modules/es6.object.get-own-property-descriptor');
module.exports = function getOwnPropertyDescriptor(it, key){
  return $.getDesc(it, key);
};
},{"../../modules/$":129,"../../modules/es6.object.get-own-property-descriptor":159}],91:[function(require,module,exports){
require('../../modules/es6.object.keys');
module.exports = require('../../modules/$.core').Object.keys;
},{"../../modules/$.core":105,"../../modules/es6.object.keys":160}],92:[function(require,module,exports){
require('../../modules/es6.object.set-prototype-of');
module.exports = require('../../modules/$.core').Object.setPrototypeOf;
},{"../../modules/$.core":105,"../../modules/es6.object.set-prototype-of":161}],93:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.promise');
module.exports = require('../modules/$.core').Promise;
},{"../modules/$.core":105,"../modules/es6.object.to-string":162,"../modules/es6.promise":163,"../modules/es6.string.iterator":165,"../modules/web.dom.iterable":169}],94:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.set');
require('../modules/es7.set.to-json');
module.exports = require('../modules/$.core').Set;
},{"../modules/$.core":105,"../modules/es6.object.to-string":162,"../modules/es6.set":164,"../modules/es6.string.iterator":165,"../modules/es7.set.to-json":168,"../modules/web.dom.iterable":169}],95:[function(require,module,exports){
require('../../modules/es6.symbol');
module.exports = require('../../modules/$.core').Symbol;
},{"../../modules/$.core":105,"../../modules/es6.symbol":166}],96:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/web.dom.iterable');
module.exports = require('../../modules/$.wks')('iterator');
},{"../../modules/$.wks":153,"../../modules/es6.string.iterator":165,"../../modules/web.dom.iterable":169}],97:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],98:[function(require,module,exports){
var isObject = require('./$.is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./$.is-object":122}],99:[function(require,module,exports){
// 19.1.2.1 Object.assign(target, source, ...)
var $        = require('./$')
  , toObject = require('./$.to-object')
  , IObject  = require('./$.iobject');

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = require('./$.fails')(function(){
  var a = Object.assign
    , A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , $$    = arguments
    , $$len = $$.length
    , index = 1
    , getKeys    = $.getKeys
    , getSymbols = $.getSymbols
    , isEnum     = $.isEnum;
  while($$len > index){
    var S      = IObject($$[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  }
  return T;
} : Object.assign;
},{"./$":129,"./$.fails":111,"./$.iobject":119,"./$.to-object":150}],100:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./$.cof')
  , TAG = require('./$.wks')('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};
},{"./$.cof":101,"./$.wks":153}],101:[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],102:[function(require,module,exports){
'use strict';
var $            = require('./$')
  , hide         = require('./$.hide')
  , ctx          = require('./$.ctx')
  , species      = require('./$.species')
  , strictNew    = require('./$.strict-new')
  , defined      = require('./$.defined')
  , forOf        = require('./$.for-of')
  , step         = require('./$.iter-step')
  , ID           = require('./$.uid')('id')
  , $has         = require('./$.has')
  , isObject     = require('./$.is-object')
  , isExtensible = Object.isExtensible || isObject
  , SUPPORT_DESC = require('./$.support-desc')
  , SIZE         = SUPPORT_DESC ? '_s' : 'size'
  , id           = 0;

var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!$has(it, ID)){
    // can't set id to frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add id
    if(!create)return 'E';
    // add missing object id
    hide(it, ID, ++id);
  // return object id with prefix
  } return 'O' + it[ID];
};

var getEntry = function(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      strictNew(that, C, NAME);
      that._i = $.create(null); // index
      that._f = undefined;      // first entry
      that._l = undefined;      // last entry
      that[SIZE] = 0;           // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    require('./$.mix')(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(SUPPORT_DESC)$.setDesc(C.prototype, 'size', {
      get: function(){
        return defined(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    require('./$.iter-define')(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    species(C);
    species(require('./$.core')[NAME]); // for wrapper
  }
};
},{"./$":129,"./$.core":105,"./$.ctx":106,"./$.defined":108,"./$.for-of":112,"./$.has":115,"./$.hide":116,"./$.is-object":122,"./$.iter-define":125,"./$.iter-step":127,"./$.mix":133,"./$.species":141,"./$.strict-new":142,"./$.support-desc":144,"./$.uid":151}],103:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var forOf   = require('./$.for-of')
  , classof = require('./$.classof');
module.exports = function(NAME){
  return function toJSON(){
    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    var arr = [];
    forOf(this, false, arr.push, arr);
    return arr;
  };
};
},{"./$.classof":100,"./$.for-of":112}],104:[function(require,module,exports){
'use strict';
var $          = require('./$')
  , $def       = require('./$.def')
  , hide       = require('./$.hide')
  , forOf      = require('./$.for-of')
  , strictNew  = require('./$.strict-new');

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = require('./$.global')[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  if(!require('./$.support-desc') || typeof C != 'function'
    || !(IS_WEAK || proto.forEach && !require('./$.fails')(function(){ new C().entries().next(); }))
  ){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    require('./$.mix')(C.prototype, methods);
  } else {
    C = wrapper(function(target, iterable){
      strictNew(target, C, NAME);
      target._c = new Base;
      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
    });
    $.each.call('add,clear,delete,forEach,get,has,set,keys,values,entries'.split(','),function(KEY){
      var chain = KEY == 'add' || KEY == 'set';
      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return chain ? this : result;
      });
    });
    if('size' in proto)$.setDesc(C.prototype, 'size', {
      get: function(){
        return this._c.size;
      }
    });
  }

  require('./$.tag')(C, NAME);

  O[NAME] = C;
  $def($def.G + $def.W + $def.F, O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};
},{"./$":129,"./$.def":107,"./$.fails":111,"./$.for-of":112,"./$.global":114,"./$.hide":116,"./$.mix":133,"./$.strict-new":142,"./$.support-desc":144,"./$.tag":145}],105:[function(require,module,exports){
var core = module.exports = {version: '1.2.3'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],106:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./$.a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./$.a-function":97}],107:[function(require,module,exports){
var global    = require('./$.global')
  , core      = require('./$.core')
  , PROTOTYPE = 'prototype';
var ctx = function(fn, that){
  return function(){
    return fn.apply(that, arguments);
  };
};
var $def = function(type, name, source){
  var key, own, out, exp
    , isGlobal = type & $def.G
    , isProto  = type & $def.P
    , target   = isGlobal ? global : type & $def.S
        ? global[name] : (global[name] || {})[PROTOTYPE]
    , exports  = isGlobal ? core : core[name] || (core[name] = {});
  if(isGlobal)source = name;
  for(key in source){
    // contains in native
    own = !(type & $def.F) && target && key in target;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    if(isGlobal && typeof target[key] != 'function')exp = source[key];
    // bind timers to global for call from export context
    else if(type & $def.B && own)exp = ctx(out, global);
    // wrap global constructors for prevent change them in library
    else if(type & $def.W && target[key] == out)!function(C){
      exp = function(param){
        return this instanceof C ? new C(param) : C(param);
      };
      exp[PROTOTYPE] = C[PROTOTYPE];
    }(out);
    else exp = isProto && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export
    exports[key] = exp;
    if(isProto)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
  }
};
// type bitmap
$def.F = 1;  // forced
$def.G = 2;  // global
$def.S = 4;  // static
$def.P = 8;  // proto
$def.B = 16; // bind
$def.W = 32; // wrap
module.exports = $def;
},{"./$.core":105,"./$.global":114}],108:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],109:[function(require,module,exports){
var isObject = require('./$.is-object')
  , document = require('./$.global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./$.global":114,"./$.is-object":122}],110:[function(require,module,exports){
// all enumerable object keys, includes symbols
var $ = require('./$');
module.exports = function(it){
  var keys       = $.getKeys(it)
    , getSymbols = $.getSymbols;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = $.isEnum
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);
  }
  return keys;
};
},{"./$":129}],111:[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],112:[function(require,module,exports){
var ctx         = require('./$.ctx')
  , call        = require('./$.iter-call')
  , isArrayIter = require('./$.is-array-iter')
  , anObject    = require('./$.an-object')
  , toLength    = require('./$.to-length')
  , getIterFn   = require('./core.get-iterator-method');
module.exports = function(iterable, entries, fn, that){
  var iterFn = getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    call(iterator, f, step.value, entries);
  }
};
},{"./$.an-object":98,"./$.ctx":106,"./$.is-array-iter":120,"./$.iter-call":123,"./$.to-length":149,"./core.get-iterator-method":154}],113:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toString  = {}.toString
  , toIObject = require('./$.to-iobject')
  , getNames  = require('./$').getNames;

var windowNames = typeof window == 'object' && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return getNames(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.get = function getOwnPropertyNames(it){
  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);
  return getNames(toIObject(it));
};
},{"./$":129,"./$.to-iobject":148}],114:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],115:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],116:[function(require,module,exports){
var $          = require('./$')
  , createDesc = require('./$.property-desc');
module.exports = require('./$.support-desc') ? function(object, key, value){
  return $.setDesc(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./$":129,"./$.property-desc":135,"./$.support-desc":144}],117:[function(require,module,exports){
module.exports = require('./$.global').document && document.documentElement;
},{"./$.global":114}],118:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};
},{}],119:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./$.cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./$.cof":101}],120:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./$.iterators')
  , ITERATOR  = require('./$.wks')('iterator');
module.exports = function(it){
  return (Iterators.Array || Array.prototype[ITERATOR]) === it;
};
},{"./$.iterators":128,"./$.wks":153}],121:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./$.cof');
module.exports = Array.isArray || function(arg){
  return cof(arg) == 'Array';
};
},{"./$.cof":101}],122:[function(require,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],123:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./$.an-object');
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};
},{"./$.an-object":98}],124:[function(require,module,exports){
'use strict';
var $ = require('./$')
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./$.hide')(IteratorPrototype, require('./$.wks')('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = $.create(IteratorPrototype, {next: require('./$.property-desc')(1,next)});
  require('./$.tag')(Constructor, NAME + ' Iterator');
};
},{"./$":129,"./$.hide":116,"./$.property-desc":135,"./$.tag":145,"./$.wks":153}],125:[function(require,module,exports){
'use strict';
var LIBRARY         = require('./$.library')
  , $def            = require('./$.def')
  , $redef          = require('./$.redef')
  , hide            = require('./$.hide')
  , has             = require('./$.has')
  , SYMBOL_ITERATOR = require('./$.wks')('iterator')
  , Iterators       = require('./$.iterators')
  , BUGGY           = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR     = '@@iterator'
  , KEYS            = 'keys'
  , VALUES          = 'values';
var returnThis = function(){ return this; };
module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCE){
  require('./$.iter-create')(Constructor, NAME, next);
  var createMethod = function(kind){
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG      = NAME + ' Iterator'
    , proto    = Base.prototype
    , _native  = proto[SYMBOL_ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , _default = _native || createMethod(DEFAULT)
    , methods, key;
  // Fix native
  if(_native){
    var IteratorPrototype = require('./$').getProto(_default.call(new Base));
    // Set @@toStringTag to native iterators
    require('./$.tag')(IteratorPrototype, TAG, true);
    // FF fix
    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, SYMBOL_ITERATOR, returnThis);
  }
  // Define iterator
  if(!LIBRARY || FORCE)hide(proto, SYMBOL_ITERATOR, _default);
  // Plug for library
  Iterators[NAME] = _default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEFAULT == VALUES ? _default : createMethod(VALUES),
      keys:    IS_SET            ? _default : createMethod(KEYS),
      entries: DEFAULT != VALUES ? _default : createMethod('entries')
    };
    if(FORCE)for(key in methods){
      if(!(key in proto))$redef(proto, key, methods[key]);
    } else $def($def.P + $def.F * BUGGY, NAME, methods);
  }
};
},{"./$":129,"./$.def":107,"./$.has":115,"./$.hide":116,"./$.iter-create":124,"./$.iterators":128,"./$.library":131,"./$.redef":136,"./$.tag":145,"./$.wks":153}],126:[function(require,module,exports){
var SYMBOL_ITERATOR = require('./$.wks')('iterator')
  , SAFE_CLOSING    = false;
try {
  var riter = [7][SYMBOL_ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }
module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[SYMBOL_ITERATOR]();
    iter.next = function(){ safe = true; };
    arr[SYMBOL_ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
},{"./$.wks":153}],127:[function(require,module,exports){
module.exports = function(done, value){
  return {value: value, done: !!done};
};
},{}],128:[function(require,module,exports){
module.exports = {};
},{}],129:[function(require,module,exports){
var $Object = Object;
module.exports = {
  create:     $Object.create,
  getProto:   $Object.getPrototypeOf,
  isEnum:     {}.propertyIsEnumerable,
  getDesc:    $Object.getOwnPropertyDescriptor,
  setDesc:    $Object.defineProperty,
  setDescs:   $Object.defineProperties,
  getKeys:    $Object.keys,
  getNames:   $Object.getOwnPropertyNames,
  getSymbols: $Object.getOwnPropertySymbols,
  each:       [].forEach
};
},{}],130:[function(require,module,exports){
var $         = require('./$')
  , toIObject = require('./$.to-iobject');
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = $.getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
},{"./$":129,"./$.to-iobject":148}],131:[function(require,module,exports){
module.exports = true;
},{}],132:[function(require,module,exports){
var global    = require('./$.global')
  , macrotask = require('./$.task').set
  , Observer  = global.MutationObserver || global.WebKitMutationObserver
  , process   = global.process
  , isNode    = require('./$.cof')(process) == 'process'
  , head, last, notify;

var flush = function(){
  var parent, domain;
  if(isNode && (parent = process.domain)){
    process.domain = null;
    parent.exit();
  }
  while(head){
    domain = head.domain;
    if(domain)domain.enter();
    head.fn.call(); // <- currently we use it only for Promise - try / catch not required
    if(domain)domain.exit();
    head = head.next;
  } last = undefined;
  if(parent)parent.enter();
};

// Node.js
if(isNode){
  notify = function(){
    process.nextTick(flush);
  };
// browsers with MutationObserver
} else if(Observer){
  var toggle = 1
    , node   = document.createTextNode('');
  new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
  notify = function(){
    node.data = toggle = -toggle;
  };
// for other environments - macrotask based on:
// - setImmediate
// - MessageChannel
// - window.postMessag
// - onreadystatechange
// - setTimeout
} else {
  notify = function(){
    // strange IE + webpack dev server bug - use .call(global)
    macrotask.call(global, flush);
  };
}

module.exports = function asap(fn){
  var task = {fn: fn, next: undefined, domain: isNode && process.domain};
  if(last)last.next = task;
  if(!head){
    head = task;
    notify();
  } last = task;
};
},{"./$.cof":101,"./$.global":114,"./$.task":146}],133:[function(require,module,exports){
var $redef = require('./$.redef');
module.exports = function(target, src){
  for(var key in src)$redef(target, key, src[key]);
  return target;
};
},{"./$.redef":136}],134:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
module.exports = function(KEY, exec){
  var $def = require('./$.def')
    , fn   = (require('./$.core').Object || {})[KEY] || Object[KEY]
    , exp  = {};
  exp[KEY] = exec(fn);
  $def($def.S + $def.F * require('./$.fails')(function(){ fn(1); }), 'Object', exp);
};
},{"./$.core":105,"./$.def":107,"./$.fails":111}],135:[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],136:[function(require,module,exports){
module.exports = require('./$.hide');
},{"./$.hide":116}],137:[function(require,module,exports){
module.exports = Object.is || function is(x, y){
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};
},{}],138:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var getDesc  = require('./$').getDesc
  , isObject = require('./$.is-object')
  , anObject = require('./$.an-object');
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = require('./$.ctx')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};
},{"./$":129,"./$.an-object":98,"./$.ctx":106,"./$.is-object":122}],139:[function(require,module,exports){
var global = require('./$.global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./$.global":114}],140:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject  = require('./$.an-object')
  , aFunction = require('./$.a-function')
  , SPECIES   = require('./$.wks')('species');
module.exports = function(O, D){
  var C = anObject(O).constructor, S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};
},{"./$.a-function":97,"./$.an-object":98,"./$.wks":153}],141:[function(require,module,exports){
'use strict';
var $       = require('./$')
  , SPECIES = require('./$.wks')('species');
module.exports = function(C){
  if(require('./$.support-desc') && !(SPECIES in C))$.setDesc(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};
},{"./$":129,"./$.support-desc":144,"./$.wks":153}],142:[function(require,module,exports){
module.exports = function(it, Constructor, name){
  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
  return it;
};
},{}],143:[function(require,module,exports){
// true  -> String#at
// false -> String#codePointAt
var toInteger = require('./$.to-integer')
  , defined   = require('./$.defined');
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l
      || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
        ? TO_STRING ? s.charAt(i) : a
        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
},{"./$.defined":108,"./$.to-integer":147}],144:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./$.fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./$.fails":111}],145:[function(require,module,exports){
var def = require('./$').setDesc
  , has = require('./$.has')
  , TAG = require('./$.wks')('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};
},{"./$":129,"./$.has":115,"./$.wks":153}],146:[function(require,module,exports){
'use strict';
var ctx                = require('./$.ctx')
  , invoke             = require('./$.invoke')
  , html               = require('./$.html')
  , cel                = require('./$.dom-create')
  , global             = require('./$.global')
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
var run = function(){
  var id = +this;
  if(queue.hasOwnProperty(id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listner = function(event){
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!setTask || !clearTask){
  setTask = function setImmediate(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(require('./$.cof')(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if(MessageChannel){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listner;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
    defer = function(id){
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listner, false);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};
},{"./$.cof":101,"./$.ctx":106,"./$.dom-create":109,"./$.global":114,"./$.html":117,"./$.invoke":118}],147:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],148:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./$.iobject')
  , defined = require('./$.defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./$.defined":108,"./$.iobject":119}],149:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./$.to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./$.to-integer":147}],150:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./$.defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./$.defined":108}],151:[function(require,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],152:[function(require,module,exports){
module.exports = function(){ /* empty */ };
},{}],153:[function(require,module,exports){
var store  = require('./$.shared')('wks')
  , Symbol = require('./$.global').Symbol;
module.exports = function(name){
  return store[name] || (store[name] =
    Symbol && Symbol[name] || (Symbol || require('./$.uid'))('Symbol.' + name));
};
},{"./$.global":114,"./$.shared":139,"./$.uid":151}],154:[function(require,module,exports){
var classof   = require('./$.classof')
  , ITERATOR  = require('./$.wks')('iterator')
  , Iterators = require('./$.iterators');
module.exports = require('./$.core').getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};
},{"./$.classof":100,"./$.core":105,"./$.iterators":128,"./$.wks":153}],155:[function(require,module,exports){
var anObject = require('./$.an-object')
  , get      = require('./core.get-iterator-method');
module.exports = require('./$.core').getIterator = function(it){
  var iterFn = get(it);
  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};
},{"./$.an-object":98,"./$.core":105,"./core.get-iterator-method":154}],156:[function(require,module,exports){
'use strict';
var setUnscope = require('./$.unscope')
  , step       = require('./$.iter-step')
  , Iterators  = require('./$.iterators')
  , toIObject  = require('./$.to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
require('./$.iter-define')(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

setUnscope('keys');
setUnscope('values');
setUnscope('entries');
},{"./$.iter-define":125,"./$.iter-step":127,"./$.iterators":128,"./$.to-iobject":148,"./$.unscope":152}],157:[function(require,module,exports){
'use strict';
var strong = require('./$.collection-strong');

// 23.1 Map Objects
require('./$.collection')('Map', function(get){
  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);
},{"./$.collection":104,"./$.collection-strong":102}],158:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $def = require('./$.def');

$def($def.S + $def.F, 'Object', {assign: require('./$.assign')});
},{"./$.assign":99,"./$.def":107}],159:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./$.to-iobject');

require('./$.object-sap')('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor){
  return function getOwnPropertyDescriptor(it, key){
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});
},{"./$.object-sap":134,"./$.to-iobject":148}],160:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./$.to-object');

require('./$.object-sap')('keys', function($keys){
  return function keys(it){
    return $keys(toObject(it));
  };
});
},{"./$.object-sap":134,"./$.to-object":150}],161:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $def = require('./$.def');
$def($def.S, 'Object', {setPrototypeOf: require('./$.set-proto').set});
},{"./$.def":107,"./$.set-proto":138}],162:[function(require,module,exports){

},{}],163:[function(require,module,exports){
'use strict';
var $          = require('./$')
  , LIBRARY    = require('./$.library')
  , global     = require('./$.global')
  , ctx        = require('./$.ctx')
  , classof    = require('./$.classof')
  , $def       = require('./$.def')
  , isObject   = require('./$.is-object')
  , anObject   = require('./$.an-object')
  , aFunction  = require('./$.a-function')
  , strictNew  = require('./$.strict-new')
  , forOf      = require('./$.for-of')
  , setProto   = require('./$.set-proto').set
  , same       = require('./$.same')
  , species    = require('./$.species')
  , SPECIES    = require('./$.wks')('species')
  , speciesConstructor = require('./$.species-constructor')
  , RECORD     = require('./$.uid')('record')
  , asap       = require('./$.microtask')
  , PROMISE    = 'Promise'
  , process    = global.process
  , isNode     = classof(process) == 'process'
  , P          = global[PROMISE]
  , Wrapper;

var testResolve = function(sub){
  var test = new P(function(){});
  if(sub)test.constructor = Object;
  return P.resolve(test) === test;
};

var useNative = function(){
  var works = false;
  function P2(x){
    var self = new P(x);
    setProto(self, P2.prototype);
    return self;
  }
  try {
    works = P && P.resolve && testResolve();
    setProto(P2, P);
    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
    // actual Firefox has broken subclass support, test that
    if(!(P2.resolve(5).then(function(){}) instanceof P2)){
      works = false;
    }
    // actual V8 bug, https://code.google.com/p/v8/issues/detail?id=4162
    if(works && require('./$.support-desc')){
      var thenableThenGotten = false;
      P.resolve($.setDesc({}, 'then', {
        get: function(){ thenableThenGotten = true; }
      }));
      works = thenableThenGotten;
    }
  } catch(e){ works = false; }
  return works;
}();

// helpers
var isPromise = function(it){
  return isObject(it) && (useNative ? classof(it) == 'Promise' : RECORD in it);
};
var sameConstructor = function(a, b){
  // library wrapper special case
  if(LIBRARY && a === P && b === Wrapper)return true;
  return same(a, b);
};
var getConstructor = function(C){
  var S = anObject(C)[SPECIES];
  return S != undefined ? S : C;
};
var isThenable = function(it){
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function(record, isReject){
  if(record.n)return;
  record.n = true;
  var chain = record.c;
  asap(function(){
    var value = record.v
      , ok    = record.s == 1
      , i     = 0;
    var run = function(react){
      var cb = ok ? react.ok : react.fail
        , ret, then;
      try {
        if(cb){
          if(!ok)record.h = true;
          ret = cb === true ? value : cb(value);
          if(ret === react.P){
            react.rej(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(ret)){
            then.call(ret, react.res, react.rej);
          } else react.res(ret);
        } else react.rej(value);
      } catch(err){
        react.rej(err);
      }
    };
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    chain.length = 0;
    record.n = false;
    if(isReject)setTimeout(function(){
      var promise = record.p
        , handler, console;
      if(isUnhandled(promise)){
        if(isNode){
          process.emit('unhandledRejection', value, promise);
        } else if(handler = global.onunhandledrejection){
          handler({promise: promise, reason: value});
        } else if((console = global.console) && console.error){
          console.error('Unhandled promise rejection', value);
        }
      } record.a = undefined;
    }, 1);
  });
};
var isUnhandled = function(promise){
  var record = promise[RECORD]
    , chain  = record.a || record.c
    , i      = 0
    , react;
  if(record.h)return false;
  while(chain.length > i){
    react = chain[i++];
    if(react.fail || !isUnhandled(react.P))return false;
  } return true;
};
var $reject = function(value){
  var record = this;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  record.v = value;
  record.s = 2;
  record.a = record.c.slice();
  notify(record, true);
};
var $resolve = function(value){
  var record = this
    , then;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  try {
    if(then = isThenable(value)){
      asap(function(){
        var wrapper = {r: record, d: false}; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch(e){
          $reject.call(wrapper, e);
        }
      });
    } else {
      record.v = value;
      record.s = 1;
      notify(record, false);
    }
  } catch(e){
    $reject.call({r: record, d: false}, e); // wrap
  }
};

// constructor polyfill
if(!useNative){
  // 25.4.3.1 Promise(executor)
  P = function Promise(executor){
    aFunction(executor);
    var record = {
      p: strictNew(this, P, PROMISE),         // <- promise
      c: [],                                  // <- awaiting reactions
      a: undefined,                           // <- checked in isUnhandled reactions
      s: 0,                                   // <- state
      d: false,                               // <- done
      v: undefined,                           // <- value
      h: false,                               // <- handled rejection
      n: false                                // <- notify
    };
    this[RECORD] = record;
    try {
      executor(ctx($resolve, record, 1), ctx($reject, record, 1));
    } catch(err){
      $reject.call(record, err);
    }
  };
  require('./$.mix')(P.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var react = {
        ok:   typeof onFulfilled == 'function' ? onFulfilled : true,
        fail: typeof onRejected == 'function'  ? onRejected  : false
      };
      var promise = react.P = new (speciesConstructor(this, P))(function(res, rej){
        react.res = res;
        react.rej = rej;
      });
      aFunction(react.res);
      aFunction(react.rej);
      var record = this[RECORD];
      record.c.push(react);
      if(record.a)record.a.push(react);
      if(record.s)notify(record, false);
      return promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
}

// export
$def($def.G + $def.W + $def.F * !useNative, {Promise: P});
require('./$.tag')(P, PROMISE);
species(P);
species(Wrapper = require('./$.core')[PROMISE]);

// statics
$def($def.S + $def.F * !useNative, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    return new this(function(res, rej){ rej(r); });
  }
});
$def($def.S + $def.F * (!useNative || testResolve(true)), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    return isPromise(x) && sameConstructor(x.constructor, this)
      ? x : new this(function(res){ res(x); });
  }
});
$def($def.S + $def.F * !(useNative && require('./$.iter-detect')(function(iter){
  P.all(iter)['catch'](function(){});
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C      = getConstructor(this)
      , values = [];
    return new C(function(res, rej){
      forOf(iterable, false, values.push, values);
      var remaining = values.length
        , results   = Array(remaining);
      if(remaining)$.each.call(values, function(promise, index){
        C.resolve(promise).then(function(value){
          results[index] = value;
          --remaining || res(results);
        }, rej);
      });
      else res(results);
    });
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C = getConstructor(this);
    return new C(function(res, rej){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(res, rej);
      });
    });
  }
});
},{"./$":129,"./$.a-function":97,"./$.an-object":98,"./$.classof":100,"./$.core":105,"./$.ctx":106,"./$.def":107,"./$.for-of":112,"./$.global":114,"./$.is-object":122,"./$.iter-detect":126,"./$.library":131,"./$.microtask":132,"./$.mix":133,"./$.same":137,"./$.set-proto":138,"./$.species":141,"./$.species-constructor":140,"./$.strict-new":142,"./$.support-desc":144,"./$.tag":145,"./$.uid":151,"./$.wks":153}],164:[function(require,module,exports){
'use strict';
var strong = require('./$.collection-strong');

// 23.2 Set Objects
require('./$.collection')('Set', function(get){
  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);
},{"./$.collection":104,"./$.collection-strong":102}],165:[function(require,module,exports){
'use strict';
var $at  = require('./$.string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./$.iter-define')(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});
},{"./$.iter-define":125,"./$.string-at":143}],166:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var $              = require('./$')
  , global         = require('./$.global')
  , has            = require('./$.has')
  , SUPPORT_DESC   = require('./$.support-desc')
  , $def           = require('./$.def')
  , $redef         = require('./$.redef')
  , $fails         = require('./$.fails')
  , shared         = require('./$.shared')
  , setTag         = require('./$.tag')
  , uid            = require('./$.uid')
  , wks            = require('./$.wks')
  , keyOf          = require('./$.keyof')
  , $names         = require('./$.get-names')
  , enumKeys       = require('./$.enum-keys')
  , isArray        = require('./$.is-array')
  , anObject       = require('./$.an-object')
  , toIObject      = require('./$.to-iobject')
  , createDesc     = require('./$.property-desc')
  , getDesc        = $.getDesc
  , setDesc        = $.setDesc
  , _create        = $.create
  , getNames       = $names.get
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , setter         = false
  , HIDDEN         = wks('_hidden')
  , isEnum         = $.isEnum
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , useNative      = typeof $Symbol == 'function'
  , ObjectProto    = Object.prototype;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = SUPPORT_DESC && $fails(function(){
  return _create(setDesc({}, 'a', {
    get: function(){ return setDesc(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = getDesc(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  setDesc(it, key, D);
  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
} : setDesc;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol.prototype);
  sym._k = tag;
  SUPPORT_DESC && setter && setSymbolDesc(ObjectProto, tag, {
    configurable: true,
    set: function(value){
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    }
  });
  return sym;
};

var isSymbol = function(it){
  return typeof it == 'symbol';
};

var $defineProperty = function defineProperty(it, key, D){
  if(D && has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return setDesc(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key);
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
    ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  var D = getDesc(it = toIObject(it), key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = getNames(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
  return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var names  = getNames(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
  return result;
};
var $stringify = function stringify(it){
  var args = [it]
    , i    = 1
    , $$   = arguments
    , replacer, $replacer;
  while($$.length > i)args.push($$[i++]);
  replacer = args[1];
  if(typeof replacer == 'function')$replacer = replacer;
  if($replacer || !isArray(replacer))replacer = function(key, value){
    if($replacer)value = $replacer.call(this, key, value);
    if(!isSymbol(value))return value;
  };
  args[1] = replacer;
  return _stringify.apply($JSON, args);
};
var buggyJSON = $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
});

// 19.4.1.1 Symbol([description])
if(!useNative){
  $Symbol = function Symbol(){
    if(isSymbol(this))throw TypeError('Symbol is not a constructor');
    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
  };
  $redef($Symbol.prototype, 'toString', function toString(){
    return this._k;
  });

  isSymbol = function(it){
    return it instanceof $Symbol;
  };

  $.create     = $create;
  $.isEnum     = $propertyIsEnumerable;
  $.getDesc    = $getOwnPropertyDescriptor;
  $.setDesc    = $defineProperty;
  $.setDescs   = $defineProperties;
  $.getNames   = $names.get = $getOwnPropertyNames;
  $.getSymbols = $getOwnPropertySymbols;

  if(SUPPORT_DESC && !require('./$.library')){
    $redef(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }
}

var symbolStatics = {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    return keyOf(SymbolRegistry, key);
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
};
// 19.4.2.2 Symbol.hasInstance
// 19.4.2.3 Symbol.isConcatSpreadable
// 19.4.2.4 Symbol.iterator
// 19.4.2.6 Symbol.match
// 19.4.2.8 Symbol.replace
// 19.4.2.9 Symbol.search
// 19.4.2.10 Symbol.species
// 19.4.2.11 Symbol.split
// 19.4.2.12 Symbol.toPrimitive
// 19.4.2.13 Symbol.toStringTag
// 19.4.2.14 Symbol.unscopables
$.each.call((
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
  'species,split,toPrimitive,toStringTag,unscopables'
).split(','), function(it){
  var sym = wks(it);
  symbolStatics[it] = useNative ? sym : wrap(sym);
});

setter = true;

$def($def.G + $def.W, {Symbol: $Symbol});

$def($def.S, 'Symbol', symbolStatics);

$def($def.S + $def.F * !useNative, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $def($def.S + $def.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});

// 19.4.3.5 Symbol.prototype[@@toStringTag]
setTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setTag(global.JSON, 'JSON', true);
},{"./$":129,"./$.an-object":98,"./$.def":107,"./$.enum-keys":110,"./$.fails":111,"./$.get-names":113,"./$.global":114,"./$.has":115,"./$.is-array":121,"./$.keyof":130,"./$.library":131,"./$.property-desc":135,"./$.redef":136,"./$.shared":139,"./$.support-desc":144,"./$.tag":145,"./$.to-iobject":148,"./$.uid":151,"./$.wks":153}],167:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $def  = require('./$.def');

$def($def.P, 'Map', {toJSON: require('./$.collection-to-json')('Map')});
},{"./$.collection-to-json":103,"./$.def":107}],168:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $def  = require('./$.def');

$def($def.P, 'Set', {toJSON: require('./$.collection-to-json')('Set')});
},{"./$.collection-to-json":103,"./$.def":107}],169:[function(require,module,exports){
require('./es6.array.iterator');
var Iterators = require('./$.iterators');
Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
},{"./$.iterators":128,"./es6.array.iterator":156}],170:[function(require,module,exports){
(function (global){
// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g =
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this;

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = require("./runtime");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

module.exports = { "default": module.exports, __esModule: true };

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./runtime":171}],171:[function(require,module,exports){
(function (process,global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

"use strict";

var _Symbol = require("babel-runtime/core-js/symbol")["default"];

var _Symbol$iterator = require("babel-runtime/core-js/symbol/iterator")["default"];

var _Object$create = require("babel-runtime/core-js/object/create")["default"];

var _Promise = require("babel-runtime/core-js/promise")["default"];

!(function (global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var iteratorSymbol = typeof _Symbol === "function" && _Symbol$iterator || "@@iterator";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided, then outerFn.prototype instanceof Generator.
    var generator = _Object$create((outerFn || Generator).prototype);

    generator._invoke = makeInvokeMethod(innerFn, self || null, new Context(tryLocsList || []));

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction ||
    // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    genFun.__proto__ = GeneratorFunctionPrototype;
    genFun.prototype = _Object$create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `value instanceof AwaitArgument` to determine if the yielded value is
  // meant to be awaited. Some may consider the name of this method too
  // cutesy, but they are curmudgeons.
  runtime.awrap = function (arg) {
    return new AwaitArgument(arg);
  };

  function AwaitArgument(arg) {
    this.arg = arg;
  }

  function AsyncIterator(generator) {
    // This invoke function is written in a style that assumes some
    // calling function (or Promise) will handle exceptions.
    function invoke(method, arg) {
      var result = generator[method](arg);
      var value = result.value;
      return value instanceof AwaitArgument ? _Promise.resolve(value.arg).then(invokeNext, invokeThrow) : _Promise.resolve(value).then(function (unwrapped) {
        // When a yielded Promise is resolved, its final value becomes
        // the .value of the Promise<{value,done}> result for the
        // current iteration. If the Promise is rejected, however, the
        // result for this iteration will be rejected with the same
        // reason. Note that rejections of yielded Promises are not
        // thrown back into the generator function, as is the case
        // when an awaited Promise is rejected. This difference in
        // behavior between yield and await is important, because it
        // allows the consumer to decide what to do with the yielded
        // rejection (swallow it and continue, manually .throw it back
        // into the generator, abandon iteration, whatever). With
        // await, by contrast, there is no opportunity to examine the
        // rejection reason outside the generator function, so the
        // only option is to throw it from the await expression, and
        // let the generator function handle the exception.
        result.value = unwrapped;
        return result;
      });
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var invokeNext = invoke.bind(generator, "next");
    var invokeThrow = invoke.bind(generator, "throw");
    var invokeReturn = invoke.bind(generator, "return");
    var previousPromise;

    function enqueue(method, arg) {
      var enqueueResult =
      // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(function () {
        return invoke(method, arg);
      }) : new _Promise(function (resolve) {
        resolve(invoke(method, arg));
      });

      // Avoid propagating enqueueResult failures to Promises returned by
      // later invocations of the iterator.
      previousPromise = enqueueResult["catch"](function (ignored) {});

      return enqueueResult;
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          if (method === "return" || method === "throw" && delegate.iterator[method] === undefined) {
            // A return or throw (when the delegate iterator has no throw
            // method) always terminates the yield* loop.
            context.delegate = null;

            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            var returnMethod = delegate.iterator["return"];
            if (returnMethod) {
              var record = tryCatch(returnMethod, delegate.iterator, arg);
              if (record.type === "throw") {
                // If the return method threw an exception, let that
                // exception prevail over the original return or throw.
                method = "throw";
                arg = record.arg;
                continue;
              }
            }

            if (method === "return") {
              // Continue with the outer return, now that the delegate
              // iterator has been terminated.
              continue;
            }
          }

          var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;
            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            context.sent = undefined;
          }
        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }
        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }
        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(arg) call above.
          method = "throw";
          arg = record.arg;
        }
      }
    };
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      this.sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function stop() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }
    },

    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
// Among the various tricks for obtaining a reference to the global
// object, this seems to be the most reliable technique that does not
// use indirect eval (which violates Content Security Policy).
typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : undefined);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":175,"babel-runtime/core-js/object/create":71,"babel-runtime/core-js/promise":76,"babel-runtime/core-js/symbol":78,"babel-runtime/core-js/symbol/iterator":79}],172:[function(require,module,exports){

/*
 * Konva JavaScript Framework v0.11.1
 * http://konvajs.github.io/
 * Licensed under the MIT or GPL Version 2 licenses.
 * Date: Sat Jan 16 2016
 *
 * Original work Copyright (C) 2011 - 2013 by Eric Rowell (KineticJS)
 * Modified work Copyright (C) 2014 - 2015 by Anton Lavrenov (Konva)
 *
 * @license
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

// runtime check for already included Konva
(function(){
    'use strict';
    /**
     * @namespace Konva
     */

    var PI_OVER_180 = Math.PI / 180;

    var Konva = {
        // public
        version: '0.11.1',

        // private
        stages: [],
        idCounter: 0,
        ids: {},
        names: {},
        shapes: {},
        listenClickTap: false,
        inDblClickWindow: false,

        // configurations
        enableTrace: false,
        traceArrMax: 100,
        dblClickWindow: 400,
        /**
         * Global pixel ratio configuration. KonvaJS automatically detect pixel ratio of current device.
         * But you may override such property, if you want to use your value.
         * @property pixelRatio
         * @default undefined
         * @memberof Konva
         * @example
         * Konva.pixelRatio = 1;
         */
        pixelRatio: undefined,
        /**
         * Drag distance property. If you start to drag a node you may want to wait until pointer is moved to some distance from start point,
         * only then start dragging.
         * @property dragDistance
         * @default 0
         * @memberof Konva
         * @example
         * Konva.dragDistance = 10;
         */
        dragDistance: 0,
        /**
         * Use degree values for angle properties. You may set this property to false if you want to use radiant values.
         * @property angleDeg
         * @default true
         * @memberof Konva
         * @example
         * node.rotation(45); // 45 degrees
         * Konva.angleDeg = false;
         * node.rotation(Math.PI / 2); // PI/2 radian
         */
        angleDeg: true,
         /**
         * Show different warnings about errors or wrong API usage
         * @property showWarnings
         * @default true
         * @memberof Konva
         * @example
         * Konva.showWarnings = false;
         */
        showWarnings: true,



        /**
         * @namespace Filters
         * @memberof Konva
         */
        Filters: {},

        /**
         * returns whether or not drag and drop is currently active
         * @method
         * @memberof Konva
         */
        isDragging: function() {
            var dd = Konva.DD;

            // if DD is not included with the build, then
            // drag and drop is not even possible
            if (dd) {
                return dd.isDragging;
            }
            return false;
        },
        /**
        * returns whether or not a drag and drop operation is ready, but may
        *  not necessarily have started
        * @method
        * @memberof Konva
        */
        isDragReady: function() {
            var dd = Konva.DD;

            // if DD is not included with the build, then
            // drag and drop is not even possible
            if (dd) {
                return !!dd.node;
            }
            return false;
        },
        _addId: function(node, id) {
            if(id !== undefined) {
                this.ids[id] = node;
            }
        },
        _removeId: function(id) {
            if(id !== undefined) {
                delete this.ids[id];
            }
        },
        _addName: function(node, name) {
            if(name) {
                if(!this.names[name]) {
                    this.names[name] = [];
                }
                this.names[name].push(node);
            }
        },
        _removeName: function(name, _id) {
            if(!name) {
                return;
            }
            var nodes = this.names[name];
            if(!nodes) {
                return;
            }
            for(var n = 0; n < nodes.length; n++) {
                var no = nodes[n];
                if(no._id === _id) {
                    nodes.splice(n, 1);
                }
            }
            if(nodes.length === 0) {
                delete this.names[name];
            }
        },
        getAngle: function(angle) {
            return this.angleDeg ? angle * PI_OVER_180 : angle;
        },
        _parseUA: function(userAgent) {
            var ua = userAgent.toLowerCase(),
                // jQuery UA regex
                match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
                /(webkit)[ \/]([\w.]+)/.exec( ua ) ||
                /(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
                /(msie) ([\w.]+)/.exec( ua ) ||
                ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
                [],

                // adding mobile flag as well
                mobile = !!(userAgent.match(/Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile/i)),
                ieMobile = !!(userAgent.match(/IEMobile/i));

            return {
                browser: match[ 1 ] || '',
                version: match[ 2 ] || '0',

                // adding mobile flab
                mobile: mobile,
                ieMobile: ieMobile  // If this is true (i.e., WP8), then Konva touch events are executed instead of equivalent Konva mouse events
            };
        },
        // user agent
        UA: undefined
    };

    var global =
        typeof window !== 'undefined' ? window :
        typeof global !== 'undefined' ? global :
        typeof WorkerGlobalScope !== 'undefined' ? self : {};


    Konva.UA = Konva._parseUA((global.navigator && global.navigator.userAgent) || '');

    if (global.Konva) {
        console.error(
            'Konva instance is already exist in current eviroment. ' +
            'Please use only one instance.'
        );
    }
    global.Konva = Konva;
    Konva.global = global;


    if( typeof exports === 'object') {
        // runtime-check for browserify and nw.js (node-webkit)
        if(global.window && global.window.document) {
            Konva.document = global.window.document;
            Konva.window = global.window;
        } else {
            // Node. Does not work with strict CommonJS, but
            // only CommonJS-like enviroments that support module.exports,
            // like Node.
            var Canvas = require('canvas');
            var jsdom = require('jsdom').jsdom;

            Konva.document = jsdom('<!DOCTYPE html><html><head></head><body></body></html>');
            Konva.window = Konva.document.parentWindow;
            Konva.window.Image = Canvas.Image;
            Konva._nodeCanvas = Canvas;
        }
        module.exports = Konva;
        return;
    }
    else if( typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(function() {
            return Konva;
        });
    }
    Konva.document = document;
    Konva.window = window;
})();

/*eslint-disable  eqeqeq, no-cond-assign, no-empty*/
(function() {
    'use strict';
    /**
     * Collection constructor.  Collection extends
     *  Array.  This class is used in conjunction with {@link Konva.Container#get}
     * @constructor
     * @memberof Konva
     */
    Konva.Collection = function() {
        var args = [].slice.call(arguments), length = args.length, i = 0;

        this.length = length;
        for(; i < length; i++) {
            this[i] = args[i];
        }
        return this;
    };
    Konva.Collection.prototype = [];
    /**
     * iterate through node array and run a function for each node.
     *  The node and index is passed into the function
     * @method
     * @memberof Konva.Collection.prototype
     * @param {Function} func
     * @example
     * // get all nodes with name foo inside layer, and set x to 10 for each
     * layer.get('.foo').each(function(shape, n) {
     *   shape.setX(10);
     * });
     */
    Konva.Collection.prototype.each = function(func) {
        for(var n = 0; n < this.length; n++) {
            func(this[n], n);
        }
    };
    /**
     * convert collection into an array
     * @method
     * @memberof Konva.Collection.prototype
     */
    Konva.Collection.prototype.toArray = function() {
        var arr = [],
            len = this.length,
            n;

        for(n = 0; n < len; n++) {
            arr.push(this[n]);
        }
        return arr;
    };
    /**
     * convert array into a collection
     * @method
     * @memberof Konva.Collection
     * @param {Array} arr
     */
    Konva.Collection.toCollection = function(arr) {
        var collection = new Konva.Collection(),
            len = arr.length,
            n;

        for(n = 0; n < len; n++) {
            collection.push(arr[n]);
        }
        return collection;
    };

    // map one method by it's name
    Konva.Collection._mapMethod = function(methodName) {
        Konva.Collection.prototype[methodName] = function() {
            var len = this.length,
                i;

            var args = [].slice.call(arguments);
            for(i = 0; i < len; i++) {
                this[i][methodName].apply(this[i], args);
            }

            return this;
        };
    };

    Konva.Collection.mapMethods = function(constructor) {
        var prot = constructor.prototype;
        for(var methodName in prot) {
            Konva.Collection._mapMethod(methodName);
        }
    };

    /*
    * Last updated November 2011
    * By Simon Sarris
    * www.simonsarris.com
    * sarris@acm.org
    *
    * Free to use and distribute at will
    * So long as you are nice to people, etc
    */

    /*
    * The usage of this class was inspired by some of the work done by a forked
    * project, KineticJS-Ext by Wappworks, which is based on Simon's Transform
    * class.  Modified by Eric Rowell
    */

    /**
     * Transform constructor
     * @constructor
     * @param {Array} [m] Optional six-element matrix
     * @memberof Konva
     */
    Konva.Transform = function(m) {
        this.m = (m && m.slice()) || [1, 0, 0, 1, 0, 0];
    };

    Konva.Transform.prototype = {
        /**
         * Copy Konva.Transform object
         * @method
         * @memberof Konva.Transform.prototype
         * @returns {Konva.Transform}
         */
        copy: function() {
            return new Konva.Transform(this.m);
        },
        /**
         * Transform point
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Object} point 2D point(x, y)
         * @returns {Object} 2D point(x, y)
         */
        point: function(point) {
            var m = this.m;
            return {
                x: m[0] * point.x + m[2] * point.y + m[4],
                y: m[1] * point.x + m[3] * point.y + m[5]
            };
        },
        /**
         * Apply translation
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Number} x
         * @param {Number} y
         * @returns {Konva.Transform}
         */
        translate: function(x, y) {
            this.m[4] += this.m[0] * x + this.m[2] * y;
            this.m[5] += this.m[1] * x + this.m[3] * y;
            return this;
        },
        /**
         * Apply scale
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Number} sx
         * @param {Number} sy
         * @returns {Konva.Transform}
         */
        scale: function(sx, sy) {
            this.m[0] *= sx;
            this.m[1] *= sx;
            this.m[2] *= sy;
            this.m[3] *= sy;
            return this;
        },
        /**
         * Apply rotation
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Number} rad  Angle in radians
         * @returns {Konva.Transform}
         */
        rotate: function(rad) {
            var c = Math.cos(rad);
            var s = Math.sin(rad);
            var m11 = this.m[0] * c + this.m[2] * s;
            var m12 = this.m[1] * c + this.m[3] * s;
            var m21 = this.m[0] * -s + this.m[2] * c;
            var m22 = this.m[1] * -s + this.m[3] * c;
            this.m[0] = m11;
            this.m[1] = m12;
            this.m[2] = m21;
            this.m[3] = m22;
            return this;
        },
        /**
         * Returns the translation
         * @method
         * @memberof Konva.Transform.prototype
         * @returns {Object} 2D point(x, y)
         */
        getTranslation: function() {
            return {
                x: this.m[4],
                y: this.m[5]
            };
        },
        /**
         * Apply skew
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Number} sx
         * @param {Number} sy
         * @returns {Konva.Transform}
         */
        skew: function(sx, sy) {
            var m11 = this.m[0] + this.m[2] * sy;
            var m12 = this.m[1] + this.m[3] * sy;
            var m21 = this.m[2] + this.m[0] * sx;
            var m22 = this.m[3] + this.m[1] * sx;
            this.m[0] = m11;
            this.m[1] = m12;
            this.m[2] = m21;
            this.m[3] = m22;
            return this;
         },
        /**
         * Transform multiplication
         * @method
         * @memberof Konva.Transform.prototype
         * @param {Konva.Transform} matrix
         * @returns {Konva.Transform}
         */
        multiply: function(matrix) {
            var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
            var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];

            var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
            var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];

            var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
            var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];

            this.m[0] = m11;
            this.m[1] = m12;
            this.m[2] = m21;
            this.m[3] = m22;
            this.m[4] = dx;
            this.m[5] = dy;
            return this;
        },
        /**
         * Invert the matrix
         * @method
         * @memberof Konva.Transform.prototype
         * @returns {Konva.Transform}
         */
        invert: function() {
            var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
            var m0 = this.m[3] * d;
            var m1 = -this.m[1] * d;
            var m2 = -this.m[2] * d;
            var m3 = this.m[0] * d;
            var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
            var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
            this.m[0] = m0;
            this.m[1] = m1;
            this.m[2] = m2;
            this.m[3] = m3;
            this.m[4] = m4;
            this.m[5] = m5;
            return this;
        },
        /**
         * return matrix
         * @method
         * @memberof Konva.Transform.prototype
         */
        getMatrix: function() {
            return this.m;
        },
        /**
         * set to absolute position via translation
         * @method
         * @memberof Konva.Transform.prototype
         * @returns {Konva.Transform}
         * @author ericdrowell
         */
        setAbsolutePosition: function(x, y) {
            var m0 = this.m[0],
                m1 = this.m[1],
                m2 = this.m[2],
                m3 = this.m[3],
                m4 = this.m[4],
                m5 = this.m[5],
                yt = ((m0 * (y - m5)) - (m1 * (x - m4))) / ((m0 * m3) - (m1 * m2)),
                xt = (x - m4 - (m2 * yt)) / m0;

            return this.translate(xt, yt);
        }
    };

    // CONSTANTS
    var CONTEXT_2D = '2d',
        OBJECT_ARRAY = '[object Array]',
        OBJECT_NUMBER = '[object Number]',
        OBJECT_STRING = '[object String]',
        PI_OVER_DEG180 = Math.PI / 180,
        DEG180_OVER_PI = 180 / Math.PI,
        HASH = '#',
        EMPTY_STRING = '',
        ZERO = '0',
        KONVA_WARNING = 'Konva warning: ',
        KONVA_ERROR = 'Konva error: ',
        RGB_PAREN = 'rgb(',
        COLORS = {
            aliceblue: [240, 248, 255],
            antiquewhite: [250, 235, 215],
            aqua: [0, 255, 255],
            aquamarine: [127, 255, 212],
            azure: [240, 255, 255],
            beige: [245, 245, 220],
            bisque: [255, 228, 196],
            black: [0, 0, 0],
            blanchedalmond: [255, 235, 205],
            blue: [0, 0, 255],
            blueviolet: [138, 43, 226],
            brown: [165, 42, 42],
            burlywood: [222, 184, 135],
            cadetblue: [95, 158, 160],
            chartreuse: [127, 255, 0],
            chocolate: [210, 105, 30],
            coral: [255, 127, 80],
            cornflowerblue: [100, 149, 237],
            cornsilk: [255, 248, 220],
            crimson: [220, 20, 60],
            cyan: [0, 255, 255],
            darkblue: [0, 0, 139],
            darkcyan: [0, 139, 139],
            darkgoldenrod: [184, 132, 11],
            darkgray: [169, 169, 169],
            darkgreen: [0, 100, 0],
            darkgrey: [169, 169, 169],
            darkkhaki: [189, 183, 107],
            darkmagenta: [139, 0, 139],
            darkolivegreen: [85, 107, 47],
            darkorange: [255, 140, 0],
            darkorchid: [153, 50, 204],
            darkred: [139, 0, 0],
            darksalmon: [233, 150, 122],
            darkseagreen: [143, 188, 143],
            darkslateblue: [72, 61, 139],
            darkslategray: [47, 79, 79],
            darkslategrey: [47, 79, 79],
            darkturquoise: [0, 206, 209],
            darkviolet: [148, 0, 211],
            deeppink: [255, 20, 147],
            deepskyblue: [0, 191, 255],
            dimgray: [105, 105, 105],
            dimgrey: [105, 105, 105],
            dodgerblue: [30, 144, 255],
            firebrick: [178, 34, 34],
            floralwhite: [255, 255, 240],
            forestgreen: [34, 139, 34],
            fuchsia: [255, 0, 255],
            gainsboro: [220, 220, 220],
            ghostwhite: [248, 248, 255],
            gold: [255, 215, 0],
            goldenrod: [218, 165, 32],
            gray: [128, 128, 128],
            green: [0, 128, 0],
            greenyellow: [173, 255, 47],
            grey: [128, 128, 128],
            honeydew: [240, 255, 240],
            hotpink: [255, 105, 180],
            indianred: [205, 92, 92],
            indigo: [75, 0, 130],
            ivory: [255, 255, 240],
            khaki: [240, 230, 140],
            lavender: [230, 230, 250],
            lavenderblush: [255, 240, 245],
            lawngreen: [124, 252, 0],
            lemonchiffon: [255, 250, 205],
            lightblue: [173, 216, 230],
            lightcoral: [240, 128, 128],
            lightcyan: [224, 255, 255],
            lightgoldenrodyellow: [250, 250, 210],
            lightgray: [211, 211, 211],
            lightgreen: [144, 238, 144],
            lightgrey: [211, 211, 211],
            lightpink: [255, 182, 193],
            lightsalmon: [255, 160, 122],
            lightseagreen: [32, 178, 170],
            lightskyblue: [135, 206, 250],
            lightslategray: [119, 136, 153],
            lightslategrey: [119, 136, 153],
            lightsteelblue: [176, 196, 222],
            lightyellow: [255, 255, 224],
            lime: [0, 255, 0],
            limegreen: [50, 205, 50],
            linen: [250, 240, 230],
            magenta: [255, 0, 255],
            maroon: [128, 0, 0],
            mediumaquamarine: [102, 205, 170],
            mediumblue: [0, 0, 205],
            mediumorchid: [186, 85, 211],
            mediumpurple: [147, 112, 219],
            mediumseagreen: [60, 179, 113],
            mediumslateblue: [123, 104, 238],
            mediumspringgreen: [0, 250, 154],
            mediumturquoise: [72, 209, 204],
            mediumvioletred: [199, 21, 133],
            midnightblue: [25, 25, 112],
            mintcream: [245, 255, 250],
            mistyrose: [255, 228, 225],
            moccasin: [255, 228, 181],
            navajowhite: [255, 222, 173],
            navy: [0, 0, 128],
            oldlace: [253, 245, 230],
            olive: [128, 128, 0],
            olivedrab: [107, 142, 35],
            orange: [255, 165, 0],
            orangered: [255, 69, 0],
            orchid: [218, 112, 214],
            palegoldenrod: [238, 232, 170],
            palegreen: [152, 251, 152],
            paleturquoise: [175, 238, 238],
            palevioletred: [219, 112, 147],
            papayawhip: [255, 239, 213],
            peachpuff: [255, 218, 185],
            peru: [205, 133, 63],
            pink: [255, 192, 203],
            plum: [221, 160, 203],
            powderblue: [176, 224, 230],
            purple: [128, 0, 128],
            rebeccapurple: [102, 51, 153],
            red: [255, 0, 0],
            rosybrown: [188, 143, 143],
            royalblue: [65, 105, 225],
            saddlebrown: [139, 69, 19],
            salmon: [250, 128, 114],
            sandybrown: [244, 164, 96],
            seagreen: [46, 139, 87],
            seashell: [255, 245, 238],
            sienna: [160, 82, 45],
            silver: [192, 192, 192],
            skyblue: [135, 206, 235],
            slateblue: [106, 90, 205],
            slategray: [119, 128, 144],
            slategrey: [119, 128, 144],
            snow: [255, 255, 250],
            springgreen: [0, 255, 127],
            steelblue: [70, 130, 180],
            tan: [210, 180, 140],
            teal: [0, 128, 128],
            thistle: [216, 191, 216],
            transparent: [255, 255, 255, 0],
            tomato: [255, 99, 71],
            turquoise: [64, 224, 208],
            violet: [238, 130, 238],
            wheat: [245, 222, 179],
            white: [255, 255, 255],
            whitesmoke: [245, 245, 245],
            yellow: [255, 255, 0],
            yellowgreen: [154, 205, 5]
        },

        RGB_REGEX = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/;

    /**
     * @namespace Util
     * @memberof Konva
     */
    Konva.Util = {
        /*
         * cherry-picked utilities from underscore.js
         */
        _isElement: function(obj) {
            return !!(obj && obj.nodeType == 1);
        },
        _isFunction: function(obj) {
            return !!(obj && obj.constructor && obj.call && obj.apply);
        },
        _isObject: function(obj) {
            return (!!obj && obj.constructor === Object);
        },
        _isArray: function(obj) {
            return Object.prototype.toString.call(obj) === OBJECT_ARRAY;
        },
        _isNumber: function(obj) {
            return Object.prototype.toString.call(obj) === OBJECT_NUMBER;
        },
        _isString: function(obj) {
            return Object.prototype.toString.call(obj) === OBJECT_STRING;
        },
        // Returns a function, that, when invoked, will only be triggered at most once
        // during a given window of time. Normally, the throttled function will run
        // as much as it can, without ever going more than once per `wait` duration;
        // but if you'd like to disable the execution on the leading edge, pass
        // `{leading: false}`. To disable execution on the trailing edge, ditto.
        _throttle: function(func, wait, opts) {
            var context, args, result;
            var timeout = null;
            var previous = 0;
            var options = opts || {};
            var later = function() {
                previous = options.leading === false ? 0 : new Date().getTime();
                timeout = null;
                result = func.apply(context, args);
                context = args = null;
            };
            return function() {
                var now = new Date().getTime();
                if (!previous && options.leading === false) {
                    previous = now;
                }
                var remaining = wait - (now - previous);
                context = this;
                args = arguments;
                if (remaining <= 0) {
                  clearTimeout(timeout);
                  timeout = null;
                  previous = now;
                  result = func.apply(context, args);
                  context = args = null;
                } else if (!timeout && options.trailing !== false) {
                  timeout = setTimeout(later, remaining);
                }
                return result;
            };
        },
        /*
         * other utils
         */
        _hasMethods: function(obj) {
            var names = [],
                key;

            for(key in obj) {
                if (!obj.hasOwnProperty(key)) {
                    continue;
                }
                if(this._isFunction(obj[key])) {
                    names.push(key);
                }
            }
            return names.length > 0;
        },
        isValidSelector: function(selector) {
            if (typeof selector !== 'string') {
                return false;
            }
            var firstChar = selector[0];
            return firstChar === '#' || firstChar === '.' || firstChar === firstChar.toUpperCase();
        },
        createCanvasElement: function() {
            var canvas = Konva.document.createElement('canvas');
            // on some environments canvas.style is readonly
            try {
                canvas.style = canvas.style || {};
            } catch (e) {
            }
            return canvas;
        },
        isBrowser: function() {
            return (typeof exports !== 'object');
        },
        _isInDocument: function(el) {
            while(el = el.parentNode) {
                if(el == Konva.document) {
                    return true;
                }
            }
            return false;
        },
        _simplifyArray: function(arr) {
            var retArr = [],
                len = arr.length,
                util = Konva.Util,
                n, val;

            for (n = 0; n < len; n++) {
                val = arr[n];
                if (util._isNumber(val)) {
                    val = Math.round(val * 1000) / 1000;
                }
                else if (!util._isString(val)) {
                    val = val.toString();
                }

                retArr.push(val);
            }

            return retArr;
        },
        /*
         * arg can be an image object or image data
         */
        _getImage: function(arg, callback) {
            var imageObj, canvas;

            // if arg is null or undefined
            if(!arg) {
                callback(null);
            }

            // if arg is already an image object
            else if(this._isElement(arg)) {
                callback(arg);
            }

            // if arg is a string, then it's a data url
            else if(this._isString(arg)) {
                imageObj = new Konva.window.Image();
                imageObj.onload = function() {
                    callback(imageObj);
                };
                imageObj.src = arg;
            }

            //if arg is an object that contains the data property, it's an image object
            else if(arg.data) {
                canvas = Konva.Util.createCanvasElement();
                canvas.width = arg.width;
                canvas.height = arg.height;
                var _context = canvas.getContext(CONTEXT_2D);
                _context.putImageData(arg, 0, 0);
                this._getImage(canvas.toDataURL(), callback);
            }
            else {
                callback(null);
            }
        },
        _getRGBAString: function(obj) {
            var red = obj.red || 0,
                green = obj.green || 0,
                blue = obj.blue || 0,
                alpha = obj.alpha || 1;

            return [
                'rgba(',
                red,
                ',',
                green,
                ',',
                blue,
                ',',
                alpha,
                ')'
            ].join(EMPTY_STRING);
        },
        _rgbToHex: function(r, g, b) {
            return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        },
        _hexToRgb: function(hex) {
            hex = hex.replace(HASH, EMPTY_STRING);
            var bigint = parseInt(hex, 16);
            return {
                r: (bigint >> 16) & 255,
                g: (bigint >> 8) & 255,
                b: bigint & 255
            };
        },
        /**
         * return random hex color
         * @method
         * @memberof Konva.Util.prototype
         */
        getRandomColor: function() {
            var randColor = (Math.random() * 0xFFFFFF << 0).toString(16);
            while (randColor.length < 6) {
                randColor = ZERO + randColor;
            }
            return HASH + randColor;
        },
        /**
         * return value with default fallback
         * @method
         * @memberof Konva.Util.prototype
         */
        get: function(val, def) {
            if (val === undefined) {
                return def;
            }
            else {
                return val;
            }
        },
        /**
         * get RGB components of a color
         * @method
         * @memberof Konva.Util.prototype
         * @param {String} color
         * @example
         * // each of the following examples return {r:0, g:0, b:255}
         * var rgb = Konva.Util.getRGB('blue');
         * var rgb = Konva.Util.getRGB('#0000ff');
         * var rgb = Konva.Util.getRGB('rgb(0,0,255)');
         */
        getRGB: function(color) {
            var rgb;
            // color string
            if (color in COLORS) {
                rgb = COLORS[color];
                return {
                    r: rgb[0],
                    g: rgb[1],
                    b: rgb[2]
                };
            }
            // hex
            else if (color[0] === HASH) {
                return this._hexToRgb(color.substring(1));
            }
            // rgb string
            else if (color.substr(0, 4) === RGB_PAREN) {
                rgb = RGB_REGEX.exec(color.replace(/ /g, ''));
                return {
                    r: parseInt(rgb[1], 10),
                    g: parseInt(rgb[2], 10),
                    b: parseInt(rgb[3], 10)
                };
            }
            // default
            else {
                return {
                    r: 0,
                    g: 0,
                    b: 0
                };
            }
        },
        // convert any color string to RGBA object
        // from https://github.com/component/color-parser
        colorToRGBA: function(str) {
            str = str || 'black';
            return Konva.Util._namedColorToRBA(str)
                || Konva.Util._hex3ColorToRGBA(str)
                || Konva.Util._hex6ColorToRGBA(str)
                || Konva.Util._rgbColorToRGBA(str)
                || Konva.Util._rgbaColorToRGBA(str);
        },
        // Parse named css color. Like "green"
        _namedColorToRBA: function(str) {
            var c = COLORS[str.toLowerCase()];
            if (!c) {
                return null;
            }
            return {
                r: c[0],
                g: c[1],
                b: c[2],
                a: 1
            };
        },
        // Parse rgb(n, n, n)
        _rgbColorToRGBA: function(str) {
            if (str.indexOf('rgb(') === 0) {
                str = str.match(/rgb\(([^)]+)\)/)[1];
                var parts = str.split(/ *, */).map(Number);
                return {
                    r: parts[0],
                    g: parts[1],
                    b: parts[2],
                    a: 1
                };
            }
        },
        // Parse rgba(n, n, n, n)
        _rgbaColorToRGBA: function(str) {
            if (str.indexOf('rgba(') === 0) {
                str = str.match(/rgba\(([^)]+)\)/)[1];
                var parts = str.split(/ *, */).map(Number);
                return {
                    r: parts[0],
                    g: parts[1],
                    b: parts[2],
                    a: parts[3]
                };
            }

        },
        // Parse #nnnnnn
        _hex6ColorToRGBA: function(str) {
            if ((str[0] === '#') && (str.length === 7)) {
                return {
                    r: parseInt(str.slice(1, 3), 16),
                    g: parseInt(str.slice(3, 5), 16),
                    b: parseInt(str.slice(5, 7), 16),
                    a: 1
                };
            }
        },
        // Parse #nnn
        _hex3ColorToRGBA: function(str) {
            if ((str[0] === '#') && (str.length === 4)) {
                return {
                    r: parseInt(str[1] + str[1], 16),
                    g: parseInt(str[2] + str[2], 16),
                    b: parseInt(str[3] + str[3], 16),
                    a: 1
                };
            }
        },
        // o1 takes precedence over o2
        _merge: function(o1, o2) {
            var retObj = this._clone(o2);
            for(var key in o1) {
                if(this._isObject(o1[key])) {
                    retObj[key] = this._merge(o1[key], retObj[key]);
                }
                else {
                    retObj[key] = o1[key];
                }
            }
            return retObj;
        },
        cloneObject: function(obj) {
            var retObj = {};
            for(var key in obj) {
                if(this._isObject(obj[key])) {
                    retObj[key] = this.cloneObject(obj[key]);
                }
                else if (this._isArray(obj[key])) {
                    retObj[key] = this.cloneArray(obj[key]);
                } else {
                    retObj[key] = obj[key];
                }
            }
            return retObj;
        },
        cloneArray: function(arr) {
            return arr.slice(0);
        },
        _degToRad: function(deg) {
            return deg * PI_OVER_DEG180;
        },
        _radToDeg: function(rad) {
            return rad * DEG180_OVER_PI;
        },
        _capitalize: function(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        },
        throw: function(str) {
            throw new Error(KONVA_ERROR + str);
        },
        error: function(str) {
          console.error(KONVA_ERROR + str);
        },
        warn: function(str) {
            /*
             * IE9 on Windows7 64bit will throw a JS error
             * if we don't use window.console in the conditional
             */
            if(Konva.global.console && console.warn && Konva.showWarnings) {
                console.warn(KONVA_WARNING + str);
            }
        },
        extend: function(child, parent) {
            function Ctor() {
                this.constructor = child;
            }
            Ctor.prototype = parent.prototype;
            var oldProto = child.prototype;
            child.prototype = new Ctor();
            for (var key in oldProto) {
                if (oldProto.hasOwnProperty(key)) {
                    child.prototype[key] = oldProto[key];
                }
            }
            child.__super__ = parent.prototype;
            // create reference to parent
            child.super = parent;
        },
        /**
         * adds methods to a constructor prototype
         * @method
         * @memberof Konva.Util.prototype
         * @param {Function} constructor
         * @param {Object} methods
         */
        addMethods: function(constructor, methods) {
            var key;

            for (key in methods) {
                constructor.prototype[key] = methods[key];
            }
        },
        _getControlPoints: function(x0, y0, x1, y1, x2, y2, t) {
            var d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)),
                d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)),
                fa = t * d01 / (d01 + d12),
                fb = t * d12 / (d01 + d12),
                p1x = x1 - fa * (x2 - x0),
                p1y = y1 - fa * (y2 - y0),
                p2x = x1 + fb * (x2 - x0),
                p2y = y1 + fb * (y2 - y0);

            return [p1x, p1y, p2x, p2y];
        },
        _expandPoints: function(p, tension) {
            var len = p.length,
                allPoints = [],
                n, cp;

            for (n = 2; n < len - 2; n += 2) {
                cp = Konva.Util._getControlPoints(p[n - 2], p[n - 1], p[n], p[n + 1], p[n + 2], p[n + 3], tension);
                allPoints.push(cp[0]);
                allPoints.push(cp[1]);
                allPoints.push(p[n]);
                allPoints.push(p[n + 1]);
                allPoints.push(cp[2]);
                allPoints.push(cp[3]);
            }

            return allPoints;
        },
        _removeLastLetter: function(str) {
            return str.substring(0, str.length - 1);
        },
        each: function(obj, func) {
            for (var key in obj) {
                func(key, obj[key]);
            }
        },
        _getProjectionToSegment: function(x1, y1, x2, y2, x3, y3) {
            var x, y, dist;

            var pd2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
            if(pd2 == 0) {
                x = x1;
                y = y1;
                dist = (x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2);
            } else {
                var u = ((x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1)) / pd2;
                if(u < 0) {
                    x = x1;
                    y = y1;
                    dist = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3);
                } else if (u > 1.0) {
                    x = x2;
                    y = y2;
                    dist = (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3);
                } else {
                    x = x1 + u * (x2 - x1);
                    y = y1 + u * (y2 - y1);
                    dist = (x - x3) * (x - x3) + (y - y3) * (y - y3);
                }
            }
            return [x, y, dist];
        },
        // line as array of points.
        // line might be closed
        _getProjectionToLine: function(pt, line, isClosed) {
            var pc = Konva.Util.cloneObject(pt);
            var dist = Number.MAX_VALUE;
            line.forEach(function(p1, i) {
                if (!isClosed && i === line.length - 1) {
                    return;
                }
                var p2 = line[(i + 1) % line.length];
                var proj = Konva.Util._getProjectionToSegment(p1.x, p1.y, p2.x, p2.y, pt.x, pt.y);
                var px = proj[0], py = proj[1], pdist = proj[2];
                if (pdist < dist) {
                    pc.x = px;
                    pc.y = py;
                    dist = pdist;
                }
            });
            return pc;
        },
        _prepareArrayForTween: function(startArray, endArray, isClosed) {
            var n, start = [], end = [];
            if (startArray.length > endArray.length) {
                var temp = endArray;
                endArray = startArray;
                startArray = temp;
            }
            for (n = 0; n < startArray.length; n += 2) {
                start.push({
                    x: startArray[n],
                    y: startArray[n + 1]
                });
            }
            for (n = 0; n < endArray.length; n += 2) {
                end.push({
                    x: endArray[n],
                    y: endArray[n + 1]
                });
            }


            var newStart = [];
            end.forEach(function(point) {
                var pr = Konva.Util._getProjectionToLine(point, start, isClosed);
                newStart.push(pr.x);
                newStart.push(pr.y);
            });
            return newStart;
        }
    };
})();

(function() {
    'use strict';
    // calculate pixel ratio
    var canvas = Konva.Util.createCanvasElement(),
        context = canvas.getContext('2d'),
        _pixelRatio = (function(){
            var devicePixelRatio = Konva.window.devicePixelRatio || 1,
            backingStoreRatio = context.webkitBackingStorePixelRatio
                || context.mozBackingStorePixelRatio
                || context.msBackingStorePixelRatio
                || context.oBackingStorePixelRatio
                || context.backingStorePixelRatio
                || 1;
            return devicePixelRatio / backingStoreRatio;
        })();

    /**
     * Canvas Renderer constructor
     * @constructor
     * @abstract
     * @memberof Konva
     * @param {Object} config
     * @param {Number} config.width
     * @param {Number} config.height
     * @param {Number} config.pixelRatio KonvaJS automatically handles pixel ratio adjustments in order to render crisp drawings
     *  on all devices. Most desktops, low end tablets, and low end phones, have device pixel ratios
     *  of 1.  Some high end tablets and phones, like iPhones and iPads (not the mini) have a device pixel ratio
     *  of 2.  Some Macbook Pros, and iMacs also have a device pixel ratio of 2.  Some high end Android devices have pixel
     *  ratios of 2 or 3.  Some browsers like Firefox allow you to configure the pixel ratio of the viewport.  Unless otherwise
     *  specified, the pixel ratio will be defaulted to the actual device pixel ratio.  You can override the device pixel
     *  ratio for special situations, or, if you don't want the pixel ratio to be taken into account, you can set it to 1.
     */
    Konva.Canvas = function(config) {
        this.init(config);
    };

    Konva.Canvas.prototype = {
        init: function(config) {
            var conf = config || {};

            var pixelRatio = conf.pixelRatio || Konva.pixelRatio || _pixelRatio;

            this.pixelRatio = pixelRatio;
            this._canvas = Konva.Util.createCanvasElement();

            // set inline styles
            this._canvas.style.padding = 0;
            this._canvas.style.margin = 0;
            this._canvas.style.border = 0;
            this._canvas.style.background = 'transparent';
            this._canvas.style.position = 'absolute';
            this._canvas.style.top = 0;
            this._canvas.style.left = 0;
        },
        /**
         * get canvas context
         * @method
         * @memberof Konva.Canvas.prototype
         * @returns {CanvasContext} context
         */
        getContext: function() {
            return this.context;
        },
        /**
         * get pixel ratio
         * @method
         * @memberof Konva.Canvas.prototype
         * @returns {Number} pixel ratio
         */
        getPixelRatio: function() {
            return this.pixelRatio;
        },
        /**
         * get pixel ratio
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {Number} pixelRatio KonvaJS automatically handles pixel ratio adustments in order to render crisp drawings
         *  on all devices. Most desktops, low end tablets, and low end phones, have device pixel ratios
         *  of 1.  Some high end tablets and phones, like iPhones and iPads have a device pixel ratio
         *  of 2.  Some Macbook Pros, and iMacs also have a device pixel ratio of 2.  Some high end Android devices have pixel
         *  ratios of 2 or 3.  Some browsers like Firefox allow you to configure the pixel ratio of the viewport.  Unless otherwise
         *  specificed, the pixel ratio will be defaulted to the actual device pixel ratio.  You can override the device pixel
         *  ratio for special situations, or, if you don't want the pixel ratio to be taken into account, you can set it to 1.
         */
        setPixelRatio: function(pixelRatio) {
            var previousRatio = this.pixelRatio;
            this.pixelRatio = pixelRatio;
            this.setSize(this.getWidth() / previousRatio, this.getHeight() / previousRatio);
        },
        /**
         * set width
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {Number} width
         */
        setWidth: function(width) {
            // take into account pixel ratio
            this.width = this._canvas.width = width * this.pixelRatio;
            this._canvas.style.width = width + 'px';

            var pixelRatio = this.pixelRatio,
                _context = this.getContext()._context;
            _context.scale(pixelRatio, pixelRatio);
        },
        /**
         * set height
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {Number} height
         */
        setHeight: function(height) {
            // take into account pixel ratio
            this.height = this._canvas.height = height * this.pixelRatio;
            this._canvas.style.height = height + 'px';
            var pixelRatio = this.pixelRatio,
                _context = this.getContext()._context;
            _context.scale(pixelRatio, pixelRatio);
        },
        /**
         * get width
         * @method
         * @memberof Konva.Canvas.prototype
         * @returns {Number} width
         */
        getWidth: function() {
            return this.width;
        },
        /**
         * get height
         * @method
         * @memberof Konva.Canvas.prototype
         * @returns {Number} height
         */
        getHeight: function() {
            return this.height;
        },
        /**
         * set size
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {Number} width
         * @param {Number} height
         */
        setSize: function(width, height) {
            this.setWidth(width);
            this.setHeight(height);
        },
        /**
         * to data url
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {String} mimeType
         * @param {Number} quality between 0 and 1 for jpg mime types
         * @returns {String} data url string
         */
        toDataURL: function(mimeType, quality) {
            try {
                // If this call fails (due to browser bug, like in Firefox 3.6),
                // then revert to previous no-parameter image/png behavior
                return this._canvas.toDataURL(mimeType, quality);
            }
            catch(e) {
                try {
                    return this._canvas.toDataURL();
                }
                catch(err) {
                    Konva.Util.warn('Unable to get data URL. ' + err.message);
                    return '';
                }
            }
        }
    };

    Konva.SceneCanvas = function(config) {
        var conf = config || {};
        var width = conf.width || 0,
            height = conf.height || 0;

        Konva.Canvas.call(this, conf);
        this.context = new Konva.SceneContext(this);
        this.setSize(width, height);
    };

    Konva.Util.extend(Konva.SceneCanvas, Konva.Canvas);

    Konva.HitCanvas = function(config) {
        var conf = config || {};
        var width = conf.width || 0,
            height = conf.height || 0;

        Konva.Canvas.call(this, conf);
        this.context = new Konva.HitContext(this);
        this.setSize(width, height);
        this.hitCanvas = true;
    };
    Konva.Util.extend(Konva.HitCanvas, Konva.Canvas);

})();

(function() {
    'use strict';
    var COMMA = ',',
        OPEN_PAREN = '(',
        CLOSE_PAREN = ')',
        OPEN_PAREN_BRACKET = '([',
        CLOSE_BRACKET_PAREN = '])',
        SEMICOLON = ';',
        DOUBLE_PAREN = '()',
        // EMPTY_STRING = '',
        EQUALS = '=',
        // SET = 'set',
        CONTEXT_METHODS = [
            'arc',
            'arcTo',
            'beginPath',
            'bezierCurveTo',
            'clearRect',
            'clip',
            'closePath',
            'createLinearGradient',
            'createPattern',
            'createRadialGradient',
            'drawImage',
            'fill',
            'fillText',
            'getImageData',
            'createImageData',
            'lineTo',
            'moveTo',
            'putImageData',
            'quadraticCurveTo',
            'rect',
            'restore',
            'rotate',
            'save',
            'scale',
            'setLineDash',
            'setTransform',
            'stroke',
            'strokeText',
            'transform',
            'translate'
        ];

    var CONTEXT_PROPERTIES = ['fillStyle', 'strokeStyle', 'shadowColor', 'shadowBlur', 'shadowOffsetX',
        'shadowOffsetY', 'lineCap', 'lineJoin', 'lineWidth', 'miterLimit', 'font', 'textAlign', 'textBaseline',
        'globalAlpha', 'globalCompositeOperation'];

    /**
     * Canvas Context constructor
     * @constructor
     * @abstract
     * @memberof Konva
     */
    Konva.Context = function(canvas) {
        this.init(canvas);
    };

    Konva.Context.prototype = {
        init: function(canvas) {
            this.canvas = canvas;
            this._context = canvas._canvas.getContext('2d');

            if (Konva.enableTrace) {
                this.traceArr = [];
                this._enableTrace();
            }
        },
        /**
         * fill shape
         * @method
         * @memberof Konva.Context.prototype
         * @param {Konva.Shape} shape
         */
        fillShape: function(shape) {
            if(shape.getFillEnabled()) {
                this._fill(shape);
            }
        },
        /**
         * stroke shape
         * @method
         * @memberof Konva.Context.prototype
         * @param {Konva.Shape} shape
         */
        strokeShape: function(shape) {
            if(shape.getStrokeEnabled()) {
                this._stroke(shape);
            }
        },
        /**
         * fill then stroke
         * @method
         * @memberof Konva.Context.prototype
         * @param {Konva.Shape} shape
         */
        fillStrokeShape: function(shape) {
            var fillEnabled = shape.getFillEnabled();
            if(fillEnabled) {
                this._fill(shape);
            }
            if(shape.getStrokeEnabled()) {
                this._stroke(shape);
            }
        },
        /**
         * get context trace if trace is enabled
         * @method
         * @memberof Konva.Context.prototype
         * @param {Boolean} relaxed if false, return strict context trace, which includes method names, method parameters
         *  properties, and property values.  If true, return relaxed context trace, which only returns method names and
         *  properites.
         * @returns {String}
         */
        getTrace: function(relaxed) {
            var traceArr = this.traceArr,
                len = traceArr.length,
                str = '',
                n, trace, method, args;

            for (n = 0; n < len; n++) {
                trace = traceArr[n];
                method = trace.method;

                // methods
                if (method) {
                    args = trace.args;
                    str += method;
                    if (relaxed) {
                        str += DOUBLE_PAREN;
                    }
                    else {
                        if (Konva.Util._isArray(args[0])) {
                            str += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;
                        }
                        else {
                            str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;
                        }
                    }
                }
                // properties
                else {
                    str += trace.property;
                    if (!relaxed) {
                        str += EQUALS + trace.val;
                    }
                }

                str += SEMICOLON;
            }

            return str;
        },
        /**
         * clear trace if trace is enabled
         * @method
         * @memberof Konva.Context.prototype
         */
        clearTrace: function() {
            this.traceArr = [];
        },
        _trace: function(str) {
            var traceArr = this.traceArr,
                len;

            traceArr.push(str);
            len = traceArr.length;

            if (len >= Konva.traceArrMax) {
                traceArr.shift();
            }
        },
        /**
         * reset canvas context transform
         * @method
         * @memberof Konva.Context.prototype
         */
        reset: function() {
            var pixelRatio = this.getCanvas().getPixelRatio();
            this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);
        },
        /**
         * get canvas
         * @method
         * @memberof Konva.Context.prototype
         * @returns {Konva.Canvas}
         */
        getCanvas: function() {
            return this.canvas;
        },
        /**
         * clear canvas
         * @method
         * @memberof Konva.Context.prototype
         * @param {Object} [bounds]
         * @param {Number} [bounds.x]
         * @param {Number} [bounds.y]
         * @param {Number} [bounds.width]
         * @param {Number} [bounds.height]
         */
        clear: function(bounds) {
            var canvas = this.getCanvas();

            if (bounds) {
                this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0);
            }
            else {
                this.clearRect(0, 0, canvas.getWidth() / canvas.pixelRatio, canvas.getHeight() / canvas.pixelRatio);
            }
        },
        _applyLineCap: function(shape) {
            var lineCap = shape.getLineCap();
            if(lineCap) {
                this.setAttr('lineCap', lineCap);
            }
        },
        _applyOpacity: function(shape) {
            var absOpacity = shape.getAbsoluteOpacity();
            if(absOpacity !== 1) {
                this.setAttr('globalAlpha', absOpacity);
            }
        },
        _applyLineJoin: function(shape) {
            var lineJoin = shape.getLineJoin();
            if(lineJoin) {
                this.setAttr('lineJoin', lineJoin);
            }
        },
        setAttr: function(attr, val) {
            this._context[attr] = val;
        },

        // context pass through methods
        arc: function() {
            var a = arguments;
            this._context.arc(a[0], a[1], a[2], a[3], a[4], a[5]);
        },
        beginPath: function() {
            this._context.beginPath();
        },
        bezierCurveTo: function() {
            var a = arguments;
            this._context.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5]);
        },
        clearRect: function() {
            var a = arguments;
            this._context.clearRect(a[0], a[1], a[2], a[3]);
        },
        clip: function() {
            this._context.clip();
        },
        closePath: function() {
            this._context.closePath();
        },
        createImageData: function() {
            var a = arguments;
            if(a.length === 2) {
                return this._context.createImageData(a[0], a[1]);
            }
            else if(a.length === 1) {
                return this._context.createImageData(a[0]);
            }
        },
        createLinearGradient: function() {
            var a = arguments;
            return this._context.createLinearGradient(a[0], a[1], a[2], a[3]);
        },
        createPattern: function() {
            var a = arguments;
            return this._context.createPattern(a[0], a[1]);
        },
        createRadialGradient: function() {
            var a = arguments;
            return this._context.createRadialGradient(a[0], a[1], a[2], a[3], a[4], a[5]);
        },
        drawImage: function() {
            var a = arguments,
                _context = this._context;

            if(a.length === 3) {
                _context.drawImage(a[0], a[1], a[2]);
            }
            else if(a.length === 5) {
                _context.drawImage(a[0], a[1], a[2], a[3], a[4]);
            }
            else if(a.length === 9) {
                _context.drawImage(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
            }
        },
        isPointInPath: function(x, y) {
            return this._context.isPointInPath(x, y);
        },
        fill: function() {
            this._context.fill();
        },
        fillRect: function(x, y, width, height) {
            this._context.fillRect(x, y, width, height);
        },
        strokeRect: function(x, y, width, height) {
            this._context.strokeRect(x, y, width, height);
        },
        fillText: function() {
            var a = arguments;
            this._context.fillText(a[0], a[1], a[2]);
        },
        measureText: function(text) {
            return this._context.measureText(text);
        },
        getImageData: function() {
            var a = arguments;
            return this._context.getImageData(a[0], a[1], a[2], a[3]);
        },
        lineTo: function() {
            var a = arguments;
            this._context.lineTo(a[0], a[1]);
        },
        moveTo: function() {
            var a = arguments;
            this._context.moveTo(a[0], a[1]);
        },
        rect: function() {
            var a = arguments;
            this._context.rect(a[0], a[1], a[2], a[3]);
        },
        putImageData: function() {
            var a = arguments;
            this._context.putImageData(a[0], a[1], a[2]);
        },
        quadraticCurveTo: function() {
            var a = arguments;
            this._context.quadraticCurveTo(a[0], a[1], a[2], a[3]);
        },
        restore: function() {
            this._context.restore();
        },
        rotate: function() {
            var a = arguments;
            this._context.rotate(a[0]);
        },
        save: function() {
            this._context.save();
        },
        scale: function() {
            var a = arguments;
            this._context.scale(a[0], a[1]);
        },
        setLineDash: function() {
            var a = arguments,
                _context = this._context;

            // works for Chrome and IE11
            if(this._context.setLineDash) {
                _context.setLineDash(a[0]);
            }
            // verified that this works in firefox
            else if('mozDash' in _context) {
                _context.mozDash = a[0];
            }
            // does not currently work for Safari
            else if('webkitLineDash' in _context) {
                _context.webkitLineDash = a[0];
            }

            // no support for IE9 and IE10
        },
        getLineDash: function() {
            return this._context.getLineDash();
        },
        setTransform: function() {
            var a = arguments;
            this._context.setTransform(a[0], a[1], a[2], a[3], a[4], a[5]);
        },
        stroke: function() {
            this._context.stroke();
        },
        strokeText: function() {
            var a = arguments;
            this._context.strokeText(a[0], a[1], a[2]);
        },
        transform: function() {
            var a = arguments;
            this._context.transform(a[0], a[1], a[2], a[3], a[4], a[5]);
        },
        translate: function() {
            var a = arguments;
            this._context.translate(a[0], a[1]);
        },
        _enableTrace: function() {
            var that = this,
                len = CONTEXT_METHODS.length,
                _simplifyArray = Konva.Util._simplifyArray,
                origSetter = this.setAttr,
                n, args;

            // to prevent creating scope function at each loop
            var func = function(methodName) {
                    var origMethod = that[methodName],
                        ret;

                    that[methodName] = function() {
                        args = _simplifyArray(Array.prototype.slice.call(arguments, 0));
                        ret = origMethod.apply(that, arguments);

                        if (methodName === 'clearRect') {
                            args[2] = args[2] / that.canvas.getPixelRatio();
                            args[3] = args[3] / that.canvas.getPixelRatio();
                        }
                        that._trace({
                            method: methodName,
                            args: args
                        });

                        return ret;
                    };
            };
            // methods
            for (n = 0; n < len; n++) {
                func(CONTEXT_METHODS[n]);
            }

            // attrs
            that.setAttr = function() {
                origSetter.apply(that, arguments);
                that._trace({
                    property: arguments[0],
                    val: arguments[1]
                });
            };
        }
    };

    CONTEXT_PROPERTIES.forEach(function(prop) {
        Object.defineProperty(Konva.Context.prototype, prop, {
            get: function () {
                return this._context[prop];
            },
            set: function (val) {
                this._context[prop] = val;
            }
        });
    });

    Konva.SceneContext = function(canvas) {
        Konva.Context.call(this, canvas);
    };

    Konva.SceneContext.prototype = {
        _fillColor: function(shape) {
            var fill = shape.fill();

            this.setAttr('fillStyle', fill);
            shape._fillFunc(this);
        },
        _fillPattern: function(shape) {
            var fillPatternX = shape.getFillPatternX(),
                fillPatternY = shape.getFillPatternY(),
                fillPatternScale = shape.getFillPatternScale(),
                fillPatternRotation = Konva.getAngle(shape.getFillPatternRotation()),
                fillPatternOffset = shape.getFillPatternOffset();

            if(fillPatternX || fillPatternY) {
                this.translate(fillPatternX || 0, fillPatternY || 0);
            }
            if(fillPatternRotation) {
                this.rotate(fillPatternRotation);
            }
            if(fillPatternScale) {
                this.scale(fillPatternScale.x, fillPatternScale.y);
            }
            if(fillPatternOffset) {
                this.translate(-1 * fillPatternOffset.x, -1 * fillPatternOffset.y);
            }

            this.setAttr('fillStyle', this.createPattern(shape.getFillPatternImage(), shape.getFillPatternRepeat() || 'repeat'));
            this.fill();
        },
        _fillLinearGradient: function(shape) {
            var start = shape.getFillLinearGradientStartPoint(),
                end = shape.getFillLinearGradientEndPoint(),
                colorStops = shape.getFillLinearGradientColorStops(),
                grd = this.createLinearGradient(start.x, start.y, end.x, end.y);

            if (colorStops) {
                // build color stops
                for(var n = 0; n < colorStops.length; n += 2) {
                    grd.addColorStop(colorStops[n], colorStops[n + 1]);
                }
                this.setAttr('fillStyle', grd);
                shape._fillFunc(this);
            }
        },
        _fillRadialGradient: function(shape) {
            var start = shape.getFillRadialGradientStartPoint(),
                end = shape.getFillRadialGradientEndPoint(),
                startRadius = shape.getFillRadialGradientStartRadius(),
                endRadius = shape.getFillRadialGradientEndRadius(),
                colorStops = shape.getFillRadialGradientColorStops(),
                grd = this.createRadialGradient(start.x, start.y, startRadius, end.x, end.y, endRadius);

            // build color stops
            for(var n = 0; n < colorStops.length; n += 2) {
                grd.addColorStop(colorStops[n], colorStops[n + 1]);
            }
            this.setAttr('fillStyle', grd);
            this.fill();
        },
        _fill: function(shape) {
            var hasColor = shape.fill(),
                hasPattern = shape.getFillPatternImage(),
                hasLinearGradient = shape.getFillLinearGradientColorStops(),
                hasRadialGradient = shape.getFillRadialGradientColorStops(),
                fillPriority = shape.getFillPriority();

            // priority fills
            if(hasColor && fillPriority === 'color') {
                this._fillColor(shape);
            }
            else if(hasPattern && fillPriority === 'pattern') {
                this._fillPattern(shape);
            }
            else if(hasLinearGradient && fillPriority === 'linear-gradient') {
                this._fillLinearGradient(shape);
            }
            else if(hasRadialGradient && fillPriority === 'radial-gradient') {
                this._fillRadialGradient(shape);
            }
            // now just try and fill with whatever is available
            else if(hasColor) {
                this._fillColor(shape);
            }
            else if(hasPattern) {
                this._fillPattern(shape);
            }
            else if(hasLinearGradient) {
                this._fillLinearGradient(shape);
            }
            else if(hasRadialGradient) {
                this._fillRadialGradient(shape);
            }
        },
        _stroke: function(shape) {
            var dash = shape.dash(),
                // ignore strokeScaleEnabled for Text
                strokeScaleEnabled = (shape.getStrokeScaleEnabled() || (shape instanceof Konva.Text));

            if(shape.hasStroke()) {
                if (!strokeScaleEnabled) {
                    this.save();
                    this.setTransform(1, 0, 0, 1, 0, 0);
                }

                this._applyLineCap(shape);
                if(dash && shape.dashEnabled()) {
                    this.setLineDash(dash);
                }

                this.setAttr('lineWidth', shape.strokeWidth());
                this.setAttr('strokeStyle', shape.stroke());

                if (!shape.getShadowForStrokeEnabled()) {
                    this.setAttr('shadowColor', 'rgba(0,0,0,0)');
                }
                shape._strokeFunc(this);

                if (!strokeScaleEnabled) {
                    this.restore();
                }
            }
        },
        _applyShadow: function(shape) {
            var util = Konva.Util,
                color = util.get(shape.getShadowRGBA(), 'black'),
                blur = util.get(shape.getShadowBlur(), 5),
                offset = util.get(shape.getShadowOffset(), {
                    x: 0,
                    y: 0
                }),
                m = shape.getAbsoluteTransform().m,
                scaleX = m[0],
                scaleY = m[3];

            this.setAttr('shadowColor', color);
            this.setAttr('shadowBlur', blur);
            this.setAttr('shadowOffsetX', offset.x * scaleX);
            this.setAttr('shadowOffsetY', offset.y * scaleY);
        }
    };
    Konva.Util.extend(Konva.SceneContext, Konva.Context);

    Konva.HitContext = function(canvas) {
        Konva.Context.call(this, canvas);
    };

    Konva.HitContext.prototype = {
        _fill: function(shape) {
            this.save();
            this.setAttr('fillStyle', shape.colorKey);
            shape._fillFuncHit(this);
            this.restore();
        },
        _stroke: function(shape) {
            if(shape.hasStroke() && shape.strokeHitEnabled()) {
                // ignore strokeScaleEnabled for Text
                var strokeScaleEnabled = (shape.getStrokeScaleEnabled() || (shape instanceof Konva.Text));
                if (!strokeScaleEnabled) {
                    this.save();
                    this.setTransform(1, 0, 0, 1, 0, 0);
                }
                this._applyLineCap(shape);
                this.setAttr('lineWidth', shape.strokeWidth());
                this.setAttr('strokeStyle', shape.colorKey);
                shape._strokeFuncHit(this);
                if (!strokeScaleEnabled) {
                    this.restore();
                }
            }
        }
    };
    Konva.Util.extend(Konva.HitContext, Konva.Context);
})();

(function() {
    'use strict';
    // CONSTANTS
    var GET = 'get',
        SET = 'set';

    Konva.Factory = {
        addGetterSetter: function(constructor, attr, def, validator, after) {
            this.addGetter(constructor, attr, def);
            this.addSetter(constructor, attr, validator, after);
            this.addOverloadedGetterSetter(constructor, attr);
        },
        addGetter: function(constructor, attr, def) {
            var method = GET + Konva.Util._capitalize(attr);

            constructor.prototype[method] = function() {
                var val = this.attrs[attr];
                return val === undefined ? def : val;
            };
        },
        addSetter: function(constructor, attr, validator, after) {
            var method = SET + Konva.Util._capitalize(attr);

            constructor.prototype[method] = function(val) {
                if (validator) {
                    val = validator.call(this, val);
                }

                this._setAttr(attr, val);

                if (after) {
                    after.call(this);
                }

                return this;
            };
        },
        addComponentsGetterSetter: function(constructor, attr, components, validator, after) {
            var len = components.length,
                capitalize = Konva.Util._capitalize,
                getter = GET + capitalize(attr),
                setter = SET + capitalize(attr),
                n, component;

            // getter
            constructor.prototype[getter] = function() {
                var ret = {};

                for (n = 0; n < len; n++) {
                    component = components[n];
                    ret[component] = this.getAttr(attr + capitalize(component));
                }

                return ret;
            };

            // setter
            constructor.prototype[setter] = function(val) {
                var oldVal = this.attrs[attr],
                    key;

                if (validator) {
                    val = validator.call(this, val);
                }

                for (key in val) {
                    if (!val.hasOwnProperty(key)) {
                        continue;
                    }
                    this._setAttr(attr + capitalize(key), val[key]);
                }

                this._fireChangeEvent(attr, oldVal, val);

                if (after) {
                    after.call(this);
                }

                return this;
            };

            this.addOverloadedGetterSetter(constructor, attr);
        },
        addOverloadedGetterSetter: function(constructor, attr) {
            var capitalizedAttr = Konva.Util._capitalize(attr),
                setter = SET + capitalizedAttr,
                getter = GET + capitalizedAttr;

            constructor.prototype[attr] = function() {
                // setting
                if (arguments.length) {
                    this[setter](arguments[0]);
                    return this;
                }
                // getting
                return this[getter]();
            };
        },
        addDeprecatedGetterSetter: function(constructor, attr, def, validator) {
            var method = GET + Konva.Util._capitalize(attr);
            var message = attr + ' property is deprecated and will be removed soon. Look at Konva change log for more information.';
            constructor.prototype[method] = function() {
                Konva.Util.error(message);
                var val = this.attrs[attr];
                return val === undefined ? def : val;
            };
            this.addSetter(constructor, attr, validator, function() {
              Konva.Util.error(message);
            });
            this.addOverloadedGetterSetter(constructor, attr);
        },
        backCompat: function(constructor, methods) {
            Konva.Util.each(methods, function(oldMethodName, newMethodName) {
                var method = constructor.prototype[newMethodName];
                constructor.prototype[oldMethodName] = function(){
                    method.apply(this, arguments);
                    Konva.Util.error(oldMethodName + ' method is deprecated and will be removed soon. Use ' + newMethodName + ' instead');
                };
            });
        },
        afterSetFilter: function() {
            this._filterUpToDate = false;
        }
    };

    Konva.Validators = {
        /**
         * @return {number}
         */
        RGBComponent: function(val) {
            if (val > 255) {
                return 255;
            } else if (val < 0) {
                return 0;
            }
            return Math.round(val);
        },
        alphaComponent: function(val) {
            if (val > 1) {
                return 1;
            }
            // chrome does not honor alpha values of 0
            else if (val < 0.0001) {
                return 0.0001;
            }

            return val;
        }
    };
})();

(function(Konva) {
    'use strict';
    // CONSTANTS
    var ABSOLUTE_OPACITY = 'absoluteOpacity',
        ABSOLUTE_TRANSFORM = 'absoluteTransform',
        CHANGE = 'Change',
        CHILDREN = 'children',
        DOT = '.',
        EMPTY_STRING = '',
        GET = 'get',
        ID = 'id',
        KONVA = 'konva',
        LISTENING = 'listening',
        MOUSEENTER = 'mouseenter',
        MOUSELEAVE = 'mouseleave',
        NAME = 'name',
        SET = 'set',
        SHAPE = 'Shape',
        SPACE = ' ',
        STAGE = 'stage',
        TRANSFORM = 'transform',
        UPPER_STAGE = 'Stage',
        VISIBLE = 'visible',
        CLONE_BLACK_LIST = ['id'],

        TRANSFORM_CHANGE_STR = [
            'xChange.konva',
            'yChange.konva',
            'scaleXChange.konva',
            'scaleYChange.konva',
            'skewXChange.konva',
            'skewYChange.konva',
            'rotationChange.konva',
            'offsetXChange.konva',
            'offsetYChange.konva',
            'transformsEnabledChange.konva'
        ].join(SPACE);

    /**
     * Node constructor. Nodes are entities that can be transformed, layered,
     * and have bound events. The stage, layers, groups, and shapes all extend Node.
     * @constructor
     * @memberof Konva
     * @abstract
     * @param {Object} config
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     */
    Konva.Node = function(config) {
        this._init(config);
    };

    Konva.Util.addMethods(Konva.Node, {
        _init: function(config) {
            var that = this;
            this._id = Konva.idCounter++;
            this.eventListeners = {};
            this.attrs = {};
            this._cache = {};
            this._filterUpToDate = false;
            this.setAttrs(config);

            // event bindings for cache handling
            this.on(TRANSFORM_CHANGE_STR, function() {
                this._clearCache(TRANSFORM);
                that._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
            });
            this.on('visibleChange.konva', function() {
                that._clearSelfAndDescendantCache(VISIBLE);
            });
            this.on('listeningChange.konva', function() {
                that._clearSelfAndDescendantCache(LISTENING);
            });
            this.on('opacityChange.konva', function() {
                that._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
            });
        },
        _clearCache: function(attr){
            if (attr) {
                delete this._cache[attr];
            }
            else {
                this._cache = {};
            }
        },
        _getCache: function(attr, privateGetter){
            var cache = this._cache[attr];

            // if not cached, we need to set it using the private getter method.
            if (cache === undefined) {
                this._cache[attr] = privateGetter.call(this);
            }

            return this._cache[attr];
        },
        /*
         * when the logic for a cached result depends on ancestor propagation, use this
         * method to clear self and children cache
         */
        _clearSelfAndDescendantCache: function(attr) {
            this._clearCache(attr);

            if (this.children) {
                this.getChildren().each(function(node) {
                    node._clearSelfAndDescendantCache(attr);
                });
            }
        },
        /**
        * clear cached canvas
        * @method
        * @memberof Konva.Node.prototype
        * @returns {Konva.Node}
        * @example
        * node.clearCache();
        */
        clearCache: function() {
            delete this._cache.canvas;
            this._filterUpToDate = false;
            return this;
        },
        /**
        *  cache node to improve drawing performance, apply filters, or create more accurate
        *  hit regions. For all basic shapes size of cache canvas will be automatically detected.
        *  If you need to cache your custom `Konva.Shape` instance you have to pass shape's bounding box
        *  properties. Look at [link to demo page](link to demo page) for more information.
        * @method
        * @memberof Konva.Node.prototype
        * @param {Object} [config]
        * @param {Number} [config.x]
        * @param {Number} [config.y]
        * @param {Number} [config.width]
        * @param {Number} [config.height]
        * @param {Number} [config.offset]  increase canvas size by `offset` pixel in all directions.
        * @param {Boolean} [config.drawBorder] when set to true, a red border will be drawn around the cached
        *  region for debugging purposes
        * @returns {Konva.Node}
        * @example
        * // cache a shape with the x,y position of the bounding box at the center and
        * // the width and height of the bounding box equal to the width and height of
        * // the shape obtained from shape.width() and shape.height()
        * image.cache();
        *
        * // cache a node and define the bounding box position and size
        * node.cache({
        *   x: -30,
        *   y: -30,
        *   width: 100,
        *   height: 200
        * });
        *
        * // cache a node and draw a red border around the bounding box
        * // for debugging purposes
        * node.cache({
        *   x: -30,
        *   y: -30,
        *   width: 100,
        *   height: 200,
        *   offset : 10,
        *   drawBorder: true
        * });
        */
        cache: function(config) {
            var conf = config || {},
                rect = this.getClientRect(true),
                width = conf.width || rect.width,
                height = conf.height || rect.height,
                x = conf.x || rect.x,
                y = conf.y || rect.y,
                offset = conf.offset || 0,
                drawBorder = conf.drawBorder || false;

            if (!width || !height) {
                throw new Error('Width or height of caching configuration equals 0.');
            }

            width += offset * 2;
            height += offset * 2;

            x -= offset;
            y -= offset;


            var cachedSceneCanvas = new Konva.SceneCanvas({
                width: width,
                height: height
            }),
            cachedFilterCanvas = new Konva.SceneCanvas({
                width: width,
                height: height
            }),
            cachedHitCanvas = new Konva.HitCanvas({
                pixelRatio: 1,
                width: width,
                height: height
            }),
            sceneContext = cachedSceneCanvas.getContext(),
            hitContext = cachedHitCanvas.getContext();

            cachedHitCanvas.isCache = true;

            this.clearCache();

            sceneContext.save();
            hitContext.save();

            sceneContext.translate(-x, -y);
            hitContext.translate(-x, -y);

            this.drawScene(cachedSceneCanvas, this, true);
            this.drawHit(cachedHitCanvas, this, true);

            sceneContext.restore();
            hitContext.restore();

            // this will draw a red border around the cached box for
            // debugging purposes
            if (drawBorder) {
                sceneContext.save();
                sceneContext.beginPath();
                sceneContext.rect(0, 0, width, height);
                sceneContext.closePath();
                sceneContext.setAttr('strokeStyle', 'red');
                sceneContext.setAttr('lineWidth', 5);
                sceneContext.stroke();
                sceneContext.restore();
            }

            this._cache.canvas = {
                scene: cachedSceneCanvas,
                filter: cachedFilterCanvas,
                hit: cachedHitCanvas,
                x: x,
                y: y
            };

            return this;
        },
        /**
         * Return client rectangle {x, y, width, height} of node. This rectangle also include all styling (strokes, shadows, etc).
         * The rectangle position is relative to parent container.
         * @method
         * @memberof Konva.Node.prototype
         * @param {Boolean} [skipTransform] flag should we skip transformation to rectangle
         * @returns {Object} rect with {x, y, width, height} properties
         * @example
         * var rect = new Konva.Rect({
         *      width : 100,
         *      height : 100,
         *      x : 50,
         *      y : 50,
         *      strokeWidth : 4,
         *      stroke : 'black',
         *      offsetX : 50,
         *      scaleY : 2
         * });
         *
         * // get client rect without think off transformations (position, rotation, scale, offset, etc)
         * rect.getClientRect(true);
         * // returns {
         * //     x : -2,   // two pixels for stroke / 2
         * //     y : -2,
         * //     width : 104, // increased by 4 for stroke
         * //     height : 104
         * //}
         *
         * // get client rect with transformation applied
         * rect.getClientRect();
         * // returns Object {x: -2, y: 46, width: 104, height: 208}
         */
        getClientRect: function() {
            // abstract method
            // redefine in Container and Shape
            throw new Error('abstract "getClientRect" method call');
        },
        _transformedRect: function(rect) {
            var points = [
                {x: rect.x, y: rect.y},
                {x: rect.x + rect.width, y: rect.y},
                {x: rect.x + rect.width, y: rect.y + rect.height},
                {x: rect.x, y: rect.y + rect.height}
            ];
            var minX, minY, maxX, maxY;
            var trans = this.getTransform();
            points.forEach(function(point) {
                var transformed = trans.point(point);
                if (minX === undefined) {
                    minX = maxX = transformed.x;
                    minY = maxY = transformed.y;
                }
                minX = Math.min(minX, transformed.x);
                minY = Math.min(minY, transformed.y);
                maxX = Math.max(maxX, transformed.x);
                maxY = Math.max(maxY, transformed.y);
            });
            return {
                x: Math.round(minX),
                y: Math.round(minY),
                width: Math.round(maxX - minX),
                height: Math.round(maxY - minY)
            };
        },
        _drawCachedSceneCanvas: function(context) {
            context.save();
            context._applyOpacity(this);
            context.translate(
                this._cache.canvas.x,
                this._cache.canvas.y
            );

            var cacheCanvas = this._getCachedSceneCanvas();
            var ratio = cacheCanvas.pixelRatio;

            context.drawImage(cacheCanvas._canvas, 0, 0, cacheCanvas.width / ratio, cacheCanvas.height / ratio);
            context.restore();
        },
        _drawCachedHitCanvas: function(context) {
            var cachedCanvas = this._cache.canvas,
                hitCanvas = cachedCanvas.hit;
            context.save();
            context.translate(
                this._cache.canvas.x,
                this._cache.canvas.y
            );
            context.drawImage(hitCanvas._canvas, 0, 0);
            context.restore();
        },
        _getCachedSceneCanvas: function() {
            var filters = this.filters(),
                cachedCanvas = this._cache.canvas,
                sceneCanvas = cachedCanvas.scene,
                filterCanvas = cachedCanvas.filter,
                filterContext = filterCanvas.getContext(),
                len, imageData, n, filter;

            if (filters) {
                if (!this._filterUpToDate) {
                    var ratio = sceneCanvas.pixelRatio;

                    try {
                        len = filters.length;
                        filterContext.clear();

                        // copy cached canvas onto filter context
                        filterContext.drawImage(sceneCanvas._canvas, 0, 0, sceneCanvas.getWidth() / ratio, sceneCanvas.getHeight() / ratio);
                        imageData = filterContext.getImageData(0, 0, filterCanvas.getWidth(), filterCanvas.getHeight());

                        // apply filters to filter context
                        for (n = 0; n < len; n++) {
                            filter = filters[n];
                            filter.call(this, imageData);
                            filterContext.putImageData(imageData, 0, 0);
                        }
                    }
                    catch(e) {
                        Konva.Util.warn('Unable to apply filter. ' + e.message);
                    }

                    this._filterUpToDate = true;
                }

                return filterCanvas;
            }
            return sceneCanvas;
        },
        /**
         * bind events to the node. KonvaJS supports mouseover, mousemove,
         *  mouseout, mouseenter, mouseleave, mousedown, mouseup, mousewheel, click, dblclick, touchstart, touchmove,
         *  touchend, tap, dbltap, dragstart, dragmove, and dragend events. The Konva Stage supports
         *  contentMouseover, contentMousemove, contentMouseout, contentMousedown, contentMouseup,
         *  contentClick, contentDblclick, contentTouchstart, contentTouchmove, contentTouchend, contentTap,
         *  and contentDblTap.  Pass in a string of events delimmited by a space to bind multiple events at once
         *  such as 'mousedown mouseup mousemove'. Include a namespace to bind an
         *  event by name such as 'click.foobar'.
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} evtStr e.g. 'click', 'mousedown touchstart', 'mousedown.foo touchstart.foo'
         * @param {Function} handler The handler function is passed an event object
         * @returns {Konva.Node}
         * @example
         * // add click listener
         * node.on('click', function() {
         *   console.log('you clicked me!');
         * });
         *
         * // get the target node
         * node.on('click', function(evt) {
         *   console.log(evt.target);
         * });
         *
         * // stop event propagation
         * node.on('click', function(evt) {
         *   evt.cancelBubble = true;
         * });
         *
         * // bind multiple listeners
         * node.on('click touchstart', function() {
         *   console.log('you clicked/touched me!');
         * });
         *
         * // namespace listener
         * node.on('click.foo', function() {
         *   console.log('you clicked/touched me!');
         * });
         *
         * // get the event type
         * node.on('click tap', function(evt) {
         *   var eventType = evt.type;
         * });
         *
         * // get native event object
         * node.on('click tap', function(evt) {
         *   var nativeEvent = evt.evt;
         * });
         *
         * // for change events, get the old and new val
         * node.on('xChange', function(evt) {
         *   var oldVal = evt.oldVal;
         *   var newVal = evt.newVal;
         * });
         *
         * // get event targets
         * // with event delegations
         * layer.on('click', 'Group', function(evt) {
         *   var shape = evt.target;
         *   var group = evtn.currentTarger;
         * });
         */
        on: function(evtStr, handler) {
            if (arguments.length === 3) {
                return this._delegate.apply(this, arguments);
            }
            var events = evtStr.split(SPACE),
                len = events.length,
                n, event, parts, baseEvent, name;

             /*
             * loop through types and attach event listeners to
             * each one.  eg. 'click mouseover.namespace mouseout'
             * will create three event bindings
             */
            for(n = 0; n < len; n++) {
                event = events[n];
                parts = event.split(DOT);
                baseEvent = parts[0];
                name = parts[1] || EMPTY_STRING;

                // create events array if it doesn't exist
                if(!this.eventListeners[baseEvent]) {
                    this.eventListeners[baseEvent] = [];
                }

                this.eventListeners[baseEvent].push({
                    name: name,
                    handler: handler
                });
            }

            return this;
        },
        /**
         * remove event bindings from the node. Pass in a string of
         *  event types delimmited by a space to remove multiple event
         *  bindings at once such as 'mousedown mouseup mousemove'.
         *  include a namespace to remove an event binding by name
         *  such as 'click.foobar'. If you only give a name like '.foobar',
         *  all events in that namespace will be removed.
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} evtStr e.g. 'click', 'mousedown touchstart', '.foobar'
         * @returns {Konva.Node}
         * @example
         * // remove listener
         * node.off('click');
         *
         * // remove multiple listeners
         * node.off('click touchstart');
         *
         * // remove listener by name
         * node.off('click.foo');
         */
        off: function(evtStr) {
            var events = (evtStr || '').split(SPACE),
                len = events.length,
                n, t, event, parts, baseEvent, name;

            if (!evtStr) {
                // remove all events
                for(t in this.eventListeners) {
                    this._off(t);
                }
            }
            for(n = 0; n < len; n++) {
                event = events[n];
                parts = event.split(DOT);
                baseEvent = parts[0];
                name = parts[1];

                if(baseEvent) {
                    if(this.eventListeners[baseEvent]) {
                        this._off(baseEvent, name);
                    }
                }
                else {
                    for(t in this.eventListeners) {
                        this._off(t, name);
                    }
                }
            }
            return this;
        },
        // some event aliases for third party integration like HammerJS
        dispatchEvent: function(evt) {
            var e = {
              target: this,
              type: evt.type,
              evt: evt
            };
            this.fire(evt.type, e);
            return this;
        },
        addEventListener: function(type, handler) {
            // we have to pass native event to handler
            this.on(type, function(evt){
                handler.call(this, evt.evt);
            });
            return this;
        },
        removeEventListener: function(type) {
            this.off(type);
            return this;
        },
        // like node.on
        _delegate: function(event, selector, handler) {
            var stopNode = this;
            this.on(event, function(evt) {
                var targets = evt.target.findAncestors(selector, true, stopNode);
                for(var i = 0; i < targets.length; i++) {
                    evt = Konva.Util.cloneObject(evt);
                    evt.currentTarget = targets[i];
                    handler.call(targets[i], evt);
                }
            });
        },
        /**
         * remove self from parent, but don't destroy
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Node}
         * @example
         * node.remove();
         */
        remove: function() {
            var parent = this.getParent();

            if(parent && parent.children) {
                parent.children.splice(this.index, 1);
                parent._setChildrenIndices();
                delete this.parent;
            }

            // every cached attr that is calculated via node tree
            // traversal must be cleared when removing a node
            this._clearSelfAndDescendantCache(STAGE);
            this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
            this._clearSelfAndDescendantCache(VISIBLE);
            this._clearSelfAndDescendantCache(LISTENING);
            this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);

            return this;
        },
        /**
         * remove and destroy self
         * @method
         * @memberof Konva.Node.prototype
         * @example
         * node.destroy();
         */
        destroy: function() {
            // remove from ids and names hashes
            Konva._removeId(this.getId());
            Konva._removeName(this.getName(), this._id);

            this.remove();
            return this;
        },
        /**
         * get attr
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} attr
         * @returns {Integer|String|Object|Array}
         * @example
         * var x = node.getAttr('x');
         */
        getAttr: function(attr) {
            var method = GET + Konva.Util._capitalize(attr);
            if(Konva.Util._isFunction(this[method])) {
                return this[method]();
            }
            // otherwise get directly
            return this.attrs[attr];
        },
        /**
        * get ancestors
        * @method
        * @memberof Konva.Node.prototype
        * @returns {Konva.Collection}
        * @example
        * shape.getAncestors().each(function(node) {
        *   console.log(node.getId());
        * })
        */
        getAncestors: function() {
            var parent = this.getParent(),
                ancestors = new Konva.Collection();

            while (parent) {
                ancestors.push(parent);
                parent = parent.getParent();
            }

            return ancestors;
        },
        /**
         * get attrs object literal
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Object}
         */
        getAttrs: function() {
            return this.attrs || {};
        },
        /**
         * set multiple attrs at once using an object literal
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} config object containing key value pairs
         * @returns {Konva.Node}
         * @example
         * node.setAttrs({
         *   x: 5,
         *   fill: 'red'
         * });
         */
        setAttrs: function(config) {
            var key, method;

            if(!config) {
                return this;
            }
            for(key in config) {
                if (key === CHILDREN) {
                    continue;
                }
                method = SET + Konva.Util._capitalize(key);
                // use setter if available
                if(Konva.Util._isFunction(this[method])) {
                    this[method](config[key]);
                }
                // otherwise set directly
                else {
                    this._setAttr(key, config[key]);
                }
            }
            return this;
        },
        /**
         * determine if node is listening for events by taking into account ancestors.
         *
         * Parent    | Self      | isListening
         * listening | listening |
         * ----------+-----------+------------
         * T         | T         | T
         * T         | F         | F
         * F         | T         | T
         * F         | F         | F
         * ----------+-----------+------------
         * T         | I         | T
         * F         | I         | F
         * I         | I         | T
         *
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
        isListening: function() {
            return this._getCache(LISTENING, this._isListening);
        },
        _isListening: function() {
            var listening = this.getListening(),
                parent = this.getParent();

            // the following conditions are a simplification of the truth table above.
            // please modify carefully
            if (listening === 'inherit') {
                if (parent) {
                    return parent.isListening();
                }
                else {
                    return true;
                }
            }
            else {
                return listening;
            }
        },
        /**
         * determine if node is visible by taking into account ancestors.
         *
         * Parent    | Self      | isVisible
         * visible   | visible   |
         * ----------+-----------+------------
         * T         | T         | T
         * T         | F         | F
         * F         | T         | T
         * F         | F         | F
         * ----------+-----------+------------
         * T         | I         | T
         * F         | I         | F
         * I         | I         | T

         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
        isVisible: function() {
            return this._getCache(VISIBLE, this._isVisible);
        },
        _isVisible: function() {
            var visible = this.getVisible(),
                parent = this.getParent();

            // the following conditions are a simplification of the truth table above.
            // please modify carefully
            if (visible === 'inherit') {
                if (parent) {
                    return parent.isVisible();
                }
                else {
                    return true;
                }
            }
            else {
                return visible;
            }
        },
        /**
         * determine if listening is enabled by taking into account descendants.  If self or any children
         * have _isListeningEnabled set to true, then self also has listening enabled.
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
        shouldDrawHit: function(canvas) {
            var layer = this.getLayer();
            return (canvas && canvas.isCache) || (layer && layer.hitGraphEnabled())
                && this.isListening() && this.isVisible();
        },
        /**
         * show node
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Node}
         */
        show: function() {
            this.setVisible(true);
            return this;
        },
        /**
         * hide node.  Hidden nodes are no longer detectable
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Node}
         */
        hide: function() {
            this.setVisible(false);
            return this;
        },
        /**
         * get zIndex relative to the node's siblings who share the same parent
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Integer}
         */
        getZIndex: function() {
            return this.index || 0;
        },
        /**
         * get absolute z-index which takes into account sibling
         *  and ancestor indices
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Integer}
         */
        getAbsoluteZIndex: function() {
            var depth = this.getDepth(),
                that = this,
                index = 0,
                nodes, len, n, child;

            function addChildren(children) {
                nodes = [];
                len = children.length;
                for(n = 0; n < len; n++) {
                    child = children[n];
                    index++;

                    if(child.nodeType !== SHAPE) {
                        nodes = nodes.concat(child.getChildren().toArray());
                    }

                    if(child._id === that._id) {
                        n = len;
                    }
                }

                if(nodes.length > 0 && nodes[0].getDepth() <= depth) {
                    addChildren(nodes);
                }
            }
            if(that.nodeType !== UPPER_STAGE) {
                addChildren(that.getStage().getChildren());
            }

            return index;
        },
        /**
         * get node depth in node tree.  Returns an integer.
         *  e.g. Stage depth will always be 0.  Layers will always be 1.  Groups and Shapes will always
         *  be >= 2
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Integer}
         */
        getDepth: function() {
            var depth = 0,
                parent = this.parent;

            while(parent) {
                depth++;
                parent = parent.parent;
            }
            return depth;
        },
        setPosition: function(pos) {
            this.setX(pos.x);
            this.setY(pos.y);
            return this;
        },
        getPosition: function() {
            return {
                x: this.getX(),
                y: this.getY()
            };
        },
        /**
         * get absolute position relative to the top left corner of the stage container div
         * or relative to passed node
         * @method
         * @param {Object} [top] optional parent node
         * @memberof Konva.Node.prototype
         * @returns {Object}
         */
        getAbsolutePosition: function(top) {
            var absoluteMatrix = this.getAbsoluteTransform(top).getMatrix(),
                absoluteTransform = new Konva.Transform(),
                offset = this.offset();

            // clone the matrix array
            absoluteTransform.m = absoluteMatrix.slice();
            absoluteTransform.translate(offset.x, offset.y);

            return absoluteTransform.getTranslation();
        },
        /**
         * set absolute position
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} pos
         * @param {Number} pos.x
         * @param {Number} pos.y
         * @returns {Konva.Node}
         */
        setAbsolutePosition: function(pos) {
            var origTrans = this._clearTransform(),
                it;

            // don't clear translation
            this.attrs.x = origTrans.x;
            this.attrs.y = origTrans.y;
            delete origTrans.x;
            delete origTrans.y;

            // unravel transform
            it = this.getAbsoluteTransform();

            it.invert();
            it.translate(pos.x, pos.y);
            pos = {
                x: this.attrs.x + it.getTranslation().x,
                y: this.attrs.y + it.getTranslation().y
            };

            this.setPosition({x: pos.x, y: pos.y});
            this._setTransform(origTrans);

            return this;
        },
        _setTransform: function(trans) {
            var key;

            for(key in trans) {
                this.attrs[key] = trans[key];
            }

            this._clearCache(TRANSFORM);
            this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
        },
        _clearTransform: function() {
            var trans = {
                x: this.getX(),
                y: this.getY(),
                rotation: this.getRotation(),
                scaleX: this.getScaleX(),
                scaleY: this.getScaleY(),
                offsetX: this.getOffsetX(),
                offsetY: this.getOffsetY(),
                skewX: this.getSkewX(),
                skewY: this.getSkewY()
            };

            this.attrs.x = 0;
            this.attrs.y = 0;
            this.attrs.rotation = 0;
            this.attrs.scaleX = 1;
            this.attrs.scaleY = 1;
            this.attrs.offsetX = 0;
            this.attrs.offsetY = 0;
            this.attrs.skewX = 0;
            this.attrs.skewY = 0;

            this._clearCache(TRANSFORM);
            this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);

            // return original transform
            return trans;
        },
        /**
         * move node by an amount relative to its current position
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} change
         * @param {Number} change.x
         * @param {Number} change.y
         * @returns {Konva.Node}
         * @example
         * // move node in x direction by 1px and y direction by 2px
         * node.move({
         *   x: 1,
         *   y: 2)
         * });
         */
        move: function(change) {
            var changeX = change.x,
                changeY = change.y,
                x = this.getX(),
                y = this.getY();

            if(changeX !== undefined) {
                x += changeX;
            }

            if(changeY !== undefined) {
                y += changeY;
            }

            this.setPosition({x: x, y: y});
            return this;
        },
        _eachAncestorReverse: function(func, top) {
            var family = [],
                parent = this.getParent(),
                len, n;

            // if top node is defined, and this node is top node,
            // there's no need to build a family tree.  just execute
            // func with this because it will be the only node
            if (top && top._id === this._id) {
                func(this);
                return true;
            }

            family.unshift(this);

            while(parent && (!top || parent._id !== top._id)) {
                family.unshift(parent);
                parent = parent.parent;
            }

            len = family.length;
            for(n = 0; n < len; n++) {
                func(family[n]);
            }
        },
        /**
         * rotate node by an amount in degrees relative to its current rotation
         * @method
         * @memberof Konva.Node.prototype
         * @param {Number} theta
         * @returns {Konva.Node}
         */
        rotate: function(theta) {
            this.setRotation(this.getRotation() + theta);
            return this;
        },
        /**
         * move node to the top of its siblings
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
        moveToTop: function() {
            if (!this.parent) {
                Konva.Util.warn('Node has no parent. moveToTop function is ignored.');
                return false;
            }
            var index = this.index;
            this.parent.children.splice(index, 1);
            this.parent.children.push(this);
            this.parent._setChildrenIndices();
            return true;
        },
        /**
         * move node up
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean} flag is moved or not
         */
        moveUp: function() {
            if (!this.parent) {
                Konva.Util.warn('Node has no parent. moveUp function is ignored.');
                return false;
            }
            var index = this.index,
                len = this.parent.getChildren().length;
            if(index < len - 1) {
                this.parent.children.splice(index, 1);
                this.parent.children.splice(index + 1, 0, this);
                this.parent._setChildrenIndices();
                return true;
            }
            return false;
        },
        /**
         * move node down
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
        moveDown: function() {
            if (!this.parent) {
                Konva.Util.warn('Node has no parent. moveDown function is ignored.');
                return false;
            }
            var index = this.index;
            if(index > 0) {
                this.parent.children.splice(index, 1);
                this.parent.children.splice(index - 1, 0, this);
                this.parent._setChildrenIndices();
                return true;
            }
            return false;
        },
        /**
         * move node to the bottom of its siblings
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Boolean}
         */
        moveToBottom: function() {
            if (!this.parent) {
                Konva.Util.warn('Node has no parent. moveToBottom function is ignored.');
                return false;
            }
            var index = this.index;
            if(index > 0) {
                this.parent.children.splice(index, 1);
                this.parent.children.unshift(this);
                this.parent._setChildrenIndices();
                return true;
            }
            return false;
        },
        /**
         * set zIndex relative to siblings
         * @method
         * @memberof Konva.Node.prototype
         * @param {Integer} zIndex
         * @returns {Konva.Node}
         */
        setZIndex: function(zIndex) {
            if (!this.parent) {
                Konva.Util.warn('Node has no parent. zIndex parameter is ignored.');
                return false;
            }
            var index = this.index;
            this.parent.children.splice(index, 1);
            this.parent.children.splice(zIndex, 0, this);
            this.parent._setChildrenIndices();
            return this;
        },
        /**
         * get absolute opacity
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Number}
         */
        getAbsoluteOpacity: function() {
            return this._getCache(ABSOLUTE_OPACITY, this._getAbsoluteOpacity);
        },
        _getAbsoluteOpacity: function() {
            var absOpacity = this.getOpacity();
            if(this.getParent()) {
                absOpacity *= this.getParent().getAbsoluteOpacity();
            }
            return absOpacity;
        },
        /**
         * move node to another container
         * @method
         * @memberof Konva.Node.prototype
         * @param {Container} newContainer
         * @returns {Konva.Node}
         * @example
         * // move node from current layer into layer2
         * node.moveTo(layer2);
         */
        moveTo: function(newContainer) {
            // do nothing if new container is already parent
            if (this.getParent() !== newContainer) {
                this.remove();
                newContainer.add(this);
            }
            return this;
        },
        /**
         * convert Node into an object for serialization.  Returns an object.
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Object}
         */
        toObject: function() {
            var obj = {},
                attrs = this.getAttrs(),
                key, val, getter, defaultValue;

            obj.attrs = {};

            for(key in attrs) {
                val = attrs[key];
                // serialize only attributes that are not function, image, DOM, or objects with methods
                if (Konva.Util._isFunction(val) || Konva.Util._isElement(val) ||
                    (Konva.Util._isObject(val) || Konva.Util._hasMethods(val))) {
                    continue;
                }
                getter = this[key];
                // remove attr value so that we can extract the default value from the getter
                delete attrs[key];
                defaultValue = getter ? getter.call(this) : null;
                // restore attr value
                attrs[key] = val;
                if (defaultValue !== val) {
                    obj.attrs[key] = val;
                }
            }

            obj.className = this.getClassName();
            return obj;
        },
        /**
         * convert Node into a JSON string.  Returns a JSON string.
         * @method
         * @memberof Konva.Node.prototype
         * @returns {String}}
         */
        toJSON: function() {
            return JSON.stringify(this.toObject());
        },
        /**
         * get parent container
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Node}
         */
        getParent: function() {
            return this.parent;
        },
        /**
         * get all ancestros (parent then parent of the parent, etc) of the node
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} [selector] selector for search
         * @param {Boolean} [includeSelf] show we think that node is ancestro itself?
         * @param {Konva.Node} [stopNode] optional node where we need to stop searching (one of ancestors)
         * @returns {Array} [ancestors]
         * @example
         * // get one of the parent group
         * var parentGroups = node.findAncestors('Group');
         */
        findAncestors: function(selector, includeSelf, stopNode) {
            var res = [];

            if (includeSelf && this._isMatch(selector)) {
                res.push(this);
            }
            var ancestor = this.parent;
            while(ancestor) {
                if (ancestor === stopNode) {
                    return res;
                }
                if (ancestor._isMatch(selector)) {
                    res.push(ancestor);
                }
                ancestor = ancestor.parent;
            }
            return res;
        },
        /**
         * get ancestor (parent or parent of the parent, etc) of the node that match passed selector
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} [selector] selector for search
         * @param {Boolean} [includeSelf] show we think that node is ancestro itself?
         * @param {Konva.Node} [stopNode] optional node where we need to stop searching (one of ancestors)
         * @returns {Konva.Node} ancestor
         * @example
         * // get one of the parent group
         * var group = node.findAncestors('.mygroup');
         */
        findAncestor: function(selector, includeSelf, stopNode) {
            return this.findAncestors(selector, includeSelf, stopNode)[0];
        },
        // is current node match passed selector?
        _isMatch: function(selector) {
            if (!selector) {
                return false;
            }
            var selectorArr = selector.replace(/ /g, '').split(','),
                len = selectorArr.length,
                n, sel;

            for (n = 0; n < len; n++) {
                sel = selectorArr[n];
                if (!Konva.Util.isValidSelector(sel)) {
                    Konva.Util.warn('Selector "' + sel + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".');
                    Konva.Util.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".');
                    Konva.Util.warn('Konva is awesome, right?');
                }
                // id selector
                if(sel.charAt(0) === '#') {
                    if (this.id() === sel.slice(1)) {
                        return true;
                    }
                }
                // name selector
                else if(sel.charAt(0) === '.') {
                    if (this.hasName(sel.slice(1))) {
                        return true;
                    }
                } else if (this._get(sel).length !== 0) {
                    return true;
                }
            }
            return false;
        },
        /**
         * get layer ancestor
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Layer}
         */
        getLayer: function() {
            var parent = this.getParent();
            return parent ? parent.getLayer() : null;
        },
        /**
         * get stage ancestor
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Stage}
         */
        getStage: function() {
            return this._getCache(STAGE, this._getStage);
        },
        _getStage: function() {
            var parent = this.getParent();
            if(parent) {
                return parent.getStage();
            }
            else {
                return undefined;
            }
        },
        /**
         * fire event
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} eventType event type.  can be a regular event, like click, mouseover, or mouseout, or it can be a custom event, like myCustomEvent
         * @param {Event} [evt] event object
         * @param {Boolean} [bubble] setting the value to false, or leaving it undefined, will result in the event
         *  not bubbling.  Setting the value to true will result in the event bubbling.
         * @returns {Konva.Node}
         * @example
         * // manually fire click event
         * node.fire('click');
         *
         * // fire custom event
         * node.fire('foo');
         *
         * // fire custom event with custom event object
         * node.fire('foo', {
         *   bar: 10
         * });
         *
         * // fire click event that bubbles
         * node.fire('click', null, true);
         */
        fire: function(eventType, evt, bubble) {
            evt = evt || {};
            evt.target = evt.target || this;
            // bubble
            if (bubble) {
                this._fireAndBubble(eventType, evt);
            }
            // no bubble
            else {
                this._fire(eventType, evt);
            }
            return this;
        },
        /**
         * get absolute transform of the node which takes into
         *  account its ancestor transforms
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Transform}
         */
        getAbsoluteTransform: function(top) {
            // if using an argument, we can't cache the result.
            if (top) {
                return this._getAbsoluteTransform(top);
            }
            // if no argument, we can cache the result
            else {
                return this._getCache(ABSOLUTE_TRANSFORM, this._getAbsoluteTransform);
            }
        },
        _getAbsoluteTransform: function(top) {
            var at = new Konva.Transform(),
                transformsEnabled, trans;

            // start with stage and traverse downwards to self
            this._eachAncestorReverse(function(node) {
                transformsEnabled = node.transformsEnabled();
                trans = node.getTransform();

                if (transformsEnabled === 'all') {
                    at.multiply(trans);
                }
                else if (transformsEnabled === 'position') {
                    at.translate(node.x(), node.y());
                }
            }, top);
            return at;
        },
        /**
         * get transform of the node
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Transform}
         */
        getTransform: function() {
            return this._getCache(TRANSFORM, this._getTransform);
        },
        _getTransform: function() {
            var m = new Konva.Transform(),
                x = this.getX(),
                y = this.getY(),
                rotation = Konva.getAngle(this.getRotation()),
                scaleX = this.getScaleX(),
                scaleY = this.getScaleY(),
                skewX = this.getSkewX(),
                skewY = this.getSkewY(),
                offsetX = this.getOffsetX(),
                offsetY = this.getOffsetY();

            if(x !== 0 || y !== 0) {
                m.translate(x, y);
            }
            if(rotation !== 0) {
                m.rotate(rotation);
            }
            if(skewX !== 0 || skewY !== 0) {
                m.skew(skewX, skewY);
            }
            if(scaleX !== 1 || scaleY !== 1) {
                m.scale(scaleX, scaleY);
            }
            if(offsetX !== 0 || offsetY !== 0) {
                m.translate(-1 * offsetX, -1 * offsetY);
            }

            return m;
        },
        /**
         * clone node.  Returns a new Node instance with identical attributes.  You can also override
         *  the node properties with an object literal, enabling you to use an existing node as a template
         *  for another node
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} obj override attrs
         * @returns {Konva.Node}
         * @example
         * // simple clone
         * var clone = node.clone();
         *
         * // clone a node and override the x position
         * var clone = rect.clone({
         *   x: 5
         * });
         */
        clone: function(obj) {
            // instantiate new node
            var attrs = Konva.Util.cloneObject(this.attrs),
                key, allListeners, len, n, listener;
            // filter black attrs
            for (var i in CLONE_BLACK_LIST) {
                var blockAttr = CLONE_BLACK_LIST[i];
                delete attrs[blockAttr];
            }
            // apply attr overrides
            for (key in obj) {
                attrs[key] = obj[key];
            }

            var node = new this.constructor(attrs);
            // copy over listeners
            for(key in this.eventListeners) {
                allListeners = this.eventListeners[key];
                len = allListeners.length;
                for(n = 0; n < len; n++) {
                    listener = allListeners[n];
                    /*
                     * don't include konva namespaced listeners because
                     *  these are generated by the constructors
                     */
                    if(listener.name.indexOf(KONVA) < 0) {
                        // if listeners array doesn't exist, then create it
                        if(!node.eventListeners[key]) {
                            node.eventListeners[key] = [];
                        }
                        node.eventListeners[key].push(listener);
                    }
                }
            }
            return node;
        },
        /**
         * Creates a composite data URL. If MIME type is not
         * specified, then "image/png" will result. For "image/jpeg", specify a quality
         * level as quality (range 0.0 - 1.0)
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} config
         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
         *  "image/png" is the default
         * @param {Number} [config.x] x position of canvas section
         * @param {Number} [config.y] y position of canvas section
         * @param {Number} [config.width] width of canvas section
         * @param {Number} [config.height] height of canvas section
         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
         *  is very high quality
         * @paremt {Number} [config.pixelRatio] pixelRatio of ouput image url. Default is 1
         * @returns {String}
         */
        toDataURL: function(config) {
            config = config || {};

            var mimeType = config.mimeType || null,
                quality = config.quality || null,
                stage = this.getStage(),
                x = config.x || 0,
                y = config.y || 0,
                pixelRatio = config.pixelRatio || 1,
                canvas = new Konva.SceneCanvas({
                    width: config.width || this.getWidth() || (stage ? stage.getWidth() : 0),
                    height: config.height || this.getHeight() || (stage ? stage.getHeight() : 0),
                    pixelRatio: pixelRatio
                }),
                context = canvas.getContext();

            context.save();

            if(x || y) {
                context.translate(-1 * x, -1 * y);
            }

            this.drawScene(canvas);
            context.restore();

            return canvas.toDataURL(mimeType, quality);
        },
        /**
         * converts node into an image.  Since the toImage
         *  method is asynchronous, a callback is required.  toImage is most commonly used
         *  to cache complex drawings as an image so that they don't have to constantly be redrawn
         * @method
         * @memberof Konva.Node.prototype
         * @param {Object} config
         * @param {Function} config.callback function executed when the composite has completed
         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
         *  "image/png" is the default
         * @param {Number} [config.x] x position of canvas section
         * @param {Number} [config.y] y position of canvas section
         * @param {Number} [config.width] width of canvas section
         * @param {Number} [config.height] height of canvas section
         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
         *  is very high quality
         * @paremt {Number} [config.pixelRatio] pixelRatio of ouput image.  Default is 1.
         * @example
         * var image = node.toImage({
         *   callback: function(img) {
         *     // do stuff with img
         *   }
         * });
         */
        toImage: function(config) {
            if (!config || !config.callback) {
                throw 'callback required for toImage method config argument';
            }
            Konva.Util._getImage(this.toDataURL(config), function(img) {
                config.callback(img);
            });
        },
        setSize: function(size) {
            this.setWidth(size.width);
            this.setHeight(size.height);
            return this;
        },
        getSize: function() {
            return {
                width: this.getWidth(),
                height: this.getHeight()
            };
        },
        getWidth: function() {
            return this.attrs.width || 0;
        },
        getHeight: function() {
            return this.attrs.height || 0;
        },
        /**
         * get class name, which may return Stage, Layer, Group, or shape class names like Rect, Circle, Text, etc.
         * @method
         * @memberof Konva.Node.prototype
         * @returns {String}
         */
        getClassName: function() {
            return this.className || this.nodeType;
        },
        /**
         * get the node type, which may return Stage, Layer, Group, or Node
         * @method
         * @memberof Konva.Node.prototype
         * @returns {String}
         */
        getType: function() {
            return this.nodeType;
        },
        getDragDistance: function() {
            // compare with undefined because we need to track 0 value
            if (this.attrs.dragDistance !== undefined) {
                return this.attrs.dragDistance;
            } else if (this.parent) {
                return this.parent.getDragDistance();
            } else {
                return Konva.dragDistance;
            }
        },
        _get: function(selector) {
            return this.className === selector || this.nodeType === selector ? [this] : [];
        },
        _off: function(type, name) {
            var evtListeners = this.eventListeners[type],
                i, evtName;

            for(i = 0; i < evtListeners.length; i++) {
                evtName = evtListeners[i].name;
                // the following two conditions must be true in order to remove a handler:
                // 1) the current event name cannot be konva unless the event name is konva
                //    this enables developers to force remove a konva specific listener for whatever reason
                // 2) an event name is not specified, or if one is specified, it matches the current event name
                if((evtName !== 'konva' || name === 'konva') && (!name || evtName === name)) {
                    evtListeners.splice(i, 1);
                    if(evtListeners.length === 0) {
                        delete this.eventListeners[type];
                        break;
                    }
                    i--;
                }
            }
        },
        _fireChangeEvent: function(attr, oldVal, newVal) {
            this._fire(attr + CHANGE, {
                oldVal: oldVal,
                newVal: newVal
            });
        },
        setId: function(id) {
            var oldId = this.getId();

            Konva._removeId(oldId);
            Konva._addId(this, id);
            this._setAttr(ID, id);
            return this;
        },
        setName: function(name) {
            var oldNames = (this.getName() || '').split(/\s/g);
            var newNames = (name || '').split(/\s/g);
            var subname, i;
            // remove all subnames
            for(i = 0; i < oldNames.length; i++) {
                subname = oldNames[i];
                if ((newNames.indexOf(subname)) === -1 && subname) {
                    Konva._removeName(subname, this._id);
                }
            }

            // add new names
            for(i = 0; i < newNames.length; i++) {
                subname = newNames[i];
                if ((oldNames.indexOf(subname) === -1) && subname) {
                    Konva._addName(this, subname);
                }
            }

            this._setAttr(NAME, name);
            return this;
        },
        // naming methods
        /**
         * add name to node
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} name
         * @returns {Konva.Node}
         * @example
         * node.name('red');
         * node.addName('selected');
         * node.name(); // return 'red selected'
         */
        addName: function(name) {
            if (!this.hasName(name)) {
                var oldName = this.name();
                var newName = oldName ? (oldName + ' ' + name) : name;
                this.setName(newName);
            }
            return this;
        },
        /**
         * check is node has name
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} name
         * @returns {Boolean}
         * @example
         * node.name('red');
         * node.hasName('red');   // return true
         * node.hasName('selected'); // return false
         */
        hasName: function(name) {
            var names = (this.name() || '').split(/\s/g);
            return names.indexOf(name) !== -1;
        },
        /**
         * remove name from node
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} name
         * @returns {Konva.Node}
         * @example
         * node.name('red selected');
         * node.removeName('selected');
         * node.hasName('selected'); // return false
         * node.name(); // return 'red'
         */
        removeName: function(name) {
            var names = (this.name() || '').split(/\s/g);
            var index = names.indexOf(name);
            if (index !== -1) {
                names.splice(index, 1);
                this.setName(names.join(' '));
            }
            return this;
        },
        /**
         * set attr
         * @method
         * @memberof Konva.Node.prototype
         * @param {String} attr
         * @param {*} val
         * @returns {Konva.Node}
         * @example
         * node.setAttr('x', 5);
         */
        setAttr: function(attr, val) {
            var method = SET + Konva.Util._capitalize(attr),
                func = this[method];

            if(Konva.Util._isFunction(func)) {
                func.call(this, val);
            }
            // otherwise set directly
            else {
                this._setAttr(attr, val);
            }
            return this;
        },
        _setAttr: function(key, val) {
            var oldVal;
            if(val !== undefined) {
                oldVal = this.attrs[key];
                if (oldVal === val) {
                    return;
                }
                this.attrs[key] = val;
                this._fireChangeEvent(key, oldVal, val);
            }
        },
        _setComponentAttr: function(key, component, val) {
            var oldVal;
            if(val !== undefined) {
                oldVal = this.attrs[key];

                if (!oldVal) {
                    // set value to default value using getAttr
                    this.attrs[key] = this.getAttr(key);
                }

                this.attrs[key][component] = val;
                this._fireChangeEvent(key, oldVal, val);
            }
        },
        _fireAndBubble: function(eventType, evt, compareShape) {
            var okayToRun = true;

            if(evt && this.nodeType === SHAPE) {
                evt.target = this;
            }

            if(eventType === MOUSEENTER && compareShape && (this._id === compareShape._id || (this.isAncestorOf && this.isAncestorOf(compareShape)))) {
                okayToRun = false;
            }
            else if(eventType === MOUSELEAVE && compareShape && (this._id === compareShape._id || (this.isAncestorOf && this.isAncestorOf(compareShape)))) {
                okayToRun = false;
            }
            if(okayToRun) {
                this._fire(eventType, evt);

                // simulate event bubbling
                var stopBubble = (eventType === MOUSEENTER || eventType === MOUSELEAVE) && ((compareShape && compareShape.isAncestorOf && compareShape.isAncestorOf(this)) || !!(compareShape && compareShape.isAncestorOf));
                if((evt && !evt.cancelBubble || !evt) && this.parent && this.parent.isListening() && (!stopBubble)) {
                    if(compareShape && compareShape.parent) {
                        this._fireAndBubble.call(this.parent, eventType, evt, compareShape.parent);
                    }
                    else {
                        this._fireAndBubble.call(this.parent, eventType, evt);
                    }
                }
            }
        },
        _fire: function(eventType, evt) {
            var events = this.eventListeners[eventType],
                i;

            evt = Konva.Util.cloneObject(evt || {});
            evt.currentTarget = this;
            evt.type = eventType;

            if (events) {
                for(i = 0; i < events.length; i++) {
                    events[i].handler.call(this, evt);
                }
            }
        },
        /**
         * draw both scene and hit graphs.  If the node being drawn is the stage, all of the layers will be cleared and redrawn
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Konva.Node}
         */
        draw: function() {
            this.drawScene();
            this.drawHit();
            return this;
        }
    });

    /**
     * create node with JSON string or an Object.  De-serializtion does not generate custom
     *  shape drawing functions, images, or event handlers (this would make the
     *  serialized object huge).  If your app uses custom shapes, images, and
     *  event handlers (it probably does), then you need to select the appropriate
     *  shapes after loading the stage and set these properties via on(), setDrawFunc(),
     *  and setImage() methods
     * @method
     * @memberof Konva.Node
     * @param {String|Object} json string or object
     * @param {Element} [container] optional container dom element used only if you're
     *  creating a stage node
     */
    Konva.Node.create = function(data, container) {
        if (Konva.Util._isString(data)) {
            data = JSON.parse(data);
        }
        return this._createNode(data, container);
    };
    Konva.Node._createNode = function(obj, container) {
        var className = Konva.Node.prototype.getClassName.call(obj),
            children = obj.children,
            no, len, n;

        // if container was passed in, add it to attrs
        if(container) {
            obj.attrs.container = container;
        }

        no = new Konva[className](obj.attrs);
        if(children) {
            len = children.length;
            for(n = 0; n < len; n++) {
                no.add(this._createNode(children[n]));
            }
        }

        return no;
    };


    // =========================== add getters setters ===========================

    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'position');
    /**
     * get/set node position relative to parent
     * @name position
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} pos
     * @param {Number} pos.x
     * @param {Number} pos.y
     * @returns {Object}
     * @example
     * // get position
     * var position = node.position();
     *
     * // set position
     * node.position({
     *   x: 5
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'x', 0);

    /**
     * get/set x position
     * @name x
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} x
     * @returns {Object}
     * @example
     * // get x
     * var x = node.x();
     *
     * // set x
     * node.x(5);
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'y', 0);

    /**
     * get/set y position
     * @name y
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} y
     * @returns {Integer}
     * @example
     * // get y
     * var y = node.y();
     *
     * // set y
     * node.y(5);
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'opacity', 1);

    /**
     * get/set opacity.  Opacity values range from 0 to 1.
     *  A node with an opacity of 0 is fully transparent, and a node
     *  with an opacity of 1 is fully opaque
     * @name opacity
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} opacity
     * @returns {Number}
     * @example
     * // get opacity
     * var opacity = node.opacity();
     *
     * // set opacity
     * node.opacity(0.5);
     */

    Konva.Factory.addGetter(Konva.Node, 'name');
    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'name');

    /**
     * get/set name
     * @name name
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} name
     * @returns {String}
     * @example
     * // get name
     * var name = node.name();
     *
     * // set name
     * node.name('foo');
     *
     * // also node may have multiple names (as css classes)
     * node.name('foo bar');
     */

    Konva.Factory.addGetter(Konva.Node, 'id');
    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'id');

    /**
     * get/set id. Id is global for whole page.
     * @name id
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} id
     * @returns {String}
     * @example
     * // get id
     * var name = node.id();
     *
     * // set id
     * node.id('foo');
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'rotation', 0);

    /**
     * get/set rotation in degrees
     * @name rotation
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} rotation
     * @returns {Number}
     * @example
     * // get rotation in degrees
     * var rotation = node.rotation();
     *
     * // set rotation in degrees
     * node.rotation(45);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Node, 'scale', ['x', 'y']);

    /**
     * get/set scale
     * @name scale
     * @param {Object} scale
     * @param {Number} scale.x
     * @param {Number} scale.y
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Object}
     * @example
     * // get scale
     * var scale = node.scale();
     *
     * // set scale
     * shape.scale({
     *   x: 2
     *   y: 3
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'scaleX', 1);

    /**
     * get/set scale x
     * @name scaleX
     * @param {Number} x
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Number}
     * @example
     * // get scale x
     * var scaleX = node.scaleX();
     *
     * // set scale x
     * node.scaleX(2);
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'scaleY', 1);

    /**
     * get/set scale y
     * @name scaleY
     * @param {Number} y
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Number}
     * @example
     * // get scale y
     * var scaleY = node.scaleY();
     *
     * // set scale y
     * node.scaleY(2);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Node, 'skew', ['x', 'y']);

    /**
     * get/set skew
     * @name skew
     * @param {Object} skew
     * @param {Number} skew.x
     * @param {Number} skew.y
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Object}
     * @example
     * // get skew
     * var skew = node.skew();
     *
     * // set skew
     * node.skew({
     *   x: 20
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'skewX', 0);

    /**
     * get/set skew x
     * @name skewX
     * @param {Number} x
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Number}
     * @example
     * // get skew x
     * var skewX = node.skewX();
     *
     * // set skew x
     * node.skewX(3);
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'skewY', 0);

    /**
     * get/set skew y
     * @name skewY
     * @param {Number} y
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Number}
     * @example
     * // get skew y
     * var skewY = node.skewY();
     *
     * // set skew y
     * node.skewY(3);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Node, 'offset', ['x', 'y']);

    /**
     * get/set offset.  Offsets the default position and rotation point
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} offset
     * @param {Number} offset.x
     * @param {Number} offset.y
     * @returns {Object}
     * @example
     * // get offset
     * var offset = node.offset();
     *
     * // set offset
     * node.offset({
     *   x: 20
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'offsetX', 0);

    /**
     * get/set offset x
     * @name offsetX
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get offset x
     * var offsetX = node.offsetX();
     *
     * // set offset x
     * node.offsetX(3);
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'offsetY', 0);

    /**
     * get/set offset y
     * @name offsetY
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get offset y
     * var offsetY = node.offsetY();
     *
     * // set offset y
     * node.offsetY(3);
     */

    Konva.Factory.addSetter(Konva.Node, 'dragDistance');
    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'dragDistance');

    /**
     * get/set drag distance
     * @name dragDistance
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} distance
     * @returns {Number}
     * @example
     * // get drag distance
     * var dragDistance = node.dragDistance();
     *
     * // set distance
     * // node starts dragging only if pointer moved more then 3 pixels
     * node.dragDistance(3);
     * // or set globally
     * Konva.dragDistance = 3;
     */


    Konva.Factory.addSetter(Konva.Node, 'width', 0);
    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'width');
    /**
     * get/set width
     * @name width
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} width
     * @returns {Number}
     * @example
     * // get width
     * var width = node.width();
     *
     * // set width
     * node.width(100);
     */

    Konva.Factory.addSetter(Konva.Node, 'height', 0);
    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'height');
    /**
     * get/set height
     * @name height
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} height
     * @returns {Number}
     * @example
     * // get height
     * var height = node.height();
     *
     * // set height
     * node.height(100);
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'listening', 'inherit');
    /**
     * get/set listenig attr.  If you need to determine if a node is listening or not
     *   by taking into account its parents, use the isListening() method
     * @name listening
     * @method
     * @memberof Konva.Node.prototype
     * @param {Boolean|String} listening Can be "inherit", true, or false.  The default is "inherit".
     * @returns {Boolean|String}
     * @example
     * // get listening attr
     * var listening = node.listening();
     *
     * // stop listening for events
     * node.listening(false);
     *
     * // listen for events
     * node.listening(true);
     *
     * // listen to events according to the parent
     * node.listening('inherit');
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'filters', undefined, function(val) {this._filterUpToDate = false; return val; });
    /**
     * get/set filters.  Filters are applied to cached canvases
     * @name filters
     * @method
     * @memberof Konva.Node.prototype
     * @param {Array} filters array of filters
     * @returns {Array}
     * @example
     * // get filters
     * var filters = node.filters();
     *
     * // set a single filter
     * node.cache();
     * node.filters([Konva.Filters.Blur]);
     *
     * // set multiple filters
     * node.cache();
     * node.filters([
     *   Konva.Filters.Blur,
     *   Konva.Filters.Sepia,
     *   Konva.Filters.Invert
     * ]);
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'visible', 'inherit');
    /**
     * get/set visible attr.  Can be "inherit", true, or false.  The default is "inherit".
     *   If you need to determine if a node is visible or not
     *   by taking into account its parents, use the isVisible() method
     * @name visible
     * @method
     * @memberof Konva.Node.prototype
     * @param {Boolean|String} visible
     * @returns {Boolean|String}
     * @example
     * // get visible attr
     * var visible = node.visible();
     *
     * // make invisible
     * node.visible(false);
     *
     * // make visible
     * node.visible(true);
     *
     * // make visible according to the parent
     * node.visible('inherit');
     */

    Konva.Factory.addGetterSetter(Konva.Node, 'transformsEnabled', 'all');

    /**
     * get/set transforms that are enabled.  Can be "all", "none", or "position".  The default
     *  is "all"
     * @name transformsEnabled
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} enabled
     * @returns {String}
     * @example
     * // enable position transform only to improve draw performance
     * node.transformsEnabled('position');
     *
     * // enable all transforms
     * node.transformsEnabled('all');
     */



    /**
     * get/set node size
     * @name size
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} size
     * @param {Number} size.width
     * @param {Number} size.height
     * @returns {Object}
     * @example
     * // get node size
     * var size = node.size();
     * var x = size.x;
     * var y = size.y;
     *
     * // set size
     * node.size({
     *   width: 100,
     *   height: 200
     * });
     */
    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'size');

    Konva.Factory.backCompat(Konva.Node, {
        rotateDeg: 'rotate',
        setRotationDeg: 'setRotation',
        getRotationDeg: 'getRotation'
    });

    Konva.Collection.mapMethods(Konva.Node);
})(Konva);

(function() {
    'use strict';
    /**
    * Grayscale Filter
    * @function
    * @memberof Konva.Filters
    * @param {Object} imageData
    * @example
    * node.cache();
    * node.filters([Konva.Filters.Grayscale]);
    */
    Konva.Filters.Grayscale = function(imageData) {
        var data = imageData.data,
            len = data.length,
            i, brightness;

        for(i = 0; i < len; i += 4) {
            brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
            // red
            data[i] = brightness;
            // green
            data[i + 1] = brightness;
            // blue
            data[i + 2] = brightness;
        }
    };
})();

(function() {
    'use strict';
    /**
     * Brighten Filter.
     * @function
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Brighten]);
     * node.brightness(0.8);
     */
    Konva.Filters.Brighten = function(imageData) {
        var brightness = this.brightness() * 255,
            data = imageData.data,
            len = data.length,
            i;

        for(i = 0; i < len; i += 4) {
            // red
            data[i] += brightness;
            // green
            data[i + 1] += brightness;
            // blue
            data[i + 2] += brightness;
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'brightness', 0, null, Konva.Factory.afterSetFilter);
    /**
    * get/set filter brightness.  The brightness is a number between -1 and 1.&nbsp; Positive values
    *  brighten the pixels and negative values darken them. Use with {@link Konva.Filters.Brighten} filter.
    * @name brightness
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} brightness value between -1 and 1
    * @returns {Number}
    */

})();

(function() {
    'use strict';
    /**
    * Invert Filter
    * @function
    * @memberof Konva.Filters
    * @param {Object} imageData
    * @example
    * node.cache();
    * node.filters([Konva.Filters.Invert]);
    */
    Konva.Filters.Invert = function(imageData) {
        var data = imageData.data,
            len = data.length,
            i;

        for(i = 0; i < len; i += 4) {
            // red
            data[i] = 255 - data[i];
            // green
            data[i + 1] = 255 - data[i + 1];
            // blue
            data[i + 2] = 255 - data[i + 2];
        }
    };
})();

/*
 the Gauss filter
 master repo: https://github.com/pavelpower/kineticjsGaussFilter
*/
(function() {
    'use strict';
    /*

     StackBlur - a fast almost Gaussian Blur For Canvas

     Version:   0.5
     Author:    Mario Klingemann
     Contact:   mario@quasimondo.com
     Website:   http://www.quasimondo.com/StackBlurForCanvas
     Twitter:   @quasimondo

     In case you find this class useful - especially in commercial projects -
     I am not totally unhappy for a small donation to my PayPal account
     mario@quasimondo.de

     Or support me on flattr:
     https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

     Copyright (c) 2010 Mario Klingemann

     Permission is hereby granted, free of charge, to any person
     obtaining a copy of this software and associated documentation
     files (the "Software"), to deal in the Software without
     restriction, including without limitation the rights to use,
     copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the
     Software is furnished to do so, subject to the following
     conditions:

     The above copyright notice and this permission notice shall be
     included in all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
     OTHER DEALINGS IN THE SOFTWARE.
     */

    function BlurStack() {
        this.r = 0;
        this.g = 0;
        this.b = 0;
        this.a = 0;
        this.next = null;
    }

    var mul_table = [
        512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512,
        454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512,
        482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456,
        437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512,
        497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328,
        320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456,
        446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335,
        329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512,
        505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405,
        399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328,
        324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271,
        268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456,
        451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388,
        385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335,
        332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292,
        289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259
    ];

    var shg_table = [
        9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17,
        17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,
        19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
        20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
        21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
        21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,
        22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
        22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23,
        23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
        23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
        23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
        23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24
    ];

    function filterGaussBlurRGBA( imageData, radius) {

        var pixels = imageData.data,
            width = imageData.width,
            height = imageData.height;

        var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum,
            r_out_sum, g_out_sum, b_out_sum, a_out_sum,
            r_in_sum, g_in_sum, b_in_sum, a_in_sum,
            pr, pg, pb, pa, rbs;

        var div = radius + radius + 1,
            widthMinus1 = width - 1,
            heightMinus1 = height - 1,
            radiusPlus1 = radius + 1,
            sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2,
            stackStart = new BlurStack(),
            stackEnd = null,
            stack = stackStart,
            stackIn = null,
            stackOut = null,
            mul_sum = mul_table[radius],
            shg_sum = shg_table[radius];

        for ( i = 1; i < div; i++ ) {
            stack = stack.next = new BlurStack();
            if ( i === radiusPlus1 ){
                stackEnd = stack;
            }
        }

        stack.next = stackStart;

        yw = yi = 0;

        for ( y = 0; y < height; y++ )
        {
            r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;

            r_out_sum = radiusPlus1 * ( pr = pixels[yi] );
            g_out_sum = radiusPlus1 * ( pg = pixels[yi + 1] );
            b_out_sum = radiusPlus1 * ( pb = pixels[yi + 2] );
            a_out_sum = radiusPlus1 * ( pa = pixels[yi + 3] );

            r_sum += sumFactor * pr;
            g_sum += sumFactor * pg;
            b_sum += sumFactor * pb;
            a_sum += sumFactor * pa;

            stack = stackStart;

            for( i = 0; i < radiusPlus1; i++ )
            {
                stack.r = pr;
                stack.g = pg;
                stack.b = pb;
                stack.a = pa;
                stack = stack.next;
            }

            for( i = 1; i < radiusPlus1; i++ )
            {
                p = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );
                r_sum += ( stack.r = ( pr = pixels[p])) * ( rbs = radiusPlus1 - i );
                g_sum += ( stack.g = ( pg = pixels[p + 1])) * rbs;
                b_sum += ( stack.b = ( pb = pixels[p + 2])) * rbs;
                a_sum += ( stack.a = ( pa = pixels[p + 3])) * rbs;

                r_in_sum += pr;
                g_in_sum += pg;
                b_in_sum += pb;
                a_in_sum += pa;

                stack = stack.next;
            }


            stackIn = stackStart;
            stackOut = stackEnd;
            for ( x = 0; x < width; x++ )
            {
                pixels[yi + 3] = pa = (a_sum * mul_sum) >> shg_sum;
                if ( pa !== 0 )
                {
                    pa = 255 / pa;
                    pixels[yi] = ((r_sum * mul_sum) >> shg_sum) * pa;
                    pixels[yi + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
                    pixels[yi + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
                } else {
                    pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
                }

                r_sum -= r_out_sum;
                g_sum -= g_out_sum;
                b_sum -= b_out_sum;
                a_sum -= a_out_sum;

                r_out_sum -= stackIn.r;
                g_out_sum -= stackIn.g;
                b_out_sum -= stackIn.b;
                a_out_sum -= stackIn.a;

                p = (yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;

                r_in_sum += ( stackIn.r = pixels[p]);
                g_in_sum += ( stackIn.g = pixels[p + 1]);
                b_in_sum += ( stackIn.b = pixels[p + 2]);
                a_in_sum += ( stackIn.a = pixels[p + 3]);

                r_sum += r_in_sum;
                g_sum += g_in_sum;
                b_sum += b_in_sum;
                a_sum += a_in_sum;

                stackIn = stackIn.next;

                r_out_sum += ( pr = stackOut.r );
                g_out_sum += ( pg = stackOut.g );
                b_out_sum += ( pb = stackOut.b );
                a_out_sum += ( pa = stackOut.a );

                r_in_sum -= pr;
                g_in_sum -= pg;
                b_in_sum -= pb;
                a_in_sum -= pa;

                stackOut = stackOut.next;

                yi += 4;
            }
            yw += width;
        }


        for ( x = 0; x < width; x++ )
        {
            g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;

            yi = x << 2;
            r_out_sum = radiusPlus1 * ( pr = pixels[yi]);
            g_out_sum = radiusPlus1 * ( pg = pixels[yi + 1]);
            b_out_sum = radiusPlus1 * ( pb = pixels[yi + 2]);
            a_out_sum = radiusPlus1 * ( pa = pixels[yi + 3]);

            r_sum += sumFactor * pr;
            g_sum += sumFactor * pg;
            b_sum += sumFactor * pb;
            a_sum += sumFactor * pa;

            stack = stackStart;

            for( i = 0; i < radiusPlus1; i++ )
            {
                stack.r = pr;
                stack.g = pg;
                stack.b = pb;
                stack.a = pa;
                stack = stack.next;
            }

            yp = width;

            for( i = 1; i <= radius; i++ )
            {
                yi = ( yp + x ) << 2;

                r_sum += ( stack.r = ( pr = pixels[yi])) * ( rbs = radiusPlus1 - i );
                g_sum += ( stack.g = ( pg = pixels[yi + 1])) * rbs;
                b_sum += ( stack.b = ( pb = pixels[yi + 2])) * rbs;
                a_sum += ( stack.a = ( pa = pixels[yi + 3])) * rbs;

                r_in_sum += pr;
                g_in_sum += pg;
                b_in_sum += pb;
                a_in_sum += pa;

                stack = stack.next;

                if( i < heightMinus1 )
                {
                    yp += width;
                }
            }

            yi = x;
            stackIn = stackStart;
            stackOut = stackEnd;
            for ( y = 0; y < height; y++ )
            {
                p = yi << 2;
                pixels[p + 3] = pa = (a_sum * mul_sum) >> shg_sum;
                if ( pa > 0 )
                {
                    pa = 255 / pa;
                    pixels[p] = ((r_sum * mul_sum) >> shg_sum ) * pa;
                    pixels[p + 1] = ((g_sum * mul_sum) >> shg_sum ) * pa;
                    pixels[p + 2] = ((b_sum * mul_sum) >> shg_sum ) * pa;
                } else {
                    pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
                }

                r_sum -= r_out_sum;
                g_sum -= g_out_sum;
                b_sum -= b_out_sum;
                a_sum -= a_out_sum;

                r_out_sum -= stackIn.r;
                g_out_sum -= stackIn.g;
                b_out_sum -= stackIn.b;
                a_out_sum -= stackIn.a;

                p = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;

                r_sum += ( r_in_sum += ( stackIn.r = pixels[p]));
                g_sum += ( g_in_sum += ( stackIn.g = pixels[p + 1]));
                b_sum += ( b_in_sum += ( stackIn.b = pixels[p + 2]));
                a_sum += ( a_in_sum += ( stackIn.a = pixels[p + 3]));

                stackIn = stackIn.next;

                r_out_sum += ( pr = stackOut.r );
                g_out_sum += ( pg = stackOut.g );
                b_out_sum += ( pb = stackOut.b );
                a_out_sum += ( pa = stackOut.a );

                r_in_sum -= pr;
                g_in_sum -= pg;
                b_in_sum -= pb;
                a_in_sum -= pa;

                stackOut = stackOut.next;

                yi += width;
            }
        }
    }

    /**
     * Blur Filter
     * @function
     * @name Blur
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Blur]);
     * node.blurRadius(10);
     */
    Konva.Filters.Blur = function Blur(imageData) {
        var radius = Math.round(this.blurRadius());

        if (radius > 0) {
            filterGaussBlurRGBA(imageData, radius);
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'blurRadius', 0, null, Konva.Factory.afterSetFilter);

    /**
    * get/set blur radius. Use with {@link Konva.Filters.Blur} filter
    * @name blurRadius
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} radius
    * @returns {Integer}
    */
})();

/*eslint-disable  max-depth */
(function() {
	'use strict';
	function pixelAt(idata, x, y) {
		var idx = (y * idata.width + x) * 4;
		var d = [];
		d.push(idata.data[idx++], idata.data[idx++], idata.data[idx++], idata.data[idx++]);
		return d;
	}

	function rgbDistance(p1, p2) {
		return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2) + Math.pow(p1[2] - p2[2], 2));
	}

	function rgbMean(pTab) {
		var m = [0, 0, 0];

		for (var i = 0; i < pTab.length; i++) {
			m[0] += pTab[i][0];
			m[1] += pTab[i][1];
			m[2] += pTab[i][2];
		}

		m[0] /= pTab.length;
		m[1] /= pTab.length;
		m[2] /= pTab.length;

		return m;
	}

	function backgroundMask(idata, threshold) {
		var rgbv_no = pixelAt(idata, 0, 0);
		var rgbv_ne = pixelAt(idata, idata.width - 1, 0);
		var rgbv_so = pixelAt(idata, 0, idata.height - 1);
		var rgbv_se = pixelAt(idata, idata.width - 1, idata.height - 1);


		var thres = threshold || 10;
		if (rgbDistance(rgbv_no, rgbv_ne) < thres && rgbDistance(rgbv_ne, rgbv_se) < thres && rgbDistance(rgbv_se, rgbv_so) < thres && rgbDistance(rgbv_so, rgbv_no) < thres) {

			// Mean color
			var mean = rgbMean([rgbv_ne, rgbv_no, rgbv_se, rgbv_so]);

			// Mask based on color distance
			var mask = [];
			for (var i = 0; i < idata.width * idata.height; i++) {
				var d = rgbDistance(mean, [idata.data[i * 4], idata.data[i * 4 + 1], idata.data[i * 4 + 2]]);
				mask[i] = (d < thres) ? 0 : 255;
			}

			return mask;
		}
	}

	function applyMask(idata, mask) {
		for (var i = 0; i < idata.width * idata.height; i++) {
			idata.data[4 * i + 3] = mask[i];
		}
	}

	function erodeMask(mask, sw, sh) {

		var weights = [1, 1, 1, 1, 0, 1, 1, 1, 1];
		var side = Math.round(Math.sqrt(weights.length));
		var halfSide = Math.floor(side / 2);

		var maskResult = [];
		for (var y = 0; y < sh; y++) {
			for (var x = 0; x < sw; x++) {

				var so = y * sw + x;
				var a = 0;
				for (var cy = 0; cy < side; cy++) {
					for (var cx = 0; cx < side; cx++) {
						var scy = y + cy - halfSide;
						var scx = x + cx - halfSide;

						if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {

							var srcOff = scy * sw + scx;
							var wt = weights[cy * side + cx];

							a += mask[srcOff] * wt;
						}
					}
				}

				maskResult[so] = (a === 255 * 8) ? 255 : 0;
			}
		}

		return maskResult;
	}

	function dilateMask(mask, sw, sh) {

		var weights = [1, 1, 1, 1, 1, 1, 1, 1, 1];
		var side = Math.round(Math.sqrt(weights.length));
		var halfSide = Math.floor(side / 2);

		var maskResult = [];
		for (var y = 0; y < sh; y++) {
			for (var x = 0; x < sw; x++) {

				var so = y * sw + x;
				var a = 0;
				for (var cy = 0; cy < side; cy++) {
					for (var cx = 0; cx < side; cx++) {
						var scy = y + cy - halfSide;
						var scx = x + cx - halfSide;

						if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {

							var srcOff = scy * sw + scx;
							var wt = weights[cy * side + cx];

							a += mask[srcOff] * wt;
						}
					}
				}

				maskResult[so] = (a >= 255 * 4) ? 255 : 0;
			}
		}

		return maskResult;
	}

	function smoothEdgeMask(mask, sw, sh) {

		var weights = [1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9];
		var side = Math.round(Math.sqrt(weights.length));
		var halfSide = Math.floor(side / 2);

		var maskResult = [];
		for (var y = 0; y < sh; y++) {
			for (var x = 0; x < sw; x++) {

				var so = y * sw + x;
				var a = 0;
				for (var cy = 0; cy < side; cy++) {
					for (var cx = 0; cx < side; cx++) {
						var scy = y + cy - halfSide;
						var scx = x + cx - halfSide;

						if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {

							var srcOff = scy * sw + scx;
							var wt = weights[cy * side + cx];

							a += mask[srcOff] * wt;
						}
					}
				}

				maskResult[so] = a;
			}
		}

		return maskResult;
	}

	/**
	 * Mask Filter
	 * @function
	 * @name Mask
	 * @memberof Konva.Filters
	 * @param {Object} imageData
	 * @example
     * node.cache();
     * node.filters([Konva.Filters.Mask]);
     * node.threshold(200);
	 */
	Konva.Filters.Mask = function(imageData) {
		// Detect pixels close to the background color
		var threshold = this.threshold(),
        mask = backgroundMask(imageData, threshold);
		if (mask) {
			// Erode
			mask = erodeMask(mask, imageData.width, imageData.height);

			// Dilate
			mask = dilateMask(mask, imageData.width, imageData.height);

			// Gradient
			mask = smoothEdgeMask(mask, imageData.width, imageData.height);

			// Apply mask
			applyMask(imageData, mask);

			// todo : Update hit region function according to mask
		}

		return imageData;
	};

	Konva.Factory.addGetterSetter(Konva.Node, 'threshold', 0, null, Konva.Factory.afterSetFilter);
})();

(function () {
    'use strict';
    /**
     * RGB Filter
     * @function
     * @name RGB
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author ippo615
     * @example
     * node.cache();
     * node.filters([Konva.Filters.RGB]);
     * node.blue(120);
     * node.green(200);
     */
    Konva.Filters.RGB = function (imageData) {
        var data = imageData.data,
            nPixels = data.length,
            red = this.red(),
            green = this.green(),
            blue = this.blue(),
            i, brightness;

        for (i = 0; i < nPixels; i += 4) {
            brightness = (0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2]) / 255;
            data[i] = brightness * red; // r
            data[i + 1] = brightness * green; // g
            data[i + 2] = brightness * blue; // b
            data[i + 3] = data[i + 3]; // alpha
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'red', 0, function(val) {
        this._filterUpToDate = false;
        if (val > 255) {
            return 255;
        }
        else if (val < 0) {
            return 0;
        }
        else {
            return Math.round(val);
        }
    });
    /**
    * get/set filter red value. Use with {@link Konva.Filters.RGB} filter.
    * @name red
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} red value between 0 and 255
    * @returns {Integer}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'green', 0, function(val) {
        this._filterUpToDate = false;
        if (val > 255) {
            return 255;
        }
        else if (val < 0) {
            return 0;
        }
        else {
            return Math.round(val);
        }
    });
    /**
    * get/set filter green value. Use with {@link Konva.Filters.RGB} filter.
    * @name green
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} green value between 0 and 255
    * @returns {Integer}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'blue', 0, Konva.Validators.RGBComponent, Konva.Factory.afterSetFilter);
    /**
    * get/set filter blue value. Use with {@link Konva.Filters.RGB} filter.
    * @name blue
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} blue value between 0 and 255
    * @returns {Integer}
    */
})();

(function () {
    'use strict';
    /**
     * RGBA Filter
     * @function
     * @name RGBA
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author codefo
     * @example
     * node.cache();
     * node.filters([Konva.Filters.RGBA]);
     * node.blue(120);
     * node.green(200);
     * node.alpha(0.3);
     */
    Konva.Filters.RGBA = function (imageData) {
        var data = imageData.data,
            nPixels = data.length,
            red = this.red(),
            green = this.green(),
            blue = this.blue(),
            alpha = this.alpha(),
            i, ia;

        for (i = 0; i < nPixels; i += 4) {
            ia = 1 - alpha;

            data[i] = red * alpha + data[i] * ia; // r
            data[i + 1] = green * alpha + data[i + 1] * ia; // g
            data[i + 2] = blue * alpha + data[i + 2] * ia; // b
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'red', 0, function(val) {
        this._filterUpToDate = false;
        if (val > 255) {
            return 255;
        }
        else if (val < 0) {
            return 0;
        }
        else {
            return Math.round(val);
        }
    });
    /**
    * get/set filter red value. Use with {@link Konva.Filters.RGBA} filter.
    * @name red
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} red value between 0 and 255
    * @returns {Integer}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'green', 0, function(val) {
        this._filterUpToDate = false;
        if (val > 255) {
            return 255;
        }
        else if (val < 0) {
            return 0;
        }
        else {
            return Math.round(val);
        }
    });
    /**
    * get/set filter green value. Use with {@link Konva.Filters.RGBA} filter.
    * @name green
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} green value between 0 and 255
    * @returns {Integer}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'blue', 0, Konva.Validators.RGBComponent, Konva.Factory.afterSetFilter);
    /**
    * get/set filter blue value. Use with {@link Konva.Filters.RGBA} filter.
    * @name blue
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} blue value between 0 and 255
    * @returns {Integer}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'alpha', 1, function(val) {
        this._filterUpToDate = false;
        if (val > 1) {
            return 1;
        }
        else if (val < 0) {
            return 0;
        }
        else {
            return val;
        }
    });
    /**
     * get/set filter alpha value. Use with {@link Konva.Filters.RGBA} filter.
     * @name alpha
     * @method
     * @memberof Konva.Node.prototype
     * @param {Float} alpha value between 0 and 1
     * @returns {Float}
     */
})();

(function () {
    'use strict';
    /**
    * HSV Filter. Adjusts the hue, saturation and value
    * @function
    * @name HSV
    * @memberof Konva.Filters
    * @param {Object} imageData
    * @author ippo615
    * @example
    * image.filters([Konva.Filters.HSV]);
    * image.value(200);
    */

    Konva.Filters.HSV = function (imageData) {
        var data = imageData.data,
            nPixels = data.length,
            v = Math.pow(2, this.value()),
            s = Math.pow(2, this.saturation()),
            h = Math.abs((this.hue()) + 360) % 360,
            i;

        // Basis for the technique used:
        // http://beesbuzz.biz/code/hsv_color_transforms.php
        // V is the value multiplier (1 for none, 2 for double, 0.5 for half)
        // S is the saturation multiplier (1 for none, 2 for double, 0.5 for half)
        // H is the hue shift in degrees (0 to 360)
        // vsu = V*S*cos(H*PI/180);
        // vsw = V*S*sin(H*PI/180);
        //[ .299V+.701vsu+.168vsw    .587V-.587vsu+.330vsw    .114V-.114vsu-.497vsw ] [R]
        //[ .299V-.299vsu-.328vsw    .587V+.413vsu+.035vsw    .114V-.114vsu+.292vsw ]*[G]
        //[ .299V-.300vsu+1.25vsw    .587V-.588vsu-1.05vsw    .114V+.886vsu-.203vsw ] [B]

        // Precompute the values in the matrix:
        var vsu = v * s * Math.cos(h * Math.PI / 180),
            vsw = v * s * Math.sin(h * Math.PI / 180);
        // (result spot)(source spot)
        var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw,
            rg = 0.587 * v - 0.587 * vsu + 0.330 * vsw,
            rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
        var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw,
            gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw,
            gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
        var br = 0.299 * v - 0.300 * vsu + 1.250 * vsw,
            bg = 0.587 * v - 0.586 * vsu - 1.050 * vsw,
            bb = 0.114 * v + 0.886 * vsu - 0.200 * vsw;

        var r, g, b, a;

        for (i = 0; i < nPixels; i += 4) {
            r = data[i + 0];
            g = data[i + 1];
            b = data[i + 2];
            a = data[i + 3];

            data[i + 0] = rr * r + rg * g + rb * b;
            data[i + 1] = gr * r + gg * g + gb * b;
            data[i + 2] = br * r + bg * g + bb * b;
            data[i + 3] = a; // alpha
        }

    };

    Konva.Factory.addGetterSetter(Konva.Node, 'hue', 0, null, Konva.Factory.afterSetFilter);
    /**
    * get/set hsv hue in degrees. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
    * @name hue
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} hue value between 0 and 359
    * @returns {Number}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'saturation', 0, null, Konva.Factory.afterSetFilter);
    /**
    * get/set hsv saturation. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
    * @name saturation
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} saturation 0 is no change, -1.0 halves the saturation, 1.0 doubles, etc..
    * @returns {Number}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'value', 0, null, Konva.Factory.afterSetFilter);
    /**
    * get/set hsv value. Use with {@link Konva.Filters.HSV} filter.
    * @name value
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} value 0 is no change, -1.0 halves the value, 1.0 doubles, etc..
    * @returns {Number}
    */

})();

(function () {
    'use strict';

    Konva.Factory.addGetterSetter(Konva.Node, 'hue', 0, null, Konva.Factory.afterSetFilter);
    /**
    * get/set hsv hue in degrees. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
    * @name hue
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} hue value between 0 and 359
    * @returns {Number}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'saturation', 0, null, Konva.Factory.afterSetFilter);
    /**
    * get/set hsv saturation. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
    * @name saturation
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} saturation 0 is no change, -1.0 halves the saturation, 1.0 doubles, etc..
    * @returns {Number}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'luminance', 0, null, Konva.Factory.afterSetFilter);
    /**
    * get/set hsl luminance. Use with {@link Konva.Filters.HSL} filter.
    * @name value
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} value 0 is no change, -1.0 halves the value, 1.0 doubles, etc..
    * @returns {Number}
    */

    /**
    * HSL Filter. Adjusts the hue, saturation and luminance (or lightness)
    * @function
    * @memberof Konva.Filters
    * @param {Object} imageData
    * @author ippo615
    * @example
    * image.filters([Konva.Filters.HSL]);
    * image.luminance(200);
    */

    Konva.Filters.HSL = function (imageData) {
        var data = imageData.data,
            nPixels = data.length,
            v = 1,
            s = Math.pow(2, this.saturation()),
            h = Math.abs((this.hue()) + 360) % 360,
            l = this.luminance() * 127,
            i;

        // Basis for the technique used:
        // http://beesbuzz.biz/code/hsv_color_transforms.php
        // V is the value multiplier (1 for none, 2 for double, 0.5 for half)
        // S is the saturation multiplier (1 for none, 2 for double, 0.5 for half)
        // H is the hue shift in degrees (0 to 360)
        // vsu = V*S*cos(H*PI/180);
        // vsw = V*S*sin(H*PI/180);
        //[ .299V+.701vsu+.168vsw    .587V-.587vsu+.330vsw    .114V-.114vsu-.497vsw ] [R]
        //[ .299V-.299vsu-.328vsw    .587V+.413vsu+.035vsw    .114V-.114vsu+.292vsw ]*[G]
        //[ .299V-.300vsu+1.25vsw    .587V-.588vsu-1.05vsw    .114V+.886vsu-.203vsw ] [B]

        // Precompute the values in the matrix:
        var vsu = v * s * Math.cos(h * Math.PI / 180),
            vsw = v * s * Math.sin(h * Math.PI / 180);
        // (result spot)(source spot)
        var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw,
            rg = 0.587 * v - 0.587 * vsu + 0.330 * vsw,
            rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
        var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw,
            gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw,
            gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
        var br = 0.299 * v - 0.300 * vsu + 1.250 * vsw,
            bg = 0.587 * v - 0.586 * vsu - 1.050 * vsw,
            bb = 0.114 * v + 0.886 * vsu - 0.200 * vsw;

        var r, g, b, a;

        for (i = 0; i < nPixels; i += 4) {
            r = data[i + 0];
            g = data[i + 1];
            b = data[i + 2];
            a = data[i + 3];

            data[i + 0] = rr * r + rg * g + rb * b + l;
            data[i + 1] = gr * r + gg * g + gb * b + l;
            data[i + 2] = br * r + bg * g + bb * b + l;
            data[i + 3] = a; // alpha
        }
    };
})();

(function () {
    'use strict';
    /**
     * Emboss Filter.
     * Pixastic Lib - Emboss filter - v0.1.0
     * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
     * License: [http://www.pixastic.com/lib/license.txt]
     * @function
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Emboss]);
     * node.embossStrength(0.8);
     * node.embossWhiteLevel(0.3);
     * node.embossDirection('right');
     * node.embossBlend(true);
     */
    Konva.Filters.Emboss = function (imageData) {

        // pixastic strength is between 0 and 10.  I want it between 0 and 1
        // pixastic greyLevel is between 0 and 255.  I want it between 0 and 1.  Also,
        // a max value of greyLevel yields a white emboss, and the min value yields a black
        // emboss.  Therefore, I changed greyLevel to whiteLevel
        var strength = this.embossStrength() * 10,
            greyLevel = this.embossWhiteLevel() * 255,
            direction = this.embossDirection(),
            blend = this.embossBlend(),
            dirY = 0,
            dirX = 0,
            data = imageData.data,
            w = imageData.width,
            h = imageData.height,
            w4 = w * 4,
            y = h;

        switch (direction) {
            case 'top-left':
                dirY = -1;
                dirX = -1;
                break;
            case 'top':
                dirY = -1;
                dirX = 0;
                break;
            case 'top-right':
                dirY = -1;
                dirX = 1;
                break;
            case 'right':
                dirY = 0;
                dirX = 1;
                break;
            case 'bottom-right':
                dirY = 1;
                dirX = 1;
                break;
            case 'bottom':
                dirY = 1;
                dirX = 0;
                break;
            case 'bottom-left':
                dirY = 1;
                dirX = -1;
                break;
            case 'left':
                dirY = 0;
                dirX = -1;
                break;
        }

        do {
            var offsetY = (y - 1) * w4;

            var otherY = dirY;
            if (y + otherY < 1){
                otherY = 0;
            }
            if (y + otherY > h) {
                otherY = 0;
            }

            var offsetYOther = (y - 1 + otherY) * w * 4;

            var x = w;
            do {
                var offset = offsetY + (x - 1) * 4;

                var otherX = dirX;
                if (x + otherX < 1){
                    otherX = 0;
                }
                if (x + otherX > w) {
                    otherX = 0;
                }

                var offsetOther = offsetYOther + (x - 1 + otherX) * 4;

                var dR = data[offset] - data[offsetOther];
                var dG = data[offset + 1] - data[offsetOther + 1];
                var dB = data[offset + 2] - data[offsetOther + 2];

                var dif = dR;
                var absDif = dif > 0 ? dif : -dif;

                var absG = dG > 0 ? dG : -dG;
                var absB = dB > 0 ? dB : -dB;

                if (absG > absDif) {
                    dif = dG;
                }
                if (absB > absDif) {
                    dif = dB;
                }

                dif *= strength;

                if (blend) {
                    var r = data[offset] + dif;
                    var g = data[offset + 1] + dif;
                    var b = data[offset + 2] + dif;

                    data[offset] = (r > 255) ? 255 : (r < 0 ? 0 : r);
                    data[offset + 1] = (g > 255) ? 255 : (g < 0 ? 0 : g);
                    data[offset + 2] = (b > 255) ? 255 : (b < 0 ? 0 : b);
                } else {
                    var grey = greyLevel - dif;
                    if (grey < 0) {
                        grey = 0;
                    } else if (grey > 255) {
                        grey = 255;
                    }

                    data[offset] = data[offset + 1] = data[offset + 2] = grey;
                }

            } while (--x);
        } while (--y);
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'embossStrength', 0.5, null, Konva.Factory.afterSetFilter);
    /**
    * get/set emboss strength. Use with {@link Konva.Filters.Emboss} filter.
    * @name embossStrength
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} level between 0 and 1.  Default is 0.5
    * @returns {Number}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'embossWhiteLevel', 0.5, null, Konva.Factory.afterSetFilter);
    /**
    * get/set emboss white level. Use with {@link Konva.Filters.Emboss} filter.
    * @name embossWhiteLevel
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} embossWhiteLevel between 0 and 1.  Default is 0.5
    * @returns {Number}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'embossDirection', 'top-left', null, Konva.Factory.afterSetFilter);
    /**
    * get/set emboss direction. Use with {@link Konva.Filters.Emboss} filter.
    * @name embossDirection
    * @method
    * @memberof Konva.Node.prototype
    * @param {String} embossDirection can be top-left, top, top-right, right, bottom-right, bottom, bottom-left or left
    *   The default is top-left
    * @returns {String}
    */

    Konva.Factory.addGetterSetter(Konva.Node, 'embossBlend', false, null, Konva.Factory.afterSetFilter);
    /**
    * get/set emboss blend. Use with {@link Konva.Filters.Emboss} filter.
    * @name embossBlend
    * @method
    * @memberof Konva.Node.prototype
    * @param {Boolean} embossBlend
    * @returns {Boolean}
    */
})();

(function () {
    'use strict';
    function remap(fromValue, fromMin, fromMax, toMin, toMax) {
        // Compute the range of the data
        var fromRange = fromMax - fromMin,
          toRange = toMax - toMin,
          toValue;

        // If either range is 0, then the value can only be mapped to 1 value
        if (fromRange === 0) {
            return toMin + toRange / 2;
        }
        if (toRange === 0) {
            return toMin;
        }

        // (1) untranslate, (2) unscale, (3) rescale, (4) retranslate
        toValue = (fromValue - fromMin) / fromRange;
        toValue = (toRange * toValue) + toMin;

        return toValue;
    }


    /**
    * Enhance Filter. Adjusts the colors so that they span the widest
    *  possible range (ie 0-255). Performs w*h pixel reads and w*h pixel
    *  writes.
    * @function
    * @name Enhance
    * @memberof Konva.Filters
    * @param {Object} imageData
    * @author ippo615
    * @example
    * node.cache();
    * node.filters([Konva.Filters.Enhance]);
    * node.enhance(0.4);
    */
    Konva.Filters.Enhance = function (imageData) {
        var data = imageData.data,
            nSubPixels = data.length,
            rMin = data[0], rMax = rMin, r,
            gMin = data[1], gMax = gMin, g,
            bMin = data[2], bMax = bMin, b,
            i;

        // If we are not enhancing anything - don't do any computation
        var enhanceAmount = this.enhance();
        if( enhanceAmount === 0 ){ return; }

        // 1st Pass - find the min and max for each channel:
        for (i = 0; i < nSubPixels; i += 4) {
            r = data[i + 0];
            if (r < rMin) { rMin = r; }
            else if (r > rMax) { rMax = r; }
            g = data[i + 1];
            if (g < gMin) { gMin = g; } else
            if (g > gMax) { gMax = g; }
            b = data[i + 2];
            if (b < bMin) { bMin = b; } else
            if (b > bMax) { bMax = b; }
            //a = data[i + 3];
            //if (a < aMin) { aMin = a; } else
            //if (a > aMax) { aMax = a; }
        }

        // If there is only 1 level - don't remap
        if( rMax === rMin ){ rMax = 255; rMin = 0; }
        if( gMax === gMin ){ gMax = 255; gMin = 0; }
        if( bMax === bMin ){ bMax = 255; bMin = 0; }

        var rMid, rGoalMax, rGoalMin,
            gMid, gGoalMax, gGoalMin,
            bMid, bGoalMax, bGoalMin;

        // If the enhancement is positive - stretch the histogram
        if ( enhanceAmount > 0 ){
            rGoalMax = rMax + enhanceAmount * (255 - rMax);
            rGoalMin = rMin - enhanceAmount * (rMin - 0);
            gGoalMax = gMax + enhanceAmount * (255 - gMax);
            gGoalMin = gMin - enhanceAmount * (gMin - 0);
            bGoalMax = bMax + enhanceAmount * (255 - bMax);
            bGoalMin = bMin - enhanceAmount * (bMin - 0);
        // If the enhancement is negative -   compress the histogram
        } else {
            rMid = (rMax + rMin) * 0.5;
            rGoalMax = rMax + enhanceAmount * (rMax - rMid);
            rGoalMin = rMin + enhanceAmount * (rMin - rMid);
            gMid = (gMax + gMin) * 0.5;
            gGoalMax = gMax + enhanceAmount * (gMax - gMid);
            gGoalMin = gMin + enhanceAmount * (gMin - gMid);
            bMid = (bMax + bMin) * 0.5;
            bGoalMax = bMax + enhanceAmount * (bMax - bMid);
            bGoalMin = bMin + enhanceAmount * (bMin - bMid);
        }

        // Pass 2 - remap everything, except the alpha
        for (i = 0; i < nSubPixels; i += 4) {
            data[i + 0] = remap(data[i + 0], rMin, rMax, rGoalMin, rGoalMax);
            data[i + 1] = remap(data[i + 1], gMin, gMax, gGoalMin, gGoalMax);
            data[i + 2] = remap(data[i + 2], bMin, bMax, bGoalMin, bGoalMax);
            //data[i + 3] = remap(data[i + 3], aMin, aMax, aGoalMin, aGoalMax);
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'enhance', 0, null, Konva.Factory.afterSetFilter);

    /**
    * get/set enhance. Use with {@link Konva.Filters.Enhance} filter.
    * @name enhance
    * @method
    * @memberof Konva.Node.prototype
    * @param {Float} amount
    * @returns {Float}
    */
})();

(function () {
    'use strict';
    /**
     * Posterize Filter. Adjusts the channels so that there are no more
     *  than n different values for that channel. This is also applied
     *  to the alpha channel.
     * @function
     * @name Posterize
     * @author ippo615
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Posterize]);
     * node.levels(0.8);
     */

    Konva.Filters.Posterize = function (imageData) {
        // level must be between 1 and 255
        var levels = Math.round(this.levels() * 254) + 1,
            data = imageData.data,
            len = data.length,
            scale = (255 / levels),
            i;

        for (i = 0; i < len; i += 1) {
            data[i] = Math.floor(data[i] / scale) * scale;
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'levels', 0.5, null, Konva.Factory.afterSetFilter);

    /**
    * get/set levels.  Must be a number between 0 and 1.  Use with {@link Konva.Filters.Posterize} filter.
    * @name levels
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} level between 0 and 1
    * @returns {Number}
    */
})();

(function () {
    'use strict';

    /**
     * Noise Filter. Randomly adds or substracts to the color channels
     * @function
     * @name Noise
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author ippo615
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Noise]);
     * node.noise(0.8);
     */
    Konva.Filters.Noise = function (imageData) {
        var amount = this.noise() * 255,
            data = imageData.data,
            nPixels = data.length,
            half = amount / 2,
            i;

        for (i = 0; i < nPixels; i += 4) {
            data[i + 0] += half - 2 * half * Math.random();
            data[i + 1] += half - 2 * half * Math.random();
            data[i + 2] += half - 2 * half * Math.random();
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'noise', 0.2, null, Konva.Factory.afterSetFilter);

    /**
    * get/set noise amount.  Must be a value between 0 and 1. Use with {@link Konva.Filters.Noise} filter.
    * @name noise
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} noise
    * @returns {Number}
    */
})();

/*eslint-disable max-depth */
(function () {
    'use strict';
    /**
     * Pixelate Filter. Averages groups of pixels and redraws
     *  them as larger pixels
     * @function
     * @name Pixelate
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author ippo615
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Pixelate]);
     * node.pixelSize(10);
     */

    Konva.Filters.Pixelate = function (imageData) {

        var pixelSize = Math.ceil(this.pixelSize()),
            width = imageData.width,
            height = imageData.height,
            x, y, i,
            //pixelsPerBin = pixelSize * pixelSize,
            red, green, blue, alpha,
            nBinsX = Math.ceil(width / pixelSize),
            nBinsY = Math.ceil(height / pixelSize),
            xBinStart, xBinEnd, yBinStart, yBinEnd,
            xBin, yBin, pixelsInBin;
        imageData = imageData.data;

        for (xBin = 0; xBin < nBinsX; xBin += 1) {
            for (yBin = 0; yBin < nBinsY; yBin += 1) {

                // Initialize the color accumlators to 0
                red = 0;
                green = 0;
                blue = 0;
                alpha = 0;

                // Determine which pixels are included in this bin
                xBinStart = xBin * pixelSize;
                xBinEnd = xBinStart + pixelSize;
                yBinStart = yBin * pixelSize;
                yBinEnd = yBinStart + pixelSize;

                // Add all of the pixels to this bin!
                pixelsInBin = 0;
                for (x = xBinStart; x < xBinEnd; x += 1) {
                    if( x >= width ){ continue; }
                    for (y = yBinStart; y < yBinEnd; y += 1) {
                        if( y >= height ){ continue; }
                        i = (width * y + x) * 4;
                        red += imageData[i + 0];
                        green += imageData[i + 1];
                        blue += imageData[i + 2];
                        alpha += imageData[i + 3];
                        pixelsInBin += 1;
                    }
                }

                // Make sure the channels are between 0-255
                red = red / pixelsInBin;
                green = green / pixelsInBin;
                blue = blue / pixelsInBin;

                // Draw this bin
                for (x = xBinStart; x < xBinEnd; x += 1) {
                    if( x >= width ){ continue; }
                    for (y = yBinStart; y < yBinEnd; y += 1) {
                        if( y >= height ){ continue; }
                        i = (width * y + x) * 4;
                        imageData[i + 0] = red;
                        imageData[i + 1] = green;
                        imageData[i + 2] = blue;
                        imageData[i + 3] = alpha;
                    }
                }
            }
        }

    };

    Konva.Factory.addGetterSetter(Konva.Node, 'pixelSize', 8, null, Konva.Factory.afterSetFilter);

    /**
    * get/set pixel size. Use with {@link Konva.Filters.Pixelate} filter.
    * @name pixelSize
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} pixelSize
    * @returns {Integer}
    */
})();

(function () {
    'use strict';
    /**
     * Threshold Filter. Pushes any value above the mid point to
     *  the max and any value below the mid point to the min.
     *  This affects the alpha channel.
     * @function
     * @name Threshold
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author ippo615
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Threshold]);
     * node.threshold(0.1);
     */

    Konva.Filters.Threshold = function (imageData) {
        var level = this.threshold() * 255,
            data = imageData.data,
            len = data.length,
            i;

        for (i = 0; i < len; i += 1) {
            data[i] = data[i] < level ? 0 : 255;
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'threshold', 0.5, null, Konva.Factory.afterSetFilter);

    /**
    * get/set threshold.  Must be a value between 0 and 1. Use with {@link Konva.Filters.Threshold} or {@link Konva.Filters.Mask} filter.
    * @name threshold
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} threshold
    * @returns {Number}
    */
})();

(function() {
    'use strict';
    /**
     * Sepia Filter
     * Based on: Pixastic Lib - Sepia filter - v0.1.0
     * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
     * @function
     * @name Sepia
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author Jacob Seidelin <jseidelin@nihilogic.dk>
     * @license MPL v1.1 [http://www.pixastic.com/lib/license.txt]
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Sepia]);
     */
    Konva.Filters.Sepia = function (imageData) {
        var data = imageData.data,
            w = imageData.width,
            y = imageData.height,
            w4 = w * 4,
            offsetY, x, offset, or, og, ob, r, g, b;

        do {
            offsetY = (y - 1) * w4;
            x = w;
            do {
                offset = offsetY + (x - 1) * 4;

                or = data[offset];
                og = data[offset + 1];
                ob = data[offset + 2];

                r = or * 0.393 + og * 0.769 + ob * 0.189;
                g = or * 0.349 + og * 0.686 + ob * 0.168;
                b = or * 0.272 + og * 0.534 + ob * 0.131;

                data[offset] = r > 255 ? 255 : r;
                data[offset + 1] = g > 255 ? 255 : g;
                data[offset + 2] = b > 255 ? 255 : b;
                data[offset + 3] = data[offset + 3];
            } while (--x);
        } while (--y);
    };
})();

(function () {
    'use strict';
    /**
     * Solarize Filter
     * Pixastic Lib - Solarize filter - v0.1.0
     * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
     * License: [http://www.pixastic.com/lib/license.txt]
     * @function
     * @name Solarize
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Solarize]);
     */
    Konva.Filters.Solarize = function (imageData) {
        var data = imageData.data,
            w = imageData.width,
            h = imageData.height,
            w4 = w * 4,
            y = h;

        do {
            var offsetY = (y - 1) * w4;
            var x = w;
            do {
                var offset = offsetY + (x - 1) * 4;
                var r = data[offset];
                var g = data[offset + 1];
                var b = data[offset + 2];

                if (r > 127) {
                    r = 255 - r;
                }
                if (g > 127) {
                    g = 255 - g;
                }
                if (b > 127) {
                    b = 255 - b;
                }

                data[offset] = r;
                data[offset + 1] = g;
                data[offset + 2] = b;
            } while (--x);
        } while (--y);
    };
})();



(function () {
    'use strict';

  /*
   * ToPolar Filter. Converts image data to polar coordinates. Performs
   *  w*h*4 pixel reads and w*h pixel writes. The r axis is placed along
   *  what would be the y axis and the theta axis along the x axis.
   * @function
   * @author ippo615
   * @memberof Konva.Filters
   * @param {ImageData} src, the source image data (what will be transformed)
   * @param {ImageData} dst, the destination image data (where it will be saved)
   * @param {Object} opt
   * @param {Number} [opt.polarCenterX] horizontal location for the center of the circle,
   *  default is in the middle
   * @param {Number} [opt.polarCenterY] vertical location for the center of the circle,
   *  default is in the middle
   */

    var ToPolar = function(src, dst, opt){

        var srcPixels = src.data,
            dstPixels = dst.data,
            xSize = src.width,
            ySize = src.height,
            xMid = opt.polarCenterX || xSize / 2,
            yMid = opt.polarCenterY || ySize / 2,
            i, x, y, r = 0, g = 0, b = 0, a = 0;

        // Find the largest radius
        var rad, rMax = Math.sqrt( xMid * xMid + yMid * yMid );
        x = xSize - xMid;
        y = ySize - yMid;
        rad = Math.sqrt( x * x + y * y );
        rMax = (rad > rMax) ? rad : rMax;

        // We'll be uisng y as the radius, and x as the angle (theta=t)
        var rSize = ySize,
            tSize = xSize,
            radius, theta;

        // We want to cover all angles (0-360) and we need to convert to
        // radians (*PI/180)
        var conversion = 360 / tSize * Math.PI / 180, sin, cos;

        // var x1, x2, x1i, x2i, y1, y2, y1i, y2i, scale;

        for( theta = 0; theta < tSize; theta += 1 ){
            sin = Math.sin(theta * conversion);
            cos = Math.cos(theta * conversion);
            for( radius = 0; radius < rSize; radius += 1 ){
                x = Math.floor(xMid + rMax * radius / rSize * cos);
                y = Math.floor(yMid + rMax * radius / rSize * sin);
                i = (y * xSize + x) * 4;
                r = srcPixels[i + 0];
                g = srcPixels[i + 1];
                b = srcPixels[i + 2];
                a = srcPixels[i + 3];

                // Store it
                //i = (theta * xSize  +  radius) * 4;
                i = (theta + radius * xSize) * 4;
                dstPixels[i + 0] = r;
                dstPixels[i + 1] = g;
                dstPixels[i + 2] = b;
                dstPixels[i + 3] = a;

            }
        }
    };

    /*
     * FromPolar Filter. Converts image data from polar coordinates back to rectangular.
     *  Performs w*h*4 pixel reads and w*h pixel writes.
     * @function
     * @author ippo615
     * @memberof Konva.Filters
     * @param {ImageData} src, the source image data (what will be transformed)
     * @param {ImageData} dst, the destination image data (where it will be saved)
     * @param {Object} opt
     * @param {Number} [opt.polarCenterX] horizontal location for the center of the circle,
     *  default is in the middle
     * @param {Number} [opt.polarCenterY] vertical location for the center of the circle,
     *  default is in the middle
     * @param {Number} [opt.polarRotation] amount to rotate the image counterclockwis,
     *  0 is no rotation, 360 degrees is a full rotation
     */

    var FromPolar = function(src, dst, opt){

        var srcPixels = src.data,
            dstPixels = dst.data,
            xSize = src.width,
            ySize = src.height,
            xMid = opt.polarCenterX || xSize / 2,
            yMid = opt.polarCenterY || ySize / 2,
            i, x, y, dx, dy, r = 0, g = 0, b = 0, a = 0;


        // Find the largest radius
        var rad, rMax = Math.sqrt( xMid * xMid + yMid * yMid );
        x = xSize - xMid;
        y = ySize - yMid;
        rad = Math.sqrt( x * x + y * y );
        rMax = (rad > rMax) ? rad : rMax;

        // We'll be uisng x as the radius, and y as the angle (theta=t)
        var rSize = ySize,
        tSize = xSize,
        radius, theta,
        phaseShift = opt.polarRotation || 0;

        // We need to convert to degrees and we need to make sure
        // it's between (0-360)
        // var conversion = tSize/360*180/Math.PI;
        //var conversion = tSize/360*180/Math.PI;

        var x1, y1;

        for( x = 0; x < xSize; x += 1 ){
            for( y = 0; y < ySize; y += 1 ){
                dx = x - xMid;
                dy = y - yMid;
                radius = Math.sqrt(dx * dx + dy * dy) * rSize / rMax;
                theta = (Math.atan2(dy, dx) * 180 / Math.PI + 360 + phaseShift) % 360;
                theta = theta * tSize / 360;
                x1 = Math.floor(theta);
                y1 = Math.floor(radius);
                i = (y1 * xSize + x1) * 4;
                r = srcPixels[i + 0];
                g = srcPixels[i + 1];
                b = srcPixels[i + 2];
                a = srcPixels[i + 3];

                // Store it
                i = (y * xSize + x) * 4;
                dstPixels[i + 0] = r;
                dstPixels[i + 1] = g;
                dstPixels[i + 2] = b;
                dstPixels[i + 3] = a;
            }
        }

    };

    //Konva.Filters.ToPolar = Konva.Util._FilterWrapDoubleBuffer(ToPolar);
    //Konva.Filters.FromPolar = Konva.Util._FilterWrapDoubleBuffer(FromPolar);

    // create a temporary canvas for working - shared between multiple calls
    var tempCanvas = Konva.Util.createCanvasElement();

    /*
     * Kaleidoscope Filter.
     * @function
     * @name Kaleidoscope
     * @author ippo615
     * @memberof Konva.Filters
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Kaleidoscope]);
     * node.kaleidoscopePower(3);
     * node.kaleidoscopeAngle(45);
     */
    Konva.Filters.Kaleidoscope = function(imageData){
        var xSize = imageData.width,
            ySize = imageData.height;

        var x, y, xoff, i, r, g, b, a, srcPos, dstPos;
        var power = Math.round( this.kaleidoscopePower() );
        var angle = Math.round( this.kaleidoscopeAngle() );
        var offset = Math.floor(xSize * (angle % 360) / 360);

        if( power < 1 ){return; }

        // Work with our shared buffer canvas
        tempCanvas.width = xSize;
        tempCanvas.height = ySize;
        var scratchData = tempCanvas.getContext('2d').getImageData(0, 0, xSize, ySize);

        // Convert thhe original to polar coordinates
        ToPolar( imageData, scratchData, {
            polarCenterX: xSize / 2,
            polarCenterY: ySize / 2
        });

        // Determine how big each section will be, if it's too small
        // make it bigger
        var minSectionSize = xSize / Math.pow(2, power);
        while( minSectionSize <= 8){
            minSectionSize = minSectionSize * 2;
            power -= 1;
        }
        minSectionSize = Math.ceil(minSectionSize);
        var sectionSize = minSectionSize;

        // Copy the offset region to 0
        // Depending on the size of filter and location of the offset we may need
        // to copy the section backwards to prevent it from rewriting itself
        var xStart = 0,
          xEnd = sectionSize,
          xDelta = 1;
        if( offset + minSectionSize > xSize ){
            xStart = sectionSize;
            xEnd = 0;
            xDelta = -1;
        }
        for( y = 0; y < ySize; y += 1 ){
            for( x = xStart; x !== xEnd; x += xDelta ){
                xoff = Math.round(x + offset) % xSize;
                srcPos = (xSize * y + xoff) * 4;
                r = scratchData.data[srcPos + 0];
                g = scratchData.data[srcPos + 1];
                b = scratchData.data[srcPos + 2];
                a = scratchData.data[srcPos + 3];
                dstPos = (xSize * y + x) * 4;
                scratchData.data[dstPos + 0] = r;
                scratchData.data[dstPos + 1] = g;
                scratchData.data[dstPos + 2] = b;
                scratchData.data[dstPos + 3] = a;
            }
        }

        // Perform the actual effect
        for( y = 0; y < ySize; y += 1 ){
            sectionSize = Math.floor( minSectionSize );
            for( i = 0; i < power; i += 1 ){
                for( x = 0; x < sectionSize + 1; x += 1 ){
                    srcPos = (xSize * y + x) * 4;
                    r = scratchData.data[srcPos + 0];
                    g = scratchData.data[srcPos + 1];
                    b = scratchData.data[srcPos + 2];
                    a = scratchData.data[srcPos + 3];
                    dstPos = (xSize * y + sectionSize * 2 - x - 1) * 4;
                    scratchData.data[dstPos + 0] = r;
                    scratchData.data[dstPos + 1] = g;
                    scratchData.data[dstPos + 2] = b;
                    scratchData.data[dstPos + 3] = a;
                }
                sectionSize *= 2;
            }
        }

        // Convert back from polar coordinates
        FromPolar(scratchData, imageData, {polarRotation: 0});
    };

    /**
    * get/set kaleidoscope power. Use with {@link Konva.Filters.Kaleidoscope} filter.
    * @name kaleidoscopePower
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} power of kaleidoscope
    * @returns {Integer}
    */
    Konva.Factory.addGetterSetter(Konva.Node, 'kaleidoscopePower', 2, null, Konva.Factory.afterSetFilter);

    /**
    * get/set kaleidoscope angle. Use with {@link Konva.Filters.Kaleidoscope} filter.
    * @name kaleidoscopeAngle
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} degrees
    * @returns {Integer}
    */
    Konva.Factory.addGetterSetter(Konva.Node, 'kaleidoscopeAngle', 0, null, Konva.Factory.afterSetFilter);

})();

(function() {
    'use strict';
    /**
     * Container constructor.&nbsp; Containers are used to contain nodes or other containers
     * @constructor
     * @memberof Konva
     * @augments Konva.Node
     * @abstract
     * @param {Object} config
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height

     */
    Konva.Container = function(config) {
        this.__init(config);
    };

    Konva.Util.addMethods(Konva.Container, {
        __init: function(config) {
            this.children = new Konva.Collection();
            Konva.Node.call(this, config);
        },
        /**
         * returns a {@link Konva.Collection} of direct descendant nodes
         * @method
         * @memberof Konva.Container.prototype
         * @param {Function} [filterFunc] filter function
         * @returns {Konva.Collection}
         * @example
         * // get all children
         * var children = layer.getChildren();
         *
         * // get only circles
         * var circles = layer.getChildren(function(node){
         *    return node.getClassName() === 'Circle';
         * });
         */
        getChildren: function(filterFunc) {
            if (!filterFunc) {
                return this.children;
            }

            var results = new Konva.Collection();
            this.children.each(function(child){
                if (filterFunc(child)) {
                    results.push(child);
                }
            });
            return results;
        },
        /**
         * determine if node has children
         * @method
         * @memberof Konva.Container.prototype
         * @returns {Boolean}
         */
        hasChildren: function() {
            return this.getChildren().length > 0;
        },
        /**
         * remove all children
         * @method
         * @memberof Konva.Container.prototype
         */
        removeChildren: function() {
            var children = Konva.Collection.toCollection(this.children);
            var child;
            for (var i = 0; i < children.length; i++) {
                child = children[i];
                // reset parent to prevent many _setChildrenIndices calls
                delete child.parent;
                child.index = 0;
                if (child.hasChildren()) {
                    child.removeChildren();
                }
                child.remove();
            }
            children = null;
            this.children = new Konva.Collection();
            return this;
        },
        /**
         * destroy all children
         * @method
         * @memberof Konva.Container.prototype
         */
        destroyChildren: function() {
           var children = Konva.Collection.toCollection(this.children);
            var child;
            for (var i = 0; i < children.length; i++) {
                child = children[i];
                // reset parent to prevent many _setChildrenIndices calls
                delete child.parent;
                child.index = 0;
                child.destroy();
            }
            children = null;
            this.children = new Konva.Collection();
            return this;
        },
        /**
         * Add node or nodes to container.
         * @method
         * @memberof Konva.Container.prototype
         * @param {...Konva.Node} child
         * @returns {Container}
         * @example
         * layer.add(shape1, shape2, shape3);
         */
        add: function(child) {
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) {
                    this.add(arguments[i]);
                }
                return this;
            }
            if (child.getParent()) {
                child.moveTo(this);
                return this;
            }
            var children = this.children;
            this._validateAdd(child);
            child.index = children.length;
            child.parent = this;
            children.push(child);
            this._fire('add', {
                child: child
            });

            // if node under drag we need to update drag animation
            if (Konva.DD && child.isDragging()) {
                Konva.DD.anim.setLayers(child.getLayer());
            }

            // chainable
            return this;
        },
        destroy: function() {
            // destroy children
            if (this.hasChildren()) {
                this.destroyChildren();
            }
            // then destroy self
            Konva.Node.prototype.destroy.call(this);
            return this;
        },
        /**
         * return a {@link Konva.Collection} of nodes that match the selector.  Use '#' for id selections
         * and '.' for name selections.  You can also select by type or class name. Pass multiple selectors
         * separated by a space.
         * @method
         * @memberof Konva.Container.prototype
         * @param {String} selector
         * @returns {Collection}
         * @example
         * // select node with id foo
         * var node = stage.find('#foo');
         *
         * // select nodes with name bar inside layer
         * var nodes = layer.find('.bar');
         *
         * // select all groups inside layer
         * var nodes = layer.find('Group');
         *
         * // select all rectangles inside layer
         * var nodes = layer.find('Rect');
         *
         * // select node with an id of foo or a name of bar inside layer
         * var nodes = layer.find('#foo, .bar');
         */
        find: function(selector) {
            var retArr = [],
                selectorArr = selector.replace(/ /g, '').split(','),
                len = selectorArr.length,
                n, i, sel, arr, node, children, clen;

            for (n = 0; n < len; n++) {
                sel = selectorArr[n];
                if (!Konva.Util.isValidSelector(sel)) {
                    Konva.Util.warn('Selector "' + sel + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".');
                    Konva.Util.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".');
                    Konva.Util.warn('Konva is awesome, right?');
                }
                // id selector
                if(sel.charAt(0) === '#') {
                    node = this._getNodeById(sel.slice(1));
                    if(node) {
                        retArr.push(node);
                    }
                }
                // name selector
                else if(sel.charAt(0) === '.') {
                    arr = this._getNodesByName(sel.slice(1));
                    retArr = retArr.concat(arr);
                }
                // unrecognized selector, pass to children
                else {
                    children = this.getChildren();
                    clen = children.length;
                    for(i = 0; i < clen; i++) {
                        retArr = retArr.concat(children[i]._get(sel));
                    }
                }
            }

            return Konva.Collection.toCollection(retArr);
        },
        /**
         * return a first node from `find` method
         * @method
         * @memberof Konva.Container.prototype
         * @param {String} selector
         * @returns {Konva.Node}
         * @example
         * // select node with id foo
         * var node = stage.findOne('#foo');
         *
         * // select node with name bar inside layer
         * var nodes = layer.findOne('.bar');
         */
        findOne: function(selector) {
            return this.find(selector)[0];
        },
        _getNodeById: function(key) {
            var node = Konva.ids[key];

            if(node !== undefined && this.isAncestorOf(node)) {
                return node;
            }
            return null;
        },
        _getNodesByName: function(key) {
            var arr = Konva.names[key] || [];
            return this._getDescendants(arr);
        },
        _get: function(selector) {
            var retArr = Konva.Node.prototype._get.call(this, selector);
            var children = this.getChildren();
            var len = children.length;
            for(var n = 0; n < len; n++) {
                retArr = retArr.concat(children[n]._get(selector));
            }
            return retArr;
        },
        // extenders
        toObject: function() {
            var obj = Konva.Node.prototype.toObject.call(this);

            obj.children = [];

            var children = this.getChildren();
            var len = children.length;
            for(var n = 0; n < len; n++) {
                var child = children[n];
                obj.children.push(child.toObject());
            }

            return obj;
        },
        _getDescendants: function(arr) {
            var retArr = [];
            var len = arr.length;
            for(var n = 0; n < len; n++) {
                var node = arr[n];
                if(this.isAncestorOf(node)) {
                    retArr.push(node);
                }
            }

            return retArr;
        },
        /**
         * determine if node is an ancestor
         * of descendant
         * @method
         * @memberof Konva.Container.prototype
         * @param {Konva.Node} node
         */
        isAncestorOf: function(node) {
            var parent = node.getParent();
            while(parent) {
                if(parent._id === this._id) {
                    return true;
                }
                parent = parent.getParent();
            }

            return false;
        },
        clone: function(obj) {
            // call super method
            var node = Konva.Node.prototype.clone.call(this, obj);

            this.getChildren().each(function(no) {
                node.add(no.clone());
            });
            return node;
        },
        /**
         * get all shapes that intersect a point.  Note: because this method must clear a temporary
         * canvas and redraw every shape inside the container, it should only be used for special sitations
         * because it performs very poorly.  Please use the {@link Konva.Stage#getIntersection} method if at all possible
         * because it performs much better
         * @method
         * @memberof Konva.Container.prototype
         * @param {Object} pos
         * @param {Number} pos.x
         * @param {Number} pos.y
         * @returns {Array} array of shapes
         */
        getAllIntersections: function(pos) {
            var arr = [];

            this.find('Shape').each(function(shape) {
                if(shape.isVisible() && shape.intersects(pos)) {
                    arr.push(shape);
                }
            });

            return arr;
        },
        _setChildrenIndices: function() {
            this.children.each(function(child, n) {
                child.index = n;
            });
        },
        drawScene: function(can, top, caching) {
            var layer = this.getLayer(),
                canvas = can || (layer && layer.getCanvas()),
                context = canvas && canvas.getContext(),
                cachedCanvas = this._cache.canvas,
                cachedSceneCanvas = cachedCanvas && cachedCanvas.scene;

            if (this.isVisible()) {
                if (!caching && cachedSceneCanvas) {
                    context.save();
                    layer._applyTransform(this, context, top);
                    this._drawCachedSceneCanvas(context);
                    context.restore();
                }
                else {
                    this._drawChildren(canvas, 'drawScene', top, false, caching);
                }
            }
            return this;
        },
        drawHit: function(can, top, caching) {
            var layer = this.getLayer(),
                canvas = can || (layer && layer.hitCanvas),
                context = canvas && canvas.getContext(),
                cachedCanvas = this._cache.canvas,
                cachedHitCanvas = cachedCanvas && cachedCanvas.hit;

            if (this.shouldDrawHit(canvas)) {
                if (layer) {
                    layer.clearHitCache();
                }
                if (!caching && cachedHitCanvas) {
                    context.save();
                    layer._applyTransform(this, context, top);
                    this._drawCachedHitCanvas(context);
                    context.restore();
                }
                else {
                    this._drawChildren(canvas, 'drawHit', top);
                }
            }
            return this;
        },
        _drawChildren: function(canvas, drawMethod, top, caching, skipBuffer) {
            var layer = this.getLayer(),
                context = canvas && canvas.getContext(),
                clipWidth = this.getClipWidth(),
                clipHeight = this.getClipHeight(),
                hasClip = clipWidth && clipHeight,
                clipX, clipY;

            if (hasClip && layer) {
                clipX = this.getClipX();
                clipY = this.getClipY();

                context.save();
                layer._applyTransform(this, context);
                context.beginPath();
                context.rect(clipX, clipY, clipWidth, clipHeight);
                context.clip();
                context.reset();
            }

            this.children.each(function(child) {
                child[drawMethod](canvas, top, caching, skipBuffer);
            });

            if (hasClip) {
                context.restore();
            }
        },
        shouldDrawHit: function(canvas) {
            var layer = this.getLayer();
            var dd = Konva.DD;
            var layerUnderDrag = dd && Konva.isDragging() && (Konva.DD.anim.getLayers().indexOf(layer) !== -1);
            return (canvas && canvas.isCache) || (layer && layer.hitGraphEnabled())
                && this.isVisible() && !layerUnderDrag;
        },
        getClientRect: function(skipTransform) {
            var minX, minY, maxX, maxY;
            var selfRect = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            };
            this.children.each(function(child) {
                var rect = child.getClientRect();

                // skip invisible children (like empty groups)
                // or don't skip... hmmm...
                // if (rect.width === 0 && rect.height === 0) {
                //     return;
                // }

                if (minX === undefined) { // initial value for first child
                    minX = rect.x;
                    minY = rect.y;
                    maxX = rect.x + rect.width;
                    maxY = rect.y + rect.height;
                } else {
                    minX = Math.min(minX, rect.x);
                    minY = Math.min(minY, rect.y);
                    maxX = Math.max(maxX, rect.x + rect.width);
                    maxY = Math.max(maxY, rect.y + rect.height);
                }

            });

            if (this.children.length !== 0) {
                selfRect = {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            }

            if (!skipTransform) {
                return this._transformedRect(selfRect);
            }
            return selfRect;
        }
    });

    Konva.Util.extend(Konva.Container, Konva.Node);
    // deprecated methods
    Konva.Container.prototype.get = Konva.Container.prototype.find;

    // add getters setters
    Konva.Factory.addComponentsGetterSetter(Konva.Container, 'clip', ['x', 'y', 'width', 'height']);
    /**
     * get/set clip
     * @method
     * @name clip
     * @memberof Konva.Container.prototype
     * @param {Object} clip
     * @param {Number} clip.x
     * @param {Number} clip.y
     * @param {Number} clip.width
     * @param {Number} clip.height
     * @returns {Object}
     * @example
     * // get clip
     * var clip = container.clip();
     *
     * // set clip
     * container.setClip({
     *   x: 20,
     *   y: 20,
     *   width: 20,
     *   height: 20
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Container, 'clipX');
    /**
     * get/set clip x
     * @name clipX
     * @method
     * @memberof Konva.Container.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get clip x
     * var clipX = container.clipX();
     *
     * // set clip x
     * container.clipX(10);
     */

    Konva.Factory.addGetterSetter(Konva.Container, 'clipY');
    /**
     * get/set clip y
     * @name clipY
     * @method
     * @memberof Konva.Container.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get clip y
     * var clipY = container.clipY();
     *
     * // set clip y
     * container.clipY(10);
     */

    Konva.Factory.addGetterSetter(Konva.Container, 'clipWidth');
    /**
     * get/set clip width
     * @name clipWidth
     * @method
     * @memberof Konva.Container.prototype
     * @param {Number} width
     * @returns {Number}
     * @example
     * // get clip width
     * var clipWidth = container.clipWidth();
     *
     * // set clip width
     * container.clipWidth(100);
     */

    Konva.Factory.addGetterSetter(Konva.Container, 'clipHeight');
    /**
     * get/set clip height
     * @name clipHeight
     * @method
     * @memberof Konva.Container.prototype
     * @param {Number} height
     * @returns {Number}
     * @example
     * // get clip height
     * var clipHeight = container.clipHeight();
     *
     * // set clip height
     * container.clipHeight(100);
     */

    Konva.Collection.mapMethods(Konva.Container);
})();

(function(Konva) {
    'use strict';
    var HAS_SHADOW = 'hasShadow';
    var SHADOW_RGBA = 'shadowRGBA';

    function _fillFunc(context) {
        context.fill();
    }
    function _strokeFunc(context) {
        context.stroke();
    }
    function _fillFuncHit(context) {
        context.fill();
    }
    function _strokeFuncHit(context) {
        context.stroke();
    }

    function _clearHasShadowCache() {
        this._clearCache(HAS_SHADOW);
    }

    function _clearGetShadowRGBACache() {
        this._clearCache(SHADOW_RGBA);
    }

    /**
     * Shape constructor.  Shapes are primitive objects such as rectangles,
     *  circles, text, lines, etc.
     * @constructor
     * @memberof Konva
     * @augments Konva.Node
     * @param {Object} config
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var customShape = new Konva.Shape({
         *   x: 5,
         *   y: 10,
         *   fill: 'red',
         *   // a Konva.Canvas renderer is passed into the drawFunc function
         *   drawFunc: function(context) {
         *     context.beginPath();
         *     context.moveTo(200, 50);
         *     context.lineTo(420, 80);
         *     context.quadraticCurveTo(300, 100, 260, 170);
         *     context.closePath();
         *     context.fillStrokeShape(this);
         *   }
         *});
     */
    Konva.Shape = function(config) {
        this.__init(config);
    };

    Konva.Util.addMethods(Konva.Shape, {
        __init: function(config) {
            this.nodeType = 'Shape';
            this._fillFunc = _fillFunc;
            this._strokeFunc = _strokeFunc;
            this._fillFuncHit = _fillFuncHit;
            this._strokeFuncHit = _strokeFuncHit;

            // set colorKey
            var shapes = Konva.shapes;
            var key;

            while(true) {
                key = Konva.Util.getRandomColor();
                if(key && !( key in shapes)) {
                    break;
                }
            }

            this.colorKey = key;
            shapes[key] = this;

            // call super constructor
            Konva.Node.call(this, config);

            this.on('shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearHasShadowCache);

            this.on('shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearGetShadowRGBACache);
        },
        hasChildren: function() {
            return false;
        },
        getChildren: function() {
            return [];
        },
        /**
         * get canvas context tied to the layer
         * @method
         * @memberof Konva.Shape.prototype
         * @returns {Konva.Context}
         */
        getContext: function() {
            return this.getLayer().getContext();
        },
        /**
         * get canvas renderer tied to the layer.  Note that this returns a canvas renderer, not a canvas element
         * @method
         * @memberof Konva.Shape.prototype
         * @returns {Konva.Canvas}
         */
        getCanvas: function() {
            return this.getLayer().getCanvas();
        },
        /**
         * returns whether or not a shadow will be rendered
         * @method
         * @memberof Konva.Shape.prototype
         * @returns {Boolean}
         */
        hasShadow: function() {
            return this._getCache(HAS_SHADOW, this._hasShadow);
        },
        _hasShadow: function() {
            return this.getShadowEnabled() && (this.getShadowOpacity() !== 0 && !!(this.getShadowColor() || this.getShadowBlur() || this.getShadowOffsetX() || this.getShadowOffsetY()));
        },
        getShadowRGBA: function() {
            return this._getCache(SHADOW_RGBA, this._getShadowRGBA);
        },
        _getShadowRGBA: function() {
            if (this.hasShadow()) {
                var rgba = Konva.Util.colorToRGBA(this.shadowColor());
                return 'rgba(' + rgba.r + ',' + rgba.g + ',' + rgba.b + ',' + (rgba.a * (this.getShadowOpacity() || 1)) + ')';
            }
        },
        /**
         * returns whether or not the shape will be filled
         * @method
         * @memberof Konva.Shape.prototype
         * @returns {Boolean}
         */
        hasFill: function() {
            return !!(this.getFill() || this.getFillPatternImage() || this.getFillLinearGradientColorStops() || this.getFillRadialGradientColorStops());
        },
        /**
         * returns whether or not the shape will be stroked
         * @method
         * @memberof Konva.Shape.prototype
         * @returns {Boolean}
         */
        hasStroke: function() {
            return !!(this.stroke());
        },
        /**
         * determines if point is in the shape, regardless if other shapes are on top of it.  Note: because
         *  this method clears a temporary canvas and then redraws the shape, it performs very poorly if executed many times
         *  consecutively.  Please use the {@link Konva.Stage#getIntersection} method if at all possible
         *  because it performs much better
         * @method
         * @memberof Konva.Shape.prototype
         * @param {Object} point
         * @param {Number} point.x
         * @param {Number} point.y
         * @returns {Boolean}
         */
        intersects: function(point) {
            var stage = this.getStage(),
                bufferHitCanvas = stage.bufferHitCanvas,
                p;

            bufferHitCanvas.getContext().clear();
            this.drawScene(bufferHitCanvas);
            p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;
            return p[3] > 0;
        },
        // extends Node.prototype.destroy
        destroy: function() {
            Konva.Node.prototype.destroy.call(this);
            delete Konva.shapes[this.colorKey];
            return this;
        },
        _useBufferCanvas: function(caching) {
            return !caching && (this.perfectDrawEnabled() && (this.getAbsoluteOpacity() !== 1) && this.hasFill() && this.hasStroke() && this.getStage()) ||
                   (this.perfectDrawEnabled() && this.hasShadow() && (this.getAbsoluteOpacity() !== 1) && this.hasFill() && this.hasStroke() && this.getStage());
        },
        /**
         * return self rectangle (x, y, width, height) of shape.
         * This method are not taken into account transformation and styles.
         * @method
         * @memberof Konva.Node.prototype
         * @returns {Object} rect with {x, y, width, height} properties
         * @example
         *
         * rect.getSelfRect();  // return {x:0, y:0, width:rect.width(), height:rect.height()}
         * circle.getSelfRect();  // return {x: - circle.width() / 2, y: - circle.height() / 2, width:circle.width(), height:circle.height()}
         *
         */
        getSelfRect: function() {
            var size = this.getSize();
            return {
                x: this._centroid ? Math.round(-size.width / 2) : 0,
                y: this._centroid ? Math.round(-size.height / 2) : 0,
                width: size.width,
                height: size.height
            };
        },
        getClientRect: function(skipTransform) {
            var fillRect = this.getSelfRect();

            var strokeWidth = (this.hasStroke() && this.strokeWidth()) || 0;
            var fillAndStrokeWidth = fillRect.width + strokeWidth;
            var fillAndStrokeHeight = fillRect.height + strokeWidth;

            var shadowOffsetX = this.shadowOffsetX();
            var shadowOffsetY = this.shadowOffsetY();

            var preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);
            var preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);

            var blurRadius = (this.hasShadow() && this.shadowBlur() || 0);

            var width = preWidth + blurRadius * 2;
            var height = preHeight + blurRadius * 2;

            // if stroke, for example = 3
            // we need to set x to 1.5, but after Math.round it will be 2
            // as we have additional offset we need to increase width and height by 1 pixel
            var roundingOffset = 0;
            if (Math.round(strokeWidth / 2) !== strokeWidth / 2) {
                roundingOffset = 1;
            }
            var rect = {
                width: width + roundingOffset,
                height: height + roundingOffset,
                x: -Math.round(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetX, 0) + fillRect.x,
                y: -Math.round(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetY, 0) + fillRect.y
            };
            if (!skipTransform) {
                return this._transformedRect(rect);
            }
            return rect;
        },
        drawScene: function(can, top, caching, skipBuffer) {
            var layer = this.getLayer(),
                canvas = can || layer.getCanvas(),
                context = canvas.getContext(),
                cachedCanvas = this._cache.canvas,
                drawFunc = this.sceneFunc(),
                hasShadow = this.hasShadow(),
                hasStroke = this.hasStroke(),
                stage, bufferCanvas, bufferContext;

            if(!this.isVisible()) {
                return this;
            }
            if (cachedCanvas) {
                context.save();
                layer._applyTransform(this, context, top);
                this._drawCachedSceneCanvas(context);
                context.restore();
                return this;
            }
            if (!drawFunc) {
                return this;
            }
            context.save();
            // if buffer canvas is needed
            if (this._useBufferCanvas(caching) && !skipBuffer) {
                stage = this.getStage();
                bufferCanvas = stage.bufferCanvas;
                bufferContext = bufferCanvas.getContext();
                bufferContext.clear();
                bufferContext.save();
                bufferContext._applyLineJoin(this);
                // layer might be undefined if we are using cache before adding to layer
                if (!caching) {
                    if (layer) {
                        layer._applyTransform(this, bufferContext, top);
                    } else {
                        var m = this.getAbsoluteTransform(top).getMatrix();
                        context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
                    }
                }

                drawFunc.call(this, bufferContext);
                bufferContext.restore();

                if (hasShadow && !canvas.hitCanvas) {
                        context.save();
                        context._applyShadow(this);
                        context._applyOpacity(this);
                        context.drawImage(bufferCanvas._canvas, 0, 0);
                        context.restore();
                } else {
                    context._applyOpacity(this);
                    context.drawImage(bufferCanvas._canvas, 0, 0);
                }
            }
            // if buffer canvas is not needed
            else {
                context._applyLineJoin(this);
                // layer might be undefined if we are using cache before adding to layer
                if (!caching) {
                    if (layer) {
                        layer._applyTransform(this, context, top);
                    } else {
                        var o = this.getAbsoluteTransform(top).getMatrix();
                        context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
                    }
                }

                if (hasShadow && hasStroke && !canvas.hitCanvas) {
                    context.save();
                    // apply shadow
                    if (!caching) {
                        context._applyOpacity(this);
                    }
                    context._applyShadow(this);
                    drawFunc.call(this, context);
                    context.restore();
                    // if shape has stroke we need to redraw shape
                    // otherwise we will see a shadow under stroke (and over fill)
                    // but I think this is unexpected behavior
                    if (this.hasFill() && this.getShadowForStrokeEnabled()) {
                        drawFunc.call(this, context);
                    }
                } else if (hasShadow && !canvas.hitCanvas) {
                    context.save();
                    if (!caching) {
                        context._applyOpacity(this);
                    }
                    context._applyShadow(this);
                    drawFunc.call(this, context);
                    context.restore();
                } else {
                    if (!caching) {
                        context._applyOpacity(this);
                    }
                    drawFunc.call(this, context);
                }
            }
            context.restore();
            return this;
        },
        drawHit: function(can, top, caching) {
            var layer = this.getLayer(),
                canvas = can || layer.hitCanvas,
                context = canvas.getContext(),
                drawFunc = this.hitFunc() || this.sceneFunc(),
                cachedCanvas = this._cache.canvas,
                cachedHitCanvas = cachedCanvas && cachedCanvas.hit;

            if(!this.shouldDrawHit(canvas)) {
                return this;
            }
            if (layer) {
                layer.clearHitCache();
            }
            if (cachedHitCanvas) {
                context.save();
                layer._applyTransform(this, context, top);
                this._drawCachedHitCanvas(context);
                context.restore();
                return this;
            }
            if (!drawFunc) {
                return this;
            }
            context.save();
            context._applyLineJoin(this);
            if (!caching) {
                if (layer) {
                    layer._applyTransform(this, context, top);
                } else {
                    var o = this.getAbsoluteTransform(top).getMatrix();
                    context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
                }
            }
            drawFunc.call(this, context);
            context.restore();
            return this;
        },
        /**
        * draw hit graph using the cached scene canvas
        * @method
        * @memberof Konva.Shape.prototype
        * @param {Integer} alphaThreshold alpha channel threshold that determines whether or not
        *  a pixel should be drawn onto the hit graph.  Must be a value between 0 and 255.
        *  The default is 0
        * @returns {Konva.Shape}
        * @example
        * shape.cache();
        * shape.drawHitFromCache();
        */
        drawHitFromCache: function(alphaThreshold) {
            var threshold = alphaThreshold || 0,
                cachedCanvas = this._cache.canvas,
                sceneCanvas = this._getCachedSceneCanvas(),
                hitCanvas = cachedCanvas.hit,
                hitContext = hitCanvas.getContext(),
                hitWidth = hitCanvas.getWidth(),
                hitHeight = hitCanvas.getHeight(),
                hitImageData, hitData, len, rgbColorKey, i, alpha;

            hitContext.clear();
            hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);

            try {
                hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);
                hitData = hitImageData.data;
                len = hitData.length;
                rgbColorKey = Konva.Util._hexToRgb(this.colorKey);

                // replace non transparent pixels with color key
                for(i = 0; i < len; i += 4) {
                    alpha = hitData[i + 3];
                    if (alpha > threshold) {
                        hitData[i] = rgbColorKey.r;
                        hitData[i + 1] = rgbColorKey.g;
                        hitData[i + 2] = rgbColorKey.b;
                        hitData[i + 3] = 255;
                    }
                    else {
                        hitData[i + 3] = 0;
                    }
                }
                hitContext.putImageData(hitImageData, 0, 0);
            }
            catch(e) {
                Konva.Util.error('Unable to draw hit graph from cached scene canvas. ' + e.message);
            }

            return this;
        }
    });
    Konva.Util.extend(Konva.Shape, Konva.Node);

    // add getters and setters
    Konva.Factory.addGetterSetter(Konva.Shape, 'stroke');

    /**
     * get/set stroke color
     * @name stroke
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} color
     * @returns {String}
     * @example
     * // get stroke color
     * var stroke = shape.stroke();
     *
     * // set stroke color with color string
     * shape.stroke('green');
     *
     * // set stroke color with hex
     * shape.stroke('#00ff00');
     *
     * // set stroke color with rgb
     * shape.stroke('rgb(0,255,0)');
     *
     * // set stroke color with rgba and make it 50% opaque
     * shape.stroke('rgba(0,255,0,0.5');
     */

    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'strokeRed', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'strokeGreen', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'strokeBlue', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'strokeAlpha', 1, Konva.Validators.alphaComponent);


    Konva.Factory.addGetterSetter(Konva.Shape, 'strokeWidth', 2);

    /**
     * get/set stroke width
     * @name strokeWidth
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} strokeWidth
     * @returns {Number}
     * @example
     * // get stroke width
     * var strokeWidth = shape.strokeWidth();
     *
     * // set stroke width
     * shape.strokeWidth();
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'strokeHitEnabled', true);

    /**
     * get/set strokeHitEnabled property. Useful for performance optimization.
     * You may set `shape.strokeHitEnabled(false)`. In this case stroke will be no draw on hit canvas, so hit area
     * of shape will be decreased (by lineWidth / 2). Remember that non closed line with `strokeHitEnabled = false`
     * will be not drawn on hit canvas, that is mean line will no trigger pointer events (like mouseover)
     * Default value is true
     * @name strokeHitEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} strokeHitEnabled
     * @returns {Boolean}
     * @example
     * // get strokeHitEnabled
     * var strokeHitEnabled = shape.strokeHitEnabled();
     *
     * // set strokeHitEnabled
     * shape.strokeHitEnabled();
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'perfectDrawEnabled', true);

    /**
     * get/set perfectDrawEnabled. If a shape has fill, stroke and opacity you may set `perfectDrawEnabled` to improve performance.
     * See http://konvajs.github.io/docs/performance/Disable_Perfect_Draw.html for more information.
     * Default value is true
     * @name perfectDrawEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} perfectDrawEnabled
     * @returns {Boolean}
     * @example
     * // get perfectDrawEnabled
     * var perfectDrawEnabled = shape.perfectDrawEnabled();
     *
     * // set perfectDrawEnabled
     * shape.perfectDrawEnabled();
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowForStrokeEnabled', true);

    /**
     * get/set shadowForStrokeEnabled. Useful for performance optimization.
     * You may set `shape.shadowForStrokeEnabled(false)`. In this case stroke will be no draw shadow for stroke.
     * Remember if you set `shadowForStrokeEnabled = false` for non closed line - that line with have no shadow!.
     * Default value is true
     * @name shadowForStrokeEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} shadowForStrokeEnabled
     * @returns {Boolean}
     * @example
     * // get shadowForStrokeEnabled
     * var shadowForStrokeEnabled = shape.shadowForStrokeEnabled();
     *
     * // set shadowForStrokeEnabled
     * shape.shadowForStrokeEnabled();
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'lineJoin');

    /**
     * get/set line join.  Can be miter, round, or bevel.  The
     *  default is miter
     * @name lineJoin
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} lineJoin
     * @returns {String}
     * @example
     * // get line join
     * var lineJoin = shape.lineJoin();
     *
     * // set line join
     * shape.lineJoin('round');
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'lineCap');

    /**
     * get/set line cap.  Can be butt, round, or square
     * @name lineCap
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} lineCap
     * @returns {String}
     * @example
     * // get line cap
     * var lineCap = shape.lineCap();
     *
     * // set line cap
     * shape.lineCap('round');
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'sceneFunc');

    /**
     * get/set scene draw function
     * @name sceneFunc
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Function} drawFunc drawing function
     * @returns {Function}
     * @example
     * // get scene draw function
     * var sceneFunc = shape.sceneFunc();
     *
     * // set scene draw function
     * shape.sceneFunc(function(context) {
     *   context.beginPath();
     *   context.rect(0, 0, this.width(), this.height());
     *   context.closePath();
     *   context.fillStrokeShape(this);
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'hitFunc');

    /**
     * get/set hit draw function
     * @name hitFunc
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Function} drawFunc drawing function
     * @returns {Function}
     * @example
     * // get hit draw function
     * var hitFunc = shape.hitFunc();
     *
     * // set hit draw function
     * shape.hitFunc(function(context) {
     *   context.beginPath();
     *   context.rect(0, 0, this.width(), this.height());
     *   context.closePath();
     *   context.fillStrokeShape(this);
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'dash');

    /**
     * get/set dash array for stroke.
     * @name dash
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Array} dash
     * @returns {Array}
     * @example
     *  // apply dashed stroke that is 10px long and 5 pixels apart
     *  line.dash([10, 5]);
     *  // apply dashed stroke that is made up of alternating dashed
     *  // lines that are 10px long and 20px apart, and dots that have
     *  // a radius of 5px and are 20px apart
     *  line.dash([10, 20, 0.001, 20]);
     */


    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowColor');

    /**
     * get/set shadow color
     * @name shadowColor
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} color
     * @returns {String}
     * @example
     * // get shadow color
     * var shadow = shape.shadowColor();
     *
     * // set shadow color with color string
     * shape.shadowColor('green');
     *
     * // set shadow color with hex
     * shape.shadowColor('#00ff00');
     *
     * // set shadow color with rgb
     * shape.shadowColor('rgb(0,255,0)');
     *
     * // set shadow color with rgba and make it 50% opaque
     * shape.shadowColor('rgba(0,255,0,0.5');
     */

    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'shadowRed', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'shadowGreen', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'shadowBlue', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'shadowAlpha', 1, Konva.Validators.alphaComponent);

    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowBlur');

    /**
     * get/set shadow blur
     * @name shadowBlur
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} blur
     * @returns {Number}
     * @example
     * // get shadow blur
     * var shadowBlur = shape.shadowBlur();
     *
     * // set shadow blur
     * shape.shadowBlur(10);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowOpacity');

    /**
     * get/set shadow opacity.  must be a value between 0 and 1
     * @name shadowOpacity
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} opacity
     * @returns {Number}
     * @example
     * // get shadow opacity
     * var shadowOpacity = shape.shadowOpacity();
     *
     * // set shadow opacity
     * shape.shadowOpacity(0.5);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'shadowOffset', ['x', 'y']);

    /**
     * get/set shadow offset
     * @name shadowOffset
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} offset
     * @param {Number} offset.x
     * @param {Number} offset.y
     * @returns {Object}
     * @example
     * // get shadow offset
     * var shadowOffset = shape.shadowOffset();
     *
     * // set shadow offset
     * shape.shadowOffset({
     *   x: 20
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowOffsetX', 0);

     /**
     * get/set shadow offset x
     * @name shadowOffsetX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get shadow offset x
     * var shadowOffsetX = shape.shadowOffsetX();
     *
     * // set shadow offset x
     * shape.shadowOffsetX(5);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowOffsetY', 0);

     /**
     * get/set shadow offset y
     * @name shadowOffsetY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get shadow offset y
     * var shadowOffsetY = shape.shadowOffsetY();
     *
     * // set shadow offset y
     * shape.shadowOffsetY(5);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternImage');

    /**
     * get/set fill pattern image
     * @name fillPatternImage
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Image} image object
     * @returns {Image}
     * @example
     * // get fill pattern image
     * var fillPatternImage = shape.fillPatternImage();
     *
     * // set fill pattern image
     * var imageObj = new Image();
     * imageObj.onload = function() {
     *   shape.fillPatternImage(imageObj);
     * };
     * imageObj.src = 'path/to/image/jpg';
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fill');

    /**
     * get/set fill color
     * @name fill
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} color
     * @returns {String}
     * @example
     * // get fill color
     * var fill = shape.fill();
     *
     * // set fill color with color string
     * shape.fill('green');
     *
     * // set fill color with hex
     * shape.fill('#00ff00');
     *
     * // set fill color with rgb
     * shape.fill('rgb(0,255,0)');
     *
     * // set fill color with rgba and make it 50% opaque
     * shape.fill('rgba(0,255,0,0.5');
     *
     * // shape without fill
     * shape.fill(null);
     */

    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'fillRed', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'fillGreen', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'fillBlue', 0, Konva.Validators.RGBComponent);
    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'fillAlpha', 1, Konva.Validators.alphaComponent);

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternX', 0);

    /**
     * get/set fill pattern x
     * @name fillPatternX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill pattern x
     * var fillPatternX = shape.fillPatternX();
     * // set fill pattern x
     * shape.fillPatternX(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternY', 0);

    /**
     * get/set fill pattern y
     * @name fillPatternY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill pattern y
     * var fillPatternY = shape.fillPatternY();
     * // set fill pattern y
     * shape.fillPatternY(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientColorStops');

    /**
     * get/set fill linear gradient color stops
     * @name fillLinearGradientColorStops
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Array} colorStops
     * @returns {Array} colorStops
     * @example
     * // get fill linear gradient color stops
     * var colorStops = shape.fillLinearGradientColorStops();
     *
     * // create a linear gradient that starts with red, changes to blue
     * // halfway through, and then changes to green
     * shape.fillLinearGradientColorStops(0, 'red', 0.5, 'blue', 1, 'green');
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientStartRadius', 0);

    /**
     * get/set fill radial gradient start radius
     * @name fillRadialGradientStartRadius
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} radius
     * @returns {Number}
     * @example
     * // get radial gradient start radius
     * var startRadius = shape.fillRadialGradientStartRadius();
     *
     * // set radial gradient start radius
     * shape.fillRadialGradientStartRadius(0);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientEndRadius', 0);

    /**
     * get/set fill radial gradient end radius
     * @name fillRadialGradientEndRadius
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} radius
     * @returns {Number}
     * @example
     * // get radial gradient end radius
     * var endRadius = shape.fillRadialGradientEndRadius();
     *
     * // set radial gradient end radius
     * shape.fillRadialGradientEndRadius(100);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientColorStops');

    /**
     * get/set fill radial gradient color stops
     * @name fillRadialGradientColorStops
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} colorStops
     * @returns {Array}
     * @example
     * // get fill radial gradient color stops
     * var colorStops = shape.fillRadialGradientColorStops();
     *
     * // create a radial gradient that starts with red, changes to blue
     * // halfway through, and then changes to green
     * shape.fillRadialGradientColorStops(0, 'red', 0.5, 'blue', 1, 'green');
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternRepeat', 'repeat');

    /**
     * get/set fill pattern repeat.  Can be 'repeat', 'repeat-x', 'repeat-y', or 'no-repeat'.  The default is 'repeat'
     * @name fillPatternRepeat
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} repeat
     * @returns {String}
     * @example
     * // get fill pattern repeat
     * var repeat = shape.fillPatternRepeat();
     *
     * // repeat pattern in x direction only
     * shape.fillPatternRepeat('repeat-x');
     *
     * // do not repeat the pattern
     * shape.fillPatternRepeat('no repeat');
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillEnabled', true);

    /**
     * get/set fill enabled flag
     * @name fillEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get fill enabled flag
     * var fillEnabled = shape.fillEnabled();
     *
     * // disable fill
     * shape.fillEnabled(false);
     *
     * // enable fill
     * shape.fillEnabled(true);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'strokeEnabled', true);

    /**
     * get/set stroke enabled flag
     * @name strokeEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get stroke enabled flag
     * var strokeEnabled = shape.strokeEnabled();
     *
     * // disable stroke
     * shape.strokeEnabled(false);
     *
     * // enable stroke
     * shape.strokeEnabled(true);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowEnabled', true);

    /**
     * get/set shadow enabled flag
     * @name shadowEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get shadow enabled flag
     * var shadowEnabled = shape.shadowEnabled();
     *
     * // disable shadow
     * shape.shadowEnabled(false);
     *
     * // enable shadow
     * shape.shadowEnabled(true);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'dashEnabled', true);

    /**
     * get/set dash enabled flag
     * @name dashEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get dash enabled flag
     * var dashEnabled = shape.dashEnabled();
     *
     * // disable dash
     * shape.dashEnabled(false);
     *
     * // enable dash
     * shape.dashEnabled(true);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'strokeScaleEnabled', true);

    /**
     * get/set strokeScale enabled flag
     * @name strokeScaleEnabled
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get stroke scale enabled flag
     * var strokeScaleEnabled = shape.strokeScaleEnabled();
     *
     * // disable stroke scale
     * shape.strokeScaleEnabled(false);
     *
     * // enable stroke scale
     * shape.strokeScaleEnabled(true);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPriority', 'color');

    /**
     * get/set fill priority.  can be color, pattern, linear-gradient, or radial-gradient.  The default is color.
     *   This is handy if you want to toggle between different fill types.
     * @name fillPriority
     * @method
     * @memberof Konva.Shape.prototype
     * @param {String} priority
     * @returns {String}
     * @example
     * // get fill priority
     * var fillPriority = shape.fillPriority();
     *
     * // set fill priority
     * shape.fillPriority('linear-gradient');
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillPatternOffset', ['x', 'y']);

    /**
     * get/set fill pattern offset
     * @name fillPatternOffset
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} offset
     * @param {Number} offset.x
     * @param {Number} offset.y
     * @returns {Object}
     * @example
     * // get fill pattern offset
     * var patternOffset = shape.fillPatternOffset();
     *
     * // set fill pattern offset
     * shape.fillPatternOffset({
     *   x: 20
     *   y: 10
     * });
     */


    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternOffsetX', 0);
    /**
     * get/set fill pattern offset x
     * @name fillPatternOffsetX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill pattern offset x
     * var patternOffsetX = shape.fillPatternOffsetX();
     *
     * // set fill pattern offset x
     * shape.fillPatternOffsetX(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternOffsetY', 0);
    /**
     * get/set fill pattern offset y
     * @name fillPatternOffsetY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill pattern offset y
     * var patternOffsetY = shape.fillPatternOffsetY();
     *
     * // set fill pattern offset y
     * shape.fillPatternOffsetY(10);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillPatternScale', ['x', 'y']);

    /**
     * get/set fill pattern scale
     * @name fillPatternScale
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} scale
     * @param {Number} scale.x
     * @param {Number} scale.y
     * @returns {Object}
     * @example
     * // get fill pattern scale
     * var patternScale = shape.fillPatternScale();
     *
     * // set fill pattern scale
     * shape.fillPatternScale({
     *   x: 2
     *   y: 2
     * });
     */


    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternScaleX', 1);
    /**
     * get/set fill pattern scale x
     * @name fillPatternScaleX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill pattern scale x
     * var patternScaleX = shape.fillPatternScaleX();
     *
     * // set fill pattern scale x
     * shape.fillPatternScaleX(2);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternScaleY', 1);
    /**
     * get/set fill pattern scale y
     * @name fillPatternScaleY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill pattern scale y
     * var patternScaleY = shape.fillPatternScaleY();
     *
     * // set fill pattern scale y
     * shape.fillPatternScaleY(2);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillLinearGradientStartPoint', ['x', 'y']);

    /**
     * get/set fill linear gradient start point
     * @name fillLinearGradientStartPoint
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} startPoint
     * @param {Number} startPoint.x
     * @param {Number} startPoint.y
     * @returns {Object}
     * @example
     * // get fill linear gradient start point
     * var startPoint = shape.fillLinearGradientStartPoint();
     *
     * // set fill linear gradient start point
     * shape.fillLinearGradientStartPoint({
     *   x: 20
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientStartPointX', 0);
    /**
     * get/set fill linear gradient start point x
     * @name fillLinearGradientStartPointX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill linear gradient start point x
     * var startPointX = shape.fillLinearGradientStartPointX();
     *
     * // set fill linear gradient start point x
     * shape.fillLinearGradientStartPointX(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientStartPointY', 0);
    /**
     * get/set fill linear gradient start point y
     * @name fillLinearGradientStartPointY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill linear gradient start point y
     * var startPointY = shape.fillLinearGradientStartPointY();
     *
     * // set fill linear gradient start point y
     * shape.fillLinearGradientStartPointY(20);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillLinearGradientEndPoint', ['x', 'y']);

    /**
     * get/set fill linear gradient end point
     * @name fillLinearGradientEndPoint
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} endPoint
     * @param {Number} endPoint.x
     * @param {Number} endPoint.y
     * @returns {Object}
     * @example
     * // get fill linear gradient end point
     * var endPoint = shape.fillLinearGradientEndPoint();
     *
     * // set fill linear gradient end point
     * shape.fillLinearGradientEndPoint({
     *   x: 20
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientEndPointX', 0);
    /**
     * get/set fill linear gradient end point x
     * @name fillLinearGradientEndPointX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill linear gradient end point x
     * var endPointX = shape.fillLinearGradientEndPointX();
     *
     * // set fill linear gradient end point x
     * shape.fillLinearGradientEndPointX(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientEndPointY', 0);
    /**
     * get/set fill linear gradient end point y
     * @name fillLinearGradientEndPointY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill linear gradient end point y
     * var endPointY = shape.fillLinearGradientEndPointY();
     *
     * // set fill linear gradient end point y
     * shape.fillLinearGradientEndPointY(20);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillRadialGradientStartPoint', ['x', 'y']);

    /**
     * get/set fill radial gradient start point
     * @name fillRadialGradientStartPoint
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} startPoint
     * @param {Number} startPoint.x
     * @param {Number} startPoint.y
     * @returns {Object}
     * @example
     * // get fill radial gradient start point
     * var startPoint = shape.fillRadialGradientStartPoint();
     *
     * // set fill radial gradient start point
     * shape.fillRadialGradientStartPoint({
     *   x: 20
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientStartPointX', 0);
    /**
     * get/set fill radial gradient start point x
     * @name fillRadialGradientStartPointX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill radial gradient start point x
     * var startPointX = shape.fillRadialGradientStartPointX();
     *
     * // set fill radial gradient start point x
     * shape.fillRadialGradientStartPointX(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientStartPointY', 0);
    /**
     * get/set fill radial gradient start point y
     * @name fillRadialGradientStartPointY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill radial gradient start point y
     * var startPointY = shape.fillRadialGradientStartPointY();
     *
     * // set fill radial gradient start point y
     * shape.fillRadialGradientStartPointY(20);
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillRadialGradientEndPoint', ['x', 'y']);

    /**
     * get/set fill radial gradient end point
     * @name fillRadialGradientEndPoint
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} endPoint
     * @param {Number} endPoint.x
     * @param {Number} endPoint.y
     * @returns {Object}
     * @example
     * // get fill radial gradient end point
     * var endPoint = shape.fillRadialGradientEndPoint();
     *
     * // set fill radial gradient end point
     * shape.fillRadialGradientEndPoint({
     *   x: 20
     *   y: 10
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientEndPointX', 0);
    /**
     * get/set fill radial gradient end point x
     * @name fillRadialGradientEndPointX
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get fill radial gradient end point x
     * var endPointX = shape.fillRadialGradientEndPointX();
     *
     * // set fill radial gradient end point x
     * shape.fillRadialGradientEndPointX(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientEndPointY', 0);
    /**
     * get/set fill radial gradient end point y
     * @name fillRadialGradientEndPointY
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get fill radial gradient end point y
     * var endPointY = shape.fillRadialGradientEndPointY();
     *
     * // set fill radial gradient end point y
     * shape.fillRadialGradientEndPointY(20);
     */

    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternRotation', 0);

    /**
     * get/set fill pattern rotation in degrees
     * @name fillPatternRotation
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Number} rotation
     * @returns {Konva.Shape}
     * @example
     * // get fill pattern rotation
     * var patternRotation = shape.fillPatternRotation();
     *
     * // set fill pattern rotation
     * shape.fillPatternRotation(20);
     */


    Konva.Factory.backCompat(Konva.Shape, {
        dashArray: 'dash',
        getDashArray: 'getDash',
        setDashArray: 'getDash',

        drawFunc: 'sceneFunc',
        getDrawFunc: 'getSceneFunc',
        setDrawFunc: 'setSceneFunc',

        drawHitFunc: 'hitFunc',
        getDrawHitFunc: 'getHitFunc',
        setDrawHitFunc: 'setHitFunc'
    });

    Konva.Collection.mapMethods(Konva.Shape);
})(Konva);

(function() {
    'use strict';
    // CONSTANTS
    var STAGE = 'Stage',
        STRING = 'string',
        PX = 'px',

        MOUSEOUT = 'mouseout',
        MOUSELEAVE = 'mouseleave',
        MOUSEOVER = 'mouseover',
        MOUSEENTER = 'mouseenter',
        MOUSEMOVE = 'mousemove',
        MOUSEDOWN = 'mousedown',
        MOUSEUP = 'mouseup',
        CLICK = 'click',
        DBL_CLICK = 'dblclick',
        TOUCHSTART = 'touchstart',
        TOUCHEND = 'touchend',
        TAP = 'tap',
        DBL_TAP = 'dbltap',
        TOUCHMOVE = 'touchmove',
        DOMMOUSESCROLL = 'DOMMouseScroll',
        MOUSEWHEEL = 'mousewheel',
        WHEEL = 'wheel',

        CONTENT_MOUSEOUT = 'contentMouseout',
        CONTENT_MOUSEOVER = 'contentMouseover',
        CONTENT_MOUSEMOVE = 'contentMousemove',
        CONTENT_MOUSEDOWN = 'contentMousedown',
        CONTENT_MOUSEUP = 'contentMouseup',
        CONTENT_CLICK = 'contentClick',
        CONTENT_DBL_CLICK = 'contentDblclick',
        CONTENT_TOUCHSTART = 'contentTouchstart',
        CONTENT_TOUCHEND = 'contentTouchend',
        CONTENT_DBL_TAP = 'contentDbltap',
        CONTENT_TAP = 'contentTap',
        CONTENT_TOUCHMOVE = 'contentTouchmove',

        DIV = 'div',
        RELATIVE = 'relative',
        KONVA_CONTENT = 'konvajs-content',
        SPACE = ' ',
        UNDERSCORE = '_',
        CONTAINER = 'container',
        EMPTY_STRING = '',
        EVENTS = [MOUSEDOWN, MOUSEMOVE, MOUSEUP, MOUSEOUT, TOUCHSTART, TOUCHMOVE, TOUCHEND, MOUSEOVER, DOMMOUSESCROLL, MOUSEWHEEL, WHEEL],

        // cached variables
        eventsLength = EVENTS.length;

    function addEvent(ctx, eventName) {
        ctx.content.addEventListener(eventName, function(evt) {
            ctx[UNDERSCORE + eventName](evt);
        }, false);
    }

    /**
     * Stage constructor.  A stage is used to contain multiple layers
     * @constructor
     * @memberof Konva
     * @augments Konva.Container
     * @param {Object} config
     * @param {String|Element} config.container Container id or DOM element
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var stage = new Konva.Stage({
         *   width: 500,
         *   height: 800,
         *   container: 'containerId'
         * });
     */
    Konva.Stage = function(config) {
        this.___init(config);
    };

    Konva.Util.addMethods(Konva.Stage, {
        ___init: function(config) {
            this.nodeType = STAGE;
            // call super constructor
            Konva.Container.call(this, config);
            this._id = Konva.idCounter++;
            this._buildDOM();
            this._bindContentEvents();
            this._enableNestedTransforms = false;
            Konva.stages.push(this);
        },
        _validateAdd: function(child) {
            if (child.getType() !== 'Layer') {
                Konva.Util.throw('You may only add layers to the stage.');
            }
        },
        /**
         * set container dom element which contains the stage wrapper div element
         * @method
         * @memberof Konva.Stage.prototype
         * @param {DomElement} container can pass in a dom element or id string
         */
        setContainer: function(container) {
            if( typeof container === STRING) {
                var id = container;
                container = Konva.document.getElementById(container);
                if (!container) {
                    throw 'Can not find container in document with id ' + id;
                }
            }
            this._setAttr(CONTAINER, container);
            return this;
        },
        shouldDrawHit: function() {
            return true;
        },
        draw: function() {
            Konva.Node.prototype.draw.call(this);
            return this;
        },
        /**
         * draw layer scene graphs
         * @name draw
         * @method
         * @memberof Konva.Stage.prototype
         */

        /**
         * draw layer hit graphs
         * @name drawHit
         * @method
         * @memberof Konva.Stage.prototype
         */

        /**
         * set height
         * @method
         * @memberof Konva.Stage.prototype
         * @param {Number} height
         */
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            this._resizeDOM();
            return this;
        },
        /**
         * set width
         * @method
         * @memberof Konva.Stage.prototype
         * @param {Number} width
         */
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            this._resizeDOM();
            return this;
        },
        /**
         * clear all layers
         * @method
         * @memberof Konva.Stage.prototype
         */
        clear: function() {
            var layers = this.children,
                len = layers.length,
                n;

            for(n = 0; n < len; n++) {
                layers[n].clear();
            }
            return this;
        },
        clone: function(obj) {
            if (!obj) {
                obj = {};
            }
            obj.container = Konva.document.createElement(DIV);
            return Konva.Container.prototype.clone.call(this, obj);
        },
        /**
         * destroy stage
         * @method
         * @memberof Konva.Stage.prototype
         */
        destroy: function() {
            var content = this.content;
            Konva.Container.prototype.destroy.call(this);

            if(content && Konva.Util._isInDocument(content)) {
                this.getContainer().removeChild(content);
            }
            var index = Konva.stages.indexOf(this);
            if (index > -1) {
                Konva.stages.splice(index, 1);
            }
            return this;
        },
        /**
         * get pointer position which can be a touch position or mouse position
         * @method
         * @memberof Konva.Stage.prototype
         * @returns {Object}
         */
        getPointerPosition: function() {
            return this.pointerPos;
        },
        getStage: function() {
            return this;
        },
        /**
         * get stage content div element which has the
         *  the class name "konvajs-content"
         * @method
         * @memberof Konva.Stage.prototype
         */
        getContent: function() {
            return this.content;
        },
        /**
         * Creates a composite data URL
         * @method
         * @memberof Konva.Stage.prototype
         * @param {Object} config
         * @param {Function} [config.callback] function executed when the composite has completed. Deprecated as method is sync now.
         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
         *  "image/png" is the default
         * @param {Number} [config.x] x position of canvas section
         * @param {Number} [config.y] y position of canvas section
         * @param {Number} [config.width] width of canvas section
         * @param {Number} [config.height] height of canvas section
         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
         *  is very high quality
         */
        toDataURL: function(config) {
            config = config || {};

            var mimeType = config.mimeType || null,
                quality = config.quality || null,
                x = config.x || 0,
                y = config.y || 0,
                canvas = new Konva.SceneCanvas({
                    width: config.width || this.getWidth(),
                    height: config.height || this.getHeight(),
                    pixelRatio: config.pixelRatio
                }),
                _context = canvas.getContext()._context,
                layers = this.children;

            if(x || y) {
                _context.translate(-1 * x, -1 * y);
            }


            layers.each(function(layer) {
                var width = layer.getCanvas().getWidth();
                var height = layer.getCanvas().getHeight();
                var ratio = layer.getCanvas().getPixelRatio();
                _context.drawImage(layer.getCanvas()._canvas, 0, 0, width / ratio, height / ratio);
            });
            var src = canvas.toDataURL(mimeType, quality);

            if (config.callback) {
                config.callback(src);
            }

            return src;
        },
        /**
         * converts stage into an image.
         * @method
         * @memberof Konva.Stage.prototype
         * @param {Object} config
         * @param {Function} config.callback function executed when the composite has completed
         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
         *  "image/png" is the default
         * @param {Number} [config.x] x position of canvas section
         * @param {Number} [config.y] y position of canvas section
         * @param {Number} [config.width] width of canvas section
         * @param {Number} [config.height] height of canvas section
         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
         *  is very high quality
         */
        toImage: function(config) {
            var cb = config.callback;

            config.callback = function(dataUrl) {
                Konva.Util._getImage(dataUrl, function(img) {
                    cb(img);
                });
            };
            this.toDataURL(config);
        },
        /**
         * get visible intersection shape. This is the preferred
         *  method for determining if a point intersects a shape or not
         * @method
         * @memberof Konva.Stage.prototype
         * @param {Object} pos
         * @param {Number} pos.x
         * @param {Number} pos.y
         * @param {String} [selector]
         * @returns {Konva.Node}
         * @example
         * var shape = stage.getIntersection({x: 50, y: 50});
         * // or if you interested in shape parent:
         * var group = stage.getIntersection({x: 50, y: 50}, 'Group');
         */
        getIntersection: function(pos, selector) {
            var layers = this.getChildren(),
                len = layers.length,
                end = len - 1,
                n, shape;

            for(n = end; n >= 0; n--) {
                shape = layers[n].getIntersection(pos, selector);
                if (shape) {
                    return shape;
                }
            }

            return null;
        },
        _resizeDOM: function() {
            if(this.content) {
                var width = this.getWidth(),
                    height = this.getHeight(),
                    layers = this.getChildren(),
                    len = layers.length,
                    n, layer;

                // set content dimensions
                this.content.style.width = width + PX;
                this.content.style.height = height + PX;

                this.bufferCanvas.setSize(width, height);
                this.bufferHitCanvas.setSize(width, height);

                // set layer dimensions
                for(n = 0; n < len; n++) {
                    layer = layers[n];
                    layer.setSize(width, height);
                    layer.draw();
                }
            }
        },
        /**
         * add layer or layers to stage
         * @method
         * @memberof Konva.Stage.prototype
         * @param {...Konva.Layer} layer
         * @example
         * stage.add(layer1, layer2, layer3);
         */
        add: function(layer) {
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) {
                    this.add(arguments[i]);
                }
                return this;
            }
            Konva.Container.prototype.add.call(this, layer);
            layer._setCanvasSize(this.width(), this.height());

            // draw layer and append canvas to container
            layer.draw();
            this.content.appendChild(layer.canvas._canvas);

            // chainable
            return this;
        },
        getParent: function() {
            return null;
        },
        getLayer: function() {
            return null;
        },
        /**
         * returns a {@link Konva.Collection} of layers
         * @method
         * @memberof Konva.Stage.prototype
         */
        getLayers: function() {
            return this.getChildren();
        },
        _bindContentEvents: function() {
            for (var n = 0; n < eventsLength; n++) {
                addEvent(this, EVENTS[n]);
            }
        },
        _mouseover: function(evt) {
            if (!Konva.UA.mobile) {
                this._setPointerPosition(evt);
                this._fire(CONTENT_MOUSEOVER, {evt: evt});
            }
        },
        _mouseout: function(evt) {
            if (!Konva.UA.mobile) {
                this._setPointerPosition(evt);
                var targetShape = this.targetShape;

                if(targetShape && !Konva.isDragging()) {
                    targetShape._fireAndBubble(MOUSEOUT, {evt: evt});
                    targetShape._fireAndBubble(MOUSELEAVE, {evt: evt});
                    this.targetShape = null;
                }
                this.pointerPos = undefined;

                this._fire(CONTENT_MOUSEOUT, {evt: evt});
            }
        },
        _mousemove: function(evt) {
            // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event
            if (Konva.UA.ieMobile) {
                return this._touchmove(evt);
            }
            // workaround fake mousemove event in chrome browser https://code.google.com/p/chromium/issues/detail?id=161464
            if ((typeof evt.movementX !== 'undefined' || typeof evt.movementY !== 'undefined') && evt.movementY === 0 && evt.movementX === 0) {
                return null;
            }
            if (Konva.UA.mobile) {
                return null;
            }
            this._setPointerPosition(evt);
            var shape;

            if (!Konva.isDragging()) {
                shape = this.getIntersection(this.getPointerPosition());
                if(shape && shape.isListening()) {
                    if(!Konva.isDragging() && (!this.targetShape || this.targetShape._id !== shape._id)) {
                        if(this.targetShape) {
                            this.targetShape._fireAndBubble(MOUSEOUT, {evt: evt}, shape);
                            this.targetShape._fireAndBubble(MOUSELEAVE, {evt: evt}, shape);
                        }
                        shape._fireAndBubble(MOUSEOVER, {evt: evt}, this.targetShape);
                        shape._fireAndBubble(MOUSEENTER, {evt: evt}, this.targetShape);
                        this.targetShape = shape;
                    }
                    else {
                        shape._fireAndBubble(MOUSEMOVE, {evt: evt});
                    }
                }
                /*
                 * if no shape was detected, clear target shape and try
                 * to run mouseout from previous target shape
                 */
                else {
                    if(this.targetShape && !Konva.isDragging()) {
                        this.targetShape._fireAndBubble(MOUSEOUT, {evt: evt});
                        this.targetShape._fireAndBubble(MOUSELEAVE, {evt: evt});
                        this.targetShape = null;
                    }

                }

                // content event
                this._fire(CONTENT_MOUSEMOVE, {evt: evt});
            }

            // always call preventDefault for desktop events because some browsers
            // try to drag and drop the canvas element
            if (evt.preventDefault) {
                evt.preventDefault();
            }
        },
        _mousedown: function(evt) {
            // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event
            if (Konva.UA.ieMobile) {
                return this._touchstart(evt);
            }
            if (!Konva.UA.mobile) {
                this._setPointerPosition(evt);
                var shape = this.getIntersection(this.getPointerPosition());

                Konva.listenClickTap = true;

                if (shape && shape.isListening()) {
                    this.clickStartShape = shape;
                    shape._fireAndBubble(MOUSEDOWN, {evt: evt});
                }

                // content event
                this._fire(CONTENT_MOUSEDOWN, {evt: evt});
            }

            // always call preventDefault for desktop events because some browsers
            // try to drag and drop the canvas element
            if (evt.preventDefault) {
                evt.preventDefault();
            }
        },
        _mouseup: function(evt) {

            // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event
            if (Konva.UA.ieMobile) {
                return this._touchend(evt);
            }
            if (!Konva.UA.mobile) {
                this._setPointerPosition(evt);
                var shape = this.getIntersection(this.getPointerPosition()),
                    clickStartShape = this.clickStartShape,
                    fireDblClick = false,
                    dd = Konva.DD;

                if(Konva.inDblClickWindow) {
                    fireDblClick = true;
                    Konva.inDblClickWindow = false;
                }
                // don't set inDblClickWindow after dragging
                else if (!dd || !dd.justDragged) {
                    Konva.inDblClickWindow = true;
                } else if (dd) {
                    dd.justDragged = false;
                }

                setTimeout(function() {
                    Konva.inDblClickWindow = false;
                }, Konva.dblClickWindow);

                if (shape && shape.isListening()) {
                    shape._fireAndBubble(MOUSEUP, {evt: evt});

                    // detect if click or double click occurred
                    if(Konva.listenClickTap && clickStartShape && clickStartShape._id === shape._id) {
                        shape._fireAndBubble(CLICK, {evt: evt});

                        if(fireDblClick) {
                            shape._fireAndBubble(DBL_CLICK, {evt: evt});
                        }
                    }
                }
                // content events
                this._fire(CONTENT_MOUSEUP, {evt: evt});
                if (Konva.listenClickTap) {
                    this._fire(CONTENT_CLICK, {evt: evt});
                    if(fireDblClick) {
                        this._fire(CONTENT_DBL_CLICK, {evt: evt});
                    }
                }

                Konva.listenClickTap = false;
            }

            // always call preventDefault for desktop events because some browsers
            // try to drag and drop the canvas element
            if (evt.preventDefault) {
                evt.preventDefault();
            }
        },
        _touchstart: function(evt) {
            this._setPointerPosition(evt);
            var shape = this.getIntersection(this.getPointerPosition());

            Konva.listenClickTap = true;

            if (shape && shape.isListening()) {
                this.tapStartShape = shape;
                shape._fireAndBubble(TOUCHSTART, {evt: evt});

                // only call preventDefault if the shape is listening for events
                if (shape.isListening() && evt.preventDefault) {
                    evt.preventDefault();
                }
            }
            // content event
            this._fire(CONTENT_TOUCHSTART, {evt: evt});
        },
        _touchend: function(evt) {
            this._setPointerPosition(evt);
            var shape = this.getIntersection(this.getPointerPosition()),
                fireDblClick = false;

            if(Konva.inDblClickWindow) {
                fireDblClick = true;
                Konva.inDblClickWindow = false;
            }
            else {
                Konva.inDblClickWindow = true;
            }

            setTimeout(function() {
                Konva.inDblClickWindow = false;
            }, Konva.dblClickWindow);

            if (shape && shape.isListening()) {
                shape._fireAndBubble(TOUCHEND, {evt: evt});

                // detect if tap or double tap occurred
                if(Konva.listenClickTap && shape._id === this.tapStartShape._id) {
                    shape._fireAndBubble(TAP, {evt: evt});

                    if(fireDblClick) {
                        shape._fireAndBubble(DBL_TAP, {evt: evt});
                    }
                }
                // only call preventDefault if the shape is listening for events
                if (shape.isListening() && evt.preventDefault) {
                    evt.preventDefault();
                }
            }
            // content events
            this._fire(CONTENT_TOUCHEND, {evt: evt});
            if (Konva.listenClickTap) {
                this._fire(CONTENT_TAP, {evt: evt});
                if(fireDblClick) {
                    this._fire(CONTENT_DBL_TAP, {evt: evt});
                }
            }

            Konva.listenClickTap = false;
        },
        _touchmove: function(evt) {
            this._setPointerPosition(evt);
            var dd = Konva.DD,
                shape;
            if (!Konva.isDragging()) {
                shape = this.getIntersection(this.getPointerPosition());
                if (shape && shape.isListening()) {
                    shape._fireAndBubble(TOUCHMOVE, {evt: evt});
                    // only call preventDefault if the shape is listening for events
                    if (shape.isListening() && evt.preventDefault) {
                        evt.preventDefault();
                    }
                }
                this._fire(CONTENT_TOUCHMOVE, {evt: evt});
            }
            if(dd) {
                if (Konva.isDragging()) {
                    evt.preventDefault();
                }
            }
        },
        _DOMMouseScroll: function(evt) {
            this._mousewheel(evt);
        },
        _mousewheel: function(evt) {
            this._setPointerPosition(evt);
            var shape = this.getIntersection(this.getPointerPosition());

            if (shape && shape.isListening()) {
                shape._fireAndBubble(MOUSEWHEEL, {evt: evt});
            }
        },
        _wheel: function(evt) {
            this._mousewheel(evt);
        },
        _setPointerPosition: function(evt) {
            var contentPosition = this._getContentPosition(),
                x = null,
                y = null;
            evt = evt ? evt : window.event;

            // touch events
            if(evt.touches !== undefined) {
                // currently, only handle one finger
                if (evt.touches.length > 0) {

                    var touch = evt.touches[0];
                    // get the information for finger #1
                    x = touch.clientX - contentPosition.left;
                    y = touch.clientY - contentPosition.top;
                }
            }
            // mouse events
            else {
                x = evt.clientX - contentPosition.left;
                y = evt.clientY - contentPosition.top;
            }
            if (x !== null && y !== null) {
                this.pointerPos = {
                    x: x,
                    y: y
                };
            }
        },
        _getContentPosition: function() {
            var rect = this.content.getBoundingClientRect ? this.content.getBoundingClientRect() : { top: 0, left: 0 };
            return {
                top: rect.top,
                left: rect.left
            };
        },
        _buildDOM: function() {
            var container = this.getContainer();
            if (!container) {
                if (Konva.Util.isBrowser()) {
                    throw 'Stage has no container. A container is required.';
                } else {
                    // automatically create element for jsdom in nodejs env
                    container = Konva.document.createElement(DIV);
                }
            }
            // clear content inside container
            container.innerHTML = EMPTY_STRING;

            // content
            this.content = Konva.document.createElement(DIV);
            this.content.style.position = RELATIVE;
            this.content.className = KONVA_CONTENT;
            this.content.setAttribute('role', 'presentation');
            container.appendChild(this.content);

            // the buffer canvas pixel ratio must be 1 because it is used as an
            // intermediate canvas before copying the result onto a scene canvas.
            // not setting it to 1 will result in an over compensation
            this.bufferCanvas = new Konva.SceneCanvas({
                pixelRatio: 1
            });
            this.bufferHitCanvas = new Konva.HitCanvas();

            this._resizeDOM();
        },
        _onContent: function(typesStr, handler) {
            var types = typesStr.split(SPACE),
                len = types.length,
                n, baseEvent;

            for(n = 0; n < len; n++) {
                baseEvent = types[n];
                this.content.addEventListener(baseEvent, handler, false);
            }
        },
        // currently cache function is now working for stage, because stage has no its own canvas element
        // TODO: may be it is better to cache all children layers?
        cache: function() {
            Konva.Util.warn('Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.');
        },
        clearCache: function() {
        }
    });
    Konva.Util.extend(Konva.Stage, Konva.Container);

    // add getters and setters
    Konva.Factory.addGetter(Konva.Stage, 'container');
    Konva.Factory.addOverloadedGetterSetter(Konva.Stage, 'container');

    /**
     * get container DOM element
     * @name container
     * @method
     * @memberof Konva.Stage.prototype
     * @returns {DomElement} container
     * @example
     * // get container
     * var container = stage.container();
     * // set container
     * var container = document.createElement('div');
     * body.appendChild(container);
     * stage.container(container);
     */

})();

(function() {
    'use strict';
    /**
     * BaseLayer constructor.
     * @constructor
     * @memberof Konva
     * @augments Konva.Container
     * @param {Object} config
     * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
     * to clear the canvas before each layer draw.  The default value is true.
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height

     * @example
     * var layer = new Konva.Layer();
     */
    Konva.BaseLayer = function(config) {
        this.___init(config);
    };

    Konva.Util.addMethods(Konva.BaseLayer, {
        ___init: function(config) {
            this.nodeType = 'Layer';
            Konva.Container.call(this, config);
        },
        createPNGStream: function() {
            return this.canvas._canvas.createPNGStream();
        },
        /**
         * get layer canvas
         * @method
         * @memberof Konva.BaseLayer.prototype
         */
        getCanvas: function() {
            return this.canvas;
        },
        /**
         * get layer hit canvas
         * @method
         * @memberof Konva.BaseLayer.prototype
         */
        getHitCanvas: function() {
            return this.hitCanvas;
        },
        /**
         * get layer canvas context
         * @method
         * @memberof Konva.BaseLayer.prototype
         */
        getContext: function() {
            return this.getCanvas().getContext();
        },
        /**
         * clear scene and hit canvas contexts tied to the layer
         * @method
         * @memberof Konva.BaseLayer.prototype
         * @param {Object} [bounds]
         * @param {Number} [bounds.x]
         * @param {Number} [bounds.y]
         * @param {Number} [bounds.width]
         * @param {Number} [bounds.height]
         * @example
         * layer.clear();
         * layer.clear({
         *   x : 0,
         *   y : 0,
         *   width : 100,
         *   height : 100
         * });
         */
        clear: function(bounds) {
            this.getContext().clear(bounds);
            return this;
        },
        clearHitCache: function() {
            this._hitImageData = undefined;
        },
        // extend Node.prototype.setZIndex
        setZIndex: function(index) {
            Konva.Node.prototype.setZIndex.call(this, index);
            var stage = this.getStage();
            if(stage) {
                stage.content.removeChild(this.getCanvas()._canvas);

                if(index < stage.getChildren().length - 1) {
                    stage.content.insertBefore(this.getCanvas()._canvas, stage.getChildren()[index + 1].getCanvas()._canvas);
                }
                else {
                    stage.content.appendChild(this.getCanvas()._canvas);
                }
            }
            return this;
        },
        // extend Node.prototype.moveToTop
        moveToTop: function() {
            Konva.Node.prototype.moveToTop.call(this);
            var stage = this.getStage();
            if(stage) {
                stage.content.removeChild(this.getCanvas()._canvas);
                stage.content.appendChild(this.getCanvas()._canvas);
            }
            return this;
        },
        // extend Node.prototype.moveUp
        moveUp: function() {
            var moved = Konva.Node.prototype.moveUp.call(this);
            if (!moved){
                return this;
            }
            var stage = this.getStage();
            if(!stage) {
                return this;
            }
            stage.content.removeChild(this.getCanvas()._canvas);

            if(this.index < stage.getChildren().length - 1) {
                stage.content.insertBefore(this.getCanvas()._canvas, stage.getChildren()[this.index + 1].getCanvas()._canvas);
            } else {
                stage.content.appendChild(this.getCanvas()._canvas);
            }
            return this;
        },
        // extend Node.prototype.moveDown
        moveDown: function() {
            if(Konva.Node.prototype.moveDown.call(this)) {
                var stage = this.getStage();
                if(stage) {
                    var children = stage.getChildren();
                    stage.content.removeChild(this.getCanvas()._canvas);
                    stage.content.insertBefore(this.getCanvas()._canvas, children[this.index + 1].getCanvas()._canvas);
                }
            }
            return this;
        },
        // extend Node.prototype.moveToBottom
        moveToBottom: function() {
            if(Konva.Node.prototype.moveToBottom.call(this)) {
                var stage = this.getStage();
                if(stage) {
                    var children = stage.getChildren();
                    stage.content.removeChild(this.getCanvas()._canvas);
                    stage.content.insertBefore(this.getCanvas()._canvas, children[1].getCanvas()._canvas);
                }
            }
            return this;
        },
        getLayer: function() {
            return this;
        },
        remove: function() {
            var _canvas = this.getCanvas()._canvas;

            Konva.Node.prototype.remove.call(this);

            if(_canvas && _canvas.parentNode && Konva.Util._isInDocument(_canvas)) {
                _canvas.parentNode.removeChild(_canvas);
            }
            return this;
        },
        getStage: function() {
            return this.parent;
        },
        setSize: function(width, height) {
            this.canvas.setSize(width, height);
            return this;
        },
        /**
         * get/set width of layer.getter return width of stage. setter doing nothing.
         * if you want change width use `stage.width(value);`
         * @name width
         * @method
         * @memberof Konva.BaseLayer.prototype
         * @returns {Number}
         * @example
         * var width = layer.width();
         */
        getWidth: function() {
            if (this.parent) {
                return this.parent.getWidth();
            }
        },
        setWidth: function() {
            Konva.Util.warn('Can not change width of layer. Use "stage.width(value)" function instead.');
        },
        /**
         * get/set height of layer.getter return height of stage. setter doing nothing.
         * if you want change height use `stage.height(value);`
         * @name height
         * @method
         * @memberof Konva.BaseLayer.prototype
         * @returns {Number}
         * @example
         * var height = layer.height();
         */
        getHeight: function() {
            if (this.parent) {
                return this.parent.getHeight();
            }
        },
        setHeight: function() {
            Konva.Util.warn('Can not change height of layer. Use "stage.height(value)" function instead.');
        },
        // the apply transform method is handled by the Layer and FastLayer class
        // because it is up to the layer to decide if an absolute or relative transform
        // should be used
        _applyTransform: function(shape, context, top) {
            var m = shape.getAbsoluteTransform(top).getMatrix();
            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
        }
    });
    Konva.Util.extend(Konva.BaseLayer, Konva.Container);

    // add getters and setters
    Konva.Factory.addGetterSetter(Konva.BaseLayer, 'clearBeforeDraw', true);
    /**
     * get/set clearBeforeDraw flag which determines if the layer is cleared or not
     *  before drawing
     * @name clearBeforeDraw
     * @method
     * @memberof Konva.BaseLayer.prototype
     * @param {Boolean} clearBeforeDraw
     * @returns {Boolean}
     * @example
     * // get clearBeforeDraw flag
     * var clearBeforeDraw = layer.clearBeforeDraw();
     *
     * // disable clear before draw
     * layer.clearBeforeDraw(false);
     *
     * // enable clear before draw
     * layer.clearBeforeDraw(true);
     */

    Konva.Collection.mapMethods(Konva.BaseLayer);
})();

(function() {
    'use strict';
    // constants
    var HASH = '#',
        BEFORE_DRAW = 'beforeDraw',
        DRAW = 'draw',

        /*
         * 2 - 3 - 4
         * |       |
         * 1 - 0   5
         *         |
         * 8 - 7 - 6
         */
        INTERSECTION_OFFSETS = [
            {x: 0, y: 0},  // 0
            {x: -1, y: 0}, // 1
            {x: -1, y: -1}, // 2
            {x: 0, y: -1}, // 3
            {x: 1, y: -1}, // 4
            {x: 1, y: 0}, // 5
            {x: 1, y: 1}, // 6
            {x: 0, y: 1}, // 7
            {x: -1, y: 1}  // 8
        ],
        INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;

    /**
     * Layer constructor.  Layers are tied to their own canvas element and are used
     * to contain groups or shapes.
     * @constructor
     * @memberof Konva
     * @augments Konva.BaseLayer
     * @param {Object} config
     * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
     * to clear the canvas before each layer draw.  The default value is true.
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height

     * @example
     * var layer = new Konva.Layer();
     */
    Konva.Layer = function(config) {
        this.____init(config);
    };

    Konva.Util.addMethods(Konva.Layer, {
        ____init: function(config) {
            this.nodeType = 'Layer';
            this.canvas = new Konva.SceneCanvas();
            this.hitCanvas = new Konva.HitCanvas({
                pixelRatio: 1
            });
            // call super constructor
            Konva.BaseLayer.call(this, config);
        },
        _setCanvasSize: function(width, height) {
            this.canvas.setSize(width, height);
            this.hitCanvas.setSize(width, height);
        },
        _validateAdd: function(child) {
            var type = child.getType();
            if (type !== 'Group' && type !== 'Shape') {
                Konva.Util.throw('You may only add groups and shapes to a layer.');
            }
        },
        /**
         * get visible intersection shape. This is the preferred
         * method for determining if a point intersects a shape or not
         * also you may pass optional selector parametr to return ancestor of intersected shape
         * @method
         * @memberof Konva.Layer.prototype
         * @param {Object} pos
         * @param {Number} pos.x
         * @param {Number} pos.y
         * @param {String} [selector]
         * @returns {Konva.Node}
         * @example
         * var shape = layer.getIntersection({x: 50, y: 50});
         * // or if you interested in shape parent:
         * var group = layer.getIntersection({x: 50, y: 50}, 'Group');
         */
        getIntersection: function(pos, selector) {
            var obj, i, intersectionOffset, shape;

            if(!this.hitGraphEnabled() || !this.isVisible()) {
                return null;
            }
            // in some cases antialiased area may be bigger than 1px
            // it is possible if we will cache node, then scale it a lot
            // TODO: check { 0; 0 } point before loop, and remove it from INTERSECTION_OFFSETS.
            var spiralSearchDistance = 1;
            var continueSearch = false;
            while (true) {
                for (i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {
                    intersectionOffset = INTERSECTION_OFFSETS[i];
                    obj = this._getIntersection({
                        x: pos.x + intersectionOffset.x * spiralSearchDistance,
                        y: pos.y + intersectionOffset.y * spiralSearchDistance
                    });
                    shape = obj.shape;
                    if (shape && selector) {
                        return shape.findAncestor(selector, true);
                    } else if (shape) {
                        return shape;
                    }
                    // we should continue search if we found antialiased pixel
                    // that means our node somewhere very close
                    continueSearch = !!obj.antialiased;
                    // stop search if found empty pixel
                    if (!obj.antialiased) {
                        break;
                    }
                }
                // if no shape, and no antialiased pixel, we should end searching
                if (continueSearch) {
                    spiralSearchDistance += 1;
                } else {
                    return null;
                }
            }
        },
        _getImageData: function(x, y) {
            var width = this.hitCanvas.width || 1,
                height = this.hitCanvas.height || 1,
                index = (Math.round(y) * width ) + Math.round(x);

            if (!this._hitImageData) {
                this._hitImageData = this.hitCanvas.context.getImageData(0, 0, width, height);
            }

            return [
                this._hitImageData.data[4 * index + 0], // Red
                this._hitImageData.data[4 * index + 1], // Green
                this._hitImageData.data[4 * index + 2], // Blue
                this._hitImageData.data[4 * index + 3] // Alpha
            ];
        },
        _getIntersection: function(pos) {
            var ratio = this.hitCanvas.pixelRatio;
            var p = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio), Math.round(pos.y * ratio), 1, 1).data,
                p3 = p[3],
                colorKey, shape;
            // fully opaque pixel
            if(p3 === 255) {
                colorKey = Konva.Util._rgbToHex(p[0], p[1], p[2]);
                shape = Konva.shapes[HASH + colorKey];
                if (shape) {
                    return {
                        shape: shape
                    };
                }
                return {
                    antialiased: true
                };
            }
            // antialiased pixel
            else if(p3 > 0) {
                return {
                    antialiased: true
                };
            }
            // empty pixel
            return {};
        },
        drawScene: function(can, top) {
            var layer = this.getLayer(),
                canvas = can || (layer && layer.getCanvas());

            this._fire(BEFORE_DRAW, {
                node: this
            });

            if(this.getClearBeforeDraw()) {
                canvas.getContext().clear();
            }

            Konva.Container.prototype.drawScene.call(this, canvas, top);

            this._fire(DRAW, {
                node: this
            });

            return this;
        },
        drawHit: function(can, top) {
            var layer = this.getLayer(),
                canvas = can || (layer && layer.hitCanvas);

            if(layer && layer.getClearBeforeDraw()) {
                layer.getHitCanvas().getContext().clear();
            }

            Konva.Container.prototype.drawHit.call(this, canvas, top);
            this.imageData = null; // Clear imageData cache
            return this;
        },
        clear: function(bounds) {
            Konva.BaseLayer.prototype.clear.call(this, bounds);
            this.getHitCanvas().getContext().clear(bounds);
            this.imageData = null; // Clear getImageData cache
            return this;
        },
        // extend Node.prototype.setVisible
        setVisible: function(visible) {
            Konva.Node.prototype.setVisible.call(this, visible);
            if(visible) {
                this.getCanvas()._canvas.style.display = 'block';
                this.hitCanvas._canvas.style.display = 'block';
            }
            else {
                this.getCanvas()._canvas.style.display = 'none';
                this.hitCanvas._canvas.style.display = 'none';
            }
            return this;
        },
        /**
         * enable hit graph
         * @name enableHitGraph
         * @method
         * @memberof Konva.Layer.prototype
         * @returns {Layer}
         */
        enableHitGraph: function() {
            this.setHitGraphEnabled(true);
            return this;
        },
        /**
         * disable hit graph
         * @name disableHitGraph
         * @method
         * @memberof Konva.Layer.prototype
         * @returns {Layer}
         */
        disableHitGraph: function() {
            this.setHitGraphEnabled(false);
            return this;
        },
        setSize: function(width, height) {
            Konva.BaseLayer.prototype.setSize.call(this, width, height);
            this.hitCanvas.setSize(width, height);
            return this;
        }
    });
    Konva.Util.extend(Konva.Layer, Konva.BaseLayer);

    Konva.Factory.addGetterSetter(Konva.Layer, 'hitGraphEnabled', true);
    /**
     * get/set hitGraphEnabled flag.  Disabling the hit graph will greatly increase
     *  draw performance because the hit graph will not be redrawn each time the layer is
     *  drawn.  This, however, also disables mouse/touch event detection
     * @name hitGraphEnabled
     * @method
     * @memberof Konva.Layer.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get hitGraphEnabled flag
     * var hitGraphEnabled = layer.hitGraphEnabled();
     *
     * // disable hit graph
     * layer.hitGraphEnabled(false);
     *
     * // enable hit graph
     * layer.hitGraphEnabled(true);
     */
    Konva.Collection.mapMethods(Konva.Layer);
})();

(function() {
    'use strict';
    /**
     * FastLayer constructor. Layers are tied to their own canvas element and are used
     * to contain shapes only.  If you don't need node nesting, mouse and touch interactions,
     * or event pub/sub, you should use FastLayer instead of Layer to create your layers.
     * It renders about 2x faster than normal layers.
     * @constructor
     * @memberof Konva
     * @augments Konva.BaseLayer
     * @param {Object} config
     * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
     * to clear the canvas before each layer draw.  The default value is true.
     * @param {Boolean} [config.visible]
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height

     * @example
     * var layer = new Konva.FastLayer();
     */
    Konva.FastLayer = function(config) {
        this.____init(config);
    };

    Konva.Util.addMethods(Konva.FastLayer, {
        ____init: function(config) {
            this.nodeType = 'Layer';
            this.canvas = new Konva.SceneCanvas();
            // call super constructor
            Konva.BaseLayer.call(this, config);
        },
        _validateAdd: function(child) {
            var type = child.getType();
            if (type !== 'Shape') {
                Konva.Util.throw('You may only add shapes to a fast layer.');
            }
        },
        _setCanvasSize: function(width, height) {
            this.canvas.setSize(width, height);
        },
        hitGraphEnabled: function() {
            return false;
        },
        getIntersection: function() {
            return null;
        },
        drawScene: function(can) {
            var layer = this.getLayer(),
                canvas = can || (layer && layer.getCanvas());

            if(this.getClearBeforeDraw()) {
                canvas.getContext().clear();
            }

            Konva.Container.prototype.drawScene.call(this, canvas);

            return this;
        },
        draw: function() {
            this.drawScene();
            return this;
        },
        // extend Node.prototype.setVisible
        setVisible: function(visible) {
            Konva.Node.prototype.setVisible.call(this, visible);
            if(visible) {
                this.getCanvas()._canvas.style.display = 'block';
            }
            else {
                this.getCanvas()._canvas.style.display = 'none';
            }
            return this;
        }
    });
    Konva.Util.extend(Konva.FastLayer, Konva.BaseLayer);

    Konva.Collection.mapMethods(Konva.FastLayer);
})();

(function() {
    'use strict';
    /**
     * Group constructor.  Groups are used to contain shapes or other groups.
     * @constructor
     * @memberof Konva
     * @augments Konva.Container
     * @param {Object} config
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height

     * @example
     * var group = new Konva.Group();
     */
    Konva.Group = function(config) {
        this.___init(config);
    };

    Konva.Util.addMethods(Konva.Group, {
        ___init: function(config) {
            this.nodeType = 'Group';
            // call super constructor
            Konva.Container.call(this, config);
        },
        _validateAdd: function(child) {
            var type = child.getType();
            if (type !== 'Group' && type !== 'Shape') {
                Konva.Util.throw('You may only add groups and shapes to groups.');
            }
        }
    });
    Konva.Util.extend(Konva.Group, Konva.Container);

    Konva.Collection.mapMethods(Konva.Group);
})();

(function(Konva) {
    'use strict';
    var BATCH_DRAW_STOP_TIME_DIFF = 500;

    var now = (function() {
        if (Konva.global.performance && Konva.global.performance.now) {
            return function() {
                return Konva.global.performance.now();
            };
        }

        return function() {
            return new Date().getTime();
        };
    })();

    function FRAF(callback) {
        setTimeout(callback, 1000 / 60);
    }

    var RAF = (function(){
        return Konva.global.requestAnimationFrame
            || Konva.global.webkitRequestAnimationFrame
            || Konva.global.mozRequestAnimationFrame
            || Konva.global.oRequestAnimationFrame
            || Konva.global.msRequestAnimationFrame
            || FRAF;
    })();



    function requestAnimFrame() {
        return RAF.apply(Konva.global, arguments);
    }

    /**
     * Animation constructor.  A stage is used to contain multiple layers and handle
     * @constructor
     * @memberof Konva
     * @param {Function} func function executed on each animation frame.  The function is passed a frame object, which contains
     *  timeDiff, lastTime, time, and frameRate properties.  The timeDiff property is the number of milliseconds that have passed
     *  since the last animation frame.  The lastTime property is time in milliseconds that elapsed from the moment the animation started
     *  to the last animation frame.  The time property is the time in milliseconds that ellapsed from the moment the animation started
     *  to the current animation frame.  The frameRate property is the current frame rate in frames / second. Return false from function,
     *  if you don't need to redraw layer/layers on some frames.
     * @param {Konva.Layer|Array} [layers] layer(s) to be redrawn on each animation frame. Can be a layer, an array of layers, or null.
     *  Not specifying a node will result in no redraw.
     * @example
     * // move a node to the right at 50 pixels / second
     * var velocity = 50;
     *
     * var anim = new Konva.Animation(function(frame) {
     *   var dist = velocity * (frame.timeDiff / 1000);
     *   node.move(dist, 0);
     * }, layer);
     *
     * anim.start();
     */
    Konva.Animation = function(func, layers) {
        var Anim = Konva.Animation;
        this.func = func;
        this.setLayers(layers);
        this.id = Anim.animIdCounter++;
        this.frame = {
            time: 0,
            timeDiff: 0,
            lastTime: now()
        };
    };
    /*
     * Animation methods
     */
    Konva.Animation.prototype = {
        /**
         * set layers to be redrawn on each animation frame
         * @method
         * @memberof Konva.Animation.prototype
         * @param {Konva.Layer|Array} [layers] layer(s) to be redrawn.&nbsp; Can be a layer, an array of layers, or null.  Not specifying a node will result in no redraw.
         * @return {Konva.Animation} this
         */
        setLayers: function(layers) {
            var lays = [];
            // if passing in no layers
            if (!layers) {
                lays = [];
            }
            // if passing in an array of Layers
            // NOTE: layers could be an array or Konva.Collection.  for simplicity, I'm just inspecting
            // the length property to check for both cases
            else if (layers.length > 0) {
                lays = layers;
            }
            // if passing in a Layer
            else {
                lays = [layers];
            }

            this.layers = lays;
            return this;
        },
        /**
         * get layers
         * @method
         * @memberof Konva.Animation.prototype
         * @return {Array} Array of Konva.Layer
         */
        getLayers: function() {
            return this.layers;
        },
        /**
         * add layer.  Returns true if the layer was added, and false if it was not
         * @method
         * @memberof Konva.Animation.prototype
         * @param {Konva.Layer} layer to add
         * @return {Bool} true if layer is added to animation, otherwise false
         */
        addLayer: function(layer) {
            var layers = this.layers,
                len = layers.length, n;

            // don't add the layer if it already exists
            for (n = 0; n < len; n++) {
                if (layers[n]._id === layer._id){
                    return false;
                }
            }

            this.layers.push(layer);
            return true;
        },
        /**
         * determine if animation is running or not.  returns true or false
         * @method
         * @memberof Konva.Animation.prototype
         * @return {Bool} is animation running?
         */
        isRunning: function() {
            var a = Konva.Animation,
                animations = a.animations,
                len = animations.length,
                n;

            for(n = 0; n < len; n++) {
                if(animations[n].id === this.id) {
                    return true;
                }
            }
            return false;
        },
        /**
         * start animation
         * @method
         * @memberof Konva.Animation.prototype
         * @return {Konva.Animation} this
         */
        start: function() {
            var Anim = Konva.Animation;
            this.stop();
            this.frame.timeDiff = 0;
            this.frame.lastTime = now();
            Anim._addAnimation(this);
            return this;
        },
        /**
         * stop animation
         * @method
         * @memberof Konva.Animation.prototype
         * @return {Konva.Animation} this
         */
        stop: function() {
            Konva.Animation._removeAnimation(this);
            return this;
        },
        _updateFrameObject: function(time) {
            this.frame.timeDiff = time - this.frame.lastTime;
            this.frame.lastTime = time;
            this.frame.time += this.frame.timeDiff;
            this.frame.frameRate = 1000 / this.frame.timeDiff;
        }
    };
    Konva.Animation.animations = [];
    Konva.Animation.animIdCounter = 0;
    Konva.Animation.animRunning = false;

    Konva.Animation._addAnimation = function(anim) {
        this.animations.push(anim);
        this._handleAnimation();
    };
    Konva.Animation._removeAnimation = function(anim) {
        var id = anim.id,
            animations = this.animations,
            len = animations.length,
            n;

        for(n = 0; n < len; n++) {
            if(animations[n].id === id) {
                this.animations.splice(n, 1);
                break;
            }
        }
    };

    Konva.Animation._runFrames = function() {
        var layerHash = {},
            animations = this.animations,
            anim, layers, func, n, i, layersLen, layer, key, needRedraw;
        /*
         * loop through all animations and execute animation
         *  function.  if the animation object has specified node,
         *  we can add the node to the nodes hash to eliminate
         *  drawing the same node multiple times.  The node property
         *  can be the stage itself or a layer
         */
        /*
         * WARNING: don't cache animations.length because it could change while
         * the for loop is running, causing a JS error
         */

        for(n = 0; n < animations.length; n++) {
            anim = animations[n];
            layers = anim.layers;
            func = anim.func;


            anim._updateFrameObject(now());
            layersLen = layers.length;

            // if animation object has a function, execute it
            if (func) {
                // allow anim bypassing drawing
                needRedraw = (func.call(anim, anim.frame) !== false);
            } else {
                needRedraw = true;
            }
            if (!needRedraw) {
                continue;
            }
            for (i = 0; i < layersLen; i++) {
                layer = layers[i];

                if (layer._id !== undefined) {
                    layerHash[layer._id] = layer;
                }
            }
        }

        for (key in layerHash) {
            if (!layerHash.hasOwnProperty(key)) {
                continue;
            }
            layerHash[key].draw();
        }
    };
    Konva.Animation._animationLoop = function() {
        var Anim = Konva.Animation;
        if(Anim.animations.length) {
            requestAnimFrame(Anim._animationLoop);
            Anim._runFrames();
        }
        else {
            Anim.animRunning = false;
        }
    };
    Konva.Animation._handleAnimation = function() {
        if(!this.animRunning) {
            this.animRunning = true;
            this._animationLoop();
        }
    };

    /**
     * batch draw
     * @method
     * @return {Konva.Layer} this
     * @memberof Konva.Base.prototype
     */
    Konva.BaseLayer.prototype.batchDraw = function() {
        var that = this,
            Anim = Konva.Animation;

        if (!this.batchAnim) {
            this.batchAnim = new Anim(function() {
                if (that.lastBatchDrawTime && now() - that.lastBatchDrawTime > BATCH_DRAW_STOP_TIME_DIFF) {
                    that.batchAnim.stop();
                }
            }, this);
        }

        this.lastBatchDrawTime = now();

        if (!this.batchAnim.isRunning()) {
            this.draw();
            this.batchAnim.start();
        }
        return this;
    };

    /**
     * batch draw
     * @method
     * @return {Konva.Stage} this
     * @memberof Konva.Stage.prototype
     */
    Konva.Stage.prototype.batchDraw = function() {
        this.getChildren().each(function(layer) {
            layer.batchDraw();
        });
        return this;
    };
})(Konva);

(function() {
    'use strict';
    var blacklist = {
        node: 1,
        duration: 1,
        easing: 1,
        onFinish: 1,
        yoyo: 1
    },

    PAUSED = 1,
    PLAYING = 2,
    REVERSING = 3,

    idCounter = 0,
    colorAttrs = ['fill', 'stroke', 'shadowColor'];

    var Tween = function(prop, propFunc, func, begin, finish, duration, yoyo) {
        this.prop = prop;
        this.propFunc = propFunc;
        this.begin = begin;
        this._pos = begin;
        this.duration = duration;
        this._change = 0;
        this.prevPos = 0;
        this.yoyo = yoyo;
        this._time = 0;
        this._position = 0;
        this._startTime = 0;
        this._finish = 0;
        this.func = func;
        this._change = finish - this.begin;
        this.pause();
    };
    /*
     * Tween methods
     */
    Tween.prototype = {
        fire: function(str) {
            var handler = this[str];
            if (handler) {
                handler();
            }
        },
        setTime: function(t) {
            if(t > this.duration) {
                if(this.yoyo) {
                    this._time = this.duration;
                    this.reverse();
                }
                else {
                    this.finish();
                }
            }
            else if(t < 0) {
                if(this.yoyo) {
                    this._time = 0;
                    this.play();
                }
                else {
                    this.reset();
                }
            }
            else {
                this._time = t;
                this.update();
            }
        },
        getTime: function() {
            return this._time;
        },
        setPosition: function(p) {
            this.prevPos = this._pos;
            this.propFunc(p);
            this._pos = p;
        },
        getPosition: function(t) {
            if(t === undefined) {
                t = this._time;
            }
            return this.func(t, this.begin, this._change, this.duration);
        },
        play: function() {
            this.state = PLAYING;
            this._startTime = this.getTimer() - this._time;
            this.onEnterFrame();
            this.fire('onPlay');
        },
        reverse: function() {
            this.state = REVERSING;
            this._time = this.duration - this._time;
            this._startTime = this.getTimer() - this._time;
            this.onEnterFrame();
            this.fire('onReverse');
        },
        seek: function(t) {
            this.pause();
            this._time = t;
            this.update();
            this.fire('onSeek');
        },
        reset: function() {
            this.pause();
            this._time = 0;
            this.update();
            this.fire('onReset');
        },
        finish: function() {
            this.pause();
            this._time = this.duration;
            this.update();
            this.fire('onFinish');
        },
        update: function() {
            this.setPosition(this.getPosition(this._time));
        },
        onEnterFrame: function() {
            var t = this.getTimer() - this._startTime;
            if(this.state === PLAYING) {
                this.setTime(t);
            }
            else if (this.state === REVERSING) {
                this.setTime(this.duration - t);
            }
        },
        pause: function() {
            this.state = PAUSED;
            this.fire('onPause');
        },
        getTimer: function() {
            return new Date().getTime();
        }
    };

    /**
     * Tween constructor.  Tweens enable you to animate a node between the current state and a new state.
     *  You can play, pause, reverse, seek, reset, and finish tweens.  By default, tweens are animated using
     *  a linear easing.  For more tweening options, check out {@link Konva.Easings}
     * @constructor
     * @memberof Konva
     * @example
     * // instantiate new tween which fully rotates a node in 1 second
     * var tween = new Konva.Tween({
     *   node: node,
     *   rotationDeg: 360,
     *   duration: 1,
     *   easing: Konva.Easings.EaseInOut
     * });
     *
     * // play tween
     * tween.play();
     *
     * // pause tween
     * tween.pause();
     */
    Konva.Tween = function(config) {
        var that = this,
            node = config.node,
            nodeId = node._id,
            duration,
            easing = config.easing || Konva.Easings.Linear,
            yoyo = !!config.yoyo,
            key;

        if (typeof config.duration === 'undefined') {
            duration = 1;
        } else if (config.duration === 0) {  // zero is bad value for duration
            duration = 0.001;
        } else {
            duration = config.duration;
        }
        this.node = node;
        this._id = idCounter++;

        this.anim = new Konva.Animation(function() {
            that.tween.onEnterFrame();
        }, node.getLayer() || ((node instanceof Konva.Stage) ? node.getLayers() : null));

        this.tween = new Tween(key, function(i) {
            that._tweenFunc(i);
        }, easing, 0, 1, duration * 1000, yoyo);

        this._addListeners();

        // init attrs map
        if (!Konva.Tween.attrs[nodeId]) {
            Konva.Tween.attrs[nodeId] = {};
        }
        if (!Konva.Tween.attrs[nodeId][this._id]) {
            Konva.Tween.attrs[nodeId][this._id] = {};
        }
        // init tweens map
        if (!Konva.Tween.tweens[nodeId]) {
            Konva.Tween.tweens[nodeId] = {};
        }

        for (key in config) {
            if (blacklist[key] === undefined) {
                this._addAttr(key, config[key]);
            }
        }

        this.reset();

        // callbacks
        this.onFinish = config.onFinish;
        this.onReset = config.onReset;
    };

    // start/diff object = attrs.nodeId.tweenId.attr
    Konva.Tween.attrs = {};
    // tweenId = tweens.nodeId.attr
    Konva.Tween.tweens = {};

    Konva.Tween.prototype = {
        _addAttr: function(key, end) {
            var node = this.node,
                nodeId = node._id,
                start, diff, tweenId, n, len, trueEnd, trueStart;

            // remove conflict from tween map if it exists
            tweenId = Konva.Tween.tweens[nodeId][key];

            if (tweenId) {
                delete Konva.Tween.attrs[nodeId][tweenId][key];
            }

            // add to tween map
            start = node.getAttr(key);

            if (Konva.Util._isArray(end)) {
                diff = [];
                len = Math.max(end.length, start.length);

                if (key === 'points' && end.length !== start.length) {
                    // before tweening points we need to make sure that start.length === end.length
                    // Konva.Util._prepareArrayForTween thinking that end.length > start.length

                    if (end.length > start.length) {
                        // so in this case we will increase number of starting points
                        trueStart = start;
                        start = Konva.Util._prepareArrayForTween(start, end, node.closed());
                    } else {
                        // in this case we will increase number of eding points
                        trueEnd = end;
                        end = Konva.Util._prepareArrayForTween(end, start, node.closed());
                    }
                }

                for (n = 0; n < len; n++) {
                    diff.push((end[n]) - (start[n]));
                }

            } else if (colorAttrs.indexOf(key) !== -1) {
                start = Konva.Util.colorToRGBA(start);
                var endRGBA = Konva.Util.colorToRGBA(end);
                diff = {
                    r: endRGBA.r - start.r,
                    g: endRGBA.g - start.g,
                    b: endRGBA.b - start.b,
                    a: endRGBA.a - start.a
                };
            } else {
                diff = end - start;
            }

            Konva.Tween.attrs[nodeId][this._id][key] = {
                start: start,
                diff: diff,
                end: end,
                trueEnd: trueEnd,
                trueStart: trueStart
            };
            Konva.Tween.tweens[nodeId][key] = this._id;
        },
        _tweenFunc: function(i) {
            var node = this.node,
                attrs = Konva.Tween.attrs[node._id][this._id],
                key, attr, start, diff, newVal, n, len, end;

            for (key in attrs) {
                attr = attrs[key];
                start = attr.start;
                diff = attr.diff;
                end = attr.end;

                if (Konva.Util._isArray(start)) {
                    newVal = [];
                    len = Math.max(start.length, end.length);
                    for (n = 0; n < len; n++) {
                        newVal.push((start[n] || 0) + (diff[n] * i));
                    }
                } else if (colorAttrs.indexOf(key) !== -1) {
                    newVal = 'rgba(' +
                            Math.round(start.r + diff.r * i) + ',' +
                            Math.round(start.g + diff.g * i) + ',' +
                            Math.round(start.b + diff.b * i) + ',' +
                            (start.a + diff.a * i) + ')';
                } else {
                    newVal = start + (diff * i);
                }

                node.setAttr(key, newVal);
            }
        },
        _addListeners: function() {
            var that = this;

            // start listeners
            this.tween.onPlay = function() {
                that.anim.start();
            };
            this.tween.onReverse = function() {
                that.anim.start();
            };

            // stop listeners
            this.tween.onPause = function() {
                that.anim.stop();
            };
            this.tween.onFinish = function() {
                var node = that.node;

                // after tweening  points of line we need to set original end
                var attrs = Konva.Tween.attrs[node._id][that._id];
                if (attrs.points && attrs.points.trueEnd) {
                    node.points(attrs.points.trueEnd);
                }

                if (that.onFinish) {
                    that.onFinish.call(that);
                }
            };
            this.tween.onReset = function() {
                var node = that.node;
                // after tweening  points of line we need to set original start
                var attrs = Konva.Tween.attrs[node._id][that._id];
                if (attrs.points && attrs.points.trueStart) {
                    node.points(attrs.points.trueStart);
                }

                if (that.onReset) {
                    that.onReset();
                }
            };
        },
        /**
         * play
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
        play: function() {
            this.tween.play();
            return this;
        },
        /**
         * reverse
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
        reverse: function() {
            this.tween.reverse();
            return this;
        },
        /**
         * reset
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
        reset: function() {
            this.tween.reset();
            return this;
        },
        /**
         * seek
         * @method
         * @memberof Konva.Tween.prototype
         * @param {Integer} t time in seconds between 0 and the duration
         * @returns {Tween}
         */
        seek: function(t) {
            this.tween.seek(t * 1000);
            return this;
        },
        /**
         * pause
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
        pause: function() {
            this.tween.pause();
            return this;
        },
        /**
         * finish
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
        finish: function() {
            this.tween.finish();
            return this;
        },
        /**
         * destroy
         * @method
         * @memberof Konva.Tween.prototype
         */
        destroy: function() {
            var nodeId = this.node._id,
                thisId = this._id,
                attrs = Konva.Tween.tweens[nodeId],
                key;

            this.pause();

            for (key in attrs) {
                delete Konva.Tween.tweens[nodeId][key];
            }

            delete Konva.Tween.attrs[nodeId][thisId];
        }
    };

    /**
     * Tween node properties. Shorter usage of {@link Konva.Tween} object.
     *
     * @method Konva.Node#to
     * @memberof Konva.Node
     * @param {Object} [params] tween params
     * @example
     *
     * circle.to({
     *  x : 50,
     *  duration : 0.5
     * });
     */
    Konva.Node.prototype.to = function(params) {
        var onFinish = params.onFinish;
        params.node = this;
        params.onFinish = function() {
            this.destroy();
            if (onFinish) {
                onFinish();
            }
        };
        var tween = new Konva.Tween(params);
        tween.play();
    };

    /*
    * These eases were ported from an Adobe Flash tweening library to JavaScript
    * by Xaric
    */

    /**
     * @namespace Easings
     * @memberof Konva
     */
    Konva.Easings = {
        /**
        * back ease in
        * @function
        * @memberof Konva.Easings
        */
        'BackEaseIn': function(t, b, c, d) {
            var s = 1.70158;
            return c * (t /= d) * t * ((s + 1) * t - s) + b;
        },
        /**
        * back ease out
        * @function
        * @memberof Konva.Easings
        */
        'BackEaseOut': function(t, b, c, d) {
            var s = 1.70158;
            return c * (( t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
        },
        /**
        * back ease in out
        * @function
        * @memberof Konva.Easings
        */
        'BackEaseInOut': function(t, b, c, d) {
            var s = 1.70158;
            if((t /= d / 2) < 1) {
                return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
            }
            return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
        },
        /**
        * elastic ease in
        * @function
        * @memberof Konva.Easings
        */
        'ElasticEaseIn': function(t, b, c, d, a, p) {
            // added s = 0
            var s = 0;
            if(t === 0) {
                return b;
            }
            if((t /= d) === 1) {
                return b + c;
            }
            if(!p) {
                p = d * 0.3;
            }
            if(!a || a < Math.abs(c)) {
                a = c;
                s = p / 4;
            }
            else {
                s = p / (2 * Math.PI) * Math.asin(c / a);
            }
            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
        },
        /**
        * elastic ease out
        * @function
        * @memberof Konva.Easings
        */
        'ElasticEaseOut': function(t, b, c, d, a, p) {
            // added s = 0
            var s = 0;
            if(t === 0) {
                return b;
            }
            if((t /= d) === 1) {
                return b + c;
            }
            if(!p) {
                p = d * 0.3;
            }
            if(!a || a < Math.abs(c)) {
                a = c;
                s = p / 4;
            }
            else {
                s = p / (2 * Math.PI) * Math.asin(c / a);
            }
            return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b);
        },
        /**
        * elastic ease in out
        * @function
        * @memberof Konva.Easings
        */
        'ElasticEaseInOut': function(t, b, c, d, a, p) {
            // added s = 0
            var s = 0;
            if(t === 0) {
                return b;
            }
            if((t /= d / 2) === 2) {
                return b + c;
            }
            if(!p) {
                p = d * (0.3 * 1.5);
            }
            if(!a || a < Math.abs(c)) {
                a = c;
                s = p / 4;
            }
            else {
                s = p / (2 * Math.PI) * Math.asin(c / a);
            }
            if(t < 1) {
                return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
            }
            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
        },
        /**
        * bounce ease out
        * @function
        * @memberof Konva.Easings
        */
        'BounceEaseOut': function(t, b, c, d) {
            if((t /= d) < (1 / 2.75)) {
                return c * (7.5625 * t * t) + b;
            }
            else if(t < (2 / 2.75)) {
                return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
            }
            else if(t < (2.5 / 2.75)) {
                return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
            }
            else {
                return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
            }
        },
        /**
        * bounce ease in
        * @function
        * @memberof Konva.Easings
        */
        'BounceEaseIn': function(t, b, c, d) {
            return c - Konva.Easings.BounceEaseOut(d - t, 0, c, d) + b;
        },
        /**
        * bounce ease in out
        * @function
        * @memberof Konva.Easings
        */
        'BounceEaseInOut': function(t, b, c, d) {
            if(t < d / 2) {
                return Konva.Easings.BounceEaseIn(t * 2, 0, c, d) * 0.5 + b;
            }
            else {
                return Konva.Easings.BounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
            }
        },
        /**
        * ease in
        * @function
        * @memberof Konva.Easings
        */
        'EaseIn': function(t, b, c, d) {
            return c * (t /= d) * t + b;
        },
        /**
        * ease out
        * @function
        * @memberof Konva.Easings
        */
        'EaseOut': function(t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        },
        /**
        * ease in out
        * @function
        * @memberof Konva.Easings
        */
        'EaseInOut': function(t, b, c, d) {
            if((t /= d / 2) < 1) {
                return c / 2 * t * t + b;
            }
            return -c / 2 * ((--t) * (t - 2) - 1) + b;
        },
        /**
        * strong ease in
        * @function
        * @memberof Konva.Easings
        */
        'StrongEaseIn': function(t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
        },
        /**
        * strong ease out
        * @function
        * @memberof Konva.Easings
        */
        'StrongEaseOut': function(t, b, c, d) {
            return c * (( t = t / d - 1) * t * t * t * t + 1) + b;
        },
        /**
        * strong ease in out
        * @function
        * @memberof Konva.Easings
        */
        'StrongEaseInOut': function(t, b, c, d) {
            if((t /= d / 2) < 1) {
                return c / 2 * t * t * t * t * t + b;
            }
            return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
        },
        /**
        * linear
        * @function
        * @memberof Konva.Easings
        */
        'Linear': function(t, b, c, d) {
            return c * t / d + b;
        }
    };
})();

(function() {
    'use strict';
    Konva.DD = {
        // properties
        anim: new Konva.Animation(function() {
            var b = this.dirty;
            this.dirty = false;
            return b;
        }),
        isDragging: false,
        justDragged: false,
        offset: {
            x: 0,
            y: 0
        },
        node: null,

        // methods
        _drag: function(evt) {
            var dd = Konva.DD,
                node = dd.node;

            if(node) {
               if(!dd.isDragging) {
                    var pos = node.getStage().getPointerPosition();
                    var dragDistance = node.dragDistance();
                    var distance = Math.max(
                        Math.abs(pos.x - dd.startPointerPos.x),
                        Math.abs(pos.y - dd.startPointerPos.y)
                    );
                    if (distance < dragDistance) {
                        return;
                    }
                }


                node.getStage()._setPointerPosition(evt);
                node._setDragPosition(evt);
                if(!dd.isDragging) {
                    dd.isDragging = true;
                    node.fire('dragstart', {
                        type: 'dragstart',
                        target: node,
                        evt: evt
                    }, true);
                }

                // execute ondragmove if defined
                node.fire('dragmove', {
                    type: 'dragmove',
                    target: node,
                    evt: evt
                }, true);
            }
        },
        _endDragBefore: function(evt) {
            var dd = Konva.DD,
                node = dd.node,
                layer;

            if(node) {
                layer = node.getLayer();
                dd.anim.stop();

                // only fire dragend event if the drag and drop
                // operation actually started.
                if(dd.isDragging) {
                    dd.isDragging = false;
                    dd.justDragged = true;
                    Konva.listenClickTap = false;

                    if (evt) {
                        evt.dragEndNode = node;
                    }
                }

                delete dd.node;

                (layer || node).draw();
            }
        },
        _endDragAfter: function(evt) {
            evt = evt || {};
            var dragEndNode = evt.dragEndNode;

            if (evt && dragEndNode) {
                dragEndNode.fire('dragend', {
                    type: 'dragend',
                    target: dragEndNode,
                    evt: evt
                }, true);
            }
        }
    };

    // Node extenders

    /**
     * initiate drag and drop
     * @method
     * @memberof Konva.Node.prototype
     */
    Konva.Node.prototype.startDrag = function() {
        var dd = Konva.DD,
            stage = this.getStage(),
            layer = this.getLayer(),
            pos = stage.getPointerPosition(),
            ap = this.getAbsolutePosition();

        if(pos) {
            if (dd.node) {
                dd.node.stopDrag();
            }

            dd.node = this;
            dd.startPointerPos = pos;
            dd.offset.x = pos.x - ap.x;
            dd.offset.y = pos.y - ap.y;
            dd.anim.setLayers(layer || this.getLayers());
            dd.anim.start();

            this._setDragPosition();
        }
    };

    Konva.Node.prototype._setDragPosition = function(evt) {
        var dd = Konva.DD,
            pos = this.getStage().getPointerPosition(),
            dbf = this.getDragBoundFunc();
        if (!pos) {
            return;
        }
        var newNodePos = {
            x: pos.x - dd.offset.x,
            y: pos.y - dd.offset.y
        };

        if(dbf !== undefined) {
            newNodePos = dbf.call(this, newNodePos, evt);
        }
        this.setAbsolutePosition(newNodePos);

        if (!this._lastPos || this._lastPos.x !== newNodePos.x ||
            this._lastPos.y !== newNodePos.y) {
            dd.anim.dirty = true;
        }

        this._lastPos = newNodePos;
    };

    /**
     * stop drag and drop
     * @method
     * @memberof Konva.Node.prototype
     */
    Konva.Node.prototype.stopDrag = function() {
        var dd = Konva.DD,
            evt = {};
        dd._endDragBefore(evt);
        dd._endDragAfter(evt);
    };

    Konva.Node.prototype.setDraggable = function(draggable) {
        this._setAttr('draggable', draggable);
        this._dragChange();
    };

    var origDestroy = Konva.Node.prototype.destroy;

    Konva.Node.prototype.destroy = function() {
        var dd = Konva.DD;

        // stop DD
        if(dd.node && dd.node._id === this._id) {

            this.stopDrag();
        }

        origDestroy.call(this);
    };

    /**
     * determine if node is currently in drag and drop mode
     * @method
     * @memberof Konva.Node.prototype
     */
    Konva.Node.prototype.isDragging = function() {
        var dd = Konva.DD;
        return !!(dd.node && dd.node._id === this._id && dd.isDragging);
    };

    Konva.Node.prototype._listenDrag = function() {
        var that = this;

        this._dragCleanup();

        if (this.getClassName() === 'Stage') {
            this.on('contentMousedown.konva contentTouchstart.konva', function(evt) {
                if(!Konva.DD.node) {
                    that.startDrag(evt);
                }
            });
        }
        else {
            this.on('mousedown.konva touchstart.konva', function(evt) {
                // ignore right and middle buttons
                if (evt.evt.button === 1 || evt.evt.button === 2) {
                    return;
                }
                if(!Konva.DD.node) {
                    that.startDrag(evt);
                }
            });
        }

        // listening is required for drag and drop
        /*
        this._listeningEnabled = true;
        this._clearSelfAndAncestorCache('listeningEnabled');
        */
    };

    Konva.Node.prototype._dragChange = function() {
        if(this.attrs.draggable) {
            this._listenDrag();
        }
        else {
            // remove event listeners
            this._dragCleanup();

            /*
             * force drag and drop to end
             * if this node is currently in
             * drag and drop mode
             */
            var stage = this.getStage();
            var dd = Konva.DD;
            if(stage && dd.node && dd.node._id === this._id) {
                dd.node.stopDrag();
            }
        }
    };

    Konva.Node.prototype._dragCleanup = function() {
        if (this.getClassName() === 'Stage') {
            this.off('contentMousedown.konva');
            this.off('contentTouchstart.konva');
        } else {
            this.off('mousedown.konva');
            this.off('touchstart.konva');
        }
    };

    Konva.Factory.addGetterSetter(Konva.Node, 'dragBoundFunc');

    /**
     * get/set drag bound function.  This is used to override the default
     *  drag and drop position
     * @name dragBoundFunc
     * @method
     * @memberof Konva.Node.prototype
     * @param {Function} dragBoundFunc
     * @returns {Function}
     * @example
     * // get drag bound function
     * var dragBoundFunc = node.dragBoundFunc();
     *
     * // create vertical drag and drop
     * node.dragBoundFunc(function(pos){
     *   return {
     *     x: this.getAbsolutePosition().x,
     *     y: pos.y
     *   };
     * });
     */

    Konva.Factory.addGetter(Konva.Node, 'draggable', false);
    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'draggable');

     /**
     * get/set draggable flag
     * @name draggable
     * @method
     * @memberof Konva.Node.prototype
     * @param {Boolean} draggable
     * @returns {Boolean}
     * @example
     * // get draggable flag
     * var draggable = node.draggable();
     *
     * // enable drag and drop
     * node.draggable(true);
     *
     * // disable drag and drop
     * node.draggable(false);
     */

    var html = Konva.document.documentElement;
    html.addEventListener('mouseup', Konva.DD._endDragBefore, true);
    html.addEventListener('touchend', Konva.DD._endDragBefore, true);

    html.addEventListener('mousemove', Konva.DD._drag);
    html.addEventListener('touchmove', Konva.DD._drag);

    html.addEventListener('mouseup', Konva.DD._endDragAfter, false);
    html.addEventListener('touchend', Konva.DD._endDragAfter, false);

})();

(function() {
    'use strict';
    /**
     * Rect constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} [config.cornerRadius]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var rect = new Konva.Rect({
     *   width: 100,
     *   height: 50,
     *   fill: 'red',
     *   stroke: 'black',
     *   strokeWidth: 5
     * });
     */
    Konva.Rect = function(config) {
        this.___init(config);
    };

    Konva.Rect.prototype = {
        ___init: function(config) {
            Konva.Shape.call(this, config);
            this.className = 'Rect';
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            var cornerRadius = this.getCornerRadius(),
                width = this.getWidth(),
                height = this.getHeight();

            context.beginPath();

            if(!cornerRadius) {
                // simple rect - don't bother doing all that complicated maths stuff.
                context.rect(0, 0, width, height);
            } else {
                // arcTo would be nicer, but browser support is patchy (Opera)
                cornerRadius = Math.min(cornerRadius, width / 2, height / 2);
                context.moveTo(cornerRadius, 0);
                context.lineTo(width - cornerRadius, 0);
                context.arc(width - cornerRadius, cornerRadius, cornerRadius, Math.PI * 3 / 2, 0, false);
                context.lineTo(width, height - cornerRadius);
                context.arc(width - cornerRadius, height - cornerRadius, cornerRadius, 0, Math.PI / 2, false);
                context.lineTo(cornerRadius, height);
                context.arc(cornerRadius, height - cornerRadius, cornerRadius, Math.PI / 2, Math.PI, false);
                context.lineTo(0, cornerRadius);
                context.arc(cornerRadius, cornerRadius, cornerRadius, Math.PI, Math.PI * 3 / 2, false);
            }
            context.closePath();
            context.fillStrokeShape(this);
        }
    };

    Konva.Util.extend(Konva.Rect, Konva.Shape);

    Konva.Factory.addGetterSetter(Konva.Rect, 'cornerRadius', 0);
    /**
     * get/set corner radius
     * @name cornerRadius
     * @method
     * @memberof Konva.Rect.prototype
     * @param {Number} cornerRadius
     * @returns {Number}
     * @example
     * // get corner radius
     * var cornerRadius = rect.cornerRadius();
     *
     * // set corner radius
     * rect.cornerRadius(10);
     */

    Konva.Collection.mapMethods(Konva.Rect);
})();

(function() {
    'use strict';
    // the 0.0001 offset fixes a bug in Chrome 27
    var PIx2 = (Math.PI * 2) - 0.0001,
        CIRCLE = 'Circle';

    /**
     * Circle constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.radius
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * // create circle
     * var circle = new Konva.Circle({
     *   radius: 40,
     *   fill: 'red',
     *   stroke: 'black'
     *   strokeWidth: 5
     * });
     */
    Konva.Circle = function(config) {
        this.___init(config);
    };

    Konva.Circle.prototype = {
        _centroid: true,
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = CIRCLE;
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            context.beginPath();
            context.arc(0, 0, this.getRadius(), 0, PIx2, false);
            context.closePath();
            context.fillStrokeShape(this);
        },
        // implements Shape.prototype.getWidth()
        getWidth: function() {
            return this.getRadius() * 2;
        },
        // implements Shape.prototype.getHeight()
        getHeight: function() {
            return this.getRadius() * 2;
        },
        // implements Shape.prototype.setWidth()
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            if (this.radius() !== width / 2) {
                this.setRadius(width / 2);
            }
        },
        // implements Shape.prototype.setHeight()
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            if (this.radius() !== height / 2) {
                this.setRadius(height / 2);
            }
        }
    };
    Konva.Util.extend(Konva.Circle, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Circle, 'radius', 0);
    Konva.Factory.addOverloadedGetterSetter(Konva.Circle, 'radius');

    /**
     * get/set radius
     * @name radius
     * @method
     * @memberof Konva.Circle.prototype
     * @param {Number} radius
     * @returns {Number}
     * @example
     * // get radius
     * var radius = circle.radius();
     *
     * // set radius
     * circle.radius(10);
     */

    Konva.Collection.mapMethods(Konva.Circle);
})();

(function() {
    'use strict';
    // the 0.0001 offset fixes a bug in Chrome 27
    var PIx2 = (Math.PI * 2) - 0.0001,
        ELLIPSE = 'Ellipse';

    /**
     * Ellipse constructor
     * @constructor
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Object} config.radius defines x and y radius
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var ellipse = new Konva.Ellipse({
     *   radius : {
     *     x : 50,
     *     y : 50
     *   },
     *   fill: 'red'
     * });
     */
    Konva.Ellipse = function(config) {
        this.___init(config);
    };

    Konva.Ellipse.prototype = {
        _centroid: true,
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = ELLIPSE;
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            var rx = this.getRadiusX(),
                ry = this.getRadiusY();

            context.beginPath();
            context.save();
            if(rx !== ry) {
                context.scale(1, ry / rx);
            }
            context.arc(0, 0, rx, 0, PIx2, false);
            context.restore();
            context.closePath();
            context.fillStrokeShape(this);
        },
        // implements Shape.prototype.getWidth()
        getWidth: function() {
            return this.getRadiusX() * 2;
        },
        // implements Shape.prototype.getHeight()
        getHeight: function() {
            return this.getRadiusY() * 2;
        },
        // implements Shape.prototype.setWidth()
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            this.setRadius({
                x: width / 2
            });
        },
        // implements Shape.prototype.setHeight()
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            this.setRadius({
                y: height / 2
            });
        }
    };
    Konva.Util.extend(Konva.Ellipse, Konva.Shape);

    // add getters setters
    Konva.Factory.addComponentsGetterSetter(Konva.Ellipse, 'radius', ['x', 'y']);

    /**
     * get/set radius
     * @name radius
     * @method
     * @memberof Konva.Ellipse.prototype
     * @param {Object} radius
     * @param {Number} radius.x
     * @param {Number} radius.y
     * @returns {Object}
     * @example
     * // get radius
     * var radius = ellipse.radius();
     *
     * // set radius
     * ellipse.radius({
     *   x: 200,
     *   y: 100
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Ellipse, 'radiusX', 0);
    /**
     * get/set radius x
     * @name radiusX
     * @method
     * @memberof Konva.Ellipse.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get radius x
     * var radiusX = ellipse.radiusX();
     *
     * // set radius x
     * ellipse.radiusX(200);
     */

    Konva.Factory.addGetterSetter(Konva.Ellipse, 'radiusY', 0);
    /**
     * get/set radius y
     * @name radiusY
     * @method
     * @memberof Konva.Ellipse.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get radius y
     * var radiusY = ellipse.radiusY();
     *
     * // set radius y
     * ellipse.radiusY(200);
     */

    Konva.Collection.mapMethods(Konva.Ellipse);

})();

(function() {
    'use strict';
    // the 0.0001 offset fixes a bug in Chrome 27
    var PIx2 = (Math.PI * 2) - 0.0001;
    /**
     * Ring constructor
     * @constructor
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.innerRadius
     * @param {Number} config.outerRadius
     * @param {Boolean} [config.clockwise]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var ring = new Konva.Ring({
     *   innerRadius: 40,
     *   outerRadius: 80,
     *   fill: 'red',
     *   stroke: 'black',
     *   strokeWidth: 5
     * });
     */
    Konva.Ring = function(config) {
        this.___init(config);
    };

    Konva.Ring.prototype = {
        _centroid: true,
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'Ring';
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            context.beginPath();
            context.arc(0, 0, this.getInnerRadius(), 0, PIx2, false);
            context.moveTo(this.getOuterRadius(), 0);
            context.arc(0, 0, this.getOuterRadius(), PIx2, 0, true);
            context.closePath();
            context.fillStrokeShape(this);
        },
        // implements Shape.prototype.getWidth()
        getWidth: function() {
            return this.getOuterRadius() * 2;
        },
        // implements Shape.prototype.getHeight()
        getHeight: function() {
            return this.getOuterRadius() * 2;
        },
        // implements Shape.prototype.setWidth()
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            if (this.outerRadius() !== width / 2) {
                this.setOuterRadius(width / 2);
            }
        },
        // implements Shape.prototype.setHeight()
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            if (this.outerRadius() !== height / 2) {
                this.setOuterRadius(height / 2);
            }
        },
        setOuterRadius: function(val) {
            this._setAttr('outerRadius', val);
            this.setWidth(val * 2);
            this.setHeight(val * 2);
        }
    };
    Konva.Util.extend(Konva.Ring, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Ring, 'innerRadius', 0);

    /**
     * get/set innerRadius
     * @name innerRadius
     * @method
     * @memberof Konva.Ring.prototype
     * @param {Number} innerRadius
     * @returns {Number}
     * @example
     * // get inner radius
     * var innerRadius = ring.innerRadius();
     *
     * // set inner radius
     * ring.innerRadius(20);
     */
    Konva.Factory.addGetter(Konva.Ring, 'outerRadius', 0);
    Konva.Factory.addOverloadedGetterSetter(Konva.Ring, 'outerRadius');

    /**
     * get/set outerRadius
     * @name outerRadius
     * @method
     * @memberof Konva.Ring.prototype
     * @param {Number} outerRadius
     * @returns {Number}
     * @example
     * // get outer radius
     * var outerRadius = ring.outerRadius();
     *
     * // set outer radius
     * ring.outerRadius(20);
     */

    Konva.Collection.mapMethods(Konva.Ring);
})();

(function() {
    'use strict';
    /**
     * Wedge constructor
     * @constructor
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.angle in degrees
     * @param {Number} config.radius
     * @param {Boolean} [config.clockwise]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * // draw a wedge that's pointing downwards
     * var wedge = new Konva.Wedge({
     *   radius: 40,
     *   fill: 'red',
     *   stroke: 'black'
     *   strokeWidth: 5,
     *   angleDeg: 60,
     *   rotationDeg: -120
     * });
     */
    Konva.Wedge = function(config) {
        this.___init(config);
    };

    Konva.Wedge.prototype = {
        _centroid: true,
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'Wedge';
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            context.beginPath();
            context.arc(0, 0, this.getRadius(), 0, Konva.getAngle(this.getAngle()), this.getClockwise());
            context.lineTo(0, 0);
            context.closePath();
            context.fillStrokeShape(this);
        },
        // implements Shape.prototype.getWidth()
        getWidth: function() {
            return this.getRadius() * 2;
        },
        // implements Shape.prototype.getHeight()
        getHeight: function() {
            return this.getRadius() * 2;
        },
        // implements Shape.prototype.setWidth()
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            if (this.radius() !== width / 2) {
                this.setRadius(width / 2);
            }
        },
        // implements Shape.prototype.setHeight()
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            if (this.radius() !== height / 2) {
                this.setRadius(height / 2);
            }
        }
    };
    Konva.Util.extend(Konva.Wedge, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Wedge, 'radius', 0);

    /**
     * get/set radius
     * @name radius
     * @method
     * @memberof Konva.Wedge.prototype
     * @param {Number} radius
     * @returns {Number}
     * @example
     * // get radius
     * var radius = wedge.radius();
     *
     * // set radius
     * wedge.radius(10);
     */

    Konva.Factory.addGetterSetter(Konva.Wedge, 'angle', 0);

    /**
     * get/set angle in degrees
     * @name angle
     * @method
     * @memberof Konva.Wedge.prototype
     * @param {Number} angle
     * @returns {Number}
     * @example
     * // get angle
     * var angle = wedge.angle();
     *
     * // set angle
     * wedge.angle(20);
     */

    Konva.Factory.addGetterSetter(Konva.Wedge, 'clockwise', false);

    /**
     * get/set clockwise flag
     * @name clockwise
     * @method
     * @memberof Konva.Wedge.prototype
     * @param {Number} clockwise
     * @returns {Number}
     * @example
     * // get clockwise flag
     * var clockwise = wedge.clockwise();
     *
     * // draw wedge counter-clockwise
     * wedge.clockwise(false);
     *
     * // draw wedge clockwise
     * wedge.clockwise(true);
     */

    Konva.Factory.backCompat(Konva.Wedge, {
        angleDeg: 'angle',
        getAngleDeg: 'getAngle',
        setAngleDeg: 'setAngle'
    });

    Konva.Collection.mapMethods(Konva.Wedge);
})();

(function() {
    'use strict';
    /**
     * Arc constructor
     * @constructor
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.angle in degrees
     * @param {Number} config.innerRadius
     * @param {Number} config.outerRadius
     * @param {Boolean} [config.clockwise]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * // draw a Arc that's pointing downwards
     * var arc = new Konva.Arc({
     *   innerRadius: 40,
     *   outerRadius: 80,
     *   fill: 'red',
     *   stroke: 'black'
     *   strokeWidth: 5,
     *   angle: 60,
     *   rotationDeg: -120
     * });
     */
    Konva.Arc = function(config) {
        this.___init(config);
    };

    Konva.Arc.prototype = {
        _centroid: true,
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'Arc';
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            var angle = Konva.getAngle(this.angle()),
                clockwise = this.clockwise();

            context.beginPath();
            context.arc(0, 0, this.getOuterRadius(), 0, angle, clockwise);
            context.arc(0, 0, this.getInnerRadius(), angle, 0, !clockwise);
            context.closePath();
            context.fillStrokeShape(this);
        },
        // implements Shape.prototype.getWidth()
        getWidth: function() {
            return this.getOuterRadius() * 2;
        },
        // implements Shape.prototype.getHeight()
        getHeight: function() {
            return this.getOuterRadius() * 2;
        },
        // implements Shape.prototype.setWidth()
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            if (this.getOuterRadius() !== width / 2) {
                this.setOuterRadius(width / 2);
            }
        },
        // implements Shape.prototype.setHeight()
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            if (this.getOuterRadius() !== height / 2) {
                this.setOuterRadius(height / 2);
            }
        }
    };
    Konva.Util.extend(Konva.Arc, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Arc, 'innerRadius', 0);

    /**
     * get/set innerRadius
     * @name innerRadius
     * @method
     * @memberof Konva.Arc.prototype
     * @param {Number} innerRadius
     * @returns {Number}
     * @example
     * // get inner radius
     * var innerRadius = arc.innerRadius();
     *
     * // set inner radius
     * arc.innerRadius(20);
     */

    Konva.Factory.addGetterSetter(Konva.Arc, 'outerRadius', 0);

    /**
     * get/set outerRadius
     * @name outerRadius
     * @method
     * @memberof Konva.Arc.prototype
     * @param {Number} outerRadius
     * @returns {Number}
     * @example
     * // get outer radius
     * var outerRadius = arc.outerRadius();
     *
     * // set outer radius
     * arc.outerRadius(20);
     */

    Konva.Factory.addGetterSetter(Konva.Arc, 'angle', 0);

    /**
     * get/set angle in degrees
     * @name angle
     * @method
     * @memberof Konva.Arc.prototype
     * @param {Number} angle
     * @returns {Number}
     * @example
     * // get angle
     * var angle = arc.angle();
     *
     * // set angle
     * arc.angle(20);
     */

    Konva.Factory.addGetterSetter(Konva.Arc, 'clockwise', false);

    /**
     * get/set clockwise flag
     * @name clockwise
     * @method
     * @memberof Konva.Arc.prototype
     * @param {Boolean} clockwise
     * @returns {Boolean}
     * @example
     * // get clockwise flag
     * var clockwise = arc.clockwise();
     *
     * // draw arc counter-clockwise
     * arc.clockwise(false);
     *
     * // draw arc clockwise
     * arc.clockwise(true);
     */

    Konva.Collection.mapMethods(Konva.Arc);
})();

(function() {
    'use strict';
    // CONSTANTS
    var IMAGE = 'Image';

    /**
     * Image constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Image} config.image
     * @param {Object} [config.crop]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var imageObj = new Image();
     * imageObj.onload = function() {
     *   var image = new Konva.Image({
     *     x: 200,
     *     y: 50,
     *     image: imageObj,
     *     width: 100,
     *     height: 100
     *   });
     * };
     * imageObj.src = '/path/to/image.jpg'
     */
    Konva.Image = function(config) {
        this.___init(config);
    };

    Konva.Image.prototype = {
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = IMAGE;
            this.sceneFunc(this._sceneFunc);
            this.hitFunc(this._hitFunc);
        },
        _useBufferCanvas: function() {
            return (this.hasShadow() || this.getAbsoluteOpacity() !== 1) && this.hasStroke() && this.getStage();
        },
        _sceneFunc: function(context) {
            var width = this.getWidth(),
                height = this.getHeight(),
                image = this.getImage(),
                cropWidth, cropHeight, params;

            if (image) {
                cropWidth = this.getCropWidth();
                cropHeight = this.getCropHeight();
                if (cropWidth && cropHeight) {
                    params = [image, this.getCropX(), this.getCropY(), cropWidth, cropHeight, 0, 0, width, height];
                } else {
                    params = [image, 0, 0, width, height];
                }
            }

            if (this.hasFill() || this.hasStroke()) {
                context.beginPath();
                context.rect(0, 0, width, height);
                context.closePath();
                context.fillStrokeShape(this);
            }

            if (image) {
                context.drawImage.apply(context, params);
            }
        },
        _hitFunc: function(context) {
            var width = this.getWidth(),
                height = this.getHeight();

            context.beginPath();
            context.rect(0, 0, width, height);
            context.closePath();
            context.fillStrokeShape(this);
        },
        getWidth: function() {
            var image = this.getImage();
            return this.attrs.width || (image ? image.width : 0);
        },
        getHeight: function() {
            var image = this.getImage();
            return this.attrs.height || (image ? image.height : 0);
        }
    };
    Konva.Util.extend(Konva.Image, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Image, 'image');

    /**
     * set image
     * @name setImage
     * @method
     * @memberof Konva.Image.prototype
     * @param {Image} image
     */

    /**
     * get image
     * @name getImage
     * @method
     * @memberof Konva.Image.prototype
     * @returns {Image}
     */

    Konva.Factory.addComponentsGetterSetter(Konva.Image, 'crop', ['x', 'y', 'width', 'height']);
    /**
     * get/set crop
     * @method
     * @name crop
     * @memberof Konva.Image.prototype
     * @param {Object} crop
     * @param {Number} crop.x
     * @param {Number} crop.y
     * @param {Number} crop.width
     * @param {Number} crop.height
     * @returns {Object}
     * @example
     * // get crop
     * var crop = image.crop();
     *
     * // set crop
     * image.crop({
     *   x: 20,
     *   y: 20,
     *   width: 20,
     *   height: 20
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Image, 'cropX', 0);
    /**
     * get/set crop x
     * @method
     * @name cropX
     * @memberof Konva.Image.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get crop x
     * var cropX = image.cropX();
     *
     * // set crop x
     * image.cropX(20);
     */

    Konva.Factory.addGetterSetter(Konva.Image, 'cropY', 0);
    /**
     * get/set crop y
     * @name cropY
     * @method
     * @memberof Konva.Image.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get crop y
     * var cropY = image.cropY();
     *
     * // set crop y
     * image.cropY(20);
     */

    Konva.Factory.addGetterSetter(Konva.Image, 'cropWidth', 0);
    /**
     * get/set crop width
     * @name cropWidth
     * @method
     * @memberof Konva.Image.prototype
     * @param {Number} width
     * @returns {Number}
     * @example
     * // get crop width
     * var cropWidth = image.cropWidth();
     *
     * // set crop width
     * image.cropWidth(20);
     */

    Konva.Factory.addGetterSetter(Konva.Image, 'cropHeight', 0);
    /**
     * get/set crop height
     * @name cropHeight
     * @method
     * @memberof Konva.Image.prototype
     * @param {Number} height
     * @returns {Number}
     * @example
     * // get crop height
     * var cropHeight = image.cropHeight();
     *
     * // set crop height
     * image.cropHeight(20);
     */

    Konva.Collection.mapMethods(Konva.Image);

    /**
     * load image from given url and create `Konva.Image` instance
     * @method
     * @memberof Konva.Image
     * @param {String} url image source
     * @param {Function} callback with Konva.Image instance as first argument
     * @example
     *  Konva.Image.fromURL(imageURL, function(image){
     *    // image is Konva.Image instance
     *    layer.add(image);
     *    layer.draw();
     *  });
     */
    Konva.Image.fromURL = function(url, callback) {
        var img = new Image();
        img.onload = function() {
          var image = new Konva.Image({
            image: img
          });
          callback(image);
        };
        img.src = url;
    };
})();

/*eslint-disable max-depth */
(function() {
    'use strict';
    // constants
    var AUTO = 'auto',
        //CANVAS = 'canvas',
        CENTER = 'center',
        CHANGE_KONVA = 'Change.konva',
        CONTEXT_2D = '2d',
        DASH = '-',
        EMPTY_STRING = '',
        LEFT = 'left',
        TEXT = 'text',
        TEXT_UPPER = 'Text',
        MIDDLE = 'middle',
        NORMAL = 'normal',
        PX_SPACE = 'px ',
        SPACE = ' ',
        RIGHT = 'right',
        WORD = 'word',
        CHAR = 'char',
        NONE = 'none',
        ATTR_CHANGE_LIST = ['fontFamily', 'fontSize', 'fontStyle', 'fontVariant', 'padding', 'align', 'lineHeight', 'text', 'width', 'height', 'wrap'],

        // cached variables
        attrChangeListLen = ATTR_CHANGE_LIST.length,
        dummyContext = Konva.Util.createCanvasElement().getContext(CONTEXT_2D);

    /**
     * Text constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {String} [config.fontFamily] default is Arial
     * @param {Number} [config.fontSize] in pixels.  Default is 12
     * @param {String} [config.fontStyle] can be normal, bold, or italic.  Default is normal
     * @param {String} [config.fontVariant] can be normal or small-caps.  Default is normal
     * @param {String} config.text
     * @param {String} [config.align] can be left, center, or right
     * @param {Number} [config.padding]
     * @param {Number} [config.width] default is auto
     * @param {Number} [config.height] default is auto
     * @param {Number} [config.lineHeight] default is 1
     * @param {String} [config.wrap] can be word, char, or none. Default is word
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var text = new Konva.Text({
     *   x: 10,
     *   y: 15,
     *   text: 'Simple Text',
     *   fontSize: 30,
     *   fontFamily: 'Calibri',
     *   fill: 'green'
     * });
     */
    Konva.Text = function(config) {
        this.___init(config);
    };
    function _fillFunc(context) {
        context.fillText(this.partialText, 0, 0);
    }
    function _strokeFunc(context) {
        context.strokeText(this.partialText, 0, 0);
    }

    Konva.Text.prototype = {
        ___init: function(config) {
            config = config || {};

            // set default color to black
            if (!config.fillLinearGradientColorStops && !config.fillRadialGradientColorStops) {
                config.fill = config.fill || 'black';
            }

            if (config.width === undefined) {
                config.width = AUTO;
            }
            if (config.height === undefined) {
                config.height = AUTO;
            }

            // call super constructor
            Konva.Shape.call(this, config);

            this._fillFunc = _fillFunc;
            this._strokeFunc = _strokeFunc;
            this.className = TEXT_UPPER;

            // update text data for certain attr changes
            for(var n = 0; n < attrChangeListLen; n++) {
                this.on(ATTR_CHANGE_LIST[n] + CHANGE_KONVA, this._setTextData);
            }

            this._setTextData();
            this.sceneFunc(this._sceneFunc);
            this.hitFunc(this._hitFunc);
        },
        _sceneFunc: function(context) {
            var p = this.getPadding(),
                textHeight = this.getTextHeight(),
                lineHeightPx = this.getLineHeight() * textHeight,
                textArr = this.textArr,
                textArrLen = textArr.length,
                totalWidth = this.getWidth(),
                n;

            context.setAttr('font', this._getContextFont());

            context.setAttr('textBaseline', MIDDLE);
            context.setAttr('textAlign', LEFT);
            context.save();
            if (p) {
                context.translate(p, 0);
                context.translate(0, p + textHeight / 2);
            } else {
                context.translate(0, textHeight / 2);
            }


            // draw text lines
            for(n = 0; n < textArrLen; n++) {
                var obj = textArr[n],
                    text = obj.text,
                    width = obj.width;

                // horizontal alignment
                context.save();
                if(this.getAlign() === RIGHT) {
                    context.translate(totalWidth - width - p * 2, 0);
                }
                else if(this.getAlign() === CENTER) {
                    context.translate((totalWidth - width - p * 2) / 2, 0);
                }

                this.partialText = text;

                context.fillStrokeShape(this);
                context.restore();
                context.translate(0, lineHeightPx);
            }
            context.restore();
        },
        _hitFunc: function(context) {
            var width = this.getWidth(),
                height = this.getHeight();

            context.beginPath();
            context.rect(0, 0, width, height);
            context.closePath();
            context.fillStrokeShape(this);
        },
        setText: function(text) {
            var str = Konva.Util._isString(text) ? text : text.toString();
            this._setAttr(TEXT, str);
            return this;
        },
        /**
         * get width of text area, which includes padding
         * @method
         * @memberof Konva.Text.prototype
         * @returns {Number}
         */
        getWidth: function() {
            return this.attrs.width === AUTO ? this.getTextWidth() + this.getPadding() * 2 : this.attrs.width;
        },
        /**
         * get the height of the text area, which takes into account multi-line text, line heights, and padding
         * @method
         * @memberof Konva.Text.prototype
         * @returns {Number}
         */
        getHeight: function() {
            return this.attrs.height === AUTO ? (this.getTextHeight() * this.textArr.length * this.getLineHeight()) + this.getPadding() * 2 : this.attrs.height;
        },
        /**
         * get text width
         * @method
         * @memberof Konva.Text.prototype
         * @returns {Number}
         */
        getTextWidth: function() {
            return this.textWidth;
        },
        /**
         * get text height
         * @method
         * @memberof Konva.Text.prototype
         * @returns {Number}
         */
        getTextHeight: function() {
            return this.textHeight;
        },
        _getTextSize: function(text) {
            var _context = dummyContext,
                fontSize = this.getFontSize(),
                metrics;

            _context.save();
            _context.font = this._getContextFont();

            metrics = _context.measureText(text);
            _context.restore();
            return {
                width: metrics.width,
                height: parseInt(fontSize, 10)
            };
        },
        _getContextFont: function() {
            return this.getFontStyle() + SPACE + this.getFontVariant() + SPACE + this.getFontSize() + PX_SPACE + this.getFontFamily();
        },
        _addTextLine: function (line, width) {
            return this.textArr.push({text: line, width: width});
        },
        _getTextWidth: function (text) {
            return dummyContext.measureText(text).width;
        },
        _setTextData: function () {
            var lines = this.getText().split('\n'),
                fontSize = +this.getFontSize(),
                textWidth = 0,
                lineHeightPx = this.getLineHeight() * fontSize,
                width = this.attrs.width,
                height = this.attrs.height,
                fixedWidth = width !== AUTO,
                fixedHeight = height !== AUTO,
                padding = this.getPadding(),
                maxWidth = width - padding * 2,
                maxHeightPx = height - padding * 2,
                currentHeightPx = 0,
                wrap = this.getWrap(),
                shouldWrap = wrap !== NONE,
                wrapAtWord = wrap !== CHAR && shouldWrap;

            this.textArr = [];
            dummyContext.save();
            dummyContext.font = this._getContextFont();
            for (var i = 0, max = lines.length; i < max; ++i) {
                var line = lines[i],
                    lineWidth = this._getTextWidth(line);
                if (fixedWidth && lineWidth > maxWidth) {
                    /*
                     * if width is fixed and line does not fit entirely
                     * break the line into multiple fitting lines
                     */
                    while (line.length > 0) {
                        /*
                         * use binary search to find the longest substring that
                         * that would fit in the specified width
                         */
                        var low = 0, high = line.length,
                            match = '', matchWidth = 0;
                        while (low < high) {
                            var mid = (low + high) >>> 1,
                                substr = line.slice(0, mid + 1),
                                substrWidth = this._getTextWidth(substr);
                            if (substrWidth <= maxWidth) {
                                low = mid + 1;
                                match = substr;
                                matchWidth = substrWidth;
                            } else {
                                high = mid;
                            }
                        }
                        /*
                         * 'low' is now the index of the substring end
                         * 'match' is the substring
                         * 'matchWidth' is the substring width in px
                         */
                        if (match) {
                            // a fitting substring was found
                            if (wrapAtWord) {
                                // try to find a space or dash where wrapping could be done
                                var wrapIndex = Math.max(match.lastIndexOf(SPACE),
                                                          match.lastIndexOf(DASH)) + 1;
                                if (wrapIndex > 0) {
                                    // re-cut the substring found at the space/dash position
                                    low = wrapIndex;
                                    match = match.slice(0, low);
                                    matchWidth = this._getTextWidth(match);
                                }
                            }
                            this._addTextLine(match, matchWidth);
                            textWidth = Math.max(textWidth, matchWidth);
                            currentHeightPx += lineHeightPx;
                            if (!shouldWrap ||
                                (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx)) {
                                /*
                                 * stop wrapping if wrapping is disabled or if adding
                                 * one more line would overflow the fixed height
                                 */
                                break;
                            }
                            line = line.slice(low);
                            if (line.length > 0) {
                                // Check if the remaining text would fit on one line
                                lineWidth = this._getTextWidth(line);
                                if (lineWidth <= maxWidth) {
                                    // if it does, add the line and break out of the loop
                                    this._addTextLine(line, lineWidth);
                                    currentHeightPx += lineHeightPx;
                                    textWidth = Math.max(textWidth, lineWidth);
                                    break;
                                }
                            }
                        } else {
                            // not even one character could fit in the element, abort
                            break;
                        }
                    }
                } else {
                    // element width is automatically adjusted to max line width
                    this._addTextLine(line, lineWidth);
                    currentHeightPx += lineHeightPx;
                    textWidth = Math.max(textWidth, lineWidth);
                }
                // if element height is fixed, abort if adding one more line would overflow
                if (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx) {
                    break;
                }
            }
            dummyContext.restore();
            this.textHeight = fontSize;
            this.textWidth = textWidth;
        }
    };
    Konva.Util.extend(Konva.Text, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Text, 'fontFamily', 'Arial');

    /**
     * get/set font family
     * @name fontFamily
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} fontFamily
     * @returns {String}
     * @example
     * // get font family
     * var fontFamily = text.fontFamily();
     *
     * // set font family
     * text.fontFamily('Arial');
     */

    Konva.Factory.addGetterSetter(Konva.Text, 'fontSize', 12);

    /**
     * get/set font size in pixels
     * @name fontSize
     * @method
     * @memberof Konva.Text.prototype
     * @param {Number} fontSize
     * @returns {Number}
     * @example
     * // get font size
     * var fontSize = text.fontSize();
     *
     * // set font size to 22px
     * text.fontSize(22);
     */

    Konva.Factory.addGetterSetter(Konva.Text, 'fontStyle', NORMAL);

    /**
     * set font style.  Can be 'normal', 'italic', or 'bold'.  'normal' is the default.
     * @name fontStyle
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} fontStyle
     * @returns {String}
     * @example
     * // get font style
     * var fontStyle = text.fontStyle();
     *
     * // set font style
     * text.fontStyle('bold');
     */

    Konva.Factory.addGetterSetter(Konva.Text, 'fontVariant', NORMAL);

    /**
     * set font variant.  Can be 'normal' or 'small-caps'.  'normal' is the default.
     * @name fontVariant
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} fontVariant
     * @returns {String}
     * @example
     * // get font variant
     * var fontVariant = text.fontVariant();
     *
     * // set font variant
     * text.fontVariant('small-caps');
     */

    Konva.Factory.addGetterSetter(Konva.Text, 'padding', 0);

    /**
     * set padding
     * @name padding
     * @method
     * @memberof Konva.Text.prototype
     * @param {Number} padding
     * @returns {Number}
     * @example
     * // get padding
     * var padding = text.padding();
     *
     * // set padding to 10 pixels
     * text.padding(10);
     */

    Konva.Factory.addGetterSetter(Konva.Text, 'align', LEFT);

    /**
     * get/set horizontal align of text.  Can be 'left', 'center', or 'right'
     * @name align
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} align
     * @returns {String}
     * @example
     * // get text align
     * var align = text.align();
     *
     * // center text
     * text.align('center');
     *
     * // align text to right
     * text.align('right');
     */

    Konva.Factory.addGetterSetter(Konva.Text, 'lineHeight', 1);

    /**
     * get/set line height.  The default is 1.
     * @name lineHeight
     * @method
     * @memberof Konva.Text.prototype
     * @param {Number} lineHeight
     * @returns {Number}
     * @example
     * // get line height
     * var lineHeight = text.lineHeight();
     *
     * // set the line height
     * text.lineHeight(2);
     */

    Konva.Factory.addGetterSetter(Konva.Text, 'wrap', WORD);

    /**
     * get/set wrap.  Can be word, char, or none. Default is word.
     * @name wrap
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} wrap
     * @returns {String}
     * @example
     * // get wrap
     * var wrap = text.wrap();
     *
     * // set wrap
     * text.wrap('word');
     */

    Konva.Factory.addGetter(Konva.Text, 'text', EMPTY_STRING);
    Konva.Factory.addOverloadedGetterSetter(Konva.Text, 'text');

    /**
     * get/set text
     * @name getText
     * @method
     * @memberof Konva.Text.prototype
     * @param {String} text
     * @returns {String}
     * @example
     * // get text
     * var text = text.text();
     *
     * // set text
     * text.text('Hello world!');
     */

    Konva.Collection.mapMethods(Konva.Text);
})();

(function () {
    'use strict';
    /**
     * Line constructor.&nbsp; Lines are defined by an array of points and
     *  a tension
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Array} config.points
     * @param {Number} [config.tension] Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
     *   The default is 0
     * @param {Boolean} [config.closed] defines whether or not the line shape is closed, creating a polygon or blob
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var line = new Konva.Line({
     *   x: 100,
     *   y: 50,
     *   points: [73, 70, 340, 23, 450, 60, 500, 20],
     *   stroke: 'red',
     *   tension: 1
     * });
     */
    Konva.Line = function (config) {
        this.___init(config);
    };

    Konva.Line.prototype = {
        ___init: function (config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'Line';

            this.on('pointsChange.konva tensionChange.konva closedChange.konva', function () {
                this._clearCache('tensionPoints');
            });

            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function (context) {
            var points = this.getPoints(),
                length = points.length,
                tension = this.getTension(),
                closed = this.getClosed(),
                tp, len, n;

            if (!length) {
                return;
            }

            context.beginPath();
            context.moveTo(points[0], points[1]);

            // tension
            if (tension !== 0 && length > 4) {
                tp = this.getTensionPoints();
                len = tp.length;
                n = closed ? 0 : 4;

                if (!closed) {
                    context.quadraticCurveTo(tp[0], tp[1], tp[2], tp[3]);
                }

                while (n < len - 2) {
                    context.bezierCurveTo(tp[n++], tp[n++], tp[n++], tp[n++], tp[n++], tp[n++]);
                }

                if (!closed) {
                    context.quadraticCurveTo(tp[len - 2], tp[len - 1], points[length - 2], points[length - 1]);
                }
            }
            // no tension
            else {
                for (n = 2; n < length; n += 2) {
                    context.lineTo(points[n], points[n + 1]);
                }
            }

            // closed e.g. polygons and blobs
            if (closed) {
                context.closePath();
                context.fillStrokeShape(this);
            }
            // open e.g. lines and splines
            else {
                context.strokeShape(this);
            }
        },
        getTensionPoints: function () {
            return this._getCache('tensionPoints', this._getTensionPoints);
        },
        _getTensionPoints: function () {
            if (this.getClosed()) {
                return this._getTensionPointsClosed();
            } else {
                return Konva.Util._expandPoints(this.getPoints(), this.getTension());
            }
        },
        _getTensionPointsClosed: function () {
            var p = this.getPoints(),
                len = p.length,
                tension = this.getTension(),
                util = Konva.Util,
                firstControlPoints = util._getControlPoints(
                    p[len - 2],
                    p[len - 1],
                    p[0],
                    p[1],
                    p[2],
                    p[3],
                    tension
                ),
                lastControlPoints = util._getControlPoints(
                    p[len - 4],
                    p[len - 3],
                    p[len - 2],
                    p[len - 1],
                    p[0],
                    p[1],
                    tension
                ),
                middle = Konva.Util._expandPoints(p, tension),
                tp = [
                    firstControlPoints[2],
                    firstControlPoints[3]
                ]
                .concat(middle)
                .concat([
                    lastControlPoints[0],
                    lastControlPoints[1],
                    p[len - 2],
                    p[len - 1],
                    lastControlPoints[2],
                    lastControlPoints[3],
                    firstControlPoints[0],
                    firstControlPoints[1],
                    p[0],
                    p[1]
                ]);

            return tp;
        },
        getWidth: function () {
            return this.getSelfRect().width;
        },
        getHeight: function () {
            return this.getSelfRect().height;
        },
        // overload size detection
        getSelfRect: function () {
            var points;
            if (this.getTension() !== 0) {
                points = this._getTensionPoints();
            } else {
                points = this.getPoints();
            }
            var minX = points[0];
            var maxX = points[0];
            var minY = points[1];
            var maxY = points[1];
            var x, y;
            for (var i = 0; i < points.length / 2; i++) {
                x = points[i * 2];
                y = points[i * 2 + 1];
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }
            return {
                x: Math.round(minX),
                y: Math.round(minY),
                width: Math.round(maxX - minX),
                height: Math.round(maxY - minY)
            };
        }
    };
    Konva.Util.extend(Konva.Line, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Line, 'closed', false);

    /**
     * get/set closed flag.  The default is false
     * @name closed
     * @method
     * @memberof Konva.Line.prototype
     * @param {Boolean} closed
     * @returns {Boolean}
     * @example
     * // get closed flag
     * var closed = line.closed();
     *
     * // close the shape
     * line.closed(true);
     *
     * // open the shape
     * line.closed(false);
     */

    Konva.Factory.addGetterSetter(Konva.Line, 'tension', 0);

    /**
     * get/set tension
     * @name tension
     * @method
     * @memberof Konva.Line.prototype
     * @param {Number} Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
     *   The default is 0
     * @returns {Number}
     * @example
     * // get tension
     * var tension = line.tension();
     *
     * // set tension
     * line.tension(3);
     */

    Konva.Factory.addGetterSetter(Konva.Line, 'points', []);
    /**
     * get/set points array
     * @name points
     * @method
     * @memberof Konva.Line.prototype
     * @param {Array} points
     * @returns {Array}
     * @example
     * // get points
     * var points = line.points();
     *
     * // set points
     * line.points([10, 20, 30, 40, 50, 60]);
     *
     * // push a new point
     * line.points(line.points().concat([70, 80]));
     */

    Konva.Collection.mapMethods(Konva.Line);
})();

(function() {
    'use strict';
    /**
     * Sprite constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {String} config.animation animation key
     * @param {Object} config.animations animation map
     * @param {Integer} [config.frameIndex] animation frame index
     * @param {Image} config.image image object
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var imageObj = new Image();
     * imageObj.onload = function() {
     *   var sprite = new Konva.Sprite({
     *     x: 200,
     *     y: 100,
     *     image: imageObj,
     *     animation: 'standing',
     *     animations: {
     *       standing: [
     *         // x, y, width, height (6 frames)
     *         0, 0, 49, 109,
     *         52, 0, 49, 109,
     *         105, 0, 49, 109,
     *         158, 0, 49, 109,
     *         210, 0, 49, 109,
     *         262, 0, 49, 109
     *       ],
     *       kicking: [
     *         // x, y, width, height (6 frames)
     *         0, 109, 45, 98,
     *         45, 109, 45, 98,
     *         95, 109, 63, 98,
     *         156, 109, 70, 98,
     *         229, 109, 60, 98,
     *         287, 109, 41, 98
     *       ]
     *     },
     *     frameRate: 7,
     *     frameIndex: 0
     *   });
     * };
     * imageObj.src = '/path/to/image.jpg'
     */
    Konva.Sprite = function(config) {
        this.___init(config);
    };

    Konva.Sprite.prototype = {
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'Sprite';

            this._updated = true;
            var that = this;
            this.anim = new Konva.Animation(function() {
                // if we don't need to redraw layer we should return false
                var updated = that._updated;
                that._updated = false;
                return updated;
            });
            this.on('animationChange.konva', function() {
                // reset index when animation changes
                this.frameIndex(0);
            });
            this.on('frameIndexChange.konva', function() {
                this._updated = true;
            });
            // smooth change for frameRate
            this.on('frameRateChange.konva', function() {
                if (!this.anim.isRunning()) {
                    return;
                }
                clearInterval(this.interval);
                this._setInterval();
            });

            this.sceneFunc(this._sceneFunc);
            this.hitFunc(this._hitFunc);
        },
        _sceneFunc: function(context) {
            var anim = this.getAnimation(),
                index = this.frameIndex(),
                ix4 = index * 4,
                set = this.getAnimations()[anim],
                offsets = this.frameOffsets(),
                x = set[ix4 + 0],
                y = set[ix4 + 1],
                width = set[ix4 + 2],
                height = set[ix4 + 3],
                image = this.getImage();

            if (this.hasFill() || this.hasStroke()) {
                context.beginPath();
                context.rect(0, 0, width, height);
                context.closePath();
                context.fillStrokeShape(this);
            }

            if(image) {
                if (offsets) {
                    var offset = offsets[anim],
                    ix2 = index * 2;
                    context.drawImage(image, x, y, width, height, offset[ix2 + 0], offset[ix2 + 1], width, height);
                } else {
                    context.drawImage(image, x, y, width, height, 0, 0, width, height);
                }
            }
        },
        _hitFunc: function(context) {
            var anim = this.getAnimation(),
                index = this.frameIndex(),
                ix4 = index * 4,
                set = this.getAnimations()[anim],
                offsets = this.frameOffsets(),
                width = set[ix4 + 2],
                height = set[ix4 + 3];

            context.beginPath();
            if (offsets) {
                var offset = offsets[anim];
                var ix2 = index * 2;
                context.rect(offset[ix2 + 0], offset[ix2 + 1], width, height);
            } else {
                context.rect(0, 0, width, height);
            }
            context.closePath();
            context.fillShape(this);
        },
        _useBufferCanvas: function() {
            return (this.hasShadow() || this.getAbsoluteOpacity() !== 1) && this.hasStroke();
        },
        _setInterval: function() {
            var that = this;
            this.interval = setInterval(function() {
                that._updateIndex();
            }, 1000 / this.getFrameRate());
        },
        /**
         * start sprite animation
         * @method
         * @memberof Konva.Sprite.prototype
         */
        start: function() {
            var layer = this.getLayer();

            /*
             * animation object has no executable function because
             *  the updates are done with a fixed FPS with the setInterval
             *  below.  The anim object only needs the layer reference for
             *  redraw
             */
            this.anim.setLayers(layer);
            this._setInterval();
            this.anim.start();
        },
        /**
         * stop sprite animation
         * @method
         * @memberof Konva.Sprite.prototype
         */
        stop: function() {
            this.anim.stop();
            clearInterval(this.interval);
        },
        /**
         * determine if animation of sprite is running or not.  returns true or false
         * @method
         * @memberof Konva.Animation.prototype
         * @returns {Boolean}
         */
        isRunning: function() {
            return this.anim.isRunning();
        },
        _updateIndex: function() {
            var index = this.frameIndex(),
                animation = this.getAnimation(),
                animations = this.getAnimations(),
                anim = animations[animation],
                len = anim.length / 4;

            if(index < len - 1) {
                this.frameIndex(index + 1);
            }
            else {
                this.frameIndex(0);
            }
        }
    };
    Konva.Util.extend(Konva.Sprite, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Sprite, 'animation');

    /**
     * get/set animation key
     * @name animation
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {String} anim animation key
     * @returns {String}
     * @example
     * // get animation key
     * var animation = sprite.animation();
     *
     * // set animation key
     * sprite.animation('kicking');
     */

    Konva.Factory.addGetterSetter(Konva.Sprite, 'animations');

    /**
     * get/set animations map
     * @name animations
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {Object} animations
     * @returns {Object}
     * @example
     * // get animations map
     * var animations = sprite.animations();
     *
     * // set animations map
     * sprite.animations({
     *   standing: [
     *     // x, y, width, height (6 frames)
     *     0, 0, 49, 109,
     *     52, 0, 49, 109,
     *     105, 0, 49, 109,
     *     158, 0, 49, 109,
     *     210, 0, 49, 109,
     *     262, 0, 49, 109
     *   ],
     *   kicking: [
     *     // x, y, width, height (6 frames)
     *     0, 109, 45, 98,
     *     45, 109, 45, 98,
     *     95, 109, 63, 98,
     *     156, 109, 70, 98,
     *     229, 109, 60, 98,
     *     287, 109, 41, 98
     *   ]
     * });
     */

    Konva.Factory.addGetterSetter(Konva.Sprite, 'frameOffsets');

    /**
    * get/set offsets map
    * @name offsets
    * @method
    * @memberof Konva.Sprite.prototype
    * @param {Object} offsets
    * @returns {Object}
    * @example
    * // get offsets map
    * var offsets = sprite.offsets();
    *
    * // set offsets map
    * sprite.offsets({
    *   standing: [
    *     // x, y (6 frames)
    *     0, 0,
    *     0, 0,
    *     5, 0,
    *     0, 0,
    *     0, 3,
    *     2, 0
    *   ],
    *   kicking: [
    *     // x, y (6 frames)
    *     0, 5,
    *     5, 0,
    *     10, 0,
    *     0, 0,
    *     2, 1,
    *     0, 0
    *   ]
    * });
    */

    Konva.Factory.addGetterSetter(Konva.Sprite, 'image');

    /**
     * get/set image
     * @name image
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {Image} image
     * @returns {Image}
     * @example
     * // get image
     * var image = sprite.image();
     *
     * // set image
     * sprite.image(imageObj);
     */

    Konva.Factory.addGetterSetter(Konva.Sprite, 'frameIndex', 0);

    /**
     * set/set animation frame index
     * @name frameIndex
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {Integer} frameIndex
     * @returns {Integer}
     * @example
     * // get animation frame index
     * var frameIndex = sprite.frameIndex();
     *
     * // set animation frame index
     * sprite.frameIndex(3);
     */

    Konva.Factory.addGetterSetter(Konva.Sprite, 'frameRate', 17);

    /**
     * get/set frame rate in frames per second.  Increase this number to make the sprite
     *  animation run faster, and decrease the number to make the sprite animation run slower
     *  The default is 17 frames per second
     * @name frameRate
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {Integer} frameRate
     * @returns {Integer}
     * @example
     * // get frame rate
     * var frameRate = sprite.frameRate();
     *
     * // set frame rate to 2 frames per second
     * sprite.frameRate(2);
     */

    Konva.Factory.backCompat(Konva.Sprite, {
        index: 'frameIndex',
        getIndex: 'getFrameIndex',
        setIndex: 'setFrameIndex'
    });

    Konva.Collection.mapMethods(Konva.Sprite);
})();

/*eslint-disable  no-shadow, max-len, max-depth */
(function () {
    'use strict';
    /**
     * Path constructor.
     * @author Jason Follas
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {String} config.data SVG data string
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var path = new Konva.Path({
     *   x: 240,
     *   y: 40,
     *   data: 'M12.582,9.551C3.251,16.237,0.921,29.021,7.08,38.564l-2.36,1.689l4.893,2.262l4.893,2.262l-0.568-5.36l-0.567-5.359l-2.365,1.694c-4.657-7.375-2.83-17.185,4.352-22.33c7.451-5.338,17.817-3.625,23.156,3.824c5.337,7.449,3.625,17.813-3.821,23.152l2.857,3.988c9.617-6.893,11.827-20.277,4.935-29.896C35.591,4.87,22.204,2.658,12.582,9.551z',
     *   fill: 'green',
     *   scale: 2
     * });
     */
    Konva.Path = function (config) {
        this.___init(config);
    };

    Konva.Path.prototype = {
        ___init: function (config) {
            this.dataArray = [];
            var that = this;

            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'Path';

            this.dataArray = Konva.Path.parsePathData(this.getData());
            this.on('dataChange.konva', function () {
                that.dataArray = Konva.Path.parsePathData(this.getData());
            });

            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            var ca = this.dataArray,
                closedPath = false;

            // context position
            context.beginPath();
            for (var n = 0; n < ca.length; n++) {
                var c = ca[n].command;
                var p = ca[n].points;
                switch (c) {
                    case 'L':
                        context.lineTo(p[0], p[1]);
                        break;
                    case 'M':
                        context.moveTo(p[0], p[1]);
                        break;
                    case 'C':
                        context.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
                        break;
                    case 'Q':
                        context.quadraticCurveTo(p[0], p[1], p[2], p[3]);
                        break;
                    case 'A':
                        var cx = p[0], cy = p[1], rx = p[2], ry = p[3], theta = p[4], dTheta = p[5], psi = p[6], fs = p[7];

                        var r = (rx > ry) ? rx : ry;
                        var scaleX = (rx > ry) ? 1 : rx / ry;
                        var scaleY = (rx > ry) ? ry / rx : 1;

                        context.translate(cx, cy);
                        context.rotate(psi);
                        context.scale(scaleX, scaleY);
                        context.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
                        context.scale(1 / scaleX, 1 / scaleY);
                        context.rotate(-psi);
                        context.translate(-cx, -cy);

                        break;
                    case 'z':
                        context.closePath();
                        closedPath = true;
                        break;
                }
            }

            if (closedPath) {
                context.fillStrokeShape(this);
            }
            else {
                context.strokeShape(this);
            }
        },
        getSelfRect: function() {
            var points = [];
            this.dataArray.forEach(function(data) {
                points = points.concat(data.points);
            });
            var minX = points[0];
            var maxX = points[0];
            var minY = points[0];
            var maxY = points[0];
            var x, y;
            for (var i = 0; i < points.length / 2; i++) {
                x = points[i * 2]; y = points[i * 2 + 1];
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }
            return {
                x: Math.round(minX),
                y: Math.round(minY),
                width: Math.round(maxX - minX),
                height: Math.round(maxY - minY)
            };
        }
    };
    Konva.Util.extend(Konva.Path, Konva.Shape);

    Konva.Path.getLineLength = function(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    };
    Konva.Path.getPointOnLine = function(dist, P1x, P1y, P2x, P2y, fromX, fromY) {
        if(fromX === undefined) {
            fromX = P1x;
        }
        if(fromY === undefined) {
            fromY = P1y;
        }

        var m = (P2y - P1y) / ((P2x - P1x) + 0.00000001);
        var run = Math.sqrt(dist * dist / (1 + m * m));
        if(P2x < P1x) {
            run *= -1;
        }
        var rise = m * run;
        var pt;

        if (P2x === P1x) { // vertical line
            pt = {
                x: fromX,
                y: fromY + rise
            };
        } else if((fromY - P1y) / ((fromX - P1x) + 0.00000001) === m) {
            pt = {
                x: fromX + run,
                y: fromY + rise
            };
        }
        else {
            var ix, iy;

            var len = this.getLineLength(P1x, P1y, P2x, P2y);
            if(len < 0.00000001) {
                return undefined;
            }
            var u = (((fromX - P1x) * (P2x - P1x)) + ((fromY - P1y) * (P2y - P1y)));
            u = u / (len * len);
            ix = P1x + u * (P2x - P1x);
            iy = P1y + u * (P2y - P1y);

            var pRise = this.getLineLength(fromX, fromY, ix, iy);
            var pRun = Math.sqrt(dist * dist - pRise * pRise);
            run = Math.sqrt(pRun * pRun / (1 + m * m));
            if(P2x < P1x) {
                run *= -1;
            }
            rise = m * run;
            pt = {
                x: ix + run,
                y: iy + rise
            };
        }

        return pt;
    };

    Konva.Path.getPointOnCubicBezier = function(pct, P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y) {
        function CB1(t) {
            return t * t * t;
        }
        function CB2(t) {
            return 3 * t * t * (1 - t);
        }
        function CB3(t) {
            return 3 * t * (1 - t) * (1 - t);
        }
        function CB4(t) {
            return (1 - t) * (1 - t) * (1 - t);
        }
        var x = P4x * CB1(pct) + P3x * CB2(pct) + P2x * CB3(pct) + P1x * CB4(pct);
        var y = P4y * CB1(pct) + P3y * CB2(pct) + P2y * CB3(pct) + P1y * CB4(pct);

        return {
            x: x,
            y: y
        };
    };
    Konva.Path.getPointOnQuadraticBezier = function(pct, P1x, P1y, P2x, P2y, P3x, P3y) {
        function QB1(t) {
            return t * t;
        }
        function QB2(t) {
            return 2 * t * (1 - t);
        }
        function QB3(t) {
            return (1 - t) * (1 - t);
        }
        var x = P3x * QB1(pct) + P2x * QB2(pct) + P1x * QB3(pct);
        var y = P3y * QB1(pct) + P2y * QB2(pct) + P1y * QB3(pct);

        return {
            x: x,
            y: y
        };
    };
    Konva.Path.getPointOnEllipticalArc = function(cx, cy, rx, ry, theta, psi) {
        var cosPsi = Math.cos(psi), sinPsi = Math.sin(psi);
        var pt = {
            x: rx * Math.cos(theta),
            y: ry * Math.sin(theta)
        };
        return {
            x: cx + (pt.x * cosPsi - pt.y * sinPsi),
            y: cy + (pt.x * sinPsi + pt.y * cosPsi)
        };
    };
    /*
     * get parsed data array from the data
     *  string.  V, v, H, h, and l data are converted to
     *  L data for the purpose of high performance Path
     *  rendering
     */
    Konva.Path.parsePathData = function(data) {
        // Path Data Segment must begin with a moveTo
        //m (x y)+  Relative moveTo (subsequent points are treated as lineTo)
        //M (x y)+  Absolute moveTo (subsequent points are treated as lineTo)
        //l (x y)+  Relative lineTo
        //L (x y)+  Absolute LineTo
        //h (x)+    Relative horizontal lineTo
        //H (x)+    Absolute horizontal lineTo
        //v (y)+    Relative vertical lineTo
        //V (y)+    Absolute vertical lineTo
        //z (closepath)
        //Z (closepath)
        //c (x1 y1 x2 y2 x y)+ Relative Bezier curve
        //C (x1 y1 x2 y2 x y)+ Absolute Bezier curve
        //q (x1 y1 x y)+       Relative Quadratic Bezier
        //Q (x1 y1 x y)+       Absolute Quadratic Bezier
        //t (x y)+    Shorthand/Smooth Relative Quadratic Bezier
        //T (x y)+    Shorthand/Smooth Absolute Quadratic Bezier
        //s (x2 y2 x y)+       Shorthand/Smooth Relative Bezier curve
        //S (x2 y2 x y)+       Shorthand/Smooth Absolute Bezier curve
        //a (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+     Relative Elliptical Arc
        //A (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+  Absolute Elliptical Arc

        // return early if data is not defined
        if(!data) {
            return [];
        }

        // command string
        var cs = data;

        // command chars
        var cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];
        // convert white spaces to commas
        cs = cs.replace(new RegExp(' ', 'g'), ',');
        // create pipes so that we can split the data
        for(var n = 0; n < cc.length; n++) {
            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
        }
        // create array
        var arr = cs.split('|');
        var ca = [];
        // init context point
        var cpx = 0;
        var cpy = 0;
        for( n = 1; n < arr.length; n++) {
            var str = arr[n];
            var c = str.charAt(0);
            str = str.slice(1);
            // remove ,- for consistency
            str = str.replace(new RegExp(',-', 'g'), '-');
            // add commas so that it's easy to split
            str = str.replace(new RegExp('-', 'g'), ',-');
            str = str.replace(new RegExp('e,-', 'g'), 'e-');
            var p = str.split(',');
            if(p.length > 0 && p[0] === '') {
                p.shift();
            }
            // convert strings to floats
            for(var i = 0; i < p.length; i++) {
                p[i] = parseFloat(p[i]);
            }
            while(p.length > 0) {
                if(isNaN(p[0])) {// case for a trailing comma before next command
                    break;
                }

                var cmd = null;
                var points = [];
                var startX = cpx, startY = cpy;
                // Move var from within the switch to up here (jshint)
                var prevCmd, ctlPtx, ctlPty;     // Ss, Tt
                var rx, ry, psi, fa, fs, x1, y1; // Aa


                // convert l, H, h, V, and v to L
                switch (c) {

                    // Note: Keep the lineTo's above the moveTo's in this switch
                    case 'l':
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'L':
                        cpx = p.shift();
                        cpy = p.shift();
                        points.push(cpx, cpy);
                        break;

                    // Note: lineTo handlers need to be above this point
                    case 'm':
                        var dx = p.shift();
                        var dy = p.shift();
                        cpx += dx;
                        cpy += dy;
                        cmd = 'M';
                        // After closing the path move the current position
                        // to the the first point of the path (if any).
                        if(ca.length > 2 && ca[ca.length - 1].command === 'z'){
                            for(var idx = ca.length - 2; idx >= 0; idx--){
                                if(ca[idx].command === 'M'){
                                    cpx = ca[idx].points[0] + dx;
                                    cpy = ca[idx].points[1] + dy;
                                    break;
                                }
                            }
                        }
                        points.push(cpx, cpy);
                        c = 'l';
                        // subsequent points are treated as relative lineTo
                        break;
                    case 'M':
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'M';
                        points.push(cpx, cpy);
                        c = 'L';
                        // subsequent points are treated as absolute lineTo
                        break;

                    case 'h':
                        cpx += p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'H':
                        cpx = p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'v':
                        cpy += p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'V':
                        cpy = p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'C':
                        points.push(p.shift(), p.shift(), p.shift(), p.shift());
                        cpx = p.shift();
                        cpy = p.shift();
                        points.push(cpx, cpy);
                        break;
                    case 'c':
                        points.push(cpx + p.shift(), cpy + p.shift(), cpx + p.shift(), cpy + p.shift());
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'C';
                        points.push(cpx, cpy);
                        break;
                    case 'S':
                        ctlPtx = cpx;
                        ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if(prevCmd.command === 'C') {
                            ctlPtx = cpx + (cpx - prevCmd.points[2]);
                            ctlPty = cpy + (cpy - prevCmd.points[3]);
                        }
                        points.push(ctlPtx, ctlPty, p.shift(), p.shift());
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'C';
                        points.push(cpx, cpy);
                        break;
                    case 's':
                        ctlPtx = cpx;
                        ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if(prevCmd.command === 'C') {
                            ctlPtx = cpx + (cpx - prevCmd.points[2]);
                            ctlPty = cpy + (cpy - prevCmd.points[3]);
                        }
                        points.push(ctlPtx, ctlPty, cpx + p.shift(), cpy + p.shift());
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'C';
                        points.push(cpx, cpy);
                        break;
                    case 'Q':
                        points.push(p.shift(), p.shift());
                        cpx = p.shift();
                        cpy = p.shift();
                        points.push(cpx, cpy);
                        break;
                    case 'q':
                        points.push(cpx + p.shift(), cpy + p.shift());
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'Q';
                        points.push(cpx, cpy);
                        break;
                    case 'T':
                        ctlPtx = cpx;
                        ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if(prevCmd.command === 'Q') {
                            ctlPtx = cpx + (cpx - prevCmd.points[0]);
                            ctlPty = cpy + (cpy - prevCmd.points[1]);
                        }
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'Q';
                        points.push(ctlPtx, ctlPty, cpx, cpy);
                        break;
                    case 't':
                        ctlPtx = cpx;
                        ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if(prevCmd.command === 'Q') {
                            ctlPtx = cpx + (cpx - prevCmd.points[0]);
                            ctlPty = cpy + (cpy - prevCmd.points[1]);
                        }
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'Q';
                        points.push(ctlPtx, ctlPty, cpx, cpy);
                        break;
                    case 'A':
                        rx = p.shift();
                        ry = p.shift();
                        psi = p.shift();
                        fa = p.shift();
                        fs = p.shift();
                        x1 = cpx;
                        y1 = cpy;
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'A';
                        points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
                        break;
                    case 'a':
                        rx = p.shift();
                        ry = p.shift();
                        psi = p.shift();
                        fa = p.shift();
                        fs = p.shift();
                        x1 = cpx;
                        y1 = cpy; cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'A';
                        points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
                        break;
                }

                ca.push({
                    command: cmd || c,
                    points: points,
                    start: {
                        x: startX,
                        y: startY
                    },
                    pathLength: this.calcLength(startX, startY, cmd || c, points)
                });
            }

            if(c === 'z' || c === 'Z') {
                ca.push({
                    command: 'z',
                    points: [],
                    start: undefined,
                    pathLength: 0
                });
            }
        }

        return ca;
    };
    Konva.Path.calcLength = function(x, y, cmd, points) {
        var len, p1, p2, t;
        var path = Konva.Path;

        switch (cmd) {
            case 'L':
                return path.getLineLength(x, y, points[0], points[1]);
            case 'C':
                // Approximates by breaking curve into 100 line segments
                len = 0.0;
                p1 = path.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
                for( t = 0.01; t <= 1; t += 0.01) {
                    p2 = path.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
                    len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                    p1 = p2;
                }
                return len;
            case 'Q':
                // Approximates by breaking curve into 100 line segments
                len = 0.0;
                p1 = path.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);
                for( t = 0.01; t <= 1; t += 0.01) {
                    p2 = path.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);
                    len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                    p1 = p2;
                }
                return len;
            case 'A':
                // Approximates by breaking curve into line segments
                len = 0.0;
                var start = points[4];
                // 4 = theta
                var dTheta = points[5];
                // 5 = dTheta
                var end = points[4] + dTheta;
                var inc = Math.PI / 180.0;
                // 1 degree resolution
                if(Math.abs(start - end) < inc) {
                    inc = Math.abs(start - end);
                }
                // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi
                p1 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);
                if(dTheta < 0) {// clockwise
                    for( t = start - inc; t > end; t -= inc) {
                        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                        p1 = p2;
                    }
                }
                else {// counter-clockwise
                    for( t = start + inc; t < end; t += inc) {
                        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                        p1 = p2;
                    }
                }
                p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
                len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);

                return len;
        }

        return 0;
    };
    Konva.Path.convertEndpointToCenterParameterization = function(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg) {
        // Derived from: http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
        var psi = psiDeg * (Math.PI / 180.0);
        var xp = Math.cos(psi) * (x1 - x2) / 2.0 + Math.sin(psi) * (y1 - y2) / 2.0;
        var yp = -1 * Math.sin(psi) * (x1 - x2) / 2.0 + Math.cos(psi) * (y1 - y2) / 2.0;

        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);

        if(lambda > 1) {
            rx *= Math.sqrt(lambda);
            ry *= Math.sqrt(lambda);
        }

        var f = Math.sqrt((((rx * rx) * (ry * ry)) - ((rx * rx) * (yp * yp)) - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp) + (ry * ry) * (xp * xp)));

        if(fa === fs) {
            f *= -1;
        }
        if(isNaN(f)) {
            f = 0;
        }

        var cxp = f * rx * yp / ry;
        var cyp = f * -ry * xp / rx;

        var cx = (x1 + x2) / 2.0 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;
        var cy = (y1 + y2) / 2.0 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;

        var vMag = function(v) {
            return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
        };
        var vRatio = function(u, v) {
            return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
        };
        var vAngle = function(u, v) {
            return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
        };
        var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
        var u = [(xp - cxp) / rx, (yp - cyp) / ry];
        var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
        var dTheta = vAngle(u, v);

        if(vRatio(u, v) <= -1) {
            dTheta = Math.PI;
        }
        if(vRatio(u, v) >= 1) {
            dTheta = 0;
        }
        if(fs === 0 && dTheta > 0) {
            dTheta = dTheta - 2 * Math.PI;
        }
        if(fs === 1 && dTheta < 0) {
            dTheta = dTheta + 2 * Math.PI;
        }
        return [cx, cy, rx, ry, theta, dTheta, psi, fs];
    };
    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Path, 'data');

    /**
     * set SVG path data string.  This method
     *  also automatically parses the data string
     *  into a data array.  Currently supported SVG data:
     *  M, m, L, l, H, h, V, v, Q, q, T, t, C, c, S, s, A, a, Z, z
     * @name setData
     * @method
     * @memberof Konva.Path.prototype
     * @param {String} SVG path command string
     */

    /**
     * get SVG path data string
     * @name getData
     * @method
     * @memberof Konva.Path.prototype
     */

    Konva.Collection.mapMethods(Konva.Path);
})();

(function() {
    'use strict';
    var EMPTY_STRING = '',
        //CALIBRI = 'Calibri',
        NORMAL = 'normal';

    /**
     * Path constructor.
     * @author Jason Follas
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {String} [config.fontFamily] default is Calibri
     * @param {Number} [config.fontSize] default is 12
     * @param {String} [config.fontStyle] can be normal, bold, or italic.  Default is normal
     * @param {String} [config.fontVariant] can be normal or small-caps.  Default is normal
     * @param {String} config.text
     * @param {String} config.data SVG data string
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var textpath = new Konva.TextPath({
     *   x: 100,
     *   y: 50,
     *   fill: '#333',
     *   fontSize: '24',
     *   fontFamily: 'Arial',
     *   text: 'All the world\'s a stage, and all the men and women merely players.',
     *   data: 'M10,10 C0,0 10,150 100,100 S300,150 400,50'
     * });
     */
    Konva.TextPath = function(config) {
        this.___init(config);
    };

    function _fillFunc(context) {
        context.fillText(this.partialText, 0, 0);
    }
    function _strokeFunc(context) {
        context.strokeText(this.partialText, 0, 0);
    }

    Konva.TextPath.prototype = {
        ___init: function(config) {
            var that = this;
            this.dummyCanvas = Konva.Util.createCanvasElement();
            this.dataArray = [];

            // call super constructor
            Konva.Shape.call(this, config);

            // overrides
            // TODO: shouldn't this be on the prototype?
            this._fillFunc = _fillFunc;
            this._strokeFunc = _strokeFunc;
            this._fillFuncHit = _fillFunc;
            this._strokeFuncHit = _strokeFunc;

            this.className = 'TextPath';

            this.dataArray = Konva.Path.parsePathData(this.attrs.data);
            this.on('dataChange.konva', function() {
                that.dataArray = Konva.Path.parsePathData(this.attrs.data);
            });

            // update text data for certain attr changes
            this.on('textChange.konva textStroke.konva textStrokeWidth.konva', that._setTextData);
            that._setTextData();
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            context.setAttr('font', this._getContextFont());
            context.setAttr('textBaseline', 'middle');
            context.setAttr('textAlign', 'left');
            context.save();

            var glyphInfo = this.glyphInfo;
            for(var i = 0; i < glyphInfo.length; i++) {
                context.save();

                var p0 = glyphInfo[i].p0;

                context.translate(p0.x, p0.y);
                context.rotate(glyphInfo[i].rotation);
                this.partialText = glyphInfo[i].text;

                context.fillStrokeShape(this);
                context.restore();

                //// To assist with debugging visually, uncomment following
                // context.beginPath();
                // if (i % 2)
                // context.strokeStyle = 'cyan';
                // else
                // context.strokeStyle = 'green';
                // var p1 = glyphInfo[i].p1;
                // context.moveTo(p0.x, p0.y);
                // context.lineTo(p1.x, p1.y);
                // context.stroke();
            }
            context.restore();
        },
        /**
         * get text width in pixels
         * @method
         * @memberof Konva.TextPath.prototype
         */
        getTextWidth: function() {
            return this.textWidth;
        },
        /**
         * get text height in pixels
         * @method
         * @memberof Konva.TextPath.prototype
         */
        getTextHeight: function() {
            return this.textHeight;
        },
        /**
         * set text
         * @method
         * @memberof Konva.TextPath.prototype
         * @param {String} text
         */
        setText: function(text) {
            Konva.Text.prototype.setText.call(this, text);
        },
        _getTextSize: function(text) {
            var dummyCanvas = this.dummyCanvas;
            var _context = dummyCanvas.getContext('2d');

            _context.save();

            _context.font = this._getContextFont();
            var metrics = _context.measureText(text);

            _context.restore();

            return {
                width: metrics.width,
                height: parseInt(this.attrs.fontSize, 10)
            };
        },
        _setTextData: function() {

            var that = this;
            var size = this._getTextSize(this.attrs.text);
            this.textWidth = size.width;
            this.textHeight = size.height;

            this.glyphInfo = [];

            var charArr = this.attrs.text.split('');

            var p0, p1, pathCmd;

            var pIndex = -1;
            var currentT = 0;

            var getNextPathSegment = function() {
                currentT = 0;
                var pathData = that.dataArray;

                for(var j = pIndex + 1; j < pathData.length; j++) {
                    if(pathData[j].pathLength > 0) {
                        pIndex = j;

                        return pathData[j];
                    }
                    else if(pathData[j].command === 'M') {
                        p0 = {
                            x: pathData[j].points[0],
                            y: pathData[j].points[1]
                        };
                    }
                }

                return {};
            };
            var findSegmentToFitCharacter = function(c) {

                var glyphWidth = that._getTextSize(c).width;

                var currLen = 0;
                var attempts = 0;

                p1 = undefined;
                while(Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 && attempts < 25) {
                    attempts++;
                    var cumulativePathLength = currLen;
                    while(pathCmd === undefined) {
                        pathCmd = getNextPathSegment();

                        if(pathCmd && cumulativePathLength + pathCmd.pathLength < glyphWidth) {
                            cumulativePathLength += pathCmd.pathLength;
                            pathCmd = undefined;
                        }
                    }

                    if(pathCmd === {} || p0 === undefined) {
                        return undefined;
                    }

                    var needNewSegment = false;

                    switch (pathCmd.command) {
                        case 'L':
                            if(Konva.Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {
                                p1 = Konva.Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);
                            }
                            else {
                                pathCmd = undefined;
                            }
                            break;
                        case 'A':

                            var start = pathCmd.points[4];
                            // 4 = theta
                            var dTheta = pathCmd.points[5];
                            // 5 = dTheta
                            var end = pathCmd.points[4] + dTheta;

                            if(currentT === 0){
                                currentT = start + 0.00000001;
                            }
                            // Just in case start is 0
                            else if(glyphWidth > currLen) {
                                currentT += (Math.PI / 180.0) * dTheta / Math.abs(dTheta);
                            }
                            else {
                                currentT -= Math.PI / 360.0 * dTheta / Math.abs(dTheta);
                            }

                            // Credit for bug fix: @therth https://github.com/ericdrowell/KonvaJS/issues/249
                            // Old code failed to render text along arc of this path: "M 50 50 a 150 50 0 0 1 250 50 l 50 0"
                            if(dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {
                                currentT = end;
                                needNewSegment = true;
                            }
                            p1 = Konva.Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);
                            break;
                        case 'C':
                            if(currentT === 0) {
                                if(glyphWidth > pathCmd.pathLength) {
                                    currentT = 0.00000001;
                                }
                                else {
                                    currentT = glyphWidth / pathCmd.pathLength;
                                }
                            }
                            else if(glyphWidth > currLen) {
                                currentT += (glyphWidth - currLen) / pathCmd.pathLength;
                            }
                            else {
                                currentT -= (currLen - glyphWidth) / pathCmd.pathLength;
                            }

                            if(currentT > 1.0) {
                                currentT = 1.0;
                                needNewSegment = true;
                            }
                            p1 = Konva.Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);
                            break;
                        case 'Q':
                            if(currentT === 0) {
                                currentT = glyphWidth / pathCmd.pathLength;
                            }
                            else if(glyphWidth > currLen) {
                                currentT += (glyphWidth - currLen) / pathCmd.pathLength;
                            }
                            else {
                                currentT -= (currLen - glyphWidth) / pathCmd.pathLength;
                            }

                            if(currentT > 1.0) {
                                currentT = 1.0;
                                needNewSegment = true;
                            }
                            p1 = Konva.Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);
                            break;

                    }

                    if(p1 !== undefined) {
                        currLen = Konva.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);
                    }

                    if(needNewSegment) {
                        needNewSegment = false;
                        pathCmd = undefined;
                    }
                }
            };
            for(var i = 0; i < charArr.length; i++) {

                // Find p1 such that line segment between p0 and p1 is approx. width of glyph
                findSegmentToFitCharacter(charArr[i]);

                if(p0 === undefined || p1 === undefined) {
                    break;
                }

                var width = Konva.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);

                // Note: Since glyphs are rendered one at a time, any kerning pair data built into the font will not be used.
                // Can foresee having a rough pair table built in that the developer can override as needed.

                var kern = 0;
                // placeholder for future implementation

                var midpoint = Konva.Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);

                var rotation = Math.atan2((p1.y - p0.y), (p1.x - p0.x));
                this.glyphInfo.push({
                    transposeX: midpoint.x,
                    transposeY: midpoint.y,
                    text: charArr[i],
                    rotation: rotation,
                    p0: p0,
                    p1: p1
                });
                p0 = p1;
            }
        },
        getSelfRect: function() {
            var points = [];
            var fontSize = this.fontSize();

            this.glyphInfo.forEach(function(info) {
                points.push(info.p0.x);
                points.push(info.p0.y);
                points.push(info.p1.x);
                points.push(info.p1.y);
            });
            var minX = points[0];
            var maxX = points[0];
            var minY = points[0];
            var maxY = points[0];
            var x, y;
            for (var i = 0; i < points.length / 2; i++) {
                x = points[i * 2]; y = points[i * 2 + 1];
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }
            return {
                x: Math.round(minX) - fontSize,
                y: Math.round(minY) - fontSize,
                width: Math.round(maxX - minX) + fontSize * 2,
                height: Math.round(maxY - minY) + fontSize * 2
            };
        }
    };

    // map TextPath methods to Text
    Konva.TextPath.prototype._getContextFont = Konva.Text.prototype._getContextFont;

    Konva.Util.extend(Konva.TextPath, Konva.Shape);

    // add setters and getters
    Konva.Factory.addGetterSetter(Konva.TextPath, 'fontFamily', 'Arial');

    /**
     * set font family
     * @name setFontFamily
     * @method
     * @memberof Konva.TextPath.prototype
     * @param {String} fontFamily
     */

     /**
     * get font family
     * @name getFontFamily
     * @method
     * @memberof Konva.TextPath.prototype
     */

    Konva.Factory.addGetterSetter(Konva.TextPath, 'fontSize', 12);

    /**
     * set font size
     * @name setFontSize
     * @method
     * @memberof Konva.TextPath.prototype
     * @param {int} fontSize
     */

     /**
     * get font size
     * @name getFontSize
     * @method
     * @memberof Konva.TextPath.prototype
     */

    Konva.Factory.addGetterSetter(Konva.TextPath, 'fontStyle', NORMAL);

    /**
     * set font style.  Can be 'normal', 'italic', or 'bold'.  'normal' is the default.
     * @name setFontStyle
     * @method
     * @memberof Konva.TextPath.prototype
     * @param {String} fontStyle
     */

     /**
     * get font style
     * @name getFontStyle
     * @method
     * @memberof Konva.TextPath.prototype
     */

    Konva.Factory.addGetterSetter(Konva.TextPath, 'fontVariant', NORMAL);

    /**
     * set font variant.  Can be 'normal' or 'small-caps'.  'normal' is the default.
     * @name setFontVariant
     * @method
     * @memberof Konva.TextPath.prototype
     * @param {String} fontVariant
     */

    /**
     * @get font variant
     * @name getFontVariant
     * @method
     * @memberof Konva.TextPath.prototype
     */

    Konva.Factory.addGetter(Konva.TextPath, 'text', EMPTY_STRING);

    /**
     * get text
     * @name getText
     * @method
     * @memberof Konva.TextPath.prototype
     */

    Konva.Collection.mapMethods(Konva.TextPath);
})();

(function() {
    'use strict';
    /**
     * RegularPolygon constructor.&nbsp; Examples include triangles, squares, pentagons, hexagons, etc.
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.sides
     * @param {Number} config.radius
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var hexagon = new Konva.RegularPolygon({
     *   x: 100,
     *   y: 200,
     *   sides: 6,
     *   radius: 70,
     *   fill: 'red',
     *   stroke: 'black',
     *   strokeWidth: 4
     * });
     */
    Konva.RegularPolygon = function(config) {
        this.___init(config);
    };

    Konva.RegularPolygon.prototype = {
        _centroid: true,
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'RegularPolygon';
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            var sides = this.attrs.sides,
                radius = this.attrs.radius,
                n, x, y;

            context.beginPath();
            context.moveTo(0, 0 - radius);

            for(n = 1; n < sides; n++) {
                x = radius * Math.sin(n * 2 * Math.PI / sides);
                y = -1 * radius * Math.cos(n * 2 * Math.PI / sides);
                context.lineTo(x, y);
            }
            context.closePath();
            context.fillStrokeShape(this);
        },
        getWidth: function() {
            return this.getRadius() * 2;
        },
        // implements Shape.prototype.getHeight()
        getHeight: function() {
            return this.getRadius() * 2;
        },
        // implements Shape.prototype.setWidth()
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            if (this.radius() !== width / 2) {
                this.setRadius(width / 2);
            }
        },
        // implements Shape.prototype.setHeight()
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            if (this.radius() !== height / 2) {
                this.setRadius(height / 2);
            }
        }
    };
    Konva.Util.extend(Konva.RegularPolygon, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.RegularPolygon, 'radius', 0);

    /**
     * set radius
     * @name setRadius
     * @method
     * @memberof Konva.RegularPolygon.prototype
     * @param {Number} radius
     */

     /**
     * get radius
     * @name getRadius
     * @method
     * @memberof Konva.RegularPolygon.prototype
     */

    Konva.Factory.addGetterSetter(Konva.RegularPolygon, 'sides', 0);

    /**
     * set number of sides
     * @name setSides
     * @method
     * @memberof Konva.RegularPolygon.prototype
     * @param {int} sides
     */

    /**
     * get number of sides
     * @name getSides
     * @method
     * @memberof Konva.RegularPolygon.prototype
     */

    Konva.Collection.mapMethods(Konva.RegularPolygon);
})();

(function() {
    'use strict';
    /**
     * Star constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Integer} config.numPoints
     * @param {Number} config.innerRadius
     * @param {Number} config.outerRadius
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var star = new Konva.Star({
     *   x: 100,
     *   y: 200,
     *   numPoints: 5,
     *   innerRadius: 70,
     *   outerRadius: 70,
     *   fill: 'red',
     *   stroke: 'black',
     *   strokeWidth: 4
     * });
     */
    Konva.Star = function(config) {
        this.___init(config);
    };

    Konva.Star.prototype = {
        _centroid: true,
        ___init: function(config) {
            // call super constructor
            Konva.Shape.call(this, config);
            this.className = 'Star';
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            var innerRadius = this.innerRadius(),
                outerRadius = this.outerRadius(),
                numPoints = this.numPoints();

            context.beginPath();
            context.moveTo(0, 0 - outerRadius);

            for(var n = 1; n < numPoints * 2; n++) {
                var radius = n % 2 === 0 ? outerRadius : innerRadius;
                var x = radius * Math.sin(n * Math.PI / numPoints);
                var y = -1 * radius * Math.cos(n * Math.PI / numPoints);
                context.lineTo(x, y);
            }
            context.closePath();

            context.fillStrokeShape(this);
        },
        // implements Shape.prototype.getWidth()
        getWidth: function() {
            return this.getOuterRadius() * 2;
        },
        // implements Shape.prototype.getHeight()
        getHeight: function() {
            return this.getOuterRadius() * 2;
        },
        // implements Shape.prototype.setWidth()
        setWidth: function(width) {
            Konva.Node.prototype.setWidth.call(this, width);
            if (this.outerRadius() !== width / 2) {
                this.setOuterRadius(width / 2);
            }
        },
        // implements Shape.prototype.setHeight()
        setHeight: function(height) {
            Konva.Node.prototype.setHeight.call(this, height);
            if (this.outerRadius() !== height / 2) {
                this.setOuterRadius(height / 2);
            }
        }
    };
    Konva.Util.extend(Konva.Star, Konva.Shape);

    // add getters setters
    Konva.Factory.addGetterSetter(Konva.Star, 'numPoints', 5);

    /**
     * set number of points
     * @name setNumPoints
     * @method
     * @memberof Konva.Star.prototype
     * @param {Integer} points
     */

     /**
     * get number of points
     * @name getNumPoints
     * @method
     * @memberof Konva.Star.prototype
     */

    Konva.Factory.addGetterSetter(Konva.Star, 'innerRadius', 0);

    /**
     * set inner radius
     * @name setInnerRadius
     * @method
     * @memberof Konva.Star.prototype
     * @param {Number} radius
     */

     /**
     * get inner radius
     * @name getInnerRadius
     * @method
     * @memberof Konva.Star.prototype
     */

    Konva.Factory.addGetterSetter(Konva.Star, 'outerRadius', 0);

    /**
     * set outer radius
     * @name setOuterRadius
     * @method
     * @memberof Konva.Star.prototype
     * @param {Number} radius
     */

     /**
     * get outer radius
     * @name getOuterRadius
     * @method
     * @memberof Konva.Star.prototype
     */

    Konva.Collection.mapMethods(Konva.Star);
})();

(function() {
    'use strict';
    // constants
    var ATTR_CHANGE_LIST = ['fontFamily', 'fontSize', 'fontStyle', 'padding', 'lineHeight', 'text'],
        CHANGE_KONVA = 'Change.konva',
        NONE = 'none',
        UP = 'up',
        RIGHT = 'right',
        DOWN = 'down',
        LEFT = 'left',
        LABEL = 'Label',

     // cached variables
     attrChangeListLen = ATTR_CHANGE_LIST.length;

    /**
     * Label constructor.&nbsp; Labels are groups that contain a Text and Tag shape
     * @constructor
     * @memberof Konva
     * @param {Object} config
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * // create label
     * var label = new Konva.Label({
     *   x: 100,
     *   y: 100,
     *   draggable: true
     * });
     *
     * // add a tag to the label
     * label.add(new Konva.Tag({
     *   fill: '#bbb',
     *   stroke: '#333',
     *   shadowColor: 'black',
     *   shadowBlur: 10,
     *   shadowOffset: [10, 10],
     *   shadowOpacity: 0.2,
     *   lineJoin: 'round',
     *   pointerDirection: 'up',
     *   pointerWidth: 20,
     *   pointerHeight: 20,
     *   cornerRadius: 5
     * }));
     *
     * // add text to the label
     * label.add(new Konva.Text({
     *   text: 'Hello World!',
     *   fontSize: 50,
     *   lineHeight: 1.2,
     *   padding: 10,
     *   fill: 'green'
     *  }));
     */
    Konva.Label = function(config) {
        this.____init(config);
    };

    Konva.Label.prototype = {
        ____init: function(config) {
            var that = this;

            Konva.Group.call(this, config);
            this.className = LABEL;

            this.on('add.konva', function(evt) {
                that._addListeners(evt.child);
                that._sync();
            });
        },
        /**
         * get Text shape for the label.  You need to access the Text shape in order to update
         * the text properties
         * @name getText
         * @method
         * @memberof Konva.Label.prototype
         */
        getText: function() {
            return this.find('Text')[0];
        },
        /**
         * get Tag shape for the label.  You need to access the Tag shape in order to update
         * the pointer properties and the corner radius
         * @name getTag
         * @method
         * @memberof Konva.Label.prototype
         */
        getTag: function() {
            return this.find('Tag')[0];
        },
        _addListeners: function(text) {
            var that = this,
                n;
            var func = function(){
                    that._sync();
                };

            // update text data for certain attr changes
            for(n = 0; n < attrChangeListLen; n++) {
                text.on(ATTR_CHANGE_LIST[n] + CHANGE_KONVA, func);
            }
        },
        getWidth: function() {
            return this.getText().getWidth();
        },
        getHeight: function() {
            return this.getText().getHeight();
        },
        _sync: function() {
            var text = this.getText(),
                tag = this.getTag(),
                width, height, pointerDirection, pointerWidth, x, y, pointerHeight;

            if (text && tag) {
                width = text.getWidth();
                height = text.getHeight();
                pointerDirection = tag.getPointerDirection();
                pointerWidth = tag.getPointerWidth();
                pointerHeight = tag.getPointerHeight();
                x = 0;
                y = 0;

                switch(pointerDirection) {
                    case UP:
                        x = width / 2;
                        y = -1 * pointerHeight;
                        break;
                    case RIGHT:
                        x = width + pointerWidth;
                        y = height / 2;
                        break;
                    case DOWN:
                        x = width / 2;
                        y = height + pointerHeight;
                        break;
                    case LEFT:
                        x = -1 * pointerWidth;
                        y = height / 2;
                        break;
                }

                tag.setAttrs({
                    x: -1 * x,
                    y: -1 * y,
                    width: width,
                    height: height
                });

                text.setAttrs({
                    x: -1 * x,
                    y: -1 * y
                });
            }
        }
    };

    Konva.Util.extend(Konva.Label, Konva.Group);

    Konva.Collection.mapMethods(Konva.Label);

    /**
     * Tag constructor.&nbsp; A Tag can be configured
     *  to have a pointer element that points up, right, down, or left
     * @constructor
     * @memberof Konva
     * @param {Object} config
     * @param {String} [config.pointerDirection] can be up, right, down, left, or none; the default
     *  is none.  When a pointer is present, the positioning of the label is relative to the tip of the pointer.
     * @param {Number} [config.pointerWidth]
     * @param {Number} [config.pointerHeight]
     * @param {Number} [config.cornerRadius]
     */
    Konva.Tag = function(config) {
        this.___init(config);
    };

    Konva.Tag.prototype = {
        ___init: function(config) {
            Konva.Shape.call(this, config);
            this.className = 'Tag';
            this.sceneFunc(this._sceneFunc);
        },
        _sceneFunc: function(context) {
            var width = this.getWidth(),
                height = this.getHeight(),
                pointerDirection = this.getPointerDirection(),
                pointerWidth = this.getPointerWidth(),
                pointerHeight = this.getPointerHeight(),
                cornerRadius = Math.min(this.getCornerRadius(), width / 2, height / 2);

            context.beginPath();
            if (!cornerRadius) {
                context.moveTo(0, 0);
            } else {
                context.moveTo(cornerRadius, 0);
            }

            if (pointerDirection === UP) {
                context.lineTo((width - pointerWidth) / 2, 0);
                context.lineTo(width / 2, -1 * pointerHeight);
                context.lineTo((width + pointerWidth) / 2, 0);
            }

            if(!cornerRadius) {
                context.lineTo(width, 0);
            } else {
                context.lineTo(width - cornerRadius, 0);
                context.arc(width - cornerRadius, cornerRadius, cornerRadius, Math.PI * 3 / 2, 0, false);
            }

            if (pointerDirection === RIGHT) {
                context.lineTo(width, (height - pointerHeight) / 2);
                context.lineTo(width + pointerWidth, height / 2);
                context.lineTo(width, (height + pointerHeight) / 2);
            }

            if(!cornerRadius) {
                context.lineTo(width, height);
            } else {
                context.lineTo(width, height - cornerRadius);
                context.arc(width - cornerRadius, height - cornerRadius, cornerRadius, 0, Math.PI / 2, false);
            }

            if (pointerDirection === DOWN) {
                context.lineTo((width + pointerWidth) / 2, height);
                context.lineTo(width / 2, height + pointerHeight);
                context.lineTo((width - pointerWidth) / 2, height);
            }

            if(!cornerRadius) {
                context.lineTo(0, height);
            } else {
                context.lineTo(cornerRadius, height);
                context.arc(cornerRadius, height - cornerRadius, cornerRadius, Math.PI / 2, Math.PI, false);
            }

            if (pointerDirection === LEFT) {
                context.lineTo(0, (height + pointerHeight) / 2);
                context.lineTo(-1 * pointerWidth, height / 2);
                context.lineTo(0, (height - pointerHeight) / 2);
            }

            if(cornerRadius) {
                context.lineTo(0, cornerRadius);
                context.arc(cornerRadius, cornerRadius, cornerRadius, Math.PI, Math.PI * 3 / 2, false);
            }

            context.closePath();
            context.fillStrokeShape(this);
        },
        getSelfRect: function() {
            var x = 0,
                y = 0,
                pointerWidth = this.getPointerWidth(),
                pointerHeight = this.getPointerHeight(),
                direction = this.pointerDirection(),
                width = this.getWidth(),
                height = this.getHeight();

            if (direction === UP) {
                y -= pointerHeight;
                height += pointerHeight;
            } else if (direction === DOWN) {
                height += pointerHeight;
            } else if (direction === LEFT) {
                // ARGH!!! I have no idea why should I used magic 1.5!!!!!!!!!
                x -= pointerWidth * 1.5;
                width += pointerWidth;
            } else if (direction === RIGHT) {
                width += pointerWidth * 1.5;
            }
            return {
                x: x,
                y: y,
                width: width,
                height: height
            };
        }
    };

    Konva.Util.extend(Konva.Tag, Konva.Shape);
    Konva.Factory.addGetterSetter(Konva.Tag, 'pointerDirection', NONE);

    /**
     * set pointer Direction
     * @name setPointerDirection
     * @method
     * @memberof Konva.Tag.prototype
     * @param {String} pointerDirection can be up, right, down, left, or none.  The
     *  default is none
     */

     /**
     * get pointer Direction
     * @name getPointerDirection
     * @method
     * @memberof Konva.Tag.prototype
     */

    Konva.Factory.addGetterSetter(Konva.Tag, 'pointerWidth', 0);

    /**
     * set pointer width
     * @name setPointerWidth
     * @method
     * @memberof Konva.Tag.prototype
     * @param {Number} pointerWidth
     */

     /**
     * get pointer width
     * @name getPointerWidth
     * @method
     * @memberof Konva.Tag.prototype
     */

    Konva.Factory.addGetterSetter(Konva.Tag, 'pointerHeight', 0);

    /**
     * set pointer height
     * @name setPointerHeight
     * @method
     * @memberof Konva.Tag.prototype
     * @param {Number} pointerHeight
     */

     /**
     * get pointer height
     * @name getPointerHeight
     * @method
     * @memberof Konva.Tag.prototype
     */

    Konva.Factory.addGetterSetter(Konva.Tag, 'cornerRadius', 0);

    /**
     * set corner radius
     * @name setCornerRadius
     * @method
     * @memberof Konva.Tag.prototype
     * @param {Number} corner radius
     */

    /**
     * get corner radius
     * @name getCornerRadius
     * @method
     * @memberof Konva.Tag.prototype
     */

    Konva.Collection.mapMethods(Konva.Tag);
})();

(function() {
    'use strict';
    /**
     * Arrow constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Array} config.points
     * @param {Number} [config.tension] Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
     *   The default is 0
     * @param {Number} config.pointerLength
     * @param {Number} config.pointerWidth
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var line = new Konva.Line({
     *   points: [73, 70, 340, 23, 450, 60, 500, 20],
     *   stroke: 'red',
     *   tension: 1,
     *   pointerLength : 10,
     *   pointerWidth : 12
     * });
     */
    Konva.Arrow = function(config) {
        this.____init(config);
    };

    Konva.Arrow.prototype = {
        ____init: function(config) {
            // call super constructor
            Konva.Line.call(this, config);
            this.className = 'Arrow';
        },
        _sceneFunc: function(ctx) {
            Konva.Line.prototype._sceneFunc.apply(this, arguments);
            var PI2 = Math.PI * 2;
            var points = this.points();
            var n = points.length;
            var dx = points[n - 2] - points[n - 4];
            var dy = points[n - 1] - points[n - 3];
            var radians = (Math.atan2(dy, dx) + PI2) % PI2;
            var length = this.pointerLength();
            var width = this.pointerWidth();

            ctx.save();
            ctx.beginPath();
            ctx.translate(points[n - 2], points[n - 1]);
            ctx.rotate(radians);
            ctx.moveTo(0, 0);
            ctx.lineTo(-length, width / 2);
            ctx.lineTo(-length, -width / 2);
            ctx.closePath();
            ctx.restore();

            if (this.pointerAtBeginning()) {
                ctx.save();
                ctx.translate(points[0], points[1]);
                dx = points[2] - points[0];
                dy = points[3] - points[1];
                ctx.rotate((Math.atan2(-dy, -dx) + PI2) % PI2);
                ctx.moveTo(0, 0);
                ctx.lineTo(-length, width / 2);
                ctx.lineTo(-length, -width / 2);
                ctx.closePath();
                ctx.restore();
            }
            ctx.fillStrokeShape(this);
        }
    };

    Konva.Util.extend(Konva.Arrow, Konva.Line);
    /**
     * get/set pointerLength
     * @name pointerLength
     * @method
     * @memberof Konva.Arrow.prototype
     * @param {Number} Length of pointer of arrow.
     *   The default is 10.
     * @returns {Number}
     * @example
     * // get tension
     * var pointerLength = line.pointerLength();
     *
     * // set tension
     * line.pointerLength(15);
     */

    Konva.Factory.addGetterSetter(Konva.Arrow, 'pointerLength', 10);
    /**
     * get/set pointerWidth
     * @name pointerWidth
     * @method
     * @memberof Konva.Arrow.prototype
     * @param {Number} Width of pointer of arrow.
     *   The default is 10.
     * @returns {Number}
     * @example
     * // get tension
     * var pointerWidth = line.pointerWidth();
     *
     * // set tension
     * line.pointerWidth(15);
     */

    Konva.Factory.addGetterSetter(Konva.Arrow, 'pointerWidth', 10);
    /**
     * get/set pointerAtBeginning
     * @name pointerAtBeginning
     * @method
     * @memberof Konva.Arrow.prototype
     * @param {Number} Should pointer displayed at beginning of arrow.
     *   The default is false.
     * @returns {Boolean}
     * @example
     * // get tension
     * var pointerAtBeginning = line.pointerAtBeginning();
     *
     * // set tension
     * line.pointerAtBeginning(true);
     */

    Konva.Factory.addGetterSetter(Konva.Arrow, 'pointerAtBeginning', false);
    Konva.Collection.mapMethods(Konva.Arrow);

})();


},{"canvas":173,"jsdom":173}],173:[function(require,module,exports){
arguments[4][162][0].apply(exports,arguments)
},{"dup":162}],174:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],175:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}]},{},[67])(67)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2F4aXMvc3JjL2F4aXMvYXhpcy1sYXllci5qcyIsImRpc3QvYXhpcy9zcmMvYXhpcy9ncmlkLWF4aXMtZ2VuZXJhdG9yLmpzIiwiZGlzdC9heGlzL3NyYy9heGlzL3RpbWUtYXhpcy1nZW5lcmF0b3IuanMiLCJkaXN0L2JlaGF2aW9ycy9zcmMvYmVoYXZpb3JzL2Jhc2UtYmVoYXZpb3IuanMiLCJkaXN0L2JlaGF2aW9ycy9zcmMvYmVoYXZpb3JzL2JlYXQtZ3JpZC1zbmFwLXNlZ21lbnQtYmVoYXZpb3IuanMiLCJkaXN0L2JlaGF2aW9ycy9zcmMvYmVoYXZpb3JzL2JyZWFrcG9pbnQtYmVoYXZpb3IuanMiLCJkaXN0L2JlaGF2aW9ycy9zcmMvYmVoYXZpb3JzL21hcmtlci1iZWhhdmlvci5qcyIsImRpc3QvYmVoYXZpb3JzL3NyYy9iZWhhdmlvcnMvbm8tYmVoYXZpb3IuanMiLCJkaXN0L2JlaGF2aW9ycy9zcmMvYmVoYXZpb3JzL3Njcm9sbC1zZWdtZW50LWJlaGF2aW9yLmpzIiwiZGlzdC9iZWhhdmlvcnMvc3JjL2JlaGF2aW9ycy9zZWdtZW50LWJlaGF2aW9yLmpzIiwiZGlzdC9iZWhhdmlvcnMvc3JjL2JlaGF2aW9ycy9zaWJsaW5nLWxvY2tlZC1zZWdtZW50LWJlaGF2aW9yLmpzIiwiZGlzdC9iZWhhdmlvcnMvc3JjL2JlaGF2aW9ycy9zaW1wbGUtc25hcC1zZWdtZW50LWJlaGF2aW9yLmpzIiwiZGlzdC9iZWhhdmlvcnMvc3JjL2JlaGF2aW9ycy90aW1lLWNvbnRleHQtYmVoYXZpb3IuanMiLCJkaXN0L2JlaGF2aW9ycy9zcmMvYmVoYXZpb3JzL3RyYWNlLWJlaGF2aW9yLmpzIiwiZGlzdC9iZWhhdmlvcnMvc3JjL2JlaGF2aW9ycy93YXZlZm9ybS1iZWhhdmlvci5qcyIsImRpc3QvY29yZS9zcmMvY29yZS9sYXllci10aW1lLWNvbnRleHQuanMiLCJkaXN0L2NvcmUvc3JjL2NvcmUvbGF5ZXIuanMiLCJkaXN0L2NvcmUvc3JjL2NvcmUvdGltZWxpbmUtdGltZS1jb250ZXh0LmpzIiwiZGlzdC9jb3JlL3NyYy9jb3JlL3RpbWVsaW5lLmpzIiwiZGlzdC9jb3JlL3NyYy9jb3JlL3RyYWNrLWNvbGxlY3Rpb24uanMiLCJkaXN0L2NvcmUvc3JjL2NvcmUvdHJhY2suanMiLCJkaXN0L2hlbHBlcnMvc3JjL2hlbHBlcnMvYW5ub3RhdGVkLW1hcmtlci1sYXllci5qcyIsImRpc3QvaGVscGVycy9zcmMvaGVscGVycy9hbm5vdGF0ZWQtc2VnbWVudC1sYXllci5qcyIsImRpc3QvaGVscGVycy9zcmMvaGVscGVycy9iZWF0LWdyaWQtbGF5ZXIuanMiLCJkaXN0L2hlbHBlcnMvc3JjL2hlbHBlcnMvYnJlYWtwb2ludC1sYXllci5qcyIsImRpc3QvaGVscGVycy9zcmMvaGVscGVycy9jdXJzb3ItbGF5ZXIuanMiLCJkaXN0L2hlbHBlcnMvc3JjL2hlbHBlcnMvZ3JpZC1heGlzLWxheWVyLmpzIiwiZGlzdC9oZWxwZXJzL3NyYy9oZWxwZXJzL21hcmtlci1sYXllci5qcyIsImRpc3QvaGVscGVycy9zcmMvaGVscGVycy9zY3JvbGxlci5qcyIsImRpc3QvaGVscGVycy9zcmMvaGVscGVycy9zZWdtZW50LWxheWVyLmpzIiwiZGlzdC9oZWxwZXJzL3NyYy9oZWxwZXJzL3RpY2stbGF5ZXIuanMiLCJkaXN0L2hlbHBlcnMvc3JjL2hlbHBlcnMvdGltZS1heGlzLWxheWVyLmpzIiwiZGlzdC9oZWxwZXJzL3NyYy9oZWxwZXJzL3RyYWNlLWxheWVyLmpzIiwiZGlzdC9oZWxwZXJzL3NyYy9oZWxwZXJzL3dhdmVmb3JtLWxheWVyLmpzIiwiZGlzdC9pbnRlcmFjdGlvbnMvc3JjL2ludGVyYWN0aW9ucy9ldmVudC1zb3VyY2UuanMiLCJkaXN0L2ludGVyYWN0aW9ucy9zcmMvaW50ZXJhY3Rpb25zL2tleWJvYXJkLmpzIiwiZGlzdC9pbnRlcmFjdGlvbnMvc3JjL2ludGVyYWN0aW9ucy9rb252YS1zdXJmYWNlLmpzIiwiZGlzdC9pbnRlcmFjdGlvbnMvc3JjL2ludGVyYWN0aW9ucy9rb252YS13YXZlLWV2ZW50LmpzIiwiZGlzdC9pbnRlcmFjdGlvbnMvc3JjL2ludGVyYWN0aW9ucy93YXZlLWV2ZW50LmpzIiwiZGlzdC9zaGFwZXMvc3JjL3NoYXBlcy9hbm5vdGF0ZWQtbWFya2VyLmpzIiwiZGlzdC9zaGFwZXMvc3JjL3NoYXBlcy9hbm5vdGF0ZWQtc2VnbWVudC5qcyIsImRpc3Qvc2hhcGVzL3NyYy9zaGFwZXMvYmFzZS1zaGFwZS5qcyIsImRpc3Qvc2hhcGVzL3NyYy9zaGFwZXMvY3Vyc29yLmpzIiwiZGlzdC9zaGFwZXMvc3JjL3NoYXBlcy9kb3QuanMiLCJkaXN0L3NoYXBlcy9zcmMvc2hhcGVzL2xpbmUuanMiLCJkaXN0L3NoYXBlcy9zcmMvc2hhcGVzL21hcmtlci5qcyIsImRpc3Qvc2hhcGVzL3NyYy9zaGFwZXMvc2VnbWVudC5qcyIsImRpc3Qvc2hhcGVzL3NyYy9zaGFwZXMvdGlja3MuanMiLCJkaXN0L3NoYXBlcy9zcmMvc2hhcGVzL3RyYWNlLWRvdHMuanMiLCJkaXN0L3NoYXBlcy9zcmMvc2hhcGVzL3RyYWNlLXBhdGguanMiLCJkaXN0L3NoYXBlcy9zcmMvc2hhcGVzL3dhdmVmb3JtLmpzIiwiZGlzdC9zdGF0ZXMvc3JjL3N0YXRlcy9iYXNlLXN0YXRlLmpzIiwiZGlzdC9zdGF0ZXMvc3JjL3N0YXRlcy9icmVha3BvaW50LXN0YXRlLmpzIiwiZGlzdC9zdGF0ZXMvc3JjL3N0YXRlcy9icnVzaC16b29tLXN0YXRlLmpzIiwiZGlzdC9zdGF0ZXMvc3JjL3N0YXRlcy9jZW50ZXJlZC1zY3JvbGwtc3RhdGUuanMiLCJkaXN0L3N0YXRlcy9zcmMvc3RhdGVzL2NlbnRlcmVkLXpvb20tc3RhdGUuanMiLCJkaXN0L3N0YXRlcy9zcmMvc3RhdGVzL2NvbnRleHQtZWRpdGlvbi1zdGF0ZS5qcyIsImRpc3Qvc3RhdGVzL3NyYy9zdGF0ZXMvZHJvcC1hbmQtYWRkLXN0YXRlLmpzIiwiZGlzdC9zdGF0ZXMvc3JjL3N0YXRlcy9lZGl0aW9uLXN0YXRlLmpzIiwiZGlzdC9zdGF0ZXMvc3JjL3N0YXRlcy9ob3Jpem9udGFsLXNlbGVjdGlvbi1zdGF0ZS5qcyIsImRpc3Qvc3RhdGVzL3NyYy9zdGF0ZXMvc2VsZWN0aW9uLXN0YXRlLmpzIiwiZGlzdC9zdGF0ZXMvc3JjL3N0YXRlcy9zaGFwZS1pbnNlcnRpb24tc3RhdGUuanMiLCJkaXN0L3N0YXRlcy9zcmMvc3RhdGVzL3NpbXBsZS1lZGl0aW9uLXN0YXRlLmpzIiwiZGlzdC91dGlscy9zcmMvdXRpbHMvZm9ybWF0LmpzIiwiZGlzdC91dGlscy9zcmMvdXRpbHMvb3J0aG9nb25hbC1kYXRhLmpzIiwiZGlzdC91dGlscy9zcmMvdXRpbHMvc2NhbGVzLmpzIiwiZGlzdC9zcmMvd2F2ZXMtdWkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvbWFwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2UuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3NldC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzLWNhbGwtY2hlY2suanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZS1jbGFzcy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZ2V0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvaW50ZXJvcC1yZXF1aXJlLWRlZmF1bHQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vbWFwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2UuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3NldC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5hLWZ1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuYW4tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY2xhc3NvZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmNvZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmNvbGxlY3Rpb24tc3Ryb25nLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY29sbGVjdGlvbi10by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmNvcmUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jdHguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5kZWYuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZG9tLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmVudW0ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmZhaWxzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZm9yLW9mLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZ2V0LW5hbWVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaGFzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaGlkZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmh0bWwuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pbnZva2UuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXMtYXJyYXktaXRlci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmlzLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlci1jYWxsLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlci1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pdGVyLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLml0ZXItZGV0ZWN0LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlci1zdGVwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlcmF0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5rZXlvZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmxpYnJhcnkuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5taWNyb3Rhc2suanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5taXguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5vYmplY3Qtc2FwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQucHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnJlZGVmLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc2FtZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnNldC1wcm90by5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnNoYXJlZC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc3RyaWN0LW5ldy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnN0cmluZy1hdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnN1cHBvcnQtZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnRhZy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnRhc2suanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC50by1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQudG8taW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnRvLWxlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnRvLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnVpZC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnVuc2NvcGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC53a3MuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubWFwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnByb21pc2UuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnNldC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9ydW50aW1lLmpzIiwibm9kZV9tb2R1bGVzL2tvbnZhL2tvbnZhLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUEsWUFBWSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7eUJBQ0ssZUFBZTs7Ozs2QkFDYixtQkFBbUI7Ozs7cUNBQ2QsNEJBQTRCOzs7Ozs7Ozs7Ozs7Ozs7O0lBY2hDLFNBQVM7WUFBVCxTQUFTOzs7Ozs7OztBQU1qQixXQU5RLFNBQVMsQ0FNaEIsU0FBUyxFQUFFLE9BQU8sRUFBRTs7OzBCQU5iLFNBQVM7O0FBTzFCLCtCQVBpQixTQUFTLDZDQU9wQixRQUFRLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRTtBQUM3QixRQUFJLENBQUMsVUFBVSxHQUFHLFNBQVMsQ0FBQzs7QUFFNUIsUUFBSSxDQUFDLGFBQWEsR0FBRywrQkFBWSxFQUFFLENBQUMsQ0FBQztBQUNyQyxRQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQztBQUN6QixhQUFPLEVBQUc7ZUFBTSxDQUFDO09BQUE7QUFDakIsV0FBSyxFQUFHO2VBQU0sTUFBSyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUs7T0FBQTtBQUN2QyxXQUFLLEVBQUc7ZUFBTSxNQUFLLFdBQVcsQ0FBQyxlQUFlO09BQUE7QUFDOUMsWUFBTSxFQUFJO2VBQU0sTUFB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QTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTs7QUNGQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBOztBQ0FBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBOztBQ0ZBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqT0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2puQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3eWZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBMYXllciBmcm9tICcuLi9jb3JlL2xheWVyJztcbmltcG9ydCBTZWdtZW50IGZyb20gJy4uL3NoYXBlcy9zZWdtZW50JztcbmltcG9ydCBCYXNlQmVoYXZpb3IgZnJvbSAnLi4vYmVoYXZpb3JzL2Jhc2UtYmVoYXZpb3InO1xuXG5cbi8qKlxuICogU2ltcGxpZmllZCBMYXllciBmb3IgQXhpcy4gVGhlIG1haW4gZGlmZmVyZW5jZSB3aXRoIGEgcmVndWxhciBsYXllciBpcyB0aGF0XG4gKiBhbiBheGlzIGxheWVyIHVzZSB0aGUgYFRpbWVsaW5lfnRpbWVDb250ZXh0YCBhdHRyaWJ1dGVzIHRvIHJlbmRlciBpdCdzIGxheW91dFxuICogYW5kIHN0YXkgc3luY2hyb25pemVkIHdpdGggdGhlIHRyYWNrcyB2aXNpYmxlIGFyZWEuIEFsbCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gKiB0byB0aGUgYFRpbWVsaW5lVGltZUNvbnRleHRgIGF0dHJpYnV0ZXMgYXJlIGJ5cGFzc2VkLlxuICpcbiAqIEl0IGFsc28gaGFuZGxlIGl0J3Mgb3duIGRhdGEgYW5kIGl0cyB1cGRhdGVzLiBUaGUgYF9nZW5lcmF0ZURhdGFgIG1ldGhvZCBpc1xuICogcmVzcG9uc2libGUgdG8gY3JlYXRlIHNvbWUgdXNlZnVsbCBkYXRhIHRvIHZpc3VhbGl6ZVxuICpcbiAqIFtleGFtcGxlIHVzYWdlIG9mIHRoZSBsYXllci1heGlzXSguL2V4YW1wbGVzL2xheWVyLWF4aXMuaHRtbClcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXhpc0xheWVyIGV4dGVuZHMgTGF5ZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZ2VuZXJhdG9yIC0gQSBmdW5jdGlvbiB0byBjcmVhdGUgZGF0YSBhY2NvcmRpbmcgdG9cbiAgICogICAgdGhlIGBUaW1lbGluZX50aW1lQ29udGV4dGAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gTGF5ZXIgb3B0aW9ucywgY2YuIExheWVyIGZvciBhdmFpbGFibGUgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgIHN1cGVyKCdlbnRpdHknLCBbXSwgb3B0aW9ucyk7XG4gICAgdGhpcy5fZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuXG4gICAgdGhpcy5fY29udGV4dFNoYXBlID0gbmV3IFNlZ21lbnQoe30pO1xuICAgIHRoaXMuX2NvbnRleHRTaGFwZS5pbnN0YWxsKHtcbiAgICAgIG9wYWNpdHkgOiAoKSA9PiAxLCBcbiAgICAgIGNvbG9yIDogKCkgPT4gdGhpcy5wYXJhbXMuY29udGV4dC5jb2xvciwgXG4gICAgICB3aWR0aCA6ICgpID0+IHRoaXMudGltZUNvbnRleHQudmlzaWJsZUR1cmF0aW9uLFxuICAgICAgaGVpZ2h0ICA6ICgpID0+IHRoaXMuX3JlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsLmRvbWFpbigpWzFdLFxuICAgICAgeSAgIDogKCkgPT4gdGhpcy5fcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwuZG9tYWluKClbMF0sXG4gICAgICB4ICAgOiAoKSA9PiAtdGhpcy50aW1lQ29udGV4dC5vZmZzZXRcbiAgICB9KTsgXG4gICAgdGhpcy5fY29udGV4dFNoYXBlLnBhcmFtcy5oYW5kbGVyV2lkdGggPSB0aGlzLnBhcmFtcy5jb250ZXh0LmhhbmRsZXJXaWR0aDtcbiAgICB0aGlzLl9jb250ZXh0U2hhcGUucmVuZGVyKHRoaXMuX3JlbmRlcmluZ0NvbnRleHQpO1xuICAgIHRoaXMuX2NvbnRleHRTaGFwZS5sYXllciA9IHRoaXM7XG4gICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuX2NvbnRleHRTaGFwZS4kZWwubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2NvbnRleHRMYXllci5hZGQodGhpcy5fY29udGV4dFNoYXBlLiRlbFtpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRCZWhhdmlvcihuZXcgQmFzZUJlaGF2aW9yKCkpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHNldCBzdHJldGNoUmF0aW8odmFsdWUpIHsgcmV0dXJuOyB9XG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBzZXQgb2Zmc2V0KHZhbHVlKSB7IHJldHVybjsgfVxuICAvKiogQHByaXZhdGUgKi9cbiAgc2V0IHN0YXJ0KHZhbHVlKSB7IHJldHVybjsgfVxuICAvKiogQHByaXZhdGUgKi9cbiAgc2V0IGR1cmF0aW9uKHZhbHVlKSB7IHJldHVybjsgfVxuICAvKiogQHByaXZhdGUgKi9cbiAgZ2V0IHN0cmV0Y2hSYXRpbygpIHsgcmV0dXJuOyB9XG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBnZXQgb2Zmc2V0KCkgeyByZXR1cm47IH1cbiAgLyoqIEBwcml2YXRlICovXG4gIGdldCBzdGFydCgpIHsgcmV0dXJuOyB9XG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBnZXQgZHVyYXRpb24oKSB7IHJldHVybjsgfVxuXG5cbiAgLyoqXG4gICAqIFRoZSBnZW5lcmF0b3IgdGhhdCBjcmVhdGVzIHRoZSBkYXRhIHRvIGJlIHJlbmRlcmVkIHRvIGRpc3BsYXkgdGhlIGF4aXMuXG4gICAqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIHNldCBnZW5lcmF0b3IoZnVuYykge1xuICAgIHRoaXMuX2dlbmVyYXRvciA9IGZ1bmM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGdlbmVyYXRvciB0aGF0IGNyZWF0ZXMgdGhlIGRhdGEgdG8gYmUgcmVuZGVyZWQgdG8gZGlzcGxheSB0aGUgYXhpcy5cbiAgICpcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgZ2V0IGdlbmVyYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2VuZXJhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHRoZSBtYWluIGRpZmZlcmVuY2Ugd2l0aCBhIGNsYXNzaWNhbCBsYXllci4gQW4gYEF4aXNMYXllcmBcbiAgICogaW5zdGFuY2UgZ2VuZXJhdGVzIGFuZCBtYWludGFpbnMgaXQncyBvd24gZGF0YS5cbiAgICovXG4gIF9nZW5lcmF0ZURhdGEoKSB7XG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XG4gICAgdGhpcy5jb250ZW50TGF5ZXJzLmZvckVhY2goKGwpID0+IHsgLy8gSGFja2VkIHRoaXMgdG8gbWFrZSBpdCB3b3JrLlxuICAgICAgbC5kZXN0cm95KCk7XG4gICAgICB0aGF0LmNvbnRlbnRMYXllcnMuZGVsZXRlKGwpO1xuICAgIH0pO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9nZW5lcmF0b3IodGhpcy50aW1lQ29udGV4dCk7XG4gICAgLy8gdGhpcy5yZW1vdmUodGhpcy5kYXRhKTtcbiAgICB0aGlzLnNldChbZGF0YV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgZGF0YSBhbmQgdXBkYXRlIHRoZSBsYXllci5cbiAgICovXG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZURhdGEoKTtcbiAgICBzdXBlci51cGRhdGUoKTtcbiAgfVxuXG4gIHVwZGF0ZUNvbnRhaW5lcigpIHtcbiAgICB0aGlzLl91cGRhdGVSZW5kZXJpbmdDb250ZXh0KCk7XG4gIH1cblxuICB1cGRhdGVTaGFwZXMoKSB7XG4gICAgY29uc3QgY2hhbmdlZENvbnRlbnRMYXllcnMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XG5cbiAgICB0aGlzLmFsbG9jYXRlU2hhcGVzVG9Db250ZW50TGF5ZXJzKHRoaXMuX3N0YWdlLCB0aGlzLmRhdGEsICdkYXR1bXMnLCB0cnVlKS5mb3JFYWNoKChjaGFuZ2VkQ29udGVudExheWVyKSA9PiB7XG4gICAgICBjaGFuZ2VkQ29udGVudExheWVycy5hZGQoY2hhbmdlZENvbnRlbnRMYXllcik7XG4gICAgfSk7XG5cbiAgICBjaGFuZ2VkQ29udGVudExheWVycy5mb3JFYWNoKChjaGFuZ2VkQ29udGVudExheWVyKSA9PiB7XG4gICAgICBjaGFuZ2VkQ29udGVudExheWVyXG4gICAgICAgIC55KHRoYXQucGFyYW1zLnRvcClcbiAgICAgICAgLm9mZnNldFgoMCk7XG4gICAgICBjaGFuZ2VkQ29udGVudExheWVyLmNsZWFyKCk7XG4gICAgICBjaGFuZ2VkQ29udGVudExheWVyLmJhdGNoRHJhdygpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fY29udGV4dFNoYXBlLnVwZGF0ZSh0aGlzLl9yZW5kZXJpbmdDb250ZXh0LCB0aGlzLnRpbWVDb250ZXh0KTtcblxuICAgIHRoaXMuX2NvbnRleHRMYXllclxuICAgICAgICAueSh0aGF0LnBhcmFtcy50b3ApXG4gICAgICAgIC5iYXRjaERyYXcoKVxuICAgICAgICAubW92ZVRvQm90dG9tKCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcmVuZGVyaW5nIGNvbnRleHQgZm9yIHRoZSBzaGFwZXMuXG4gICAqL1xuICBfdXBkYXRlUmVuZGVyaW5nQ29udGV4dCgpIHtcbiAgICB0aGlzLl9yZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsID0gdGhpcy50aW1lQ29udGV4dC50aW1lVG9QaXhlbDtcbiAgICB0aGlzLl9yZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbCA9IHRoaXMuX3ZhbHVlVG9QaXhlbDtcblxuICAgIHRoaXMuX3JlbmRlcmluZ0NvbnRleHQuaGVpZ2h0ID0gdGhpcy5wYXJhbXMuaGVpZ2h0O1xuICAgIHRoaXMuX3JlbmRlcmluZ0NvbnRleHQud2lkdGggID0gdGhpcy50aW1lQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLnRpbWVDb250ZXh0LnZpc2libGVEdXJhdGlvbik7XG5cbiAgICAvLyBmb3IgZm9yZWlnbiBvYmplY3QgaXNzdWUgaW4gY2hyb21lXG4gICAgdGhpcy5fcmVuZGVyaW5nQ29udGV4dC5vZmZzZXRYID0gdGhpcy50aW1lQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLnRpbWVDb250ZXh0Lm9mZnNldCk7XG5cbiAgICAvLyBleHBvc2Ugc29tZSB0aW1lbGluZSBhdHRyaWJ1dGVzIC0gYWxsb3cgdG8gaW1wcm92ZSBwZXJmIGluIHNvbWUgY2FzZXMgLSBjZi4gV2F2ZWZvcm1cbiAgICB0aGlzLl9yZW5kZXJpbmdDb250ZXh0LnRyYWNrT2Zmc2V0WCA9IHRoaXMudGltZUNvbnRleHQudGltZVRvUGl4ZWwodGhpcy50aW1lQ29udGV4dC5vZmZzZXQpO1xuICAgIHRoaXMuX3JlbmRlcmluZ0NvbnRleHQudmlzaWJsZVdpZHRoID0gdGhpcy50aW1lQ29udGV4dC52aXNpYmxlV2lkdGg7XG4gIH1cblxuICB2aXNpYmxlX2RhdGEodGltZUNvbnRleHQsIGRhdGEpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgc29ydF9kYXRhKGRhdGEpIHsgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aXNMYXllcjsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBnZW5lcmF0b3IgdG8gY3JlYXRlIGRhdGEgZm9yIGdyaWQgYXhpcyBhY2NvcmRpbmcgdG8gYSBgYnBtYCBhbmQgYSBgbWV0ZXJgLlxuICpcbiAqIFtleGFtcGxlIHVzYWdlXSguL2V4YW1wbGVzL2xheWVyLWF4aXMuaHRtbClcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYnBtIC0gVGhlIG51bWJlciBvZiBiZWF0cyBwZXIgbWludXRlcy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWduYXR1cmUgLSBUaGUgbWV0ZXIgb2YgdGhlIG1lc3VyZSAoYCc0LzQnYCwgYCczLzgnYCwgLi4uKS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSAtIFRoZSBjb25maWd1cmVkIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgZGF0YSB3aGVuIGNhbGxlZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ3JpZEF4aXNHZW5lcmF0b3IoYnBtLCBzaWduYXR1cmUpIHtcbiAgY29uc3QgX2JwcyA9ICBicG0gLyA2MDsgLy8gc2VjXG4gIGNvbnN0IF91bml0ID0gMSAvIHBhcnNlSW50KHNpZ25hdHVyZS5zcGxpdCgnLycpWzFdLCAxMCk7XG4gIGNvbnN0IF9uYnJVbml0c1Blck1lc3VyZSA9IHBhcnNlSW50KHNpZ25hdHVyZS5zcGxpdCgnLycpWzBdLCAxMCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHRpbWVDb250ZXh0KSB7XG4gICAgY29uc3QgZHVyYXRpb24gPSB0aW1lQ29udGV4dC52aXNpYmxlRHVyYXRpb247XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGltZUNvbnRleHQub2Zmc2V0O1xuICAgIGNvbnN0IGRhdGEgPSBbXTtcblxuICAgIC8vIGNvbnN0IG1pbiA9IE1hdGgubWluKC1vZmZzZXQsIDApO1xuICAgIGNvbnN0IG1pbiA9IC0gb2Zmc2V0O1xuICAgIC8vIHJlbW92ZSB0aGUgdGltZWxpbmUncyBvZmZzZXQgdG8ga2VlcCB0aGUgbGF5ZXIgY2VudGVyZWRcbiAgICBjb25zdCBtYXggPSBkdXJhdGlvbiAtIG9mZnNldDtcblxuICAgIC8vIGRlZmluZSBwaXhlbHMgZm9yIDEgc2Vjb25kXG4gICAgY29uc3QgcGl4ZWxzUGVyU2Vjb25kID0gdGltZUNvbnRleHQuY29tcHV0ZWRQaXhlbHNQZXJTZWNvbmQ7XG4gICAgLy8gdGltZSBmb3Igb25lIF91bml0XG4gICAgY29uc3QgdW5pdFRpbWUgPSAxIC8gX2JwcztcbiAgICAvLyBkZWZpbmUgdGhlIGZpcnN0IHRpY2sgPiBtaW5cbiAgICBjb25zdCBtb2R1bG8gPSBtaW4gJSB1bml0VGltZTtcbiAgICBjb25zdCBtdWx0ID0gKG1pbiAtIG1vZHVsbykgLyB1bml0VGltZTtcbiAgICBjb25zdCBmaXJzdFRpY2tUaW1lID0gdW5pdFRpbWUgKiBtdWx0O1xuICAgIC8vIHRyYWNrIHdoaWNoIHBvc2l0aW9uIG9mIGN1cnJlbnQgYmVhdCBpbiB0aGUgbWVzdXJlXG4gICAgbGV0IHBvc2l0aW9uSW5NZXN1cmUgPSBtdWx0ICUgX25iclVuaXRzUGVyTWVzdXJlO1xuXG4gICAgLy8gcmVtb3ZlIG5vdCBmb2N1c2VkIGJlYXRzLCBpZiB6b29tZWQgb3V0XG4gICAgY29uc3QgcGl4ZWxzUGVyVGljayA9IHBpeGVsc1BlclNlY29uZCAvIF9icHM7XG4gICAgY29uc3QgbWluU3RlcCA9IDU7XG5cbiAgICAvLyB0aW1lIHNob3VsZCBiZVxuICAgIGZvciAobGV0IHRpbWUgPSBmaXJzdFRpY2tUaW1lOyB0aW1lIDwgbWF4OyB0aW1lICs9IHVuaXRUaW1lKSB7XG4gICAgICAvLyBmaW5kIGZpcnN0IGJlYXRcbiAgICAgIGNvbnN0IGZvY3VzZWQgPSAocG9zaXRpb25Jbk1lc3VyZSsrICUgX25iclVuaXRzUGVyTWVzdXJlID09PSAwKTtcbiAgICAgIC8vIGlnbm9yZSBpZiBwaXhlbHMgcGVyIHRpY2tzIGlzIHRvbyBzbWFsbFxuICAgICAgaWYgKChwaXhlbHNQZXJUaWNrIDw9IG1pblN0ZXApICYmICFmb2N1c2VkKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgIGRhdGEucHVzaCh7IHRpbWUsIGZvY3VzZWQgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ3JpZEF4aXNHZW5lcmF0b3I7IiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgcGFkTGVmdCB9IGZyb20gJy4uL3V0aWxzL2Zvcm1hdCc7XG5cbi8qKlxuICogQSBnZW5lcmF0b3IgdG8gY3JlYXRlIGRhdGEgZm9yIHRpbWUgYXhpcy5cbiAqXG4gKiBbZXhhbXBsZSB1c2FnZV0oLi9leGFtcGxlcy9sYXllci1heGlzLmh0bWwpXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259IC0gVGhlIGNvbmZpZ3VyZWQgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBkYXRhIHdoZW4gY2FsbGVkLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0aW1lQXhpc0dlbmVyYXRvcigpIHtcbiAgLy8gYWRkIGZhY3RvcnkgdG8gc2hhcmUgQVBJIHdpdGggYnBtR2VuZXJhdG9yXG4gIHJldHVybiBmdW5jdGlvbih0aW1lQ29udGV4dCkge1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdGltZUNvbnRleHQudmlzaWJsZUR1cmF0aW9uO1xuICAgIGNvbnN0IG9mZnNldCA9IHRpbWVDb250ZXh0Lm9mZnNldDtcbiAgICBjb25zdCBkYXRhID0gW107XG5cbiAgICAvLyBjb25zdCBtaW4gPSBNYXRoLm1pbigtb2Zmc2V0LCAwKTtcbiAgICBjb25zdCBtaW4gPSAtIG9mZnNldDtcbiAgICAvLyByZW1vdmUgdGhlIHRpbWVsaW5lJ3Mgb2Zmc2V0IHRvIGtlZXAgdGhlIGxheWVyIGNlbnRlcmVkXG4gICAgY29uc3QgbWF4ID0gZHVyYXRpb24gLSBvZmZzZXQ7XG5cbiAgICAvLyBkZWZpbmUgcGl4ZWxzIGZvciAxIHNlY29uZFxuICAgIGNvbnN0IHBpeGVsc1BlclNlY29uZCA9IHRpbWVDb250ZXh0LmNvbXB1dGVkUGl4ZWxzUGVyU2Vjb25kO1xuICAgIGNvbnN0IG1pblN0ZXAgPSA3O1xuXG4gICAgLy8gZGVmaW5lIGFsbCBkaXNwbGF5IGluZm9ybWF0aW9uIGFjY29yZGluZyB0byB0aGUgcGl4ZWxzUGVyU2Vjb25kIHJhdGlvXG4gICAgbGV0IHN0ZXAsIHR5cGUsIHRvRml4ZWQsIG1hcmtlck1vZHVsbywgaW5jbHVkZU1vZHVsbztcblxuICAgIGlmIChwaXhlbHNQZXJTZWNvbmQgKiA0ID4gbWluU3RlcCkge1xuICAgICAgc3RlcCA9IDE7IC8vIHRoZSBzdGVwIHRvIHVzZSB0byBjb21wdXRlIHRpbWVcbiAgICAgIHRvRml4ZWQgPSAwO1xuICAgICAgbWFya2VyTW9kdWxvID0gNjA7IC8vIGEgdGltZXN0YW1wIGV2ZXJ5IDUgc3RlcGl4ZWxzUGVyU2Vjb25kXG4gICAgICBpbmNsdWRlTW9kdWxvID0gNTsgLy8gYSB0aWNrIGV2ZXJ5IDUgc3RlcGl4ZWxzUGVyU2Vjb25kXG4gICAgICB0eXBlID0gJzYwc2VjJztcbiAgICB9XG5cbiAgICBpZiAocGl4ZWxzUGVyU2Vjb25kICogMiA+IG1pblN0ZXApIHtcbiAgICAgIHN0ZXAgPSAxO1xuICAgICAgdG9GaXhlZCA9IDA7XG4gICAgICBtYXJrZXJNb2R1bG8gPSAzMDtcbiAgICAgIGluY2x1ZGVNb2R1bG8gPSAxO1xuICAgICAgdHlwZSA9ICczMHNlYyc7XG4gICAgfVxuXG4gICAgaWYgKHBpeGVsc1BlclNlY29uZCA+IG1pblN0ZXApIHtcbiAgICAgIHN0ZXAgPSAxO1xuICAgICAgdG9GaXhlZCA9IDA7XG4gICAgICBtYXJrZXJNb2R1bG8gPSAxMDtcbiAgICAgIGluY2x1ZGVNb2R1bG8gPSAxO1xuICAgICAgdHlwZSA9ICdzZWMnO1xuICAgIH1cblxuICAgIGlmIChwaXhlbHNQZXJTZWNvbmQgLyAxMCA+IG1pblN0ZXApIHtcbiAgICAgIHN0ZXAgPSAxIC8gMTA7XG4gICAgICB0b0ZpeGVkID0gMTtcbiAgICAgIG1hcmtlck1vZHVsbyA9IDEwO1xuICAgICAgaW5jbHVkZU1vZHVsbyA9IDE7XG4gICAgICB0eXBlID0gJ2RzJztcbiAgICB9XG5cbiAgICBpZiAocGl4ZWxzUGVyU2Vjb25kIC8gMTAwID4gbWluU3RlcCkge1xuICAgICAgc3RlcCA9IDEgLyAxMDA7XG4gICAgICB0b0ZpeGVkID0gMjtcbiAgICAgIG1hcmtlck1vZHVsbyA9IDEwO1xuICAgICAgaW5jbHVkZU1vZHVsbyA9IDE7XG4gICAgICB0eXBlID0gJ2NzJztcbiAgICB9XG5cbiAgICBpZiAocGl4ZWxzUGVyU2Vjb25kIC8gMTAwMCA+IG1pblN0ZXApIHtcbiAgICAgIHN0ZXAgPSAxIC8gMTAwMDtcbiAgICAgIHRvRml4ZWQgPSAzO1xuICAgICAgbWFya2VyTW9kdWxvID0gMTA7XG4gICAgICBpbmNsdWRlTW9kdWxvID0gMTtcbiAgICAgIHR5cGUgPSAnbXMnO1xuICAgIH1cblxuICAgIGZvciAobGV0IHRpbWUgPSBtaW47IHRpbWUgPCBtYXg7IHRpbWUgKz0gc3RlcCkge1xuICAgICAgY29uc3QgZm9ybWF0dGVkVGltZSA9IHRpbWUudG9GaXhlZCh0b0ZpeGVkKTtcblxuICAgICAgaWYgKE1hdGgucm91bmQoZm9ybWF0dGVkVGltZSAvIHN0ZXApICUgaW5jbHVkZU1vZHVsbyAhPT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzXG4gICAgICBjb25zdCBmb2N1c2VkID0gTWF0aC5yb3VuZChmb3JtYXR0ZWRUaW1lIC8gc3RlcCkgJSBtYXJrZXJNb2R1bG8gPT09IDAgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgIGNvbnN0IGRhdHVtID0geyB0aW1lOiBmb3JtYXR0ZWRUaW1lLCBmb2N1c2VkIH07XG5cbiAgICAgIGlmIChmb2N1c2VkID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgxMDAwICogZm9ybWF0dGVkVGltZSk7XG4gICAgICAgIGNvbnN0IG1pbiA9IHBhZExlZnQoZGF0ZS5nZXRNaW51dGVzKCksIDAsIDIpO1xuICAgICAgICBjb25zdCBzZWMgPSBwYWRMZWZ0KGRhdGUuZ2V0U2Vjb25kcygpLCAwLCAyKTtcbiAgICAgICAgY29uc3QgbWlsbGkgPSBwYWRMZWZ0KGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCksIDAsIDMpO1xuICAgICAgICBjb25zdCBsYWJlbCA9IGAke21pbn06JHtzZWN9OiR7bWlsbGl9YDtcblxuICAgICAgICBkYXR1bS5sYWJlbCA9IGxhYmVsO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnB1c2goZGF0dW0pO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRpbWVBeGlzR2VuZXJhdG9yOyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBJcyBhbiBhYnN0cmFjdCBjbGFzcyBvciBpbnRlcmZhY2UgdG8gYmUgb3ZlcnJpZGVuIGluIG9yZGVyIHRvIGRlZmluZSB0aGUgd2F5XG4gKiBhIGdpdmVuIHNoYXBlIHNob3VsZCBiZWhhdmUgd2hlbiBzZWxlY3RlZCBvciBlZGl0ZWQgYnkgYSB1c2VyLiBJbnN0YW5jZXMgb2ZcbiAqIGBCYXNlQmVoYXZpb3JgIGFyZSBpbnRlcm5hbGx5IHVzZWQgYnkgYExheWVyYCBpbnN0YW5jZXMgdG8gbW9kaWZ5IHRoZSBkYXRhXG4gKiBhY2NvcmRpbmcgdG8gYSB1c2VyIGludGVyYWN0aW9uIGFuZCBhIGdpdmVuIHNoYXBlLiBBIHNpbmdsZSBpbnN0YW5jZSBvZlxuICogYEJlaGF2aW9yYCBpcyBjcmVhdGVkIGluIG9uZSBnaXZlbiBzaGFwZS5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGUgb25seSBtZXRob2QgdG8gb3ZlcnJpZGUgdG8gZGVmaW5lIGEgbmV3IGJlaGF2aW9yIGZvciBhXG4gKiBzaGFwZSBpcyB0aGUgYGVkaXRgIG1ldGhvZC4gSG93ZXZlciwgaWYgbmVlZGVkIGluIHNwZWNpYWwgY2FzZXMsIGFsbCB0aGVcbiAqIHNlbGVjdGlvbiBoYW5kbGluZyBjYW4gYmUgb3ZlcnJpZGVuIHRvby5cbiAqXG4gKiBUaGUgZmxvdyBpcyB0aGUgZm9sbG93aW5nOlxuICogYEV2ZW50YCAgLSAoZm9yd2FyZGVkIHRvKSAtPiBgTGF5ZXJgIC0gKGNvbW1hbmQpIC0+IGBCZWhhdmlvcmAgLSAobW9kaWZ5KSAtPiBgZGF0YWAgLSAodXBhdGVzKSAtPiBgU2hhcGVgXG4gKlxuICogVGhlIGJlaGF2aW9yIHJlc3BvbnNhYmlsaXR5IGlzIHRoZW4gdG8gbW9kaWZ5IHRoZSBkYXRhIGFjY29yZGluZyB0byB0aGVcbiAqIHVzZXIgaW50ZXJhY3Rpb25zLCB3aGlsZSBzaGFwZXMgYXJlIGFsd2F5cyBhIHZpZXcgb2YgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlXG4gKiBkYXRhLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlQmVoYXZpb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9zZWxlY3RlZERhdHVtcyA9IG5ldyBTZXQoKTsgLy8gbm8gZHVwbGljYXRlIGluIFNldFxuICAgIHRoaXMuX3NlbGVjdGVkQ2xhc3MgPSBudWxsO1xuICAgIHRoaXMuX2xheWVyID0gbnVsbDtcbiAgfVxuXG4gIGluaXRpYWxpemUobGF5ZXIpIHtcbiAgICB0aGlzLl9sYXllciA9IGxheWVyO1xuICAgIHRoaXMuX3NlbGVjdGVkQ2xhc3MgPSBsYXllci5wYXJhbXMuc2VsZWN0ZWRDbGFzc05hbWU7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgcmVmZXJlbmNlcyB0byB0aGUgc2VsZWN0ZWQgZGF0dW1zLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAdG9kbyAtIHJlbmFtZSB0byBgY2xlYXJTZWxlY3Rpb25gIChyZW1vdmluZyB0aGUgY2xhc3MpID9cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fc2VsZWN0ZWREYXR1bXMuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY2xhc3MgdG8gYWRkIHRvIHRoZSBzaGFwZXMgd2hlbiBzZWxlY3RlZC5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHNldCBzZWxlY3RlZENsYXNzKHZhbHVlKSB7XG4gICAgdGhpcy5fc2VsZWN0ZWRDbGFzcyA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjbGFzcyB0byBhZGQgdG8gdGhlIHNoYXBlcyB3aGVuIHNlbGVjdGVkLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHNlbGVjdGVkQ2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkQ2xhc3M7XG4gIH1cblxuICAvKipcbiAgICogQW4gYXJyYXkgY29udGFpbmluZyBhbGwgdGhlIHNlbGVjdGVkIGRhdHVtcyBvZiB0aGUgbGF5ZXIuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG4gIGdldCBzZWxlY3RlZERhdHVtcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWREYXR1bXM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdHVtIC0gVGhlIGRhdHVtIHRvIHNlbGVjdC5cbiAgICogQHRvZG8gLSBQYXNzIHRoZSBzaGFwZSBvYmplY3QgdG8gZ2V0IHRoZSBhY2Nlc3NvcnMgP1xuICAgKi9cbiAgc2VsZWN0KGRhdHVtKSB7XG4gICAgLy8gJGl0ZW0uY2xhc3NMaXN0LmFkZCh0aGlzLnNlbGVjdGVkQ2xhc3MpO1xuICAgIHRoaXMuX3NlbGVjdGVkRGF0dW1zLmFkZChkYXR1bSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdHVtIC0gVGhlIGRhdHVtIHRvIHVuc2VsZWN0LlxuICAgKiBAdG9kbyAtIFBhc3MgdGhlIHNoYXBlIG9iamVjdCB0byBnZXQgdGhlIGFjY2Vzc29ycyA/XG4gICAqL1xuICB1bnNlbGVjdChkYXR1bSkge1xuICAgIC8vICRpdGVtLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5zZWxlY3RlZENsYXNzKTtcbiAgICB0aGlzLl9zZWxlY3RlZERhdHVtcy5kZWxldGUoZGF0dW0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXR1bSAtIFRoZSBkYXR1bSB0byB0b2dnbGUgc2VsZWN0aW9uLlxuICAgKiBAdG9kbyAtIFBhc3MgdGhlIHNoYXBlIG9iamVjdCB0byBnZXQgdGhlIGFjY2Vzc29ycyA/XG4gICAqL1xuICB0b2dnbGVTZWxlY3Rpb24oZGF0dW0pIHtcbiAgICBjb25zdCBtZXRob2QgPSB0aGlzLl9zZWxlY3RlZERhdHVtcy5oYXMoZGF0dW0pID8gJ3Vuc2VsZWN0JyA6ICdzZWxlY3QnO1xuICAgIHRoaXNbbWV0aG9kXShkYXR1bSk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJmYWNlIG1ldGhvZCB0byBvdmVycmlkZSBpbiBvcmRlciB0byBkZWZpbmUgaXRzIHBhcnRpY3VsYXIgYmVoYXZpb3Igd2hlblxuICAgKiBpbnRlcmFjdGVkIHdpdGguXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZW5kZXJpbmdDb250ZXh0IC0gVGhlIGxheWVyIHJlbmRlcmluZyBjb250ZXh0LlxuICAgKiBAcGFyYW0ge0Jhc2VTaGFwZX0gc2hhcGUgLSBUaGUgc2hhcGUgb2JqZWN0IHRvIGJlIGVkaXRlZC5cbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGRhdHVtIC0gVGhlIHJlbGF0ZWQgZGF0dW0gdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZHggLSBUaGUgdmFsdWUgb2YgdGhlIGludGVyYWN0aW9uIGluIHRoZSB4IGF4aXMgKGluIHBpeGVscykuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkeSAtIFRoZSB2YWx1ZSBvZiB0aGUgaW50ZXJhY3Rpb24gaW4gdGhlIHkgYXhpcyAoaW4gcGl4ZWxzKS5cbiAgICogQHBhcmFtIHtFbGVtZW50fSAkdGFyZ2V0IC0gVGhlIHRhcmdldCBET00gZWxlbWVudCBvZiB0aGUgaW50ZXJhY3Rpb24uXG4gICAqL1xuICBlZGl0KHJlbmRlcmluZ0NvbnRleHQsIHNoYXBlLCBkYXR1bSwgZHgsIGR5LCAkdGFyZ2V0KSB7XG4gICAgLy8gbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBjaGlsZHJlblxuICB9XG5cbiAgLyoqXG4gICAqIFRPRE86IHBvc3NpYmxlIGFjdGlvbnMgYXJlICdhZGQnLCAncmVtb3ZlJywgJ2VkaXQnLCAnbWluaW1pemUnLCAnaGlnaGxpZ2h0JywgJ3NlbGVjdCcsICd1bnNlbGVjdCcuXG4gICAqL1xuICBjYW4oYWN0aW9uLCBkYXR1bXMpIHsgXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVE9ET1xuICAgKi9cbiAgY3JlYXRlKGRhdHVtKSB7IH1cblxuICAvKipcbiAgICogVE9ET1xuICAgKi9cbiAgcmVtb3ZlKGRhdHVtKSB7IH1cblxuICAvKipcbiAgICogVE9ET1xuICAgKi9cbiAgbWluaW1pemUoKSB7IH1cblxuICAvKipcbiAgICogVE9ET1xuICAgKi9cbiAgaGlnaGxpZ2h0KGRhdHVtLCBpc0hpZ2hsaWdodGVkKSB7IH1cblxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEJhc2VCZWhhdmlvciBmcm9tICcuL2Jhc2UtYmVoYXZpb3InO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJlYXRHcmlkU25hcFNlZ21lbnRCZWhhdmlvciBleHRlbmRzIEJhc2VCZWhhdmlvciB7XG5cbiAgY29uc3RydWN0b3IoYmVhdEdyaWQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2JlYXRHcmlkID0gYmVhdEdyaWQ7XG4gIH1cblxuICBzZXQgYmVhdEdyaWQodmFsdWUpIHtcbiAgICB0aGlzLl9iZWF0R3JpZCA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IGJlYXRHcmlkKCkge1xuICAgIHJldHVybiB0aGlzLl9iZWF0R3JpZDtcbiAgfVxuXG4gIGVkaXQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIGxldCBhY3Rpb24gPSAnbW92ZSc7XG5cbiAgICBpZiAodGFyZ2V0Lmhhc05hbWUoJ2hhbmRsZXInKSkge1xuICAgICAgaWYgKHRhcmdldC5oYXNOYW1lKCdsZWZ0JykpIFxuICAgICAgICBhY3Rpb24gPSAncmVzaXplTGVmdCc7XG4gICAgICBlbHNlIGlmICh0YXJnZXQuaGFzTmFtZSgncmlnaHQnKSkgXG4gICAgICAgIGFjdGlvbiA9ICdyZXNpemVSaWdodCc7XG4gICAgICBlbHNlIFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQga29udmEgc2hhcGUgbmFtZScpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0Lmhhc05hbWUoJ3NlZ21lbnQnKSkgXG4gICAgICBhY3Rpb24gPSAnbW92ZSc7XG4gICAgZWxzZSBcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBrb252YSBzaGFwZSBuYW1lJyk7XG5cbiAgICB0aGlzW2BfJHthY3Rpb259YF0ocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCk7XG4gIH1cblxuICBfbW92ZShyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgY29uc3QgdGltZVRvUGl4ZWwgPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsO1xuICAgIGNvbnN0IGxheWVySGVpZ2h0ID0gcmVuZGVyaW5nQ29udGV4dC5oZWlnaHQ7XG4gICAgLy8gY3VycmVudCB2YWx1ZXNcbiAgICBjb25zdCB4ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS54KGRhdHVtKSk7XG4gICAgY29uc3QgeSA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHNoYXBlLnkoZGF0dW0pKTtcbiAgICBjb25zdCB3aWR0aCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoc2hhcGUud2lkdGgoZGF0dW0pKTtcbiAgICBjb25zdCBoZWlnaHQgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbChzaGFwZS5oZWlnaHQoZGF0dW0pKTtcbiAgICAvLyB0YXJnZXQgdmFsdWVzXG4gICAgbGV0IHRhcmdldFggPSBNYXRoLm1heCh4ICsgZHgsIDApO1xuICAgIGxldCB0YXJnZXRZID0geSArIGR5O1xuXG4gICAgLy8gbG9jayBpbiBsYXllcidzIHkgYXhpc1xuICAgIGlmICh0YXJnZXRZID4gbGF5ZXJIZWlnaHQpIHtcbiAgICAgIHRhcmdldFkgPSBsYXllckhlaWdodDtcbiAgICB9IGVsc2UgaWYgKHRhcmdldFkgLSAobGF5ZXJIZWlnaHQgLSBoZWlnaHQpIDwgMCkge1xuICAgICAgdGFyZ2V0WSA9IChsYXllckhlaWdodCAtIGhlaWdodCk7XG4gICAgfVxuXG4gICAgY29uc3QgYmVhdDAgPSB0aGlzLl9iZWF0R3JpZC5iZWF0KHRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRYKSk7XG4gICAgY29uc3Qgc25hcHBlZDAgPSB0aGlzLl9iZWF0R3JpZC5zZWNvbmRzKE1hdGgucm91bmQoYmVhdDApKTtcbiAgICBjb25zdCBiZWF0MSA9IHRoaXMuX2JlYXRHcmlkLmJlYXQodGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFgpICsgc2hhcGUud2lkdGgoZGF0dW0pKTtcbiAgICBjb25zdCBzbmFwcGVkMSA9IHRoaXMuX2JlYXRHcmlkLnNlY29uZHMoTWF0aC5yb3VuZChiZWF0MSkpO1xuXG4gICAgaWYgKHNuYXBwZWQwICE9PSBzbmFwcGVkMSkge1xuICAgICAgc2hhcGUueChkYXR1bSwgc25hcHBlZDApO1xuICAgICAgc2hhcGUud2lkdGgoZGF0dW0sIHNuYXBwZWQxLXNuYXBwZWQwKTtcbiAgICAgIHNoYXBlLnkoZGF0dW0sIHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsLmludmVydCh0YXJnZXRZKSk7XG4gICAgfVxuICB9XG5cbiAgX3Jlc2l6ZUxlZnQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIGNvbnN0IHRpbWVUb1BpeGVsID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbDtcbiAgICAvLyBjdXJyZW50IHZhbHVlc1xuICAgIGNvbnN0IHggICAgID0gdGltZVRvUGl4ZWwoc2hhcGUueChkYXR1bSkpO1xuICAgIGNvbnN0IHdpZHRoID0gdGltZVRvUGl4ZWwoc2hhcGUud2lkdGgoZGF0dW0pKTtcbiAgICAvLyB0YXJnZXQgdmFsdWVzXG4gICAgbGV0IG1heFRhcmdldFggID0geCArIHdpZHRoO1xuICAgIGxldCB0YXJnZXRYICAgICA9IHggKyBkeCA8IG1heFRhcmdldFggPyBNYXRoLm1heCh4ICsgZHgsIDApIDogeDtcbiAgICBsZXQgdGFyZ2V0V2lkdGggPSB0YXJnZXRYICE9PSAwID8gTWF0aC5tYXgod2lkdGggLSBkeCwgMSkgOiB3aWR0aDtcblxuXG4gICAgY29uc3QgYmVhdDAgPSB0aGlzLl9iZWF0R3JpZC5iZWF0KHRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRYKSk7XG4gICAgY29uc3Qgc25hcHBlZDAgPSB0aGlzLl9iZWF0R3JpZC5zZWNvbmRzKE1hdGgucm91bmQoYmVhdDApKTtcbiAgICBjb25zdCBiZWF0MSA9IHRoaXMuX2JlYXRHcmlkLmJlYXQodGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFgpICsgdGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFdpZHRoKSk7XG4gICAgY29uc3Qgc25hcHBlZDEgPSB0aGlzLl9iZWF0R3JpZC5zZWNvbmRzKE1hdGgucm91bmQoYmVhdDEpKTtcblxuXG4gICAgaWYgKHNuYXBwZWQwICE9PSBzbmFwcGVkMSkge1xuICAgICAgc2hhcGUueChkYXR1bSwgc25hcHBlZDApO1xuICAgICAgc2hhcGUud2lkdGgoZGF0dW0sIHNuYXBwZWQxIC0gc25hcHBlZDApO1xuICAgIH1cbiAgICBcbiAgfVxuXG4gIF9yZXNpemVSaWdodChyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgLy8gY3VycmVudCB2YWx1ZXNcbiAgICBjb25zdCB3aWR0aCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoc2hhcGUud2lkdGgoZGF0dW0pKTtcbiAgICAvLyB0YXJnZXQgdmFsdWVzXG4gICAgbGV0IHRhcmdldFdpZHRoID0gTWF0aC5tYXgod2lkdGggKyBkeCwgMSk7XG5cbiAgICBjb25zdCBiZWF0MSA9IHRoaXMuX2JlYXRHcmlkLmJlYXQoc2hhcGUueChkYXR1bSkgKyByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRXaWR0aCkpO1xuICAgIGNvbnN0IHNuYXBwZWQxID0gdGhpcy5fYmVhdEdyaWQuc2Vjb25kcyhNYXRoLnJvdW5kKGJlYXQxKSk7XG5cbiAgICBpZiAoc25hcHBlZDEgLSBzaGFwZS54KGRhdHVtKSkge1xuICAgICAgc2hhcGUud2lkdGgoZGF0dW0sIHNuYXBwZWQxIC0gc2hhcGUueChkYXR1bSkpO1xuICAgIH1cbiAgfVxuXG4gIHNlbGVjdChkYXR1bSkge1xuICAgIHN1cGVyLnNlbGVjdChkYXR1bSk7XG4gICAgdGhpcy5oaWdobGlnaHQoZGF0dW0sIHRydWUpO1xuICB9XG5cbiAgdW5zZWxlY3QoZGF0dW0pIHtcbiAgICBzdXBlci51bnNlbGVjdChkYXR1bSk7XG4gICAgdGhpcy5oaWdobGlnaHQoZGF0dW0sIGZhbHNlKTtcbiAgfVxuXG4gIGhpZ2hsaWdodChkYXR1bSwgaXNIaWdobGlnaHRlZCkge1xuICAgIGNvbnN0IHNoYXBlID0gdGhpcy5fbGF5ZXIuZ2V0U2hhcGVGcm9tRGF0dW0oZGF0dW0pO1xuICAgIGlmIChzaGFwZSkge1xuICAgICAgaWYgKGlzSGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgc2hhcGUucGFyYW1zLmNvbG9yID0gJ3JlZCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaGFwZS5wYXJhbXMuY29sb3IgPSAnYmxhY2snO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNoYXBlIGZvciB0aGlzIGRhdHVtIGluIHRoaXMgbGF5ZXInLCB7IGRhdHVtOiBkYXR1bSwgbGF5ZXI6IHRoaXMuX2xheWVyIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEJhc2VCZWhhdmlvciBmcm9tICcuL2Jhc2UtYmVoYXZpb3InO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJyZWFrcG9pbnRCZWhhdmlvciBleHRlbmRzIEJhc2VCZWhhdmlvciB7XG4gIGVkaXQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIGNvbnN0IGRhdGEgID0gdGhpcy5fbGF5ZXIuZGF0YTtcbiAgICBjb25zdCBsYXllckhlaWdodCA9IHJlbmRlcmluZ0NvbnRleHQuaGVpZ2h0O1xuICAgIC8vIGN1cnJlbnQgcG9zaXRpb25cbiAgICBjb25zdCB4ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS54KGRhdHVtKSk7XG4gICAgY29uc3QgeSA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHNoYXBlLnkoZGF0dW0pKTtcbiAgICAvLyB0YXJnZXQgcG9zaXRpb25cbiAgICBsZXQgdGFyZ2V0WCA9IHggKyBkeDtcbiAgICBsZXQgdGFyZ2V0WSA9IHkgKyBkeTtcblxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDIpIHtcbiAgICAgIC8vIGNyZWF0ZSBhIHNvcnRlZCBtYXAgb2YgYWxsIGB4YCBwb3NpdGlvbnNcbiAgICAgIGNvbnN0IHhNYXAgPSBkYXRhLm1hcCgoZCkgPT4gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS54KGQpKSk7XG4gICAgICB4TWFwLnNvcnQoKGEsIGIpID0+IGEgPCBiID8gLTEgOiAxKTtcbiAgICAgIC8vIGZpbmQgaW5kZXggb2Ygb3VyIHNoYXBlIHggcG9zaXRpb25cbiAgICAgIGNvbnN0IGluZGV4ID0geE1hcC5pbmRleE9mKHgpO1xuICAgICAgLy8gbG9jayB0byBuZXh0IHNpYmxpbmdzXG4gICAgICBpZiAodGFyZ2V0WCA8IHhNYXBbaW5kZXggLSAxXSB8fCB0YXJnZXRYID4geE1hcFtpbmRleCArIDFdKSB7XG4gICAgICAgIHRhcmdldFggPSB4O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0YXJnZXRYIDwgMClcbiAgICAgIHRhcmdldFggPSAwO1xuXG4gICAgLy8gbG9jayBpbiB5IGF4aXNcbiAgICBpZiAodGFyZ2V0WSA8IDApIHtcbiAgICAgIHRhcmdldFkgPSAwO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0WSA+IGxheWVySGVpZ2h0KSB7XG4gICAgICB0YXJnZXRZID0gbGF5ZXJIZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGRhdHVtIHdpdGggbmV3IHZhbHVlc1xuICAgIHNoYXBlLngoZGF0dW0sIHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFgpKTtcbiAgICBzaGFwZS55KGRhdHVtLCByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbC5pbnZlcnQodGFyZ2V0WSkpO1xuICB9XG5cbiAgc2VsZWN0KGRhdHVtKSB7XG4gICAgc3VwZXIuc2VsZWN0KGRhdHVtKTtcbiAgICB0aGlzLmhpZ2hsaWdodChkYXR1bSwgdHJ1ZSk7XG4gIH1cblxuICB1bnNlbGVjdChkYXR1bSkge1xuICAgIHN1cGVyLnVuc2VsZWN0KGRhdHVtKTtcbiAgICB0aGlzLmhpZ2hsaWdodChkYXR1bSwgZmFsc2UpO1xuICB9XG5cbiAgaGlnaGxpZ2h0KGRhdHVtLCBpc0hpZ2hsaWdodGVkKSB7XG4gICAgY29uc3Qgc2hhcGUgPSB0aGlzLl9sYXllci5nZXRTaGFwZUZyb21EYXR1bShkYXR1bSk7XG4gICAgaWYgKHNoYXBlKSB7XG4gICAgICBpZiAoaXNIaWdobGlnaHRlZCkge1xuICAgICAgICBzaGFwZS5wYXJhbXMuY29sb3IgPSAncmVkJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNoYXBlLnBhcmFtcy5jb2xvciA9ICdibGFjayc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2hhcGUgZm9yIHRoaXMgZGF0dW0gaW4gdGhpcyBsYXllcicsIHsgZGF0dW06IGRhdHVtLCBsYXllcjogdGhpcy5fbGF5ZXIgfSk7XG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgQmFzZUJlaGF2aW9yIGZyb20gJy4vYmFzZS1iZWhhdmlvcic7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFya2VyQmVoYXZpb3IgZXh0ZW5kcyBCYXNlQmVoYXZpb3Ige1xuXG5cdGVkaXQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuXHRcdGNvbnN0IHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHNoYXBlLngoZGF0dW0pKTtcblx0XHRsZXQgdGFyZ2V0WCA9ICh4ICsgZHgpID4gMCA/IHggKyBkeCA6IDA7XG5cblx0XHRzaGFwZS54KGRhdHVtLCByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRYKSk7XG5cdH1cblxuXHRzZWxlY3QoZGF0dW0pIHtcblx0XHRzdXBlci5zZWxlY3QoZGF0dW0pO1xuXHRcdHRoaXMuaGlnaGxpZ2h0KGRhdHVtLCB0cnVlKTtcblx0fVxuXG5cdHVuc2VsZWN0KGRhdHVtKSB7XG5cdFx0c3VwZXIudW5zZWxlY3QoZGF0dW0pO1xuXHRcdHRoaXMuaGlnaGxpZ2h0KGRhdHVtLCBmYWxzZSk7XG5cdH1cblxuXHRoaWdobGlnaHQoZGF0dW0sIGlzSGlnaGxpZ2h0ZWQpIHtcblx0XHRjb25zdCBzaGFwZSA9IHRoaXMuX2xheWVyLmdldFNoYXBlRnJvbURhdHVtKGRhdHVtKTtcblx0XHRpZiAoc2hhcGUpIHtcblx0XHRcdGlmIChpc0hpZ2hsaWdodGVkKSB7XG5cdFx0XHRcdHNoYXBlLnBhcmFtcy5jb2xvciA9ICdyZWQnO1xuXHRcdFx0XHRzaGFwZS5wYXJhbXMuaGFuZGxlckNvbG9yID0gJ3JlZCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBkZWZhdWx0cyA9IHNoYXBlLl9nZXREZWZhdWx0cygpO1xuXHRcdFx0XHRzaGFwZS5wYXJhbXMuY29sb3IgPSBkZWZhdWx0cy5jb2xvcjtcblx0XHRcdFx0c2hhcGUucGFyYW1zLmhhbmRsZXJDb2xvciA9IGRlZmF1bHRzLmhhbmRsZXJDb2xvcjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdObyBzaGFwZSBmb3IgdGhpcyBkYXR1bSBpbiB0aGlzIGxheWVyJywgeyBkYXR1bTogZGF0dW0sIGxheWVyOiB0aGlzLl9sYXllciB9KTtcblx0XHR9XG5cdH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlQmVoYXZpb3IgZnJvbSAnLi9iYXNlLWJlaGF2aW9yJztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb0JlaGF2aW9yIGV4dGVuZHMgQmFzZUJlaGF2aW9yIHtcblxuICBzZXQgc2VsZWN0ZWRDbGFzcyh2YWx1ZSkgeyB9XG5cbiAgZ2V0IHNlbGVjdGVkQ2xhc3MoKSB7IH1cblxuICBnZXQgc2VsZWN0ZWREYXR1bXMoKSB7IH1cblxuICBzZWxlY3QoZGF0dW0pIHsgfVxuXG4gIHVuc2VsZWN0KGRhdHVtKSB7IH1cblxuICB0b2dnbGVTZWxlY3Rpb24oZGF0dW0pIHsgfVxuXG4gIGVkaXQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksICR0YXJnZXQpIHsgfVxuXG4gIGNhbihhY3Rpb24sIGRhdHVtcykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBjcmVhdGUoZGF0dW0pIHsgfVxuXG4gIHJlbW92ZShkYXR1bSkgeyB9XG5cbiAgbWluaW1pemUoKSB7IH1cblxuICBoaWdobGlnaHQoZGF0dW0sIGlzSGlnaGxpZ2h0ZWQpIHsgfVxuXG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgQmFzZUJlaGF2aW9yIGZyb20gJy4vYmFzZS1iZWhhdmlvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjcm9sbFNlZ21lbnRCZWhhdmlvciBleHRlbmRzIEJhc2VCZWhhdmlvciB7XG4gIGNvbnN0cnVjdG9yKHRhcmdldFRpbWVsaW5lKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnRhcmdldFRpbWVsaW5lID0gdGFyZ2V0VGltZWxpbmU7XG4gIH1cblxuICBlZGl0KHJlbmRlcmluZ0NvbnRleHQsIHNoYXBlLCBkYXR1bSwgZHgsIGR5LCB0YXJnZXQpIHtcbiAgICBsZXQgYWN0aW9uID0gJ21vdmUnO1xuXG4gICAgaWYgKHRhcmdldC5oYXNOYW1lKCdoYW5kbGVyJykpIHtcbiAgICAgIGlmICh0YXJnZXQuaGFzTmFtZSgnbGVmdCcpKSBcbiAgICAgICAgYWN0aW9uID0gJ3Jlc2l6ZUxlZnQnO1xuICAgICAgZWxzZSBpZiAodGFyZ2V0Lmhhc05hbWUoJ3JpZ2h0JykpIFxuICAgICAgICBhY3Rpb24gPSAncmVzaXplUmlnaHQnO1xuICAgICAgZWxzZSBcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGtvbnZhIHNoYXBlIG5hbWUnKTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5oYXNOYW1lKCdzZWdtZW50JykpIFxuICAgICAgYWN0aW9uID0gJ21vdmUnO1xuICAgIGVsc2UgXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQga29udmEgc2hhcGUgbmFtZScpO1xuXG4gICAgdGhpc1tgXyR7YWN0aW9ufWBdKHJlbmRlcmluZ0NvbnRleHQsIHNoYXBlLCBkYXR1bSwgZHgsIGR5LCB0YXJnZXQpO1xuICB9XG5cbiAgX21vdmUocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIGNvbnN0IGxheWVySGVpZ2h0ID0gcmVuZGVyaW5nQ29udGV4dC5oZWlnaHQ7XG4gICAgLy8gY3VycmVudCB2YWx1ZXNcbiAgICBjb25zdCB4ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS54KGRhdHVtKSk7XG4gICAgY29uc3QgeSA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHNoYXBlLnkoZGF0dW0pKTtcbiAgICBjb25zdCB3aWR0aCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoc2hhcGUud2lkdGgoZGF0dW0pKTtcbiAgICBjb25zdCBoZWlnaHQgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbChzaGFwZS5oZWlnaHQoZGF0dW0pKTtcbiAgICAvLyB0YXJnZXQgdmFsdWVzXG4gICAgbGV0IHRhcmdldFggPSBNYXRoLm1heCh4ICsgZHgsIDApO1xuICAgIGxldCB0YXJnZXRZID0geSArIGR5O1xuXG4gICAgLy8gbG9jayBpbiBsYXllcidzIHkgYXhpc1xuICAgIGlmICh0YXJnZXRZID4gbGF5ZXJIZWlnaHQpIHtcbiAgICAgIHRhcmdldFkgPSBsYXllckhlaWdodDtcbiAgICB9IGVsc2UgaWYgKHRhcmdldFkgLSAobGF5ZXJIZWlnaHQgLSBoZWlnaHQpIDwgMCkge1xuICAgICAgdGFyZ2V0WSA9IChsYXllckhlaWdodCAtIGhlaWdodCk7XG4gICAgfVxuXG4gICAgc2hhcGUueChkYXR1bSwgcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0WCkpO1xuICAgIHNoYXBlLnkoZGF0dW0sIHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsLmludmVydCh0YXJnZXRZKSk7XG5cbiAgICB0aGlzLnRhcmdldFRpbWVsaW5lLnZpc2libGVJbnRlcnZhbCA9IHtzdGFydDogc2hhcGUueChkYXR1bSksIGR1cmF0aW9uOiBzaGFwZS53aWR0aChkYXR1bSl9O1xuICAgIHRoaXMudGFyZ2V0VGltZWxpbmUudHJhY2tzLnVwZGF0ZSgpO1xuICB9XG5cbiAgX3Jlc2l6ZUxlZnQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIC8vIGN1cnJlbnQgdmFsdWVzXG4gICAgY29uc3QgeCAgICAgPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHNoYXBlLngoZGF0dW0pKTtcbiAgICBjb25zdCB3aWR0aCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoc2hhcGUud2lkdGgoZGF0dW0pKTtcbiAgICAvLyB0YXJnZXQgdmFsdWVzXG4gICAgbGV0IG1heFRhcmdldFggID0geCArIHdpZHRoO1xuICAgIGxldCB0YXJnZXRYICAgICA9IHggKyBkeCA8IG1heFRhcmdldFggPyBNYXRoLm1heCh4ICsgZHgsIDApIDogeDtcbiAgICBsZXQgdGFyZ2V0V2lkdGggPSB0YXJnZXRYICE9PSAwID8gTWF0aC5tYXgod2lkdGggLSBkeCwgMSkgOiB3aWR0aDtcblxuICAgIHNoYXBlLngoZGF0dW0sIHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFgpKTtcbiAgICBzaGFwZS53aWR0aChkYXR1bSwgcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0V2lkdGgpKTtcblxuICAgIHRoaXMudGFyZ2V0VGltZWxpbmUudmlzaWJsZUludGVydmFsID0ge3N0YXJ0OiBzaGFwZS54KGRhdHVtKSwgZHVyYXRpb246IHNoYXBlLndpZHRoKGRhdHVtKX07XG4gICAgdGhpcy50YXJnZXRUaW1lbGluZS50cmFja3MudXBkYXRlKCk7XG4gIH1cblxuICBfcmVzaXplUmlnaHQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIC8vIGN1cnJlbnQgdmFsdWVzXG4gICAgY29uc3Qgd2lkdGggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHNoYXBlLndpZHRoKGRhdHVtKSk7XG4gICAgLy8gdGFyZ2V0IHZhbHVlc1xuICAgIGxldCB0YXJnZXRXaWR0aCA9IE1hdGgubWF4KHdpZHRoICsgZHgsIDEpO1xuXG4gICAgc2hhcGUud2lkdGgoZGF0dW0sIHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFdpZHRoKSk7XG5cbiAgICB0aGlzLnRhcmdldFRpbWVsaW5lLnZpc2libGVJbnRlcnZhbCA9IHtzdGFydDogc2hhcGUueChkYXR1bSksIGR1cmF0aW9uOiBzaGFwZS53aWR0aChkYXR1bSl9O1xuICAgIHRoaXMudGFyZ2V0VGltZWxpbmUudHJhY2tzLnVwZGF0ZSgpO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgQmFzZUJlaGF2aW9yIGZyb20gJy4vYmFzZS1iZWhhdmlvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlZ21lbnRCZWhhdmlvciBleHRlbmRzIEJhc2VCZWhhdmlvciB7XG4gIGVkaXQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIGxldCBhY3Rpb24gPSAnbW92ZSc7XG5cbiAgICBpZiAodGFyZ2V0Lmhhc05hbWUoJ2hhbmRsZXInKSkge1xuICAgICAgaWYgKHRhcmdldC5oYXNOYW1lKCdsZWZ0JykpIFxuICAgICAgICBhY3Rpb24gPSAncmVzaXplTGVmdCc7XG4gICAgICBlbHNlIGlmICh0YXJnZXQuaGFzTmFtZSgncmlnaHQnKSkgXG4gICAgICAgIGFjdGlvbiA9ICdyZXNpemVSaWdodCc7XG4gICAgICBlbHNlIFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQga29udmEgc2hhcGUgbmFtZScpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0Lmhhc05hbWUoJ3NlZ21lbnQnKSkgXG4gICAgICBhY3Rpb24gPSAnbW92ZSc7XG4gICAgZWxzZSBcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBrb252YSBzaGFwZSBuYW1lJyk7XG5cbiAgICB0aGlzW2BfJHthY3Rpb259YF0ocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCk7XG4gIH1cblxuICBfbW92ZShyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgY29uc3QgbGF5ZXJIZWlnaHQgPSByZW5kZXJpbmdDb250ZXh0LmhlaWdodDtcbiAgICAvLyBjdXJyZW50IHZhbHVlc1xuICAgIGNvbnN0IHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHNoYXBlLngoZGF0dW0pKTtcbiAgICBjb25zdCB5ID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwoc2hhcGUueShkYXR1bSkpO1xuICAgIGNvbnN0IHdpZHRoID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS53aWR0aChkYXR1bSkpO1xuICAgIGNvbnN0IGhlaWdodCA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHNoYXBlLmhlaWdodChkYXR1bSkpO1xuICAgIC8vIHRhcmdldCB2YWx1ZXNcbiAgICBsZXQgdGFyZ2V0WCA9IE1hdGgubWF4KHggKyBkeCwgMCk7XG4gICAgbGV0IHRhcmdldFkgPSB5ICsgZHk7XG5cbiAgICAvLyBsb2NrIGluIGxheWVyJ3MgeSBheGlzXG4gICAgaWYgKHRhcmdldFkgPiBsYXllckhlaWdodCkge1xuICAgICAgdGFyZ2V0WSA9IGxheWVySGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0WSAtIChsYXllckhlaWdodCAtIGhlaWdodCkgPCAwKSB7XG4gICAgICB0YXJnZXRZID0gKGxheWVySGVpZ2h0IC0gaGVpZ2h0KTtcbiAgICB9XG5cbiAgICBzaGFwZS54KGRhdHVtLCByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRYKSk7XG4gICAgc2hhcGUueShkYXR1bSwgcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFkpKTtcbiAgfVxuXG4gIF9yZXNpemVMZWZ0KHJlbmRlcmluZ0NvbnRleHQsIHNoYXBlLCBkYXR1bSwgZHgsIGR5LCB0YXJnZXQpIHtcbiAgICAvLyBjdXJyZW50IHZhbHVlc1xuICAgIGNvbnN0IHggICAgID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS54KGRhdHVtKSk7XG4gICAgY29uc3Qgd2lkdGggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHNoYXBlLndpZHRoKGRhdHVtKSk7XG4gICAgLy8gdGFyZ2V0IHZhbHVlc1xuICAgIGxldCBtYXhUYXJnZXRYICA9IHggKyB3aWR0aDtcbiAgICBsZXQgdGFyZ2V0WCAgICAgPSB4ICsgZHggPCBtYXhUYXJnZXRYID8gTWF0aC5tYXgoeCArIGR4LCAwKSA6IHg7XG4gICAgbGV0IHRhcmdldFdpZHRoID0gdGFyZ2V0WCAhPT0gMCA/IE1hdGgubWF4KHdpZHRoIC0gZHgsIDEpIDogd2lkdGg7XG5cbiAgICBzaGFwZS54KGRhdHVtLCByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRYKSk7XG4gICAgc2hhcGUud2lkdGgoZGF0dW0sIHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFdpZHRoKSk7XG4gIH1cblxuICBfcmVzaXplUmlnaHQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIC8vIGN1cnJlbnQgdmFsdWVzXG4gICAgY29uc3Qgd2lkdGggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHNoYXBlLndpZHRoKGRhdHVtKSk7XG4gICAgLy8gdGFyZ2V0IHZhbHVlc1xuICAgIGxldCB0YXJnZXRXaWR0aCA9IE1hdGgubWF4KHdpZHRoICsgZHgsIDEpO1xuXG4gICAgc2hhcGUud2lkdGgoZGF0dW0sIHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFdpZHRoKSk7XG4gIH1cblxuICBzZWxlY3QoZGF0dW0pIHtcbiAgICBzdXBlci5zZWxlY3QoZGF0dW0pO1xuICAgIHRoaXMuaGlnaGxpZ2h0KGRhdHVtLCB0cnVlKTtcbiAgfVxuXG4gIHVuc2VsZWN0KGRhdHVtKSB7XG4gICAgc3VwZXIudW5zZWxlY3QoZGF0dW0pO1xuICAgIHRoaXMuaGlnaGxpZ2h0KGRhdHVtLCBmYWxzZSk7XG4gIH1cblxuICBoaWdobGlnaHQoZGF0dW0sIGlzSGlnaGxpZ2h0ZWQpIHtcbiAgICBjb25zdCBzaGFwZSA9IHRoaXMuX2xheWVyLmdldFNoYXBlRnJvbURhdHVtKGRhdHVtKTtcbiAgICBpZiAoc2hhcGUpIHtcbiAgICAgIGlmIChpc0hpZ2hsaWdodGVkKSB7XG4gICAgICAgIHNoYXBlLnBhcmFtcy5jb2xvciA9ICdyZWQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2hhcGUucGFyYW1zLmNvbG9yID0gJ2JsYWNrJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzaGFwZSBmb3IgdGhpcyBkYXR1bSBpbiB0aGlzIGxheWVyJywgeyBkYXR1bTogZGF0dW0sIGxheWVyOiB0aGlzLl9sYXllciB9KTtcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlQmVoYXZpb3IgZnJvbSAnLi9iYXNlLWJlaGF2aW9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2libGluZ0xvY2tlZFNlZ21lbnRCZWhhdmlvciBleHRlbmRzIEJhc2VCZWhhdmlvciB7XG4gIGVkaXQocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIGNvbnN0IGRhdGEgID0gdGhpcy5fbGF5ZXIuZGF0YTtcbiAgICBjb25zdCBsYXllckhlaWdodCA9IHJlbmRlcmluZ0NvbnRleHQuaGVpZ2h0O1xuICAgIC8vIGN1cnJlbnQgcG9zaXRpb25cbiAgICBjb25zdCB4ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS54KGRhdHVtKSk7XG4gICAgY29uc3QgeSA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHNoYXBlLnkoZGF0dW0pKTtcbiAgICAvLyB0YXJnZXQgcG9zaXRpb25cbiAgICBsZXQgdGFyZ2V0WCA9IHggKyBkeDtcbiAgICBsZXQgdGFyZ2V0WSA9IHkgKyBkeTtcblxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDIpIHtcbiAgICAgIC8vIGNyZWF0ZSBhIHNvcnRlZCBtYXAgb2YgYWxsIGB4YCBwb3NpdGlvbnNcbiAgICAgIGNvbnN0IHhNYXAgPSBkYXRhLm1hcCgoZCkgPT4ge1xuICAgICAgICBsZXQgeCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoc2hhcGUueChkKSk7IFxuICAgICAgICBsZXQgd2lkdGggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHNoYXBlLngoZCkgKyBzaGFwZS53aWR0aChkKSk7XG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiB4LCBlbmQ6IHggKyB3aWR0aCB9O1xuICAgICAgfSk7XG4gICAgICB4TWFwLnNvcnQoKGEsIGIpID0+IGEuc3RhcnQgPCBiLnN0YXJ0ID8gLTEgOiAxKTtcbiAgICAgIC8vIGZpbmQgaW5kZXggb2Ygb3VyIHNoYXBlIHggcG9zaXRpb25cbiAgICAgIGNvbnN0IGluZGV4ID0geE1hcC5pbmRleE9mKHgpO1xuICAgICAgLy8gbG9jayB0byBuZXh0IHNpYmxpbmdzXG4gICAgICBpZiAodGFyZ2V0WCA8IHhNYXBbaW5kZXggLSAxXS5lbmQgfHwgdGFyZ2V0WCArIHNoYXBlLndpZHRoKGRhdHVtKSA+IHhNYXBbaW5kZXggKyAxXS5zdGFydCkge1xuICAgICAgICB0YXJnZXRYID0geDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0WCA8IDApXG4gICAgICB0YXJnZXRYID0gMDtcblxuICAgIC8vIGxvY2sgaW4geSBheGlzXG4gICAgaWYgKHRhcmdldFkgPCAwKSB7XG4gICAgICB0YXJnZXRZID0gMDtcbiAgICB9IGVsc2UgaWYgKHRhcmdldFkgPiBsYXllckhlaWdodCkge1xuICAgICAgdGFyZ2V0WSA9IGxheWVySGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBkYXR1bSB3aXRoIG5ldyB2YWx1ZXNcbiAgICBzaGFwZS54KGRhdHVtLCByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRYKSk7XG4gICAgc2hhcGUueShkYXR1bSwgcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFkpKTtcbiAgfVxuXG4gIHNlbGVjdChkYXR1bSkge1xuICAgIHN1cGVyLnNlbGVjdChkYXR1bSk7XG4gICAgdGhpcy5oaWdobGlnaHQoZGF0dW0sIHRydWUpO1xuICB9XG5cbiAgdW5zZWxlY3QoZGF0dW0pIHtcbiAgICBzdXBlci51bnNlbGVjdChkYXR1bSk7XG4gICAgdGhpcy5oaWdobGlnaHQoZGF0dW0sIGZhbHNlKTtcbiAgfVxuXG4gIGhpZ2hsaWdodChkYXR1bSwgaXNIaWdobGlnaHRlZCkge1xuICAgIGNvbnN0IHNoYXBlID0gdGhpcy5fbGF5ZXIuZ2V0U2hhcGVGcm9tRGF0dW0oZGF0dW0pO1xuICAgIGlmIChzaGFwZSkge1xuICAgICAgaWYgKGlzSGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgc2hhcGUucGFyYW1zLmNvbG9yID0gJ3JlZCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaGFwZS5wYXJhbXMuY29sb3IgPSAnYmxhY2snO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNoYXBlIGZvciB0aGlzIGRhdHVtIGluIHRoaXMgbGF5ZXInLCB7IGRhdHVtOiBkYXR1bSwgbGF5ZXI6IHRoaXMuX2xheWVyIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEJhc2VCZWhhdmlvciBmcm9tICcuL2Jhc2UtYmVoYXZpb3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaW1wbGVTbmFwU2VnbWVudEJlaGF2aW9yIGV4dGVuZHMgQmFzZUJlaGF2aW9yIHtcbiAgZWRpdChyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgbGV0IGFjdGlvbiA9ICdtb3ZlJztcblxuICAgIGlmICh0YXJnZXQuaGFzTmFtZSgnaGFuZGxlcicpKSB7XG4gICAgICBpZiAodGFyZ2V0Lmhhc05hbWUoJ2xlZnQnKSkgXG4gICAgICAgIGFjdGlvbiA9ICdyZXNpemVMZWZ0JztcbiAgICAgIGVsc2UgaWYgKHRhcmdldC5oYXNOYW1lKCdyaWdodCcpKSBcbiAgICAgICAgYWN0aW9uID0gJ3Jlc2l6ZVJpZ2h0JztcbiAgICAgIGVsc2UgXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBrb252YSBzaGFwZSBuYW1lJyk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQuaGFzTmFtZSgnc2VnbWVudCcpKSBcbiAgICAgIGFjdGlvbiA9ICdtb3ZlJztcbiAgICBlbHNlIFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGtvbnZhIHNoYXBlIG5hbWUnKTtcblxuICAgIHRoaXNbYF8ke2FjdGlvbn1gXShyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KTtcbiAgfVxuXG4gIF9tb3ZlKHJlbmRlcmluZ0NvbnRleHQsIHNoYXBlLCBkYXR1bSwgZHgsIGR5LCB0YXJnZXQpIHtcbiAgICBjb25zdCBsYXllckhlaWdodCA9IHJlbmRlcmluZ0NvbnRleHQuaGVpZ2h0O1xuICAgIC8vIGN1cnJlbnQgdmFsdWVzXG4gICAgY29uc3QgeCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoc2hhcGUueChkYXR1bSkpO1xuICAgIGNvbnN0IHkgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbChzaGFwZS55KGRhdHVtKSk7XG4gICAgY29uc3Qgd2lkdGggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHNoYXBlLndpZHRoKGRhdHVtKSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwoc2hhcGUuaGVpZ2h0KGRhdHVtKSk7XG4gICAgLy8gdGFyZ2V0IHZhbHVlc1xuICAgIGxldCB0YXJnZXRYID0gTWF0aC5tYXgoeCArIGR4LCAwKTtcbiAgICBsZXQgdGFyZ2V0WSA9IHkgKyBkeTtcblxuICAgIC8vIGxvY2sgaW4gbGF5ZXIncyB5IGF4aXNcbiAgICBpZiAodGFyZ2V0WSA+IGxheWVySGVpZ2h0KSB7XG4gICAgICB0YXJnZXRZID0gbGF5ZXJIZWlnaHQ7XG4gICAgfSBlbHNlIGlmICh0YXJnZXRZIC0gKGxheWVySGVpZ2h0IC0gaGVpZ2h0KSA8IDApIHtcbiAgICAgIHRhcmdldFkgPSAobGF5ZXJIZWlnaHQgLSBoZWlnaHQpO1xuICAgIH1cblxuICAgIHNoYXBlLngoZGF0dW0sIHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFgpKTtcbiAgICBzaGFwZS55KGRhdHVtLCByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbC5pbnZlcnQodGFyZ2V0WSkpO1xuXG4gICAgY29uc3Qgc25hcHBlZFggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKE1hdGgucm91bmQoc2hhcGUueChkYXR1bSkpKTtcblxuICAgIHNoYXBlLngoZGF0dW0sIHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHNuYXBwZWRYKSk7XG4gIH1cblxuICBfcmVzaXplTGVmdChyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgLy8gY3VycmVudCB2YWx1ZXNcbiAgICBjb25zdCB4ICAgICA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoc2hhcGUueChkYXR1bSkpO1xuICAgIGNvbnN0IHdpZHRoID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS53aWR0aChkYXR1bSkpO1xuICAgIC8vIHRhcmdldCB2YWx1ZXNcbiAgICBsZXQgbWF4VGFyZ2V0WCAgPSB4ICsgd2lkdGg7XG4gICAgbGV0IHRhcmdldFggICAgID0geCArIGR4IDwgbWF4VGFyZ2V0WCA/IE1hdGgubWF4KHggKyBkeCwgMCkgOiB4O1xuICAgIGxldCB0YXJnZXRXaWR0aCA9IHRhcmdldFggIT09IDAgPyBNYXRoLm1heCh3aWR0aCAtIGR4LCAxKSA6IHdpZHRoO1xuXG4gICAgc2hhcGUueChkYXR1bSwgcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0WCkpO1xuICAgIHNoYXBlLndpZHRoKGRhdHVtLCByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRXaWR0aCkpO1xuICB9XG5cbiAgX3Jlc2l6ZVJpZ2h0KHJlbmRlcmluZ0NvbnRleHQsIHNoYXBlLCBkYXR1bSwgZHgsIGR5LCB0YXJnZXQpIHtcbiAgICAvLyBjdXJyZW50IHZhbHVlc1xuICAgIGNvbnN0IHdpZHRoID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS53aWR0aChkYXR1bSkpO1xuICAgIC8vIHRhcmdldCB2YWx1ZXNcbiAgICBsZXQgdGFyZ2V0V2lkdGggPSBNYXRoLm1heCh3aWR0aCArIGR4LCAxKTtcblxuICAgIHNoYXBlLndpZHRoKGRhdHVtLCByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRXaWR0aCkpO1xuICB9XG5cbiAgc2VsZWN0KGRhdHVtKSB7XG4gICAgc3VwZXIuc2VsZWN0KGRhdHVtKTtcbiAgICB0aGlzLmhpZ2hsaWdodChkYXR1bSwgdHJ1ZSk7XG4gIH1cblxuICB1bnNlbGVjdChkYXR1bSkge1xuICAgIHN1cGVyLnVuc2VsZWN0KGRhdHVtKTtcbiAgICB0aGlzLmhpZ2hsaWdodChkYXR1bSwgZmFsc2UpO1xuICB9XG5cbiAgaGlnaGxpZ2h0KGRhdHVtLCBpc0hpZ2hsaWdodGVkKSB7XG4gICAgY29uc3Qgc2hhcGUgPSB0aGlzLl9sYXllci5nZXRTaGFwZUZyb21EYXR1bShkYXR1bSk7XG4gICAgaWYgKHNoYXBlKSB7XG4gICAgICBpZiAoaXNIaWdobGlnaHRlZCkge1xuICAgICAgICBzaGFwZS5wYXJhbXMuY29sb3IgPSAncmVkJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNoYXBlLnBhcmFtcy5jb2xvciA9ICdibGFjayc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2hhcGUgZm9yIHRoaXMgZGF0dW0gaW4gdGhpcyBsYXllcicsIHsgZGF0dW06IGRhdHVtLCBsYXllcjogdGhpcy5fbGF5ZXIgfSk7XG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgQmFzZUJlaGF2aW9yIGZyb20gJy4vYmFzZS1iZWhhdmlvcic7XG5cbi8qKlxuKiBUaW1lQ29udGV4dEJlaGF2aW9yIGlzIHVzZWQgaW50ZXJuYWxseSBpbiBMYXllcnMgdG8gbW9kaWZ5IHRoZWlyIFRpbWVDb250ZXh0LlxuKiBUaGlzIG9iamVjdCBpcyBkaWZmZXJlbnQgZnJvbSBvdGhlciBTaGFwZXMgQmVoYXZpb3JzIGFuZCBleGlzdHMgbW9zdGx5IHRvIGRlY3JlYXNlIHRoZSBzaXplIG9mIHRoZSBMYXllci5cbiogQWxsIHRoZSBjb2RlIGhlcmUgY291bGQgYmUgY29uc2lkZXJlZCBhcyBwYXJ0IG9mIHRoZSBsYXllci5cbiovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lQ29udGV4dEJlaGF2aW9yIGV4dGVuZHMgQmFzZUJlaGF2aW9yIHtcblx0ZWRpdChsYXllciwgZHgsIGR5LCB0YXJnZXQpIHtcblx0XHRjb25zdCB0aW1lQ29udGV4dCA9IGxheWVyLnRpbWVDb250ZXh0O1xuXG5cdFx0aWYgKHRhcmdldC5oYXNOYW1lKCdoYW5kbGVyJykpIHtcblx0XHRcdGlmICh0YXJnZXQuaGFzTmFtZSgnbGVmdCcpKSBcblx0XHRcdFx0dGhpcy5fZWRpdExlZnQodGltZUNvbnRleHQsIGR4KTtcblx0XHRcdGVsc2UgaWYgKHRhcmdldC5oYXNOYW1lKCdyaWdodCcpKSBcblx0XHRcdFx0dGhpcy5fZWRpdFJpZ2h0KHRpbWVDb250ZXh0LCBkeCk7XG5cdFx0XHRlbHNlIFxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQga29udmEgc2hhcGUgbmFtZScpO1xuXHRcdH0gZWxzZSBpZiAodGFyZ2V0Lmhhc05hbWUoJ3NlZ21lbnQnKSkgXG5cdFx0XHR0aGlzLl9tb3ZlKHRpbWVDb250ZXh0LCBkeCk7XG5cdFx0ZWxzZSBcblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBrb252YSBzaGFwZSBuYW1lJyk7XG5cdH1cblxuXHRfZWRpdExlZnQodGltZUNvbnRleHQsIGR4KSB7XG5cdFx0Ly8gZWRpdCBgc3RhcnRgLCBgb2Zmc2V0YCBhbmQgYGR1cmF0aW9uYFxuXHRcdGNvbnN0IHggPSB0aW1lQ29udGV4dC5wYXJlbnQudGltZVRvUGl4ZWwodGltZUNvbnRleHQuc3RhcnQpO1xuXHRcdGNvbnN0IG9mZnNldCA9IHRpbWVDb250ZXh0LnRpbWVUb1BpeGVsKHRpbWVDb250ZXh0Lm9mZnNldCk7XG5cdFx0Y29uc3Qgd2lkdGggPSB0aW1lQ29udGV4dC50aW1lVG9QaXhlbCh0aW1lQ29udGV4dC5kdXJhdGlvbik7XG5cblx0XHRjb25zdCB0YXJnZXRYID0geCArIGR4O1xuXHRcdGNvbnN0IHRhcmdldE9mZnNldCA9IG9mZnNldCAtIGR4O1xuXHRcdGNvbnN0IHRhcmdldFdpZHRoID0gTWF0aC5tYXgod2lkdGggLSBkeCwgMSk7XG5cblx0XHR0aW1lQ29udGV4dC5zdGFydCA9IHRpbWVDb250ZXh0LnBhcmVudC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0WCk7XG5cdFx0dGltZUNvbnRleHQub2Zmc2V0ID0gdGltZUNvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldE9mZnNldCk7XG5cdFx0dGltZUNvbnRleHQuZHVyYXRpb24gPSB0aW1lQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0V2lkdGgpO1xuXHR9XG5cblx0X2VkaXRSaWdodCh0aW1lQ29udGV4dCwgZHgpIHtcblx0XHRjb25zdCB3aWR0aCA9IHRpbWVDb250ZXh0LnRpbWVUb1BpeGVsKHRpbWVDb250ZXh0LmR1cmF0aW9uKTtcblx0XHRjb25zdCB0YXJnZXRXaWR0aCA9IE1hdGgubWF4KHdpZHRoICsgZHgsIDEpO1xuXG5cdFx0dGltZUNvbnRleHQuZHVyYXRpb24gPSB0aW1lQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0V2lkdGgpO1xuXHR9XG5cblx0X21vdmUodGltZUNvbnRleHQsIGR4KSB7XG5cdFx0Y29uc3QgeCA9IHRpbWVDb250ZXh0LnBhcmVudC50aW1lVG9QaXhlbCh0aW1lQ29udGV4dC5zdGFydCk7XG5cdFx0Y29uc3QgdGFyZ2V0WCA9IE1hdGgubWF4KHggKyBkeCwgMCk7XG5cblx0XHR0aW1lQ29udGV4dC5zdGFydCA9IHRpbWVDb250ZXh0LnBhcmVudC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0WCk7XG5cdH1cblxuXHRzdHJldGNoKGxheWVyLCBkeCwgZHksIHRhcmdldCkge1xuXHRcdGNvbnN0IHRpbWVDb250ZXh0ID0gbGF5ZXIudGltZUNvbnRleHQ7XG5cdFx0Y29uc3QgbGFzdER1cmF0aW9uID0gdGltZUNvbnRleHQuZHVyYXRpb247XG5cdFx0Y29uc3QgbGFzdE9mZnNldCA9IHRpbWVDb250ZXh0Lm9mZnNldDtcblxuXHRcdHRoaXMuZWRpdChsYXllciwgZHgsIGR5LCB0YXJnZXQpO1xuXG5cdFx0Y29uc3QgbmV3RHVyYXRpb24gPSB0aW1lQ29udGV4dC5kdXJhdGlvbjtcblx0XHRjb25zdCByYXRpbyA9IChuZXdEdXJhdGlvbiAvIGxhc3REdXJhdGlvbik7XG5cblx0XHR0aW1lQ29udGV4dC5zdHJldGNoUmF0aW8gKj0gcmF0aW87XG5cdFx0dGltZUNvbnRleHQub2Zmc2V0ID0gbGFzdE9mZnNldDtcblx0XHR0aW1lQ29udGV4dC5kdXJhdGlvbiA9IGxhc3REdXJhdGlvbjtcblx0fVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEJhc2VCZWhhdmlvciBmcm9tICcuL2Jhc2UtYmVoYXZpb3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFjZUJlaGF2aW9yIGV4dGVuZHMgQmFzZUJlaGF2aW9yIHtcbiAgZWRpdChyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5oYXNOYW1lKCdtaW4nKSkge1xuICAgICAgdGhpcy5fZWRpdFJhbmdlKHJlbmRlcmluZ0NvbnRleHQsIHNoYXBlLCBkYXR1bSwgZHgsIC1keSwgJ21pbicpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0Lmhhc05hbWUoJ21heCcpKSB7XG4gICAgICB0aGlzLl9lZGl0UmFuZ2UocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgLWR5LCAnbWF4Jyk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQuaGFzTmFtZSgnbWVhbicpKSB7XG4gICAgICB0aGlzLl9lZGl0TWVhbihyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCAtZHkpO1xuICAgIH0gZWxzZSBcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBrb252YSBzaGFwZSBuYW1lJyk7XG4gIH1cblxuICBfZWRpdE1lYW4ocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHkpIHtcbiAgICAvLyB3b3JrIGluIHBpeGVsIGRvbWFpblxuICAgIGNvbnN0IHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHNoYXBlLngoZGF0dW0pKTtcbiAgICBjb25zdCB5ID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwoc2hhcGUubWVhbihkYXR1bSkpO1xuXG4gICAgbGV0IHRhcmdldFggPSB4ICsgZHg7XG4gICAgbGV0IHRhcmdldFkgPSB5IC0gZHk7XG5cbiAgICBzaGFwZS54KGRhdHVtLCByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRYKSk7XG4gICAgc2hhcGUubWVhbihkYXR1bSwgcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwuaW52ZXJ0KHRhcmdldFkpKTtcbiAgfVxuXG4gIF9lZGl0UmFuZ2UocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHJhbmdlU2lkZSkge1xuICAgIGNvbnN0IHJhbmdlID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwoc2hhcGUucmFuZ2UoZGF0dW0pKTtcblxuICAgIGxldCB0YXJnZXRSYW5nZSA9IHJhbmdlU2lkZSA9PT0gJ21pbicgPyByYW5nZSArIDIgKiBkeSA6IHJhbmdlIC0gMiAqIGR5O1xuICAgIHRhcmdldFJhbmdlID0gTWF0aC5tYXgodGFyZ2V0UmFuZ2UsIDApO1xuXG4gICAgc2hhcGUucmFuZ2UoZGF0dW0sIE1hdGgubWF4KDAsIHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsLmludmVydCh0YXJnZXRSYW5nZSkpKTtcbiAgfVxuXG4gIHNlbGVjdChkYXR1bSkge1xuICAgIHN1cGVyLnNlbGVjdChkYXR1bSk7XG4gICAgdGhpcy5oaWdobGlnaHQoZGF0dW0sIHRydWUpO1xuICB9XG5cbiAgdW5zZWxlY3QoZGF0dW0pIHtcbiAgICBzdXBlci51bnNlbGVjdChkYXR1bSk7XG4gICAgdGhpcy5oaWdobGlnaHQoZGF0dW0sIGZhbHNlKTtcbiAgfVxuXG4gIGhpZ2hsaWdodChkYXR1bSwgaXNIaWdobGlnaHRlZCkge1xuICAgIGNvbnN0IHNoYXBlID0gdGhpcy5fbGF5ZXIuZ2V0U2hhcGVGcm9tRGF0dW0oZGF0dW0pO1xuICAgIGlmIChzaGFwZSkge1xuICAgICAgaWYgKGlzSGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgc2hhcGUucGFyYW1zLm1lYW5Db2xvciA9ICdyZWQnO1xuICAgICAgICBzaGFwZS5wYXJhbXMucmFuZ2VDb2xvciA9ICdyZWQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdHMgPSBzaGFwZS5fZ2V0RGVmYXVsdHMoKTtcbiAgICAgICAgc2hhcGUucGFyYW1zLm1lYW5Db2xvciA9IGRlZmF1bHRzLm1lYW5Db2xvcjtcbiAgICAgICAgc2hhcGUucGFyYW1zLnJhbmdlQ29sb3IgPSBkZWZhdWx0cy5yYW5nZUNvbG9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNoYXBlIGZvciB0aGlzIGRhdHVtIGluIHRoaXMgbGF5ZXInLCB7IGRhdHVtOiBkYXR1bSwgbGF5ZXI6IHRoaXMuX2xheWVyIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEJhc2VCZWhhdmlvciBmcm9tICcuL2Jhc2UtYmVoYXZpb3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXYXZlZm9ybUJlaGF2aW9yIGV4dGVuZHMgQmFzZUJlaGF2aW9yIHtcbiAgZWRpdChyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgbGV0IGFjdGlvbiA9ICdtb3ZlJztcblxuICAgIGlmICh0YXJnZXQuaGFzTmFtZSgnaGFuZGxlcicpKSB7XG4gICAgICBpZiAodGFyZ2V0Lmhhc05hbWUoJ2xlZnQnKSkgXG4gICAgICAgIGFjdGlvbiA9ICdyZXNpemVMZWZ0JztcbiAgICAgIGVsc2UgaWYgKHRhcmdldC5oYXNOYW1lKCdyaWdodCcpKSBcbiAgICAgICAgYWN0aW9uID0gJ3Jlc2l6ZVJpZ2h0JztcbiAgICAgIGVsc2UgXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBrb252YSBzaGFwZSBuYW1lJyk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQuaGFzTmFtZSgnYm9keScpKSB7XG4gICAgICBhY3Rpb24gPSAnbW92ZSc7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQuaGFzTmFtZSgnaGVhZGVyJykpIHtcbiAgICAgIC8vIFRPRE9cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQga29udmEgc2hhcGUgbmFtZScpO1xuXG4gICAgdGhpc1tgXyR7YWN0aW9ufWBdKHJlbmRlcmluZ0NvbnRleHQsIHNoYXBlLCBkYXR1bSwgZHgsIGR5LCB0YXJnZXQpO1xuICB9XG5cbiAgX21vdmUocmVuZGVyaW5nQ29udGV4dCwgc2hhcGUsIGRhdHVtLCBkeCwgZHksIHRhcmdldCkge1xuICAgIGNvbnN0IGxheWVySGVpZ2h0ID0gcmVuZGVyaW5nQ29udGV4dC5oZWlnaHQ7XG4gICAgLy8gY3VycmVudCB2YWx1ZXNcbiAgICBjb25zdCB4ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS54KGRhdHVtKSk7XG4gICAgLy8gY29uc3QgeSA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHNoYXBlLnkoZGF0dW0pKTtcbiAgICBjb25zdCB5ID0gMDtcbiAgICBjb25zdCB3aWR0aCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoc2hhcGUud2lkdGgoZGF0dW0pKTtcbiAgICAvLyBjb25zdCBoZWlnaHQgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbChzaGFwZS5oZWlnaHQoZGF0dW0pKTtcbiAgICBjb25zdCBoZWlnaHQgPSByZW5kZXJpbmdDb250ZXh0LmhlaWdodDtcbiAgICAvLyB0YXJnZXQgdmFsdWVzXG4gICAgbGV0IHRhcmdldFggPSBNYXRoLm1heCh4ICsgZHgsIDApO1xuICAgIGxldCB0YXJnZXRZID0geSArIGR5O1xuXG4gICAgLy8gbG9jayBpbiBsYXllcidzIHkgYXhpc1xuICAgIGlmICh0YXJnZXRZID4gbGF5ZXJIZWlnaHQpIHtcbiAgICAgIHRhcmdldFkgPSBsYXllckhlaWdodDtcbiAgICB9IGVsc2UgaWYgKHRhcmdldFkgLSAobGF5ZXJIZWlnaHQgLSBoZWlnaHQpIDwgMCkge1xuICAgICAgdGFyZ2V0WSA9IChsYXllckhlaWdodCAtIGhlaWdodCk7XG4gICAgfVxuXG4gICAgc2hhcGUueChkYXR1bSwgcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0WCkpO1xuICAgIC8vIHNoYXBlLnkoZGF0dW0sIHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsLmludmVydCh0YXJnZXRZKSk7XG4gIH1cblxuICBfcmVzaXplTGVmdChyZW5kZXJpbmdDb250ZXh0LCBzaGFwZSwgZGF0dW0sIGR4LCBkeSwgdGFyZ2V0KSB7XG4gICAgLy8gcmV0dXJuOyAvLyBUT0RPOiB1cGRhdGUgdGhpcyBmb3IgdGhlIHdhdmVmb3JtIHNoYXBlXG4gICAgLy8gY3VycmVudCB2YWx1ZXNcbiAgICBjb25zdCB4ICAgICA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwoc2hhcGUueChkYXR1bSkpO1xuICAgIGNvbnN0IHdpZHRoID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS53aWR0aChkYXR1bSkpO1xuICAgIC8vIHRhcmdldCB2YWx1ZXNcbiAgICBsZXQgbWF4VGFyZ2V0WCAgPSB4ICsgd2lkdGg7XG4gICAgbGV0IHRhcmdldFggICAgID0geCArIGR4IDwgbWF4VGFyZ2V0WCA/IE1hdGgubWF4KHggKyBkeCwgMCkgOiB4O1xuICAgIGxldCB0YXJnZXRXaWR0aCA9IHRhcmdldFggIT09IDAgPyBNYXRoLm1heCh3aWR0aCAtIGR4LCAxKSA6IHdpZHRoO1xuXG4gICAgc2hhcGUueChkYXR1bSwgcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQodGFyZ2V0WCkpO1xuICAgIHNoYXBlLndpZHRoKGRhdHVtLCByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRXaWR0aCkpO1xuICB9XG5cbiAgX3Jlc2l6ZVJpZ2h0KHJlbmRlcmluZ0NvbnRleHQsIHNoYXBlLCBkYXR1bSwgZHgsIGR5LCB0YXJnZXQpIHtcbiAgICAvLyByZXR1cm47IC8vIFRPRE86IHVwZGF0ZSB0aGlzIGZvciB0aGUgd2F2ZWZvcm0gc2hhcGVcbiAgICAvLyBjdXJyZW50IHZhbHVlc1xuICAgIGNvbnN0IHdpZHRoID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChzaGFwZS53aWR0aChkYXR1bSkpO1xuICAgIC8vIHRhcmdldCB2YWx1ZXNcbiAgICBsZXQgdGFyZ2V0V2lkdGggPSBNYXRoLm1heCh3aWR0aCArIGR4LCAxKTtcblxuICAgIHNoYXBlLndpZHRoKGRhdHVtLCByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydCh0YXJnZXRXaWR0aCkpO1xuICB9XG5cbiAgc2VsZWN0KGRhdHVtKSB7XG4gICAgc3VwZXIuc2VsZWN0KGRhdHVtKTtcbiAgICB0aGlzLmhpZ2hsaWdodChkYXR1bSwgdHJ1ZSk7XG4gIH1cblxuICB1bnNlbGVjdChkYXR1bSkge1xuICAgIHN1cGVyLnVuc2VsZWN0KGRhdHVtKTtcbiAgICB0aGlzLmhpZ2hsaWdodChkYXR1bSwgZmFsc2UpO1xuICB9XG5cbiAgaGlnaGxpZ2h0KGRhdHVtLCBpc0hpZ2hsaWdodGVkKSB7XG4gICAgY29uc3Qgc2hhcGUgPSB0aGlzLl9sYXllci5nZXRTaGFwZUZyb21EYXR1bShkYXR1bSk7XG4gICAgaWYgKHNoYXBlKSB7XG4gICAgICAvLyBpZiAoaXNIaWdobGlnaHRlZCkge1xuICAgICAgLy8gICBzaGFwZS5wYXJhbXMuY29sb3IgPSAncmVkJztcbiAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAvLyAgIHNoYXBlLnBhcmFtcy5jb2xvciA9ICdibGFjayc7XG4gICAgICAvLyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2hhcGUgZm9yIHRoaXMgZGF0dW0gaW4gdGhpcyBsYXllcicsIHsgZGF0dW06IGRhdHVtLCBsYXllcjogdGhpcy5fbGF5ZXIgfSk7XG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgc2NhbGVzIGZyb20gJy4uL3V0aWxzL3NjYWxlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExheWVyVGltZUNvbnRleHQge1xuICAvKipcbiAgICogQHBhcmFtIHtUaW1lbGluZVRpbWVDb250ZXh0fSBwYXJlbnQgLSBUaGUgYFRpbWVsaW5lVGltZUNvbnRleHRgIGluc3RhbmNlIG9mIHRoZSB0aW1lbGluZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIGlmICghcGFyZW50KSB7IHRocm93IG5ldyBFcnJvcignTGF5ZXJUaW1lQ29udGV4dCBtdXN0IGhhdmUgYSBwYXJlbnQnKTsgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGBUaW1lbGluZVRpbWVDb250ZXh0YCBpbnN0YW5jZSBvZiB0aGUgdGltZWxpbmUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7VGltZWxpbmVUaW1lQ29udGV4dH1cbiAgICAgKi9cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLl9sb2NrZWRUb1BhcmVudEludGVydmFsID0gZmFsc2U7XG5cbiAgICB0aGlzLl90aW1lVG9QaXhlbCA9IG51bGw7XG4gICAgdGhpcy5fc3RhcnQgPSAwO1xuICAgIHRoaXMuX2R1cmF0aW9uID0gcGFyZW50LnZpc2libGVEdXJhdGlvbjtcbiAgICB0aGlzLl9vZmZzZXQgPSAwO1xuICAgIHRoaXMuX3N0cmV0Y2hSYXRpbyA9IDE7XG4gICAgLy8gcmVnaXN0ZXIgaW50byB0aGUgdGltZWxpbmUncyBUaW1lQ29udGV4dFxuICAgIHRoaXMucGFyZW50Ll9jaGlsZHJlbi5wdXNoKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgY3VycmVudCB0aW1lIGNvbnRleHQuXG4gICAqXG4gICAqIEByZXR1cm4ge0xheWVyVGltZUNvbnRleHR9XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjdHggPSBuZXcgdGhpcygpO1xuXG4gICAgY3R4LnBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgIGN0eC5zdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgY3R4LmR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbjtcbiAgICBjdHgub2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgY3R4LnN0cmV0Y2hSYXRpbyA9IHRoaXMuc3RyZXRjaFJhdGlvOyAvLyBjcmVhdGVzIHRoZSBsb2NhbCBzY2FsZSBpZiBuZWVkZWRcblxuICAgIHJldHVybiBjdHg7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHRpbWUgY29udGV4dCAoaW4gc2Vjb25kcykuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgc3RhcnQoKSB7XG4gICAgcmV0dXJuICghdGhpcy5fbG9ja2VkVG9QYXJlbnRJbnRlcnZhbCk/IHRoaXMuX3N0YXJ0IDogLXRoaXMucGFyZW50Lm9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgdGltZSBjb250ZXh0IChpbiBzZWNvbmRzKS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHNldCBzdGFydCh2YWx1ZSkge1xuICAgIHRoaXMuX3N0YXJ0ID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZHVyYXRpb24gb2YgdGhlIHRpbWUgY29udGV4dCAoaW4gc2Vjb25kcykuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgZHVyYXRpb24oKSB7XG4gICAgcmV0dXJuICghdGhpcy5fbG9ja2VkVG9QYXJlbnRJbnRlcnZhbCk/IHRoaXMuX2R1cmF0aW9uIDogdGhpcy5wYXJlbnQudmlzaWJsZUR1cmF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGR1cmF0aW9uIG9mIHRoZSB0aW1lIGNvbnRleHQgKGluIHNlY29uZHMpLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgc2V0IGR1cmF0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQgb2YgdGhlIHRpbWUgY29udGV4dCAoaW4gc2Vjb25kcykuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgb2Zmc2V0KCkge1xuICAgIHJldHVybiAoIXRoaXMuX2xvY2tlZFRvUGFyZW50SW50ZXJ2YWwpPyB0aGlzLl9vZmZzZXQgOiB0aGlzLnBhcmVudC5vZmZzZXQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgb2Zmc2V0IG9mIHRoZSB0aW1lIGNvbnRleHQgKGluIHNlY29uZHMpLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgc2V0IG9mZnNldCh2YWx1ZSkge1xuICAgIHRoaXMuX29mZnNldCA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0cmV0Y2ggcmF0aW8gb2YgdGhlIHRpbWUgY29udGV4dC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBzdHJldGNoUmF0aW8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmV0Y2hSYXRpbztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdHJldGNoIHJhdGlvIG9mIHRoZSB0aW1lIGNvbnRleHQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBzZXQgc3RyZXRjaFJhdGlvKHZhbHVlKSB7XG4gICAgLy8gcmVtb3ZlIGxvY2FsIHNjYWxlIGlmIHJhdGlvID0gMVxuICAgIGlmICh2YWx1ZSA9PT0gIDEpIHtcbiAgICAgIHRoaXMuX3RpbWVUb1BpeGVsID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gcmV1c2UgcHJldmlzb3VzbHkgY3JlYXRlZCBsb2NhbCBzY2FsZSBpZiBleGlzdHNcbiAgICBjb25zdCB0aW1lVG9QaXhlbCA9IHRoaXMuX3RpbWVUb1BpeGVsID9cbiAgICAgIHRoaXMuX3RpbWVUb1BpeGVsIDogc2NhbGVzLmxpbmVhcigpLmRvbWFpbihbMCwgMV0pO1xuXG4gICAgdGltZVRvUGl4ZWwucmFuZ2UoWzAsIHRoaXMucGFyZW50LmNvbXB1dGVkUGl4ZWxzUGVyU2Vjb25kICogdmFsdWVdKTtcblxuICAgIHRoaXMuX3RpbWVUb1BpeGVsID0gdGltZVRvUGl4ZWw7XG4gICAgdGhpcy5fc3RyZXRjaFJhdGlvID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGltZSB0byBwaXhlbCB0cmFuc2ZlcnQgZnVuY3Rpb24gb2YgdGhlIHRpbWUgY29udGV4dC4gSWZcbiAgICogdGhlIGBzdHJldGNoUmF0aW9gIGF0dHJpYnV0ZSBpcyBlcXVhbCB0byAxLCB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBnbG9iYWxcbiAgICogb25lIGZyb20gdGhlIGBUaW1lbGluZVRpbWVDb250ZXh0YCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgZ2V0IHRpbWVUb1BpeGVsKCkge1xuICAgIGlmICghdGhpcy5fdGltZVRvUGl4ZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC50aW1lVG9QaXhlbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fdGltZVRvUGl4ZWw7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgcGl4ZWwgdG8gdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHB4XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIHBpeGVsVG9UaW1lKHB4KSB7XG4gICAgaWYgKCF0aGlzLl90aW1lVG9QaXhlbCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnRpbWVUb1BpeGVsLmludmVydChweCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3RpbWVUb1BpeGVsLmludmVydChweCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0aW1lIGludGVydmFsIG9mIHRoZSB2aXNpYmxlIGFyZWEgaW4gdGhlIHRpbWVsaW5lLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fSBcbiAgICovXG4gIGdldCB2aXNpYmxlSW50ZXJ2YWwoKSB7XG4gICAgdmFyIGludGVydmFsID0ge307XG4gICAgaW50ZXJ2YWwuc3RhcnQgPSAtdGhpcy5vZmZzZXQ7XG4gICAgaW50ZXJ2YWwuZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xuICAgIHJldHVybiBpbnRlcnZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb2N1cyB0aGUgdGltZWxpbmUgdmlzaWJsZSBhcmVhIGluIHRoZSBwcm92aWRlZCB0aW1lIGludGVydmFsLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fSBcbiAgICovXG4gIHNldCB2aXNpYmxlSW50ZXJ2YWwodmFsdWUpIHtcbiAgICB0aGlzLm9mZnNldCA9IC12YWx1ZS5zdGFydDtcbiAgICB0aGlzLmR1cmF0aW9uID0gdmFsdWUuZHVyYXRpb247XG4gIH1cblxuICAvKipcbiAgICogIFRPRE9cbiAgICovXG4gIGdldCBsb2NrZWRUb1BhcmVudEludGVydmFsKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NrZWRUb1BhcmVudEludGVydmFsO1xuICB9XG5cbiAgc2V0IGxvY2tlZFRvUGFyZW50SW50ZXJ2YWwodmFsdWUpIHtcbiAgICB0aGlzLl9sb2NrZWRUb1BhcmVudEludGVydmFsID0gdmFsdWU7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBzY2FsZXMgZnJvbSAnLi4vdXRpbHMvc2NhbGVzJztcbmltcG9ydCBldmVudHMgZnJvbSAnZXZlbnRzJztcbmltcG9ydCBTZWdtZW50IGZyb20gJy4uL3NoYXBlcy9zZWdtZW50JztcbmltcG9ydCBUaW1lQ29udGV4dEJlaGF2aW9yIGZyb20gJy4uL2JlaGF2aW9ycy90aW1lLWNvbnRleHQtYmVoYXZpb3InO1xuaW1wb3J0IEtvbnZhIGZyb20gJ2tvbnZhJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5ZXIgZXh0ZW5kcyBldmVudHMuRXZlbnRFbWl0dGVyIHtcblxuXHRjb25zdHJ1Y3RvcihkYXRhVHlwZSwgZGF0YSwgb3B0aW9ucykge1xuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmRhdGFUeXBlID0gZGF0YVR5cGU7XG5cblx0XHRpZiAoIW9wdGlvbnMpIFxuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXG5cdFx0Y29uc3QgZGVmYXVsdHMgPSB7XG5cdFx0XHRoZWlnaHQ6IDEwMCxcblx0XHRcdHRvcDogMCxcblx0XHRcdG9wYWNpdHk6IDEsXG5cdFx0XHR5RG9tYWluOiBbMCwgMV0sXG5cdFx0XHRjbGFzc05hbWU6IG51bGwsIC8vIFRPRE9cblx0XHRcdHNlbGVjdGVkQ2xhc3NOYW1lOiAnc2VsZWN0ZWQnLFxuXHRcdFx0Y29udGV4dDoge1xuXHRcdFx0XHRoYW5kbGVyV2lkdGg6IDEwLFxuXHRcdFx0XHRoYW5kbGVyT3BhY2l0eTogMC4yLFxuXHRcdFx0XHRvcGFjaXR5OiAwLjUsIFxuXHRcdFx0XHRjb2xvcjogJyM3ODc4NzgnLFxuXHRcdFx0fSwgXG5cdFx0XHRoaXR0YWJsZTogdHJ1ZSwgLy8gd2hlbiBmYWxzZSB0aGUgbGF5ZXIgaXMgbm90IHJldHVybmVkIGJ5IGBCYXNlU3RhdGUuZ2V0SGl0TGF5ZXJzYFxuXHRcdH07XG5cblx0XHR0aGlzLl9iZWhhdmlvciA9IG51bGw7XG5cblx0XHQvKipcblx0XHQqIFBhcmFtZXRlcnMgb2YgdGhlIGxheWVycywgYGRlZmF1bHRzYCBvdmVycmlkZWQgd2l0aCBvcHRpb25zLlxuXHRcdCogQHR5cGUge09iamVjdH1cblx0XHQqL1xuXHRcdHRoaXMucGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuXHRcdHRoaXMudGltZUNvbnRleHRCZWhhdmlvciA9IG5ldyBUaW1lQ29udGV4dEJlaGF2aW9yKCk7XG5cblx0XHR0aGlzLl9zaGFwZUNvbmZpZ3VyYXRpb24gPSBudWxsO1x0XHRcdCAvLyB7IGN0b3IsIGFjY2Vzc29ycywgb3B0aW9ucyB9XG5cdFx0dGhpcy5fY29tbW9uU2hhcGVDb25maWd1cmF0aW9uID0gbnVsbDsgLy8geyBjdG9yLCBhY2Nlc3NvcnMsIG9wdGlvbnMgfVxuXHRcdHRoaXMuXyRkYXR1bVRvU2hhcGUgPSBuZXcgTWFwKCk7XG5cdFx0dGhpcy5fJHNoYXBlVG9EYXR1bSA9IG5ldyBNYXAoKTtcblx0XHR0aGlzLl9jb21tb25TaGFwZSA9IG51bGw7XG5cdFx0dGhpcy5fcmVuZGVyaW5nQ29udGV4dCA9IHt9O1xuXHRcdHRoaXMuZGF0YSA9IFtdO1xuXG5cdFx0dGhpcy5faXNDb250ZXh0RWRpdGFibGUgPSBmYWxzZTtcblxuXHRcdHRoaXMuX3ZhbHVlVG9QaXhlbCA9IHNjYWxlcy5saW5lYXIoKVxuXHRcdFx0LmRvbWFpbih0aGlzLnBhcmFtcy55RG9tYWluKVxuXHRcdFx0LnJhbmdlKFt0aGlzLnBhcmFtcy5oZWlnaHQsIDBdKTtcblxuXHRcdHRoaXMuY29udGVudExheWVycyA9IG5ldyBTZXQoKTtcblxuXHRcdHRoaXMuX2RyYWdMYXllciA9IG5ldyBLb252YS5MYXllcih7fSk7XG5cblx0XHR0aGlzLl9jb21tb25TaGFwZUxheWVyID0gbmV3IEtvbnZhLkZhc3RMYXllcih7fSk7XG5cdFx0dGhpcy5fY29tbW9uU2hhcGVMYXllci5hZGROYW1lKCdjb21tb24tc2hhcGUtbGF5ZXInKTtcblx0XHR0aGlzLl9jb21tb25TaGFwZUxheWVyLmxheWVyID0gdGhpcztcblxuXHRcdHRoaXMuX2NvbnRleHRMYXllciA9IG5ldyBLb252YS5MYXllcih7fSk7XG5cdFx0dGhpcy5fY29udGV4dExheWVyLmxheWVyID0gdGhpcztcblx0XHR0aGlzLl9jb250ZXh0TGF5ZXIuYWRkTmFtZSgnY29udGV4dC1sYXllcicpO1xuXG5cdFx0dGhpcy5zZXRDb250ZXh0RWRpdGFibGUodGhpcy5faXNDb250ZXh0RWRpdGFibGUpO1xuXHRcdFxuXHRcdHRoaXMuX2NvbnRleHRTaGFwZSA9IG5ldyBTZWdtZW50KHt9KTtcblx0XHR0aGlzLl9jb250ZXh0U2hhcGUuaW5zdGFsbCh7XG5cdFx0XHRvcGFjaXR5XHQ6ICgpID0+IDEsIFxuXHRcdFx0Y29sb3JcdDogKCkgPT4gdGhpcy5wYXJhbXMuY29udGV4dC5jb2xvciwgXG5cdFx0XHR3aWR0aFx0OiAoKSA9PiB0aGlzLnRpbWVDb250ZXh0LmR1cmF0aW9uLFxuXHRcdFx0aGVpZ2h0XHQ6ICgpID0+IHRoaXMuX3JlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsLmRvbWFpbigpWzFdLFxuXHRcdFx0eVx0XHQ6ICgpID0+IHRoaXMuX3JlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsLmRvbWFpbigpWzBdLFxuXHRcdFx0eFx0XHQ6ICgpID0+IHRoaXMudGltZUNvbnRleHQuc3RhcnQgLyB0aGlzLnRpbWVDb250ZXh0LnN0cmV0Y2hSYXRpb1xuXHRcdH0pOyBcblx0XHR0aGlzLl9jb250ZXh0U2hhcGUucGFyYW1zLmhhbmRsZXJXaWR0aCA9IHRoaXMucGFyYW1zLmNvbnRleHQuaGFuZGxlcldpZHRoO1xuXHRcdHRoaXMuX2NvbnRleHRTaGFwZS5yZW5kZXIodGhpcy5fcmVuZGVyaW5nQ29udGV4dCk7XG5cdFx0dGhpcy5fY29udGV4dFNoYXBlLmxheWVyID0gdGhpcztcblx0XHR0aGlzLl9jb250ZXh0U2hhcGUuaXNDb250ZXh0U2hhcGUgPSB0cnVlO1xuXHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLl9jb250ZXh0U2hhcGUuJGVsLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLl9jb250ZXh0TGF5ZXIuYWRkKHRoaXMuX2NvbnRleHRTaGFwZS4kZWxbaV0pO1xuXHRcdH1cblxuXHRcdHRoaXMuX3N0YWdlID0gbnVsbDtcblx0fVxuXG5cdGdldCB2aXNpYmxlKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnTGF5ZXIudmlzaWJsZSgpO1xuXHR9XG5cblx0c2V0IHZpc2libGUodmFsdWUpIHtcblx0XHR0aGlzLl9jb250ZXh0TGF5ZXIudmlzaWJsZSh2YWx1ZSk7XG5cdFx0dGhpcy5fY29tbW9uU2hhcGVMYXllci52aXNpYmxlKHZhbHVlKTtcblx0XHR0aGlzLl9kcmFnTGF5ZXIudmlzaWJsZSh2YWx1ZSk7XG5cdFx0dGhpcy5jb250ZW50TGF5ZXIuZm9yRWFjaCgobCkgPT4gbC52aXNpYmxlKHZhbHVlKSk7XG5cdH1cblxuXHRnZXQgekluZGV4KCkge1xuXHRcdHJldHVybiB0aGlzLl9jb250ZXh0TGF5ZXIuZ2V0WkluZGV4KCk7XG5cdH1cblxuXHRjcmVhdGVDb250YWluZXIoc3RhZ2UpIHtcblx0XHR0aGlzLl9zdGFnZSA9IHN0YWdlO1xuXG5cdFx0dGhpcy5fc3RhZ2UuYWRkKHRoaXMuX2NvbnRleHRMYXllcik7XG5cdFx0dGhpcy5fc3RhZ2UuYWRkKHRoaXMuX2NvbW1vblNoYXBlTGF5ZXIpO1xuXHRcdHRoaXMuX3N0YWdlLmFkZCh0aGlzLl9kcmFnTGF5ZXIpO1xuXHR9XG5cblxuXHRfZGVzdHJveShpdCkge1xuXHRcdHZhciBlbnRyeSA9IGl0Lm5leHQoKTtcblx0XHR3aGlsZSAoIWVudHJ5LmRvbmUpIHtcblx0XHRcdHZhciBsYXllciA9IGVudHJ5LnZhbHVlO1xuXHRcdFx0bGF5ZXIuZGVzdHJveSgpO1xuXHRcdH1cblx0fVxuXG5cdGRlc3Ryb3koKSB7XG5cdFx0dGhpcy5fY29udGV4dFNoYXBlLmRlc3Ryb3koKTtcblx0XHR0aGlzLl9kZXN0cm95KHRoaXMuXyRkYXR1bVRvU2hhcGUudmFsdWVzKCkpO1xuXHRcdHRoaXMuX2Rlc3Ryb3kodGhpcy5jb250ZW50TGF5ZXJzLnZhbHVlcyk7XG5cdFx0dGhpcy5jb250ZW50TGF5ZXJzLmNsZWFyKCk7XG5cblx0XHR0aGlzLl9jb21tb25TaGFwZUxheWVyID0gbnVsbDtcblx0XHR0aGlzLl9jb250ZXh0TGF5ZXIgPSBudWxsO1xuXHRcdHRoaXMuX2NvbnRleHRTaGFwZSA9IG51bGw7XG5cdFx0dGhpcy5fc3RhZ2UgPSBudWxsO1xuXHRcdHRoaXMucGFyYW1zID0gbnVsbDtcblx0XHR0aGlzLnRpbWVDb250ZXh0QmVoYXZpb3IgPSBudWxsO1xuXHRcdHRoaXMuX3NoYXBlQ29uZmlndXJhdGlvbiA9IG51bGw7XG5cdFx0dGhpcy5fY29tbW9uU2hhcGVDb25maWd1cmF0aW9uID0gbnVsbDtcblx0XHR0aGlzLl8kZGF0dW1Ub1NoYXBlID0gbnVsbDtcblx0XHR0aGlzLl8kc2hhcGVUb0RhdHVtID0gbnVsbDtcblx0XHR0aGlzLl9jb21tb25TaGFwZSA9IG51bGw7XG5cdFx0dGhpcy5fcmVuZGVyaW5nQ29udGV4dCA9IG51bGw7XG5cdFx0dGhpcy5faXNDb250ZXh0RWRpdGFibGUgPSBudWxsO1xuXHRcdHRoaXMuX2JlaGF2aW9yID0gbnVsbDtcblx0fVxuXG5cblxuXHQvKipcblx0ICogQWxsb3dzIHRvIG92ZXJyaWRlIGRlZmF1bHQgdGhlIGBUaW1lQ29udGV4dEJlaGF2aW9yYCB1c2VkIHRvIGVkaXQgdGhlIGxheWVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gY3RvclxuXHQgKi9cblx0c3RhdGljIGNvbmZpZ3VyZVRpbWVDb250ZXh0QmVoYXZpb3IoY3Rvcikge1xuXHRcdHRoaXMudGltZUNvbnRleHRCZWhhdmlvckN0b3IgPSBjdG9yO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYExheWVyVGltZUNvbnRleHRgJ3MgYHN0YXJ0YCB0aW1lIGRvbWFpbiB2YWx1ZS5cblx0ICpcblx0ICogQHR5cGUge051bWJlcn1cblx0ICovXG5cdGdldCBzdGFydCgpIHtcblx0XHRyZXR1cm4gdGhpcy50aW1lQ29udGV4dC5zdGFydDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIGBMYXllclRpbWVDb250ZXh0YCdzIGBzdGFydGAgdGltZSBkb21haW4gdmFsdWUuXG5cdCAqXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqL1xuXHRzZXQgc3RhcnQodmFsdWUpIHtcblx0XHR0aGlzLnRpbWVDb250ZXh0LnN0YXJ0ID0gdmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBgTGF5ZXJUaW1lQ29udGV4dGAncyBgb2Zmc2V0YCB0aW1lIGRvbWFpbiB2YWx1ZS5cblx0ICpcblx0ICogQHR5cGUge051bWJlcn1cblx0ICovXG5cdGdldCBvZmZzZXQoKSB7XG5cdFx0cmV0dXJuIHRoaXMudGltZUNvbnRleHQub2Zmc2V0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgYExheWVyVGltZUNvbnRleHRgJ3MgYG9mZnNldGAgdGltZSBkb21haW4gdmFsdWUuXG5cdCAqXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqL1xuXHRzZXQgb2Zmc2V0KHZhbHVlKSB7XG5cdFx0dGhpcy50aW1lQ29udGV4dC5vZmZzZXQgPSB2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGBMYXllclRpbWVDb250ZXh0YCdzIGBkdXJhdGlvbmAgdGltZSBkb21haW4gdmFsdWUuXG5cdCAqXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqL1xuXHRnZXQgZHVyYXRpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudGltZUNvbnRleHQuZHVyYXRpb247XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBgTGF5ZXJUaW1lQ29udGV4dGAncyBgZHVyYXRpb25gIHRpbWUgZG9tYWluIHZhbHVlLlxuXHQgKlxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKi9cblx0c2V0IGR1cmF0aW9uKHZhbHVlKSB7XG5cdFx0dGhpcy50aW1lQ29udGV4dC5kdXJhdGlvbiA9IHZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYExheWVyVGltZUNvbnRleHRgJ3MgYHN0cmV0Y2hSYXRpb2AgdGltZSBkb21haW4gdmFsdWUuXG5cdCAqXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqL1xuXHRnZXQgc3RyZXRjaFJhdGlvKCkge1xuXHRcdHJldHVybiB0aGlzLnRpbWVDb250ZXh0LnN0cmV0Y2hSYXRpbztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIGBMYXllclRpbWVDb250ZXh0YCdzIGBzdHJldGNoUmF0aW9gIHRpbWUgZG9tYWluIHZhbHVlLlxuXHQgKlxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKi9cblx0c2V0IHN0cmV0Y2hSYXRpbyh2YWx1ZSkge1xuXHRcdHRoaXMudGltZUNvbnRleHQuc3RyZXRjaFJhdGlvID0gdmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IHRoZSBkb21haW4gYm91bmRhcmllcyBvZiB0aGUgZGF0YSBmb3IgdGhlIHkgYXhpcy5cblx0ICpcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKi9cblx0c2V0IHlEb21haW4oZG9tYWluKSB7XG5cdFx0dGhpcy5wYXJhbXMueURvbWFpbiA9IGRvbWFpbjtcblx0XHR0aGlzLl92YWx1ZVRvUGl4ZWwuZG9tYWluKGRvbWFpbik7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZG9tYWluIGJvdW5kYXJpZXMgb2YgdGhlIGRhdGEgZm9yIHRoZSB5IGF4aXMuXG5cdCAqXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICovXG5cdGdldCB5RG9tYWluKCkge1xuXHRcdHJldHVybiB0aGlzLnBhcmFtcy55RG9tYWluO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIHdob2xlIGxheWVyLlxuXHQgKlxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKi9cblx0c2V0IG9wYWNpdHkodmFsdWUpIHtcblx0XHR0aGlzLnBhcmFtcy5vcGFjaXR5ID0gdmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgb3BhY2l0eSBvZiB0aGUgd2hvbGUgbGF5ZXIuXG5cdCAqXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqL1xuXHRnZXQgb3BhY2l0eSgpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJhbXMub3BhY2l0eTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0cmFuc2ZlcnQgZnVuY3Rpb24gdXNlZCB0byBkaXNwbGF5IHRoZSBkYXRhIGluIHRoZSB4IGF4aXMuXG5cdCAqXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqL1xuXHRnZXQgdGltZVRvUGl4ZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMudGltZUNvbnRleHQudGltZVRvUGl4ZWw7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdHJhbnNmZXJ0IGZ1bmN0aW9uIHVzZWQgdG8gZGlzcGxheSB0aGUgZGF0YSBpbiB0aGUgeSBheGlzLlxuXHQgKlxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKi9cblx0Z2V0IHZhbHVlVG9QaXhlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmFsdWVUb1BpeGVsO1xuXHR9XG5cblxuXG5cblxuXG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVyIHRoZSBiZWhhdmlvciB0byB1c2Ugd2hlbiBpbnRlcmFjdGluZyB3aXRoIGEgc2hhcGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QmFzZUJlaGF2aW9yfSBiZWhhdmlvclxuXHQgKi9cblx0c2V0QmVoYXZpb3IoYmVoYXZpb3IpIHtcblx0XHRiZWhhdmlvci5pbml0aWFsaXplKHRoaXMpO1xuXHRcdHRoaXMuX2JlaGF2aW9yID0gYmVoYXZpb3I7XG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKiogU0VMRUNUSU9OICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFxuXHRnZXQgc2VsZWN0ZWREYXR1bXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2JlaGF2aW9yID8gdGhpcy5fYmVoYXZpb3Iuc2VsZWN0ZWREYXR1bXMgOiBuZXcgU2V0KCk7XG5cdH1cblxuXHRpc1NlbGVjdGVkKGRhdHVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2JlaGF2aW9yLl9zZWxlY3RlZERhdHVtcy5oYXMoZGF0dW0pO1xuXHR9XG5cblx0c2VsZWN0KCRkYXR1bXMpIHtcblx0XHRpZiAoJGRhdHVtcyA9PT0gdW5kZWZpbmVkIHx8ICgkZGF0dW1zLmxlbmd0aCA9PT0gdW5kZWZpbmVkICYmICRkYXR1bXMuc2l6ZSA9PT0gdW5kZWZpbmVkKSlcblx0XHRcdCRkYXR1bXMgPSB0aGlzLmRhdGE7XG5cblx0XHRpZiAoIXRoaXMuX2JlaGF2aW9yIHx8ICF0aGlzLl9iZWhhdmlvci5jYW4oJ3NlbGVjdCcsICRkYXR1bXMpKSByZXR1cm4gZmFsc2U7XG5cblx0XHRjb25zdCB0aGF0ID0gdGhpcztcblx0XHQkZGF0dW1zLmZvckVhY2goKGRhdHVtKSA9PiB7XG5cdFx0XHRjb25zdCBzaGFwZSA9IHRoYXQuXyRkYXR1bVRvU2hhcGUuZ2V0KGRhdHVtKTtcblx0XHRcdGlmIChzaGFwZSkge1xuXHRcdFx0XHR0aGlzLl9iZWhhdmlvci5zZWxlY3QoZGF0dW0pO1xuXHRcdFx0XHR0aGlzLl90b0Zyb250KGRhdHVtKTtcblx0XHRcdFx0dGhhdC5lbWl0KCdzZWxlY3QnLCBkYXR1bSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vIHNoYXBlIGZvciB0aGlzIGRhdHVtIGluIHRoaXMgbGF5ZXInLCB7IGRhdHVtOiBkYXR1bSwgbGF5ZXI6IHRoYXQgfSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHVuc2VsZWN0KCRkYXR1bXMpIHtcblx0XHRpZiAoJGRhdHVtcyA9PT0gdW5kZWZpbmVkIHx8ICgkZGF0dW1zLmxlbmd0aCA9PT0gdW5kZWZpbmVkICYmICRkYXR1bXMuc2l6ZSA9PT0gdW5kZWZpbmVkKSlcblx0XHRcdCRkYXR1bXMgPSB0aGlzLmRhdGE7XG5cblx0XHRpZiAoIXRoaXMuX2JlaGF2aW9yIHx8ICF0aGlzLl9iZWhhdmlvci5jYW4oJ3Vuc2VsZWN0JywgJGRhdHVtcykpIHJldHVybiBmYWxzZTtcblx0XHRcblx0XHRjb25zdCB0aGF0ID0gdGhpcztcblx0XHQkZGF0dW1zLmZvckVhY2goKGRhdHVtKSA9PiB7XG5cdFx0XHRjb25zdCBzaGFwZSA9IHRoYXQuXyRkYXR1bVRvU2hhcGUuZ2V0KGRhdHVtKTtcblx0XHRcdGlmIChzaGFwZSkge1xuXHRcdFx0XHR0aGlzLl9iZWhhdmlvci51bnNlbGVjdChkYXR1bSk7XG5cdFx0XHRcdHRoYXQuZW1pdCgndW5zZWxlY3QnLCBkYXR1bSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vIHNoYXBlIGZvciB0aGlzIGRhdHVtIGluIHRoaXMgbGF5ZXInLCB7IGRhdHVtOiBkYXR1bSwgbGF5ZXI6IHRoYXQgfSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdF90b0Zyb250KCRkYXR1bSkge1xuXHRcdGNvbnN0ICRzaGFwZSA9IHRoaXMuXyRkYXR1bVRvU2hhcGUuZ2V0KCRkYXR1bSk7XG5cdFx0aWYgKCRzaGFwZSkge1xuXHRcdFx0aWYgKCRzaGFwZS4kZWwgaW5zdGFuY2VvZiBBcnJheSB8fCAkc2hhcGUuJGVsIGluc3RhbmNlb2YgU2V0KSB7XG5cdFx0XHRcdCRzaGFwZS4kZWwuZm9yRWFjaCgoZWwpID0+IGVsLm1vdmVUb1RvcCgpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCRzaGFwZS4kZWwubW92ZVRvVG9wKCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTm8gc2hhcGUgZm9yIHRoaXMgZGF0dW0gaW4gdGhpcyBsYXllcicsIHsgZGF0dW06ICRkYXR1bSwgbGF5ZXI6IHRoaXMgfSk7XG5cdFx0fVxuXHR9XG5cblx0dG9EcmFnTGF5ZXIoJGRhdHVtcykge1xuXHRcdGNvbnN0IHRoYXQgPSB0aGlzO1xuXHRcdCRkYXR1bXMuZm9yRWFjaCgoJGRhdHVtKSA9PiB7XG5cdFx0XHRjb25zdCAkc2hhcGUgPSB0aGlzLl8kZGF0dW1Ub1NoYXBlLmdldCgkZGF0dW0pO1xuXHRcdFx0aWYgKCRzaGFwZSkge1xuXHRcdFx0XHRpZiAoJHNoYXBlLiRlbCBpbnN0YW5jZW9mIEFycmF5IHx8ICRzaGFwZS4kZWwgaW5zdGFuY2VvZiBTZXQpIHtcblx0XHRcdFx0XHQkc2hhcGUuJGVsLmZvckVhY2goKGVsKSA9PiB0aGF0Ll9kcmFnTGF5ZXIuYWRkKGVsKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fZHJhZ0xheWVyLmFkZCgkc2hhcGUuJGVsKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdObyBzaGFwZSBmb3IgdGhpcyBkYXR1bSBpbiB0aGlzIGxheWVyJywgeyBkYXR1bTogJGRhdHVtLCBsYXllcjogdGhhdCB9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cblx0XG5cdHRvZ2dsZVNlbGVjdGlvbigkZGF0dW1zKSB7XG5cdFx0Y29uc3QgdGhhdCA9IHRoaXM7XG5cblx0XHQvLyBUT0RPOiB1c2UgdGhlIHRoaXMuX2JlaGF2aW9yLmNhbiBtZXRob2QuXG5cdFx0JGRhdHVtcy5mb3JFYWNoKChkYXR1bSkgPT4ge1xuXHRcdFx0Y29uc3Qgc2hhcGUgPSB0aGF0Ll8kZGF0dW1Ub1NoYXBlLmdldChkYXR1bSk7XG5cdFx0XHRpZiAoc2hhcGUpIHtcblx0XHRcdFx0dGhpcy5fYmVoYXZpb3IudG9nZ2xlU2VsZWN0aW9uKGRhdHVtKTtcblx0XHRcdFx0dGhhdC5lbWl0KCd0b2dnbGUtc2VsZWN0JywgZGF0dW0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdObyBzaGFwZSBmb3IgdGhpcyBkYXR1bSBpbiB0aGlzIGxheWVyJywgeyBkYXR1bTogZGF0dW0sIGxheWVyOiB0aGF0IH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcblx0LyoqXG5cdCAqIFNldHMgdGhlIGNvbnRleHQgb2YgdGhlIGxheWVyLCB0aHVzIGRlZmluaW5nIGl0cyBgc3RhcnRgLCBgZHVyYXRpb25gLFxuXHQgKiBgb2Zmc2V0YCBhbmQgYHN0cmV0Y2hSYXRpb2AuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VGltZUNvbnRleHR9IHRpbWVDb250ZXh0IC0gVGhlIHRpbWVDb250ZXh0IGluIHdoaWNoIHRoZSBsYXllciBpcyBkaXNwbGF5ZWQuXG5cdCAqL1xuXHRzZXRUaW1lQ29udGV4dCh0aW1lQ29udGV4dCkge1xuXHRcdHRoaXMudGltZUNvbnRleHQgPSB0aW1lQ29udGV4dDtcblx0XHQvLyBjcmVhdGUgYSBtaXhpbiB0byBwYXNzIHRvIHRoZSBzaGFwZXNcblx0XHR0aGlzLl9yZW5kZXJpbmdDb250ZXh0ID0ge307XG5cdFx0dGhpcy5fdXBkYXRlUmVuZGVyaW5nQ29udGV4dCgpO1xuXHR9XG5cblx0LyoqXG5cdCogUmVnaXN0ZXIgYSBzaGFwZSBhbmQgaXRzIGNvbmZpZ3VyYXRpb24gdG8gdXNlIGluIG9yZGVyIHRvIHJlbmRlciB0aGUgZGF0YS5cblx0KlxuXHQqIEBwYXJhbSB7QmFzZVNoYXBlfSBjdG9yIC0gVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBzaGFwZSB0byBiZSB1c2VkLlxuXHQqIEBwYXJhbSB7T2JqZWN0fSBbYWNjZXNzb3JzPXt9XSAtIERlZmluZXMgaG93IHRoZSBzaGFwZSBzaG91bGQgYWRhcHQgdG8gYSBwYXJ0aWN1bGFyIGRhdGEgc3RydXR1cmUuXG5cdCogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIEdsb2JhbCBjb25maWd1cmF0aW9uIGZvciB0aGUgc2hhcGVzLCBpcyBzcGVjaWZpYyB0byBlYWNoIGBTaGFwZWAuXG5cdCovXG5cdGNvbmZpZ3VyZVNoYXBlKGN0b3IsIGFjY2Vzc29ycywgb3B0aW9ucykge1xuXHRcdGlmICghYWNjZXNzb3JzKSBcblx0XHRcdGFjY2Vzc29ycyA9IHt9O1xuXHRcdGlmICghb3B0aW9ucykgXG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0dGhpcy5fc2hhcGVDb25maWd1cmF0aW9uID0geyBjdG9yOiBjdG9yLCBhY2Nlc3NvcnM6IGFjY2Vzc29ycywgb3B0aW9uczogb3B0aW9ucyB9O1xuXHR9XG5cblx0LyoqXG5cdCogT3B0aW9ubmFseSByZWdpc3RlciBhIHNoYXBlIHRvIGJlIHVzZWQgYWNjcm9zIHRoZSBlbnRpcmUgY29sbGVjdGlvbi5cblx0KlxuXHQqIEBwYXJhbSB7QmFzZVNoYXBlfSBjdG9yIC0gVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBzaGFwZSB0byBiZSB1c2VkLlxuXHQqIEBwYXJhbSB7T2JqZWN0fSBbYWNjZXNzb3JzPXt9XSAtIERlZmluZXMgaG93IHRoZSBzaGFwZSBzaG91bGQgYWRhcHQgdG8gYSBwYXJ0aWN1bGFyIGRhdGEgc3RydXR1cmUuXG5cdCogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIEdsb2JhbCBjb25maWd1cmF0aW9uIGZvciB0aGUgc2hhcGVzLCBpcyBzcGVjaWZpYyB0byBlYWNoIGBTaGFwZWAuXG5cdCovXG5cdGNvbmZpZ3VyZUNvbW1vblNoYXBlKEN0b3IsIGFjY2Vzc29ycywgb3B0aW9ucykge1xuXHRcdGlmICghYWNjZXNzb3JzKVx0YWNjZXNzb3JzID0ge307XG5cdFx0aWYgKCFvcHRpb25zKVx0b3B0aW9ucyA9IHt9O1xuXHRcdHRoaXMuX2NvbW1vblNoYXBlQ29uZmlndXJhdGlvbiA9IHsgY3RvcjogQ3RvciwgYWNjZXNzb3JzOiBhY2Nlc3NvcnMsIG9wdGlvbnM6IG9wdGlvbnMgfTtcblx0XHR0aGlzLl9jb21tb25TaGFwZSA9IG5ldyBDdG9yKG9wdGlvbnMpO1xuXHRcdHRoaXMuX2NvbW1vblNoYXBlLmluc3RhbGwoYWNjZXNzb3JzKTtcblx0XHR0aGlzLl9jb21tb25TaGFwZS5yZW5kZXIodGhpcy5fcmVuZGVyaW5nQ29udGV4dCk7XG5cdFx0aWYgKHRoaXMuX2NvbW1vblNoYXBlLiRlbCBpbnN0YW5jZW9mIEFycmF5IHx8IHRoaXMuX2NvbW1vblNoYXBlLiRlbCBpbnN0YW5jZW9mIFNldCkge1xuXHRcdFx0dGhpcy5fY29tbW9uU2hhcGUuJGVsLmZvckVhY2goKGVsKSA9PiB0aGlzLl9jb21tb25TaGFwZUxheWVyLmFkZChlbCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jb21tb25TaGFwZUxheWVyLmFkZCh0aGlzLl9jb21tb25TaGFwZS4kZWwpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERlZmluZXMgaWYgdGhlIGBMYXllcmAsIGFuZCB0aHVzIHRoZSBgTGF5ZXJUaW1lQ29udGV4dGAgaXMgZWRpdGFibGUgb3Igbm90LlxuXHQqXG5cdCogQHBhcmFtcyB7Qm9vbGVhbn0gW2Jvb2w9dHJ1ZV1cblx0Ki9cblx0c2V0Q29udGV4dEVkaXRhYmxlKGVkaXRhYmxlKSB7XG5cdFx0aWYgKGVkaXRhYmxlID09PSB1bmRlZmluZWQpXG5cdFx0XHRlZGl0YWJsZSA9IHRydWU7XG5cdFx0Ly8gdGhpcy5fY29udGV4dExheWVyLnZpc2libGUoZWRpdGFibGUpO1xuXHRcdHRoaXMuX2NvbnRleHRMYXllci5vcGFjaXR5KChlZGl0YWJsZSk/IHRoaXMucGFyYW1zLmNvbnRleHQub3BhY2l0eSA6IDApO1xuXHRcdHRoaXMuX2NvbnRleHRMYXllci5saXN0ZW5pbmcoZWRpdGFibGUpO1xuXHRcdHRoaXMuX2NvbnRleHRMYXllci52aXNpYmxlKGVkaXRhYmxlKTtcblx0XHR0aGlzLl9pc0NvbnRleHRFZGl0YWJsZSA9IGVkaXRhYmxlO1xuXHR9XG5cdFxuXG5cblx0LyoqXG5cdCogVXBkYXRlcyB0aGUgdmFsdWVzIHN0b3JlZCBpbnQgdGhlIGBfcmVuZGVyaW5nQ29udGV4dGAgcGFzc2VkXHR0byBzaGFwZXNcblx0KiBmb3IgcmVuZGVyaW5nIGFuZCB1cGRhdGluZy5cblx0Ki9cblx0X3VwZGF0ZVJlbmRlcmluZ0NvbnRleHQoKSB7XG5cblx0XHR0aGlzLl9yZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsID0gdGhpcy50aW1lQ29udGV4dC50aW1lVG9QaXhlbDtcblx0XHR0aGlzLl9yZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbCA9IHRoaXMuX3ZhbHVlVG9QaXhlbDtcblxuXHRcdHRoaXMuX3JlbmRlcmluZ0NvbnRleHQuaGVpZ2h0ID0gdGhpcy5wYXJhbXMuaGVpZ2h0O1xuXHRcdHRoaXMuX3JlbmRlcmluZ0NvbnRleHQud2lkdGggID0gdGhpcy50aW1lQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLnRpbWVDb250ZXh0LmR1cmF0aW9uKTtcblx0XHQvLyBmb3IgZm9yZWlnbiBvYmplY3QgaXNzdWUgaW4gY2hyb21lXG5cdFx0dGhpcy5fcmVuZGVyaW5nQ29udGV4dC5vZmZzZXRYID0gdGhpcy50aW1lQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLnRpbWVDb250ZXh0Lm9mZnNldCk7XG5cdFx0dGhpcy5fcmVuZGVyaW5nQ29udGV4dC5zdGFydFggPSB0aGlzLnRpbWVDb250ZXh0LnBhcmVudC50aW1lVG9QaXhlbCh0aGlzLnRpbWVDb250ZXh0LnN0YXJ0KTtcblx0XHR0aGlzLl9yZW5kZXJpbmdDb250ZXh0LnBpeGVsc1BlclNlY29uZCA9IHRoaXMudGltZUNvbnRleHQucGFyZW50LmNvbXB1dGVkUGl4ZWxzUGVyU2Vjb25kO1xuXG5cdFx0Ly8gQHRvZG8gcmVwbGFjZSB3aXRoIGBtaW5YYCBhbmQgYG1heFhgIHJlcHJlc2VudGluZyB0aGUgdmlzaWJsZSBwaXhlbHMgaW4gd2hpY2hcblx0XHQvLyB0aGUgc2hhcGVzIHNob3VsZCBiZSByZW5kZXJlZCwgY291bGQgYWxsb3cgdG8gbm90IHVwZGF0ZSB0aGUgRE9NIG9mIHNoYXBlc1xuXHRcdC8vIHdobyBhcmUgbm90IGluIHRoaXMgYXJlYS5cblx0XHR0aGlzLl9yZW5kZXJpbmdDb250ZXh0LnRyYWNrT2Zmc2V0WCA9IHRoaXMudGltZUNvbnRleHQucGFyZW50LnRpbWVUb1BpeGVsKHRoaXMudGltZUNvbnRleHQucGFyZW50Lm9mZnNldCk7XG5cdFx0dGhpcy5fcmVuZGVyaW5nQ29udGV4dC52aXNpYmxlV2lkdGggPSB0aGlzLnRpbWVDb250ZXh0LnBhcmVudC52aXNpYmxlV2lkdGg7XG5cdH1cblxuXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8vIEhlbHBlcnNcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRnZXREYXR1bUZyb21TaGFwZSgkc2hhcGUpIHtcblx0XHRyZXR1cm4gdGhpcy5fJHNoYXBlVG9EYXR1bS5nZXQoJHNoYXBlKTtcblx0fVxuXG5cdGdldFNoYXBlRnJvbURhdHVtKCRkYXR1bSkge1xuXHRcdHJldHVybiB0aGlzLl8kZGF0dW1Ub1NoYXBlLmdldCgkZGF0dW0pO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0cmlldmUgYWxsIHRoZSBkYXR1bXMgaW4gYSBnaXZlbiBhcmVhIGFzIGRlZmluZWQgaW4gdGhlIHJlZ2lzdGVyZWQgYFNoYXBlfmluQXJlYWAgbWV0aG9kLlxuXHQqXG5cdCogQHBhcmFtIHtPYmplY3R9IGFyZWEgLSBUaGUgYXJlYSBpbiB3aGljaCB0byBmaW5kIHRoZSBlbGVtZW50c1xuXHQqIEBwYXJhbSB7TnVtYmVyfSBhcmVhLnRvcFxuXHQqIEBwYXJhbSB7TnVtYmVyfSBhcmVhLmxlZnRcblx0KiBAcGFyYW0ge051bWJlcn0gYXJlYS53aWR0aFxuXHQqIEBwYXJhbSB7TnVtYmVyfSBhcmVhLmhlaWdodFxuXHQqIEByZXR1cm4ge0FycmF5fSAtIGxpc3Qgb2YgdGhlIGRhdHVtcyBwcmVzZW50cyBpbiB0aGUgYXJlYVxuXHQqL1xuXHRnZXREYXR1bXNJbkFyZWEoYXJlYSkge1xuXHRcdFxuXHRcdGxldCB4MSA9IGFyZWEubGVmdDtcblx0XHRsZXQgeTEgPSBhcmVhLnRvcDtcblx0XHRsZXQgeDIgPSBhcmVhLmxlZnQgKyBhcmVhLndpZHRoO1xuXHRcdGxldCB5MiA9IGFyZWEudG9wICsgYXJlYS5oZWlnaHQgKyB0aGlzLnBhcmFtcy50b3A7XG5cblx0XHRjb25zdCAkZmlsdGVyZWREYXR1bXMgPSBuZXcgU2V0KCk7XG5cblx0XHRjb25zdCAkZW50cmllcyA9IHRoaXMuXyRkYXR1bVRvU2hhcGUuZW50cmllcygpO1xuXG5cdFx0Y29uc3QgdGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLmNvbnRlbnRMYXllcnMuZm9yRWFjaCgoY29udGVudExheWVyKSA9PiB7XG5cdFx0XHRjb250ZW50TGF5ZXIuY2hpbGRyZW4uZm9yRWFjaCgoa29udmFTaGFwZSkgPT4ge1xuXHRcdFx0XHRjb25zdCAkc2hhcGUgPSBrb252YVNoYXBlLnNoYXBlO1xuXHRcdFx0XHRpZiAoJHNoYXBlKSB7XG5cdFx0XHRcdFx0Y29uc3QgJGRhdHVtID0gdGhhdC5nZXREYXR1bUZyb21TaGFwZSgkc2hhcGUpO1xuXHRcdFx0XHRcdGNvbnN0IGluQXJlYSA9ICRzaGFwZS5pbkFyZWEodGhpcy5fcmVuZGVyaW5nQ29udGV4dCwgJGRhdHVtLCB4MSwgeTEsIHgyLCB5Mik7XG5cblx0XHRcdFx0XHRpZiAoaW5BcmVhKSB7IFxuXHRcdFx0XHRcdFx0JGZpbHRlcmVkRGF0dW1zLmFkZCgkZGF0dW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0XG5cdFx0cmV0dXJuICRmaWx0ZXJlZERhdHVtcztcblx0fVxuXG5cdHVwZGF0ZSgkZGF0dW1zKSB7XG5cblx0XHR0aGlzLnVwZGF0ZUNvbnRhaW5lcigpO1xuXG5cdFx0dGhpcy51cGRhdGVTaGFwZXMoJGRhdHVtcyk7XG5cdFx0XG5cdH1cblxuXG5cdHNvcnRfZGF0YShkYXRhKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgZGV2ZWxvcGVyIG11c3QgYXNzaWduIGEgcHJvcGVyIGZ1bmN0aW9uJyk7XG5cdH1cblxuXHR2aXNpYmxlX2RhdGEodGltZUNvbnRleHQsIGRhdGEpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkZXZlbG9wZXIgbXVzdCBhc3NpZ24gYSBwcm9wZXIgZnVuY3Rpb24nKTtcblx0fVxuXG5cblx0dXBkYXRlU2hhcGVzKCRkYXR1bXMpIHtcblx0XHRjb25zdCB0aGF0ID0gdGhpcztcblx0XHRjb25zdCBjaGFuZ2VkQ29udGVudExheWVycyA9IG5ldyBTZXQoKTtcblx0XHR2YXIgdGFyZ2V0RGF0YSA9IG51bGw7XG5cdFx0dmFyIGludGVydmFsID0gbnVsbDtcblx0XHR2YXIgZXJhc2VDaGlsZHJlbiA9IHRydWU7XG5cblx0XHRpZiAoJGRhdHVtcyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX2NvbW1vblNoYXBlKSB7XG5cdFx0XHRpbnRlcnZhbCA9IHRoaXMudmlzaWJsZV9kYXRhKHRoaXMudGltZUNvbnRleHQsIHRoaXMuZGF0YSk7XG5cdFx0fVxuXG5cdFx0aWYgKCRkYXR1bXMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGFyZ2V0RGF0YSA9IHRoaXMuZGF0YS5zbGljZShpbnRlcnZhbFswXSwgTWF0aC5taW4oaW50ZXJ2YWxbMV0rMSwgdGhpcy5kYXRhLmxlbmd0aCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXREYXRhID0gJGRhdHVtcztcblx0XHRcdGVyYXNlQ2hpbGRyZW4gPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBjb25zb2xlLmxvZyhbdGhpcy5fJGRhdHVtVG9TaGFwZS5zaXplLCB0aGlzLmRhdGEubGVuZ3RoXSk7XG5cdFx0dGhpcy5hbGxvY2F0ZVNoYXBlc1RvQ29udGVudExheWVycyh0aGlzLl9zdGFnZSwgdGFyZ2V0RGF0YSwgJ2RhdHVtcycsIGVyYXNlQ2hpbGRyZW4pLmZvckVhY2goKGNoYW5nZWRDb250ZW50TGF5ZXIpID0+IHtcblx0XHRcdGNoYW5nZWRDb250ZW50TGF5ZXJzLmFkZChjaGFuZ2VkQ29udGVudExheWVyKTtcblx0XHR9KTtcblxuXHRcdC8vIGNvbnNvbGUubG9nKCdudW1iZXIgb2YgY2hhbmdlZENvbnRlbnRMYXllcnMgOiAnICsgY2hhbmdlZENvbnRlbnRMYXllcnMuc2l6ZSk7XG5cblx0XHRjaGFuZ2VkQ29udGVudExheWVycy5mb3JFYWNoKChjaGFuZ2VkQ29udGVudExheWVyKSA9PiB7XG5cdFx0XHRjaGFuZ2VkQ29udGVudExheWVyXG5cdFx0XHRcdC55KHRoYXQucGFyYW1zLnRvcClcblx0XHRcdFx0Lm9mZnNldFgoLXRoYXQuX3JlbmRlcmluZ0NvbnRleHQuc3RhcnRYKVxuXHRcdFx0XHQueCh0aGF0Ll9yZW5kZXJpbmdDb250ZXh0Lm9mZnNldFgpXG5cdFx0XHRcdC5jbGlwKHsgXG5cdFx0XHRcdFx0eDogLXRoYXQuX3JlbmRlcmluZ0NvbnRleHQub2Zmc2V0WCwgXG5cdFx0XHRcdFx0eTogMCwgXG5cdFx0XHRcdFx0d2lkdGg6IHRoYXQuX3JlbmRlcmluZ0NvbnRleHQud2lkdGgsIFxuXHRcdFx0XHRcdGhlaWdodDogdGhhdC5fcmVuZGVyaW5nQ29udGV4dC5oZWlnaHQgXG5cdFx0XHRcdH0pO1xuXHRcdFx0Y2hhbmdlZENvbnRlbnRMYXllci5jbGVhcigpO1xuXHRcdFx0Y2hhbmdlZENvbnRlbnRMYXllci5iYXRjaERyYXcoKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuX2RyYWdMYXllclxuXHRcdFx0XHQueSh0aGF0LnBhcmFtcy50b3ApXG5cdFx0XHRcdC5vZmZzZXRYKC10aGF0Ll9yZW5kZXJpbmdDb250ZXh0LnN0YXJ0WClcblx0XHRcdFx0LngodGhhdC5fcmVuZGVyaW5nQ29udGV4dC5vZmZzZXRYKVxuXHRcdFx0XHQuY2xpcCh7IFxuXHRcdFx0XHRcdHg6IC10aGF0Ll9yZW5kZXJpbmdDb250ZXh0Lm9mZnNldFgsIFxuXHRcdFx0XHRcdHk6IDAsIFxuXHRcdFx0XHRcdHdpZHRoOiB0aGF0Ll9yZW5kZXJpbmdDb250ZXh0LndpZHRoLCBcblx0XHRcdFx0XHRoZWlnaHQ6IHRoYXQuX3JlbmRlcmluZ0NvbnRleHQuaGVpZ2h0IFxuXHRcdFx0XHR9KS5jbGVhcigpLmJhdGNoRHJhdygpO1xuXG5cblx0XHRpZiAodGhpcy5fY29tbW9uU2hhcGUpIHtcblx0XHRcdHRoaXMuX2NvbW1vblNoYXBlTGF5ZXJcblx0XHRcdFx0LnkodGhhdC5wYXJhbXMudG9wKVxuXHRcdFx0XHQub2Zmc2V0WCgtdGhhdC5fcmVuZGVyaW5nQ29udGV4dC5zdGFydFgpXG5cdFx0XHRcdC54KHRoYXQuX3JlbmRlcmluZ0NvbnRleHQub2Zmc2V0WClcblx0XHRcdFx0LmNsaXAoeyBcblx0XHRcdFx0XHR4OiAtdGhhdC5fcmVuZGVyaW5nQ29udGV4dC5vZmZzZXRYLCBcblx0XHRcdFx0XHR5OiAwLCBcblx0XHRcdFx0XHR3aWR0aDogdGhhdC5fcmVuZGVyaW5nQ29udGV4dC53aWR0aCwgXG5cdFx0XHRcdFx0aGVpZ2h0OiB0aGF0Ll9yZW5kZXJpbmdDb250ZXh0LmhlaWdodFxuXHRcdFx0XHR9KTtcblx0XHRcdHRoaXMuX2NvbW1vblNoYXBlLnVwZGF0ZSh0aGlzLl9yZW5kZXJpbmdDb250ZXh0LCB0aGF0LmRhdGEuc2xpY2UoaW50ZXJ2YWxbMF0sIGludGVydmFsWzFdKzEpKTtcblx0XHRcdHRoaXMuX2NvbW1vblNoYXBlTGF5ZXIuYmF0Y2hEcmF3KCk7XG5cdFx0XHQvLyB0aGlzLl9jb21tb25TaGFwZUxheWVyLm1vdmVUb0JvdHRvbSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NvbnRleHRTaGFwZS51cGRhdGUodGhpcy5fcmVuZGVyaW5nQ29udGV4dCwgdGhpcy50aW1lQ29udGV4dCk7XG5cblx0XHR0aGlzLl9jb250ZXh0TGF5ZXJcblx0XHRcdFx0LnkodGhhdC5wYXJhbXMudG9wKVxuXHRcdFx0XHQuYmF0Y2hEcmF3KCk7XG5cdFx0XHRcdC8vIC5tb3ZlVG9Cb3R0b20oKTtcblx0fVxuXG5cdHVwZGF0ZUNvbnRhaW5lcigpIHtcblx0XHR0aGlzLl91cGRhdGVSZW5kZXJpbmdDb250ZXh0KCk7XG5cdFx0Y29uc3QgdGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLmNvbnRlbnRMYXllcnMuZm9yRWFjaCgoY29udGVudExheWVyKSA9PiB7XG5cdFx0XHRjb250ZW50TGF5ZXJcblx0XHRcdFx0Lm9mZnNldFgoLXRoaXMuX3JlbmRlcmluZ0NvbnRleHQuc3RhcnRYKVxuXHRcdFx0XHQueCh0aGlzLl9yZW5kZXJpbmdDb250ZXh0Lm9mZnNldFgpXG5cdFx0XHRcdC5jbGlwKHt4Oi10aGlzLl9yZW5kZXJpbmdDb250ZXh0Lm9mZnNldFgsIHk6MCwgd2lkdGg6IHRoaXMuX3JlbmRlcmluZ0NvbnRleHQud2lkdGgsIGhlaWdodDogdGhpcy5fcmVuZGVyaW5nQ29udGV4dC5oZWlnaHR9KTtcblx0XHR9KTtcblx0fVxuXG5cblxuXHRhbGxvY2F0ZVNoYXBlc1RvQ29udGVudExheWVycyhzdGFnZSwgb2JqcywgdHlwZSwgZXJhc2VDaGlsZHJlbikge1xuXHRcdGNvbnN0IExJTUlUID0gMzA7IC8vIFRPRE86IG1ha2UgdGhlIExJTUlUIGEgZHluYW1pYyB2YXJpYWJsZSwgY29udHJvbGxlZCBieSBhIHVzZXIgZGVmaW5lZCBmdW5jdGlvbi5cblxuXHRcdGNvbnN0IGNoYW5nZWRDb250ZW50TGF5ZXJzID0gbmV3IFNldCgpO1xuXG5cdFx0Y29uc3Qga29udmFTaGFwZXMgPSBuZXcgU2V0KCk7XG5cblx0XHQvKlxuXHRcdCAqIE9mIGNvdXJzZSBvbmUgY291bGQgd3JpdGUgbGVzcyBjb2RlIGJ5IGluY2x1ZGluZyB0aGUgdHlwZSBjaGVja2luZyBpbnNpZGUgdGhlIGZvckVhY2guXG5cdFx0ICogQnV0IHRoYXQgd291bGQgbWVhbiBhIGNoZWNrIGZvciBlYWNoIG9iamVjdC4gVGhpcyB3YXksIHRoZSBwcm9ncmFtIGNoZWNrcyBvbmx5IG9uZSB0aW1lLlxuXHRcdCAqIFRoaXMgaXMgbWVhbnQgdG8gYmUgYSBzbWFsbCBvcHRpbWl6YXRpb24uIE5vdCBwcmV0dHksIG9mIGNvdXJzZS5cblx0XHQgKiBBbm90aGVyIHRoaW5nOiBpbiBvcmRlciB0byB1c2UganVzdCBvbmUgZm9yRWFjaCBhdCB1cGRhdGVTaGFwZXMsIEkgaW5jbHVkZWQgdGhlIHNoYXBlIHVwZGF0ZSBpbiBoZXJlXG5cdFx0ICovXG5cdFx0Y29uc3QgdGhhdCA9IHRoaXM7XG5cdFx0aWYgKHR5cGUgPT0gJ2RhdHVtcycpIHtcblx0XHRcdG9ianMuZm9yRWFjaCgoZGF0dW0pID0+IHtcblx0XHRcdFx0bGV0IHNoYXBlID0gdGhhdC5nZXRTaGFwZUZyb21EYXR1bShkYXR1bSk7XG5cdFx0XHRcdGlmIChzaGFwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0Ly8gdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGRhdHVtJywgeyBkYXR1bTogZGF0dW0sIGxheWVyOiB0aGF0IH0pO1xuXHRcdFx0XHRcdHRoYXQuX2FkZChkYXR1bSk7XG5cdFx0XHRcdFx0c2hhcGUgPSB0aGF0LmdldFNoYXBlRnJvbURhdHVtKGRhdHVtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzaGFwZS51cGRhdGUodGhhdC5fcmVuZGVyaW5nQ29udGV4dCwgZGF0dW0pOyBcblx0XHRcdFx0aWYgKHNoYXBlLiRlbCBpbnN0YW5jZW9mIEFycmF5IHx8IHNoYXBlLiRlbCBpbnN0YW5jZW9mIFNldCkge1xuXHRcdFx0XHRcdHNoYXBlLiRlbC5mb3JFYWNoKChlbCkgPT4ga29udmFTaGFwZXMuYWRkKGVsKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0a29udmFTaGFwZXMuYWRkKHNoYXBlLiRlbCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PSAnc2hhcGVzJykge1xuXHRcdFx0b2Jqcy5mb3JFYWNoKChzaGFwZSkgPT4ge1xuXHRcdFx0XHRjb25zdCBkYXR1bSA9IHRoYXQuZ2V0RGF0dW1Gcm9tU2hhcGUoc2hhcGUpO1xuXHRcdFx0XHRpZiAoZGF0dW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5rbm93biBzaGFwZScsIHsgc2hhcGU6IHNoYXBlLCBsYXllcjogdGhhdCB9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzaGFwZS51cGRhdGUodGhhdC5fcmVuZGVyaW5nQ29udGV4dCwgZGF0dW0pOyBcblx0XHRcdFx0aWYgKHNoYXBlLiRlbCBpbnN0YW5jZW9mIEFycmF5IHx8IHNoYXBlLiRlbCBpbnN0YW5jZW9mIFNldCkge1xuXHRcdFx0XHRcdHNoYXBlLiRlbC5mb3JFYWNoKChlbCkgPT4ga29udmFTaGFwZXMuYWRkKGVsKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0a29udmFTaGFwZXMuYWRkKHNoYXBlLiRlbCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gb2JqZWN0cyB0eXBlJyk7XG5cdFx0fVxuXG5cdFx0Y29uc3Qga3NJdCA9IGtvbnZhU2hhcGVzLmVudHJpZXMoKTtcblxuXHRcdGNvbnN0IGNsSXQgPSB0aGlzLmNvbnRlbnRMYXllcnMuZW50cmllcygpO1xuXG5cdFx0dmFyIGNsZSA9IGNsSXQubmV4dCgpO1xuXHRcdHZhciBrc2UgPSBrc0l0Lm5leHQoKTtcblxuXHRcdHZhciBwcmV2aW91c1NoYXBlID0gbnVsbDtcblxuXHRcdHdoaWxlICghY2xlLmRvbmUpIHtcblx0XHRcdGNvbnN0IGxheWVyID0gY2xlLnZhbHVlWzFdO1xuXHRcdFx0d2hpbGUgKCFrc2UuZG9uZSkge1xuXHRcdFx0XHRjb25zdCBrb252YVNoYXBlID0ga3NlLnZhbHVlWzFdO1xuXHRcdFx0XHRpZiAobGF5ZXIuY2hpbGRyZW4ubGVuZ3RoID49IExJTUlUICYmIGtvbnZhU2hhcGUuc2hhcGUgIT0gcHJldmlvdXNTaGFwZSkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlcmFzZUNoaWxkcmVuICYmICFjaGFuZ2VkQ29udGVudExheWVycy5oYXMobGF5ZXIpKSB7XG5cdFx0XHRcdFx0bGF5ZXIucmVtb3ZlQ2hpbGRyZW4oKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRrb252YVNoYXBlLnJlbW92ZSgpO1xuXHRcdFx0XHRsYXllci5hZGQoa29udmFTaGFwZSk7XG5cdFx0XHRcdGtzZSA9IGtzSXQubmV4dCgpO1xuXHRcdFx0XHRjaGFuZ2VkQ29udGVudExheWVycy5hZGQobGF5ZXIpO1xuXHRcdFx0fVxuXHRcdFx0Y2xlID0gY2xJdC5uZXh0KCk7XG5cdFx0fVxuXG5cdFx0d2hpbGUgKCFrc2UuZG9uZSkge1xuXHRcdFx0Y29uc3QgbGF5ZXIgPSBuZXcgS29udmEuTGF5ZXIoe30pO1xuXHRcdFx0bGF5ZXIubGF5ZXIgPSB0aGlzO1xuXHRcdFx0bGF5ZXIuYWRkTmFtZSgnY29udGVudC1sYXllcicpO1xuXHRcdFx0bGF5ZXIuY2xlYXJCZWZvcmVEcmF3KHRydWUpO1xuXHRcdFx0dGhpcy5jb250ZW50TGF5ZXJzLmFkZChsYXllcik7XG5cdFx0XHRzdGFnZS5hZGQobGF5ZXIpO1xuXHRcdFx0d2hpbGUgKCFrc2UuZG9uZSAmJiBsYXllci5jaGlsZHJlbi5sZW5ndGggPCBMSU1JVCkge1xuXHRcdFx0XHRjb25zdCBrb252YVNoYXBlID0ga3NlLnZhbHVlWzFdO1xuXHRcdFx0XHRrb252YVNoYXBlLnJlbW92ZSgpO1xuXHRcdFx0XHRsYXllci5hZGQoa29udmFTaGFwZSk7XG5cdFx0XHRcdGtzZSA9IGtzSXQubmV4dCgpO1xuXHRcdFx0fVxuXHRcdFx0Y2hhbmdlZENvbnRlbnRMYXllcnMuYWRkKGxheWVyKTtcblx0XHR9XG5cblx0XHQvLyBrb252YVNoYXBlcy5mb3JFYWNoKChrcykgPT4ga3Muc2hhcGUuc3RhcnREcmFnKCkpO1xuXG5cdFx0cmV0dXJuIGNoYW5nZWRDb250ZW50TGF5ZXJzO1xuXHR9XG5cblx0c2V0KGRhdGEpIHtcblx0XHRpZiAoIXRoaXMuX2JlaGF2aW9yIHx8ICF0aGlzLl9iZWhhdmlvci5jYW4oJ2FkZCcsIGRhdGEpKSByZXR1cm4gZmFsc2U7XG5cblx0XHRjb25zdCB0aGF0ID0gdGhpcztcblxuXHRcdHRoaXMudW5zZWxlY3QoKTtcblxuXHRcdHRoaXMuZGF0YS5mb3JFYWNoKChkYXR1bSkgPT4gdGhhdC5fJGRhdHVtVG9TaGFwZS5nZXQoZGF0dW0pLmRlc3Ryb3koKSk7XG5cdFx0dGhpcy5fJGRhdHVtVG9TaGFwZS5jbGVhcigpO1xuXHRcdHRoaXMuXyRzaGFwZVRvRGF0dW0uY2xlYXIoKTtcblxuXHRcdHRoaXMuY29udGVudExheWVycy5mb3JFYWNoKChsYXllcik9PiBsYXllci5kZXN0cm95KCkpO1xuXG5cdFx0dGhpcy5kYXRhLmxlbmd0aCA9IDA7XG5cblx0XHRkYXRhLmZvckVhY2goKGRhdHVtKSA9PiB7XG5cdFx0XHR0aGF0Ll9hZGQoZGF0dW0pO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5kYXRhID0gZGF0YTtcblxuXHRcdHRoaXMuc29ydF9kYXRhKHRoaXMuZGF0YSk7XG5cblx0XHR0aGlzLmVtaXQoJ3NldCcsIGRhdGEpO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRfYWRkKGRhdHVtKSB7XG5cdFx0Y29uc3QgQ3RvciA9IHRoaXMuX3NoYXBlQ29uZmlndXJhdGlvbi5jdG9yO1xuXHRcdGNvbnN0IGFjY2Vzc29ycyA9IHRoaXMuX3NoYXBlQ29uZmlndXJhdGlvbi5hY2Nlc3NvcnM7XG5cdFx0Y29uc3Qgb3B0aW9ucyA9IHRoaXMuX3NoYXBlQ29uZmlndXJhdGlvbi5vcHRpb25zO1xuXG5cdFx0Y29uc3Qgc2hhcGUgPSBuZXcgQ3RvcihvcHRpb25zKTtcblx0XHRzaGFwZS5pbnN0YWxsKGFjY2Vzc29ycyk7XG5cdFx0c2hhcGUucmVuZGVyKHRoaXMuX3JlbmRlcmluZ0NvbnRleHQpO1xuXHRcdHNoYXBlLmxheWVyID0gdGhpcztcblx0XHRzaGFwZS5kYXR1bSA9IGRhdHVtO1xuXHRcdHRoaXMuXyRkYXR1bVRvU2hhcGUuc2V0KGRhdHVtLCBzaGFwZSk7XG5cdFx0dGhpcy5fJHNoYXBlVG9EYXR1bS5zZXQoc2hhcGUsIGRhdHVtKTtcblx0fVxuXG5cdGFkZChkYXR1bSkge1xuXHRcdGlmICghdGhpcy5fYmVoYXZpb3IgfHwgIXRoaXMuX2JlaGF2aW9yLmNhbignYWRkJywgW2RhdHVtXSkpIHJldHVybiBmYWxzZTtcblxuXHRcdHRoaXMuX2FkZChkYXR1bSk7XG5cdFx0dGhpcy5kYXRhW3RoaXMuZGF0YS5sZW5ndGhdID0gZGF0dW07XG5cdFx0dGhpcy5zb3J0X2RhdGEodGhpcy5kYXRhKTtcblxuXHRcdHRoaXMuZW1pdCgnYWRkJywgZGF0dW0pO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZW1vdmUoZGF0dW0pIHtcblx0XHRpZiAoIXRoaXMuX2JlaGF2aW9yIHx8ICF0aGlzLl9iZWhhdmlvci5jYW4oJ3JlbW92ZScsIFtkYXR1bV0pKSByZXR1cm4gZmFsc2U7XG5cblx0XHR0aGlzLnVuc2VsZWN0KGRhdHVtKTtcblx0XHRjb25zdCBzaGFwZSA9IHRoaXMuXyRkYXR1bVRvU2hhcGUuZ2V0KGRhdHVtKTtcblx0XHRpZiAoc2hhcGUpIHtcblx0XHRcdGNvbnN0IGNoYW5nZWRDb250ZW50TGF5ZXJzID0gbmV3IFNldCgpO1xuXHRcdFx0aWYgKHNoYXBlLiRlbCBpbnN0YW5jZW9mIEFycmF5IHx8IHNoYXBlLiRlbCBpbnN0YW5jZW9mIFNldCkge1xuXHRcdFx0XHRzaGFwZS4kZWwuZm9yRWFjaCgoZWwpID0+IGNoYW5nZWRDb250ZW50TGF5ZXJzLmFkZChlbCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hhbmdlZENvbnRlbnRMYXllcnMuYWRkKHNoYXBlLiRlbCk7XG5cdFx0XHR9XG5cdFx0XHRzaGFwZS5sYXllciA9IG51bGw7XG5cdFx0XHRzaGFwZS5kZXN0cm95KCk7XG5cdFx0XHR0aGlzLl8kZGF0dW1Ub1NoYXBlLmRlbGV0ZShkYXR1bSk7XG5cdFx0XHR0aGlzLl8kc2hhcGVUb0RhdHVtLmRlbGV0ZShzaGFwZSk7XG5cblx0XHRcdGNoYW5nZWRDb250ZW50TGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiB7XG5cdFx0XHRcdGlmIChsYXllci5jaGlsZHJlbiA9PT0gMCkge1xuXHRcdFx0XHRcdGxheWVyLmRlc3Ryb3koKTtcblx0XHRcdFx0XHR0aGlzLmNvbnRlbnRMYXllcnMuZGVsZXRlKGxheWVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5kYXRhLnNwbGljZSh0aGlzLmRhdGEuaW5kZXhPZihkYXR1bSksIDEpO1xuXG5cdFx0dGhpcy5lbWl0KCdyZW1vdmUnLCBkYXR1bSk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVESVRJT04gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cblx0LyoqXG5cdCAqIEVkaXQgZGF0dW0ocykgYWNjb3JkaW5nIHRvIHRoZSBgZWRpdGAgZGVmaW5lZCBpbiB0aGUgcmVnaXN0ZXJlZCBgQmVoYXZpb3JgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdFtdfSAkZGF0dW1zIC0gVGhlIGRhdHVtKHMpIHRvIGVkaXQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkeCAtIFRoZSBtb2RpZmljYXRpb24gdG8gYXBwbHkgaW4gdGhlIHggYXhpcyAoaW4gcGl4ZWxzKS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGR5IC0gVGhlIG1vZGlmaWNhdGlvbiB0byBhcHBseSBpbiB0aGUgeSBheGlzIChpbiBwaXhlbHMpLlxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9ICR0YXJnZXQgLSBUaGUgdGFyZ2V0IG9mIHRoZSBpbnRlcmFjdGlvbiAoZm9yIGV4YW1wbGUsIGxlZnRcblx0ICogICAgaGFuZGxlciBET00gZWxlbWVudCBpbiBhIHNlZ21lbnQpLlxuXHQgKi9cblx0ZWRpdCgkZGF0dW1zLCBkeCwgZHksICR0YXJnZXQpIHtcblx0XHRpZiAoIXRoaXMuX2JlaGF2aW9yIHx8ICF0aGlzLl9iZWhhdmlvci5jYW4oJ2VkaXQnLCAkZGF0dW1zKSkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0Y29uc3QgdGhhdCA9IHRoaXM7XG5cdFx0JGRhdHVtcy5mb3JFYWNoKChkYXR1bSkgPT4ge1xuXHRcdFx0Y29uc3Qgc2hhcGUgPSB0aGF0Ll8kZGF0dW1Ub1NoYXBlLmdldChkYXR1bSk7XG5cdFx0XHR0aGlzLl9iZWhhdmlvci5lZGl0KHRoaXMuX3JlbmRlcmluZ0NvbnRleHQsIHNoYXBlLCBkYXR1bSwgZHgsIGR5LCAkdGFyZ2V0KTtcblx0XHR9KTtcblx0XHR0aGlzLmVtaXQoJ2VkaXQnLCAkZGF0dW1zKTtcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblxuXHQvKipcblx0KiBFZGl0IHRoZSBsYXllciBhbmQgdGh1cyBpdHMgcmVsYXRlZCBgTGF5ZXJUaW1lQ29udGV4dGAgYXR0cmlidXRlcy5cblx0KlxuXHQqIEBwYXJhbSB7TnVtYmVyfSBkeCAtIFRoZSBtb2RpZmljYXRpb24gdG8gYXBwbHkgaW4gdGhlIHggYXhpcyAoaW4gcGl4ZWxzKS5cblx0KiBAcGFyYW0ge051bWJlcn0gZHkgLSBUaGUgbW9kaWZpY2F0aW9uIHRvIGFwcGx5IGluIHRoZSB5IGF4aXMgKGluIHBpeGVscykuXG5cdCogQHBhcmFtIHtFbGVtZW50fSAkdGFyZ2V0IC0gVGhlIHRhcmdldCBvZiB0aGUgZXZlbnQgb2YgdGhlIGludGVyYWN0aW9uLlxuXHQqL1xuXHRlZGl0Q29udGV4dChkeCwgZHksICR0YXJnZXQpIHtcblx0XHQvLyBUT0RPXG5cdFx0dGhpcy50aW1lQ29udGV4dEJlaGF2aW9yLmVkaXQodGhpcywgZHgsIGR5LCAkdGFyZ2V0KTtcblx0XHR0aGlzLmVtaXQoJ2VkaXQtY29udGV4dCcpO1xuXHR9XG5cblx0LyoqXG5cdCogU3RyZXRjaCB0aGUgbGF5ZXIgYW5kIHRodXMgaXRzIHJlbGF0ZWQgYExheWVyVGltZUNvbnRleHRgIGF0dHJpYnV0ZXMuXG5cdCpcblx0KiBAcGFyYW0ge051bWJlcn0gZHggLSBUaGUgbW9kaWZpY2F0aW9uIHRvIGFwcGx5IGluIHRoZSB4IGF4aXMgKGluIHBpeGVscykuXG5cdCogQHBhcmFtIHtOdW1iZXJ9IGR5IC0gVGhlIG1vZGlmaWNhdGlvbiB0byBhcHBseSBpbiB0aGUgeSBheGlzIChpbiBwaXhlbHMpLlxuXHQqIEBwYXJhbSB7RWxlbWVudH0gJHRhcmdldCAtIFRoZSB0YXJnZXQgb2YgdGhlIGV2ZW50IG9mIHRoZSBpbnRlcmFjdGlvbi5cblx0Ki9cblx0c3RyZXRjaENvbnRleHQoZHgsIGR5LCAkdGFyZ2V0KSB7XG5cdFx0Ly8gVE9ET1xuXHRcdHRoaXMudGltZUNvbnRleHRCZWhhdmlvci5zdHJldGNoKHRoaXMsIGR4LCBkeSwgJHRhcmdldCk7XG5cdFx0dGhpcy5lbWl0KCdzdHJldGNoLWNvbnRleHQnKTtcblx0fVxuXG5cdG1pbmltaXplKCkge1xuXHRcdC8vIFRPRE9cblx0fVxuXG59IiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHNjYWxlcyBmcm9tICcuLi91dGlscy9zY2FsZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lbGluZVRpbWVDb250ZXh0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwaXhlbHNQZXJTZWNvbmQgLSBUaGUgbnVtYmVyIG9mIHBpeGVscyB0aGF0IHNob3VsZCBiZVxuICAgKiAgICB1c2VkIHRvIGRpc3BsYXkgb25lIHNlY29uZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZpc2libGVXaWR0aCAtIFRoZSBkZWZhdWx0IHdpdGggb2YgdGhlIHZpc2libGUgYXJlYVxuICAgKiAgICBkaXNwbGF5ZWQgaW4gYHRyYWNrc2AgKGluIHBpeGVscykuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwaXhlbHNQZXJTZWNvbmQsIHZpc2libGVXaWR0aCkge1xuICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG5cbiAgICB0aGlzLl90aW1lVG9QaXhlbCA9IG51bGw7XG4gICAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgICB0aGlzLl96b29tID0gMTtcbiAgICB0aGlzLl9jb21wdXRlZFBpeGVsc1BlclNlY29uZCA9IHBpeGVsc1BlclNlY29uZDtcbiAgICAvLyBwYXJhbXNcbiAgICB0aGlzLl92aXNpYmxlV2lkdGggPSB2aXNpYmxlV2lkdGg7XG4gICAgdGhpcy5fbWFpbnRhaW5WaXNpYmxlRHVyYXRpb24gPSBmYWxzZTtcblxuICAgIC8vIGNyZWF0ZSB0aGUgdGltZVRvUGl4ZWwgc2NhbGVcbiAgICBjb25zdCBzY2FsZSA9IHNjYWxlcy5saW5lYXIoKVxuICAgICAgLmRvbWFpbihbMCwgMV0pXG4gICAgICAucmFuZ2UoWzAsIHBpeGVsc1BlclNlY29uZF0pO1xuXG4gICAgdGhpcy5fdGltZVRvUGl4ZWwgPSBzY2FsZTtcblxuICAgIHRoaXMuX29yaWdpbmFsUGl4ZWxzUGVyU2Vjb25kID0gdGhpcy5fY29tcHV0ZWRQaXhlbHNQZXJTZWNvbmQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHBpeGVscyBwZXIgc2Vjb25kcyBpZ25vcmluZyB0aGUgY3VycmVudCB6b29tIHZhbHVlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHBpeGVsc1BlclNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWxQaXhlbHNQZXJTZWNvbmQ7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBhbGwgdGhlIGNhcmFjdGVyaXN0aWNzIG9mIHRoaXMgb2JqZWN0IGFjY29yZGluZyB0byB0aGUgbmV3XG4gICAqIGdpdmVuIHZhbHVlIG9mIHBpeGVscyBwZXIgc2Vjb25kcy4gUHJvcGFnYXRlcyB0aGUgY2hhbmdlcyB0byB0aGVcbiAgICogYExheWVyVGltZUNvbnRleHRgIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgc2V0IHBpeGVsc1BlclNlY29uZCh2YWx1ZSkge1xuICAgIHRoaXMuX2NvbXB1dGVkUGl4ZWxzUGVyU2Vjb25kID0gdmFsdWUgKiB0aGlzLnpvb207XG4gICAgdGhpcy5fb3JpZ2luYWxQaXhlbHNQZXJTZWNvbmQgPSB2YWx1ZTtcbiAgICB0aGlzLl91cGRhdGVUaW1lVG9QaXhlbFJhbmdlKCk7XG5cbiAgICAvLyBmb3JjZSBjaGlsZHJlbiBzY2FsZSB1cGRhdGVcbiAgICB0aGlzLl9jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuc3RyZXRjaFJhdGlvID09PSAxKSB7IHJldHVybjsgfVxuICAgICAgY2hpbGQuc3RyZXRjaFJhdGlvID0gY2hpbGQuc3RyZXRjaFJhdGlvO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBwaXhlbHMgcGVyIHNlY29uZHMgaW5jbHVkaW5nIHRoZSBjdXJyZW50IHpvb20gdmFsdWUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgY29tcHV0ZWRQaXhlbHNQZXJTZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXB1dGVkUGl4ZWxzUGVyU2Vjb25kO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgb2Zmc2V0IGFwcGxpZWQgdG8gdGhlIHJlZ2lzdGVyZWQgYFRyYWNrYCBpbnN0YW5jZXNcbiAgICogZnJvbSBvcmlnaW4gKGluIHNlY29uZHMpLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb2Zmc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG9mZnNldCB0byBhcHBseSB0byB0aGUgcmVnaXN0ZXJlZCBgVHJhY2tgIGluc3RhbmNlcyBmcm9tIG9yaWdpblxuICAgKiAoaW4gc2Vjb25kcykuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBzZXQgb2Zmc2V0KHZhbHVlKSB7XG4gICAgdGhpcy5fb2Zmc2V0ID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCB6b29tIGxldmVsIGFwcGxpZWQgdG8gdGhlIHdob2xlIHZpc3VhbGl6YXRpb24uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgem9vbSgpIHtcbiAgICByZXR1cm4gdGhpcy5fem9vbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB6b29tIHJhdGlvIGZvciB0aGUgd2hvbGUgdmlzdWFsaXphdGlvbi5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHNldCB6b29tKHZhbHVlKSB7XG4gICAgLy8gQ29tcHV0ZSBjaGFuZ2UgdG8gcHJvcGFnYXRlIHRvIGNoaWxkcmVuIHdobyBoYXZlIHRoZWlyIG93biB0aW1lVG9QaXhlbFxuICAgIGNvbnN0IHJhdGlvQ2hhbmdlID0gdmFsdWUgLyB0aGlzLl96b29tO1xuICAgIHRoaXMuX3pvb20gPSB2YWx1ZTtcbiAgICB0aGlzLl9jb21wdXRlZFBpeGVsc1BlclNlY29uZCA9IHRoaXMuX29yaWdpbmFsUGl4ZWxzUGVyU2Vjb25kICogdmFsdWU7XG4gICAgdGhpcy5fdXBkYXRlVGltZVRvUGl4ZWxSYW5nZSgpO1xuXG4gICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLnN0cmV0Y2hSYXRpbyA9PT0gMSkgeyByZXR1cm47IH1cbiAgICAgIGNoaWxkLnN0cmV0Y2hSYXRpbyA9IGNoaWxkLnN0cmV0Y2hSYXRpbyAqIHJhdGlvQ2hhbmdlO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZpc2libGUgd2lkdGggb2YgdGhlIGBUcmFja2AgaW5zdGFuY2VzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHZpc2libGVXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlzaWJsZVdpZHRoO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZpc2libGUgd2lkdGggb2YgdGhlIGBUcmFja2AgaW5zdGFuY2VzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgc2V0IHZpc2libGVXaWR0aCh2YWx1ZSkge1xuICAgIGNvbnN0IHdpZHRoUmF0aW8gPSB2YWx1ZSAvIHRoaXMudmlzaWJsZVdpZHRoO1xuICAgIHRoaXMuX3Zpc2libGVXaWR0aCA9IHZhbHVlO1xuXG4gICAgaWYgKHRoaXMubWFpbnRhaW5WaXNpYmxlRHVyYXRpb24pIHtcbiAgICAgIHRoaXMucGl4ZWxzUGVyU2Vjb25kID0gdGhpcy5fY29tcHV0ZWRQaXhlbHNQZXJTZWNvbmQgKiB3aWR0aFJhdGlvO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkdXJhdGlvbiBkaXNwbGF5ZWQgYnkgYFRyYWNrYCBpbnN0YW5jZXMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgdmlzaWJsZUR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnZpc2libGVXaWR0aCAvIHRoaXMuX2NvbXB1dGVkUGl4ZWxzUGVyU2Vjb25kO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIGR1cmF0aW9uIGRpc3BsYXllZCBieSB0cmFja3Mgc2hvdWxkIGJlIG1haW50YWluZWQgd2hlblxuICAgKiB0aGVpciB3aWR0aCBpcyB1cGRhdGVkLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1haW50YWluVmlzaWJsZUR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tYWludGFpblZpc2libGVEdXJhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGlmIHRoZSBkdXJhdGlvbiBkaXNwbGF5ZWQgYnkgdHJhY2tzIHNob3VsZCBiZSBtYWludGFpbmVkIHdoZW5cbiAgICogdGhlaXIgd2lkdGggaXMgdXBkYXRlZC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBzZXQgbWFpbnRhaW5WaXNpYmxlRHVyYXRpb24oYm9vbCkge1xuICAgIHRoaXMuX21haW50YWluVmlzaWJsZUR1cmF0aW9uID0gYm9vbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0aW1lIHRvIHBpeGVsIHRyYXNmZXJ0IGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICBnZXQgdGltZVRvUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWVUb1BpeGVsO1xuICB9XG5cbiAgX3VwZGF0ZVRpbWVUb1BpeGVsUmFuZ2UoKSB7XG4gICAgdGhpcy50aW1lVG9QaXhlbC5yYW5nZShbMCwgdGhpcy5fY29tcHV0ZWRQaXhlbHNQZXJTZWNvbmRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0aW1lIGludGVydmFsIG9mIHRoZSB2aXNpYmxlIGFyZWEgaW4gdGhlIHRpbWVsaW5lLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fSBcbiAgICovXG4gIGdldCB2aXNpYmxlSW50ZXJ2YWwoKSB7XG4gICAgdmFyIGludGVydmFsID0ge307XG4gICAgaW50ZXJ2YWwuc3RhcnQgPSAtdGhpcy5vZmZzZXQ7XG4gICAgaW50ZXJ2YWwuZHVyYXRpb24gPSB0aGlzLnZpc2libGVEdXJhdGlvbjtcbiAgICByZXR1cm4gaW50ZXJ2YWw7XG4gIH1cblxuICAvKipcbiAgICogRm9jdXMgdGhlIHRpbWVsaW5lIHZpc2libGUgYXJlYSBpbiB0aGUgcHJvdmlkZWQgdGltZSBpbnRlcnZhbC5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH0gXG4gICAqL1xuICBzZXQgdmlzaWJsZUludGVydmFsKHZhbHVlKSB7XG4gICAgdGhpcy5vZmZzZXQgPSAtdmFsdWUuc3RhcnQ7XG4gICAgdGhpcy5waXhlbHNQZXJTZWNvbmQgPSB0aGlzLnZpc2libGVXaWR0aCAvIHZhbHVlLmR1cmF0aW9uO1xuICB9XG5cblxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IGV2ZW50cyBmcm9tICdldmVudHMnO1xuaW1wb3J0IFRyYWNrIGZyb20gJy4vdHJhY2snO1xuaW1wb3J0IFRyYWNrQ29sbGVjdGlvbiBmcm9tICcuL3RyYWNrLWNvbGxlY3Rpb24nO1xuaW1wb3J0IFRpbWVsaW5lVGltZUNvbnRleHQgZnJvbSAnLi90aW1lbGluZS10aW1lLWNvbnRleHQnO1xuaW1wb3J0IExheWVyVGltZUNvbnRleHQgZnJvbSAnLi9sYXllci10aW1lLWNvbnRleHQnO1xuaW1wb3J0IFN1cmZhY2UgZnJvbSAnLi4vaW50ZXJhY3Rpb25zL2tvbnZhLXN1cmZhY2UnO1xuaW1wb3J0IEtleWJvYXJkIGZyb20gJy4uL2ludGVyYWN0aW9ucy9rZXlib2FyZCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVsaW5lIGV4dGVuZHMgZXZlbnRzLkV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3BpeGVsc1BlclNlY29uZD0xMDBdIC0gdGhlIGRlZmF1bHQgc2NhbGluZyBiZXR3ZWVuIHRpbWUgYW5kIHBpeGVscy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt2aXNpYmxlV2lkdGg9MTAwMF0gLSB0aGUgZGVmYXVsdCB2aXNpYmxlIGFyZWEgZm9yIGFsbCByZWdpc3RlcmVkIHRyYWNrcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBpeGVsc1BlclNlY29uZCwgdmlzaWJsZVdpZHRoLCBvcHRzKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmIChwaXhlbHNQZXJTZWNvbmQgPT09IHVuZGVmaW5lZClcbiAgICAgIHBpeGVsc1BlclNlY29uZCA9IDEwMDtcbiAgICBpZiAodmlzaWJsZVdpZHRoID09PSB1bmRlZmluZWQpXG4gICAgICB2aXNpYmxlV2lkdGggPSAxMDAwO1xuICAgIGlmIChvcHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdHMgPSB7IHJlZ2lzdGVyS2V5Ym9hcmQ6IHRydWUgfTtcbiAgICB9IGVsc2UgaWYgKG9wdHMucmVnaXN0ZXJLZXlib2FyZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRzLnJlZ2lzdGVyS2V5Ym9hcmQgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX3RyYWNrcyA9IG5ldyBUcmFja0NvbGxlY3Rpb24odGhpcyk7XG4gICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuXG4gICAgLy8gZGVmYXVsdCBpbnRlcmFjdGlvbnNcbiAgICB0aGlzLl9zdXJmYWNlQ3RvciA9IFN1cmZhY2U7XG5cbiAgICBpZiAob3B0cy5yZWdpc3RlcktleWJvYXJkKSB7XG4gICAgICB0aGlzLmNyZWF0ZUludGVyYWN0aW9uKEtleWJvYXJkLCBkb2N1bWVudCk7XG4gICAgfVxuXG4gICAgLy8gc3RvcmVzXG4gICAgdGhpcy5fdHJhY2tCeUlkID0ge307XG4gICAgdGhpcy5fZ3JvdXBlZExheWVycyA9IHt9O1xuXG4gICAgLyoqIEB0eXBlIHtUaW1lbGluZVRpbWVDb250ZXh0fSAtIG1hc3RlciB0aW1lIGNvbnRleHQgZm9yIHRoZSB2aXN1YWxpemF0aW9uLiAqL1xuICAgIHRoaXMudGltZUNvbnRleHQgPSBuZXcgVGltZWxpbmVUaW1lQ29udGV4dChwaXhlbHNQZXJTZWNvbmQsIHZpc2libGVXaWR0aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBgVGltZWxpbmVUaW1lQ29udGV4dGAncyBgb2Zmc2V0YCB0aW1lIGRvbWFpbiB2YWx1ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn0gW29mZnNldD0wXVxuICAgKi9cbiAgZ2V0IG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lQ29udGV4dC5vZmZzZXQ7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBgVGltZWxpbmVUaW1lQ29udGV4dGAncyBgb2Zmc2V0YCB0aW1lIGRvbWFpbiB2YWx1ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn0gW29mZnNldD0wXVxuICAgKi9cbiAgc2V0IG9mZnNldCh2YWx1ZSkge1xuICAgIHRoaXMudGltZUNvbnRleHQub2Zmc2V0ID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYFRpbWVsaW5lVGltZUNvbnRleHRgJ3MgYHpvb21gIHZhbHVlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfSBbb2Zmc2V0PTBdXG4gICAqL1xuICBnZXQgem9vbSgpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lQ29udGV4dC56b29tO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGBUaW1lbGluZVRpbWVDb250ZXh0YCdzIGB6b29tYCB2YWx1ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn0gW29mZnNldD0wXVxuICAgKi9cbiAgc2V0IHpvb20odmFsdWUpIHtcbiAgICB0aGlzLnRpbWVDb250ZXh0Lnpvb20gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgVGltZWxpbmVUaW1lQ29udGV4dGAncyBgcGl4ZWxzUGVyU2Vjb25kYCByYXRpby5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn0gW29mZnNldD0wXVxuICAgKi9cbiAgZ2V0IHBpeGVsc1BlclNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lQ29udGV4dC5waXhlbHNQZXJTZWNvbmQ7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYFRpbWVsaW5lVGltZUNvbnRleHRgJ3MgYHBpeGVsc1BlclNlY29uZGAgcmF0aW8uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9IFtvZmZzZXQ9MF1cbiAgICovXG4gIHNldCBwaXhlbHNQZXJTZWNvbmQodmFsdWUpIHtcbiAgICB0aGlzLnRpbWVDb250ZXh0LnBpeGVsc1BlclNlY29uZCA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRpbWUgaW50ZXJ2YWwgb2YgdGhlIHZpc2libGUgYXJlYSBpbiB0aGUgdGltZWxpbmUuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9IFxuICAgKi9cbiAgZ2V0IHZpc2libGVJbnRlcnZhbCgpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lQ29udGV4dC52aXNpYmxlSW50ZXJ2YWw7XG4gIH1cblxuICAvKipcbiAgICogRm9jdXMgdGhlIHRpbWVsaW5lIHZpc2libGUgYXJlYSBpbiB0aGUgcHJvdmlkZWQgdGltZSBpbnRlcnZhbC5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH0gXG4gICAqL1xuICBzZXQgdmlzaWJsZUludGVydmFsKHZhbHVlKSB7XG4gICAgdGhpcy50aW1lQ29udGV4dC52aXNpYmxlSW50ZXJ2YWwgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgVGltZWxpbmVUaW1lQ29udGV4dGAncyBgdmlzaWJsZVdpZHRoYCBwaXhlbCBkb21haW4gdmFsdWUuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9IFtvZmZzZXQ9MF1cbiAgICovXG4gIGdldCB2aXNpYmxlV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMudGltZUNvbnRleHQudmlzaWJsZVdpZHRoO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGBUaW1lbGluZVRpbWVDb250ZXh0YCdzIGB2aXNpYmxlV2lkdGhgIHBpeGVsIGRvbWFpbiB2YWx1ZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn0gW29mZnNldD0wXVxuICAgKi9cbiAgc2V0IHZpc2libGVXaWR0aCh2YWx1ZSkge1xuICAgIHRoaXMudGltZUNvbnRleHQudmlzaWJsZVdpZHRoID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBgVGltZWxpbmVUaW1lQ29udGV4dGAncyBgdGltZVRvUGl4ZWxgIHRyYW5zZmVydCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgZ2V0IHRpbWVUb1BpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLnRpbWVDb250ZXh0LnRpbWVUb1BpeGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYFRpbWVsaW5lVGltZUNvbnRleHRgJ3MgYHZpc2libGVEdXJhdGlvbmAgaGVscGVyIHZhbHVlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHZpc2libGVEdXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lQ29udGV4dC52aXNpYmxlRHVyYXRpb247XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYFRpbWVsaW5lVGltZUNvbnRleHRgJ3MgYG1haW50YWluVmlzaWJsZUR1cmF0aW9uYCB2YWx1ZS5cbiAgICogRGVmaW5lcyBpZiB0aGUgZHVyYXRpb24gb2YgdGhlIHZpc2libGUgYXJlYSBzaG91bGQgYmUgbWFpbnRhaW4gd2hlblxuICAgKiB0aGUgYHZpc2libGVXaWR0aGAgYXR0cmlidXRlIGlzIHVwZGF0ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc2V0IG1haW50YWluVmlzaWJsZUR1cmF0aW9uKGJvb2wpIHtcbiAgICB0aGlzLnRpbWVDb250ZXh0Lm1haW50YWluVmlzaWJsZUR1cmF0aW9uID0gYm9vbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGBUaW1lbGluZVRpbWVDb250ZXh0YCdzIGBtYWludGFpblZpc2libGVEdXJhdGlvbmAgY3VycmVudCB2YWx1ZS5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgbWFpbnRhaW5WaXNpYmxlRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGltZUNvbnRleHQubWFpbnRhaW5WaXNpYmxlRHVyYXRpb247XG4gIH1cblxuICAvKipcbiAgICogT2JqZWN0IG1haW50YWluaW5nIGFycmF5cyBvZiBgTGF5ZXJgIGluc3RhbmNlcyBvcmRlcmVkIGJ5IHRoZWlyIGBncm91cElkYC5cbiAgICogSXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBgVHJhY2tDb2xsZWN0aW9uYCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdldCBncm91cGVkTGF5ZXJzKCkge1xuICAgIHJldHVybiB0aGlzLl9ncm91cGVkTGF5ZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgU3VyZmFjZWAgdGhhdCBpcyBpbnN0YW5jaWF0ZWQgb24gZWFjaCBgVHJhY2tgXG4gICAqIGluc3RhbmNlLiBUaGlzIG1ldGhvcyBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBhZGRpbmcgYW55IGBUcmFja2AgaW5zdGFuY2VcbiAgICogdG8gdGhlIGN1cnJlbnQgYHRpbWVsaW5lYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFNvdXJjZX0gQ3RvciAtIFRoZSBjb25zdHJ1Y3RvciB0byB1c2UgaW4gb3JkZXIgdG8gY2F0Y2ggbW91c2VcbiAgICogICAgZXZlbnRzIG9uIGVhY2ggYFRyYWNrYCBpbnN0YW5jZXMuXG4gICAqL1xuICBjb25maWd1cmVTdXJmYWNlKEN0b3IpIHtcbiAgICB0aGlzLl9zdXJmYWNlQ3RvciA9IEN0b3I7XG4gIH1cblxuICAvKipcbiAgICogRmFjdG9yeSBtZXRob2QgdG8gYWRkIGludGVyYWN0aW9uIG1vZHVsZXMgdGhlIHRpbWVsaW5lIHNob3VsZCBsaXN0ZW4gdG8uXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSB0aW1lbGluZSBpbnN0YW5jaWF0ZSBhIGdsb2JhbCBgS2V5Ym9hcmRgIGluc3RhbmNlIGFuZCBhXG4gICAqIGBTdXJmYWNlYCBpbnN0YW5jZSBvbiBlYWNoIGNvbnRhaW5lci5cbiAgICogU2hvdWxkIGJlIHVzZWQgdG8gaW5zdGFsbCBuZXcgaW50ZXJhY3Rpb25zIGltcGxlbWVudGluZyB0aGUgYEV2ZW50U291cmNlYCBpbnRlcmZhY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRTb3VyY2V9IEN0b3IgLSBUaGUgY29udHJ1Y3RvciBvZiB0aGUgaW50ZXJhY3Rpb24gbW9kdWxlIHRvIGluc3RhbmNpYXRlLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9ICRlbCAtIFRoZSBET00gZWxlbWVudCB3aGljaCB3aWxsIGJlIGJpbmRlZCB0byB0aGUgYEV2ZW50U291cmNlYCBtb2R1bGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBPcHRpb25zIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGBDdG9yYC5cbiAgICovXG4gIGNyZWF0ZUludGVyYWN0aW9uKEN0b3IsICRlbCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIFxuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIGNvbnN0IGludGVyYWN0aW9uID0gbmV3IEN0b3IoJGVsLCBvcHRpb25zKTtcbiAgICBpbnRlcmFjdGlvbi5vbignZXZlbnQnLCAoZSkgPT4gdGhpcy5faGFuZGxlRXZlbnQoZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHRoZSBsYXllcnMgc2l0dWF0ZWQgdW5kZXIgdGhlIHBvc2l0aW9uIG9mIGEgYFdhdmVFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7V2F2ZXNFdmVudH0gZSAtIEFuIGV2ZW50IHRyaWdnZXJlZCBieSBhIGBXYXZlRXZlbnRgXG4gICAqIEByZXR1cm4ge0FycmF5fSAtIE1hdGNoZWQgbGF5ZXJzXG4gICAqL1xuICBnZXRIaXRMYXllcnMoZSkge1xuICAgIGNvbnN0IHggPSBlLm9yaWdpbmFsRXZlbnQub2Zmc2V0WDtcbiAgICBjb25zdCB5ID0gZS5vcmlnaW5hbEV2ZW50Lm9mZnNldFk7XG5cbiAgICBsZXQgbGF5ZXJzID0gW107XG5cbiAgICB0aGlzLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgICAgY29uc3QgY3R4WCA9IGxheWVyLl9jb250ZXh0U2hhcGUuJHNlZ21lbnQuZ2V0QWJzb2x1dGVQb3NpdGlvbigpLng7XG4gICAgICBjb25zdCBjdHhZID0gbGF5ZXIuX2NvbnRleHRTaGFwZS4kc2VnbWVudC5nZXRBYnNvbHV0ZVBvc2l0aW9uKCkueTtcbiAgICAgIGNvbnN0IGN0eFcgPSBsYXllci5fY29udGV4dFNoYXBlLiRzZWdtZW50LndpZHRoKCk7XG4gICAgICBjb25zdCBjdHhIID0gbGF5ZXIuX2NvbnRleHRTaGFwZS4kc2VnbWVudC5oZWlnaHQoKTtcblxuICAgICAgaWYgKHggPj0gY3R4WCAmJiB4IDw9IGN0eFggKyBjdHhXICYmIHkgPj0gY3R4WSAmJiB5IDw9IGN0eFkgKyBjdHhIKVxuICAgICAgICBsYXllcnMucHVzaChsYXllcik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjYWxsYmFjayB0aGF0IGlzIHVzZWQgdG8gbGlzdGVuIHRvIGludGVyYWN0aW9ucyBtb2R1bGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dhdmVFdmVudH0gZSAtIEFuIGV2ZW50IGdlbmVyYXRlZCBieSBhbiBpbnRlcmFjdGlvbiBtb2R1bGVzIChgRXZlbnRTb3VyY2VgKS5cbiAgICovXG4gIF9oYW5kbGVFdmVudChlKSB7XG4gICAgY29uc3QgaGl0TGF5ZXJzID0gKGUuc291cmNlID09PSAnc3VyZmFjZScpID9cbiAgICAgIHRoaXMuZ2V0SGl0TGF5ZXJzKGUpIDogbnVsbDtcbiAgICAvLyBlbWl0IGV2ZW50IGFzIGEgbWlkZGxld2FyZVxuICAgIHRoaXMuZW1pdCgnZXZlbnQnLCBlLCBoaXRMYXllcnMpO1xuICAgIC8vIHByb3BhZ2F0ZSB0byB0aGUgc3RhdGVcbiAgICBpZiAoIXRoaXMuX3N0YXRlKSB7IHJldHVybjsgfVxuICAgIHRoaXMuX3N0YXRlLmhhbmRsZUV2ZW50KGUsIGhpdExheWVycyk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc3RhdGUgb2YgdGhlIHRpbWVsaW5lLlxuICAgKlxuICAgKiBAdHlwZSB7QmFzZVN0YXRlfVxuICAgKi9cbiAgc2V0IHN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlKSB7IHRoaXMuX3N0YXRlLmV4aXQoKTsgfVxuICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgaWYgKHRoaXMuX3N0YXRlKSB7IHRoaXMuX3N0YXRlLmVudGVyKCk7IH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSB0aW1lbGluZS5cbiAgICpcbiAgICogQHR5cGUge0Jhc2VTdGF0ZX1cbiAgICovXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYFRyYWNrQ29sbGVjdGlvbmAgaW5zdGFuY2UuXG4gICAqXG4gICAqIEB0eXBlIHtUcmFja0NvbGxlY3Rpb259XG4gICAqL1xuICBnZXQgdHJhY2tzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFja3M7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBhbGwgcmVnaXN0ZXJlZCBsYXllcnMuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG4gIGdldCBsYXllcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWNrcy5sYXllcnM7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5ldyB0cmFjayB0byB0aGUgdGltZWxpbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhY2t9IHRyYWNrIC0gVGhlIG5ldyB0cmFjayB0byBiZSByZWdpc3RlcmVkIGluIHRoZSB0aW1lbGluZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFt0cmFja0lkPW51bGxdIC0gT3B0aW9ubmFsIHVuaXF1ZSBpZCB0byBhc3NvY2lhdGUgd2l0aFxuICAgKiAgICB0aGUgdHJhY2ssIHRoaXMgaWQgb25seSBleGlzdHMgaW4gdGltZWxpbmUncyBjb250ZXh0IGFuZCBzaG91bGQgYmUgdXNlZFxuICAgKiAgICBpbiBjb25qb25jdGlvbiB3aXRoIGBhZGRMYXllcmAgbWV0aG9kLlxuICAgKi9cbiAgYWRkKHRyYWNrLCB0cmFja0lkKSB7XG4gICAgaWYgKHRyYWNrSWQgPT09IHVuZGVmaW5lZClcbiAgICAgIHRyYWNrSWQgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMudHJhY2tzLmluZGV4T2YodHJhY2spICE9PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFjayBhbHJlYWR5IGFkZGVkIHRvIHRoZSB0aW1lbGluZScpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlZ2lzdGVyVHJhY2tJZCh0cmFjaywgdHJhY2tJZCk7XG4gICAgdHJhY2suY29uZmlndXJlKHRoaXMudGltZUNvbnRleHQpO1xuXG4gICAgdGhpcy50cmFja3MucHVzaCh0cmFjayk7XG4gICAgdGhpcy5jcmVhdGVJbnRlcmFjdGlvbih0aGlzLl9zdXJmYWNlQ3RvciwgdHJhY2spO1xuXG4gICAgdGhpcy5lbWl0KCdhZGQnLCB0cmFjaywgdHJhY2tJZCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIHRyYWNrIGZyb20gdGhlIHRpbWVsaW5lIGFuZCBkZXN0cm95cyB0aGF0IHRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYWNrfSB0cmFjayAtIHRoZSB0cmFjayB0byByZW1vdmUgZnJvbSB0aGUgdGltZWxpbmUuXG4gICAqIEB0b2RvIG5vdCBpbXBsZW1lbnRlZC5cbiAgICovXG4gIHJlbW92ZSh0cmFjaykge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy50cmFja3MuaW5kZXhPZih0cmFjayk7XG4gICAgdmFyIHRyYWNrSWQ7XG4gICAgaWYgKHRoaXMudHJhY2tzLmluZGV4T2YodHJhY2spICE9PSAtMSkge1xuICAgICAgdHJhY2suZGVzdHJveSgpO1xuICAgICAgZGVsZXRlIHRoaXMuX3RyYWNrQnlJZFt0cmFjay5pZF07XG4gICAgICB0cmFja0lkID0gdHJhY2suaWQ7XG4gICAgICB0cmFjay5pZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZW1pdCgncmVtb3ZlJywgdHJhY2ssIHRyYWNrSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byBjcmVhdGUgYSBuZXcgYFRyYWNrYCBpbnN0YW5jZS4gVGhlIGB0cmFja2AgaXMgYWRkZWQsXG4gICAqIHJlbmRlcmVkIGFuZCB1cGRhdGVkIGJlZm9yZSBiZWluZyByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSAkZWwgLSBUaGUgRE9NIGVsZW1lbnQgd2hlcmUgdGhlIHRyYWNrIHNob3VsZCBiZSBpbnNlcnRlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRyYWNrSGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgbmV3bHkgY3JlYXRlZCB0cmFjay5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFt0cmFja0lkPW51bGxdIC0gT3B0aW9ubmFsIHVuaXF1ZSBpZCB0byBhc3NvY2lhdGUgd2l0aFxuICAgKiAgICB0aGUgdHJhY2ssIHRoaXMgaWQgb25seSBleGlzdHMgaW4gdGltZWxpbmUncyBjb250ZXh0IGFuZCBzaG91bGQgYmUgdXNlZCBpblxuICAgKiAgICBjb25qb25jdGlvbiB3aXRoIGBhZGRMYXllcmAgbWV0aG9kLlxuICAgKiBAcmV0dXJuIHtUcmFja31cbiAgICovXG4gIGNyZWF0ZVRyYWNrKCRlbCwgdHJhY2tIZWlnaHQsIHRyYWNrSWQpIHtcbiAgICBpZiAodHJhY2tIZWlnaHQgPT09IHVuZGVmaW5lZClcbiAgICAgIHRyYWNrSGVpZ2h0ID0gMTAwO1xuICAgIGlmICh0cmFja0lkID09PSB1bmRlZmluZWQpXG4gICAgICB0cmFja0lkID0gbnVsbDtcblxuICAgIGNvbnN0IHRyYWNrID0gbmV3IFRyYWNrKCRlbCwgdHJhY2tIZWlnaHQpO1xuICAgIC8vIEFkZCB0cmFjayB0byB0aGUgdGltZWxpbmVcbiAgICB0aGlzLmFkZCh0cmFjaywgdHJhY2tJZCk7XG5cbiAgICB0cmFjay51cGRhdGUoKTtcblxuICAgIHJldHVybiB0cmFjaztcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0cmFjayBpZCBpcyBkZWZpbmVkLCBhc3NvY2lhdGUgYSB0cmFjayB3aXRoIGEgdW5pcXVlIGlkLlxuICAgKi9cbiAgX3JlZ2lzdGVyVHJhY2tJZCh0cmFjaywgdHJhY2tJZCkge1xuICAgIGlmICh0cmFja0lkICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5fdHJhY2tCeUlkW3RyYWNrSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0cmFja0lkOiBcIiR7dHJhY2tJZH1cIiBpcyBhbHJlYWR5IHVzZWRgKTtcbiAgICAgIH1cbiAgICAgIHRyYWNrLmlkID0gdHJhY2tJZDtcbiAgICAgIHRoaXMuX3RyYWNrQnlJZFt0cmFja0lkXSA9IHRyYWNrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gYWRkIGEgYExheWVyYCBpbnN0YW5jZSBpbnRvIGEgZ2l2ZW4gYFRyYWNrYC4gSXMgZGVzaWduZWQgdG8gYmVcbiAgICogdXNlZCBpbiBjb25qb25jdGlvbiB3aXRoIHRoZSBgVGltZWxpbmV+Z2V0TGF5ZXJzQnlHcm91cGAgbWV0aG9kLiBUaGVcbiAgICogbGF5ZXIgaXMgaW50ZXJuYWxseSByZW5kZXJlZCBhbmQgdXBkYXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSBUaGUgYExheWVyYCBpbnN0YW5jZSB0byBhZGQgaW50byB0aGUgdmlzdWFsaXphdGlvbi5cbiAgICogQHBhcmFtIHsoVHJhY2t8U3RyaW5nKX0gdHJhY2tPclRyYWNrSWQgLSBUaGUgYFRyYWNrYCBpbnN0YW5jZSAob3IgaXRzIGBpZGBcbiAgICogICAgYXMgZGVmaW5lZCBpbiB0aGUgYGNyZWF0ZVRyYWNrYCBtZXRob2QpIHdoZXJlIHRoZSBgTGF5ZXJgIGluc3RhbmNlIHNob3VsZCBiZSBpbnNlcnRlZC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtncm91cElkPSdkZWZhdWx0J10gLSBBbiBvcHRpb25uYWwgZ3JvdXAgaWQgaW4gd2hpY2ggdGhlXG4gICAqICAgIGBMYXllcmAgc2hvdWxkIGJlIGluc2VydGVkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc0F4aXNdIC0gU2V0IHRvIGB0cnVlYCBpZiB0aGUgYWRkZWQgYGxheWVyYCBpcyBhblxuICAgKiAgICBpbnN0YW5jZSBvZiBgQXhpc0xheWVyYCAodGhlc2UgbGF5ZXJzIHNoYXJlcyB0aGUgYFRpbWxpbmVUaW1lQ29udGV4dGAgaW5zdGFuY2VcbiAgICogICAgb2YgdGhlIHRpbWVsaW5lKS5cbiAgICovXG4gIGFkZExheWVyKGxheWVyLCB0cmFja09yVHJhY2tJZCwgZ3JvdXBJZCwgaXNBeGlzKSB7XG5cbiAgICBpZiAoZ3JvdXBJZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgZ3JvdXBJZCA9ICdkZWZhdWx0JztcbiAgICBpZiAoaXNBeGlzID09PSB1bmRlZmluZWQpXG4gICAgICBpc0F4aXMgPSBmYWxzZTtcblxuICAgIGxldCB0cmFjayA9IHRyYWNrT3JUcmFja0lkO1xuXG4gICAgaWYgKHR5cGVvZiB0cmFja09yVHJhY2tJZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyYWNrID0gdGhpcy5nZXRUcmFja0J5SWQodHJhY2tPclRyYWNrSWQpO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZXMgdGhlIGBMYXllclRpbWVDb250ZXh0YCBpZiBub3QgcHJlc2VudFxuICAgIGlmICghbGF5ZXIudGltZUNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHRpbWVDb250ZXh0ID0gaXNBeGlzID9cbiAgICAgICAgdGhpcy50aW1lQ29udGV4dCA6IG5ldyBMYXllclRpbWVDb250ZXh0KHRoaXMudGltZUNvbnRleHQpO1xuXG4gICAgICBsYXllci5zZXRUaW1lQ29udGV4dCh0aW1lQ29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gd2Ugc2hvdWxkIGhhdmUgYSBUcmFjayBpbnN0YW5jZSBhdCB0aGlzIHBvaW50XG4gICAgdHJhY2suYWRkKGxheWVyKTtcblxuICAgIGlmICghdGhpcy5fZ3JvdXBlZExheWVyc1tncm91cElkXSkge1xuICAgICAgdGhpcy5fZ3JvdXBlZExheWVyc1tncm91cElkXSA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMuX2dyb3VwZWRMYXllcnNbZ3JvdXBJZF0ucHVzaChsYXllcik7XG5cbiAgICBcbiAgICBsYXllci51cGRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgbGF5ZXIgZnJvbSBpdHMgdHJhY2suIFRoZSBsYXllciBpcyBkZXRhdGNoZWQgZnJvbSB0aGUgRE9NIGJ1dFxuICAgKiBjYW4gc3RpbGwgYmUgcmV1c2VkIGxhdGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0xheWVyfSBsYXllciAtIFRoZSBsYXllciB0byByZW1vdmUuXG4gICAqL1xuICByZW1vdmVMYXllcihsYXllcikge1xuICAgIHRoaXMudHJhY2tzLmZvckVhY2goZnVuY3Rpb24odHJhY2spIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdHJhY2subGF5ZXJzLmluZGV4T2YobGF5ZXIpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkgeyB0cmFjay5yZW1vdmUobGF5ZXIpOyB9XG4gICAgfSk7XG5cbiAgICAvLyBjbGVhbiByZWZlcmVuY2VzIGluIGhlbHBlcnNcbiAgICBmb3IgKGxldCBncm91cElkIGluIHRoaXMuX2dyb3VwZWRMYXllcnMpIHtcbiAgICAgIGNvbnN0IGdyb3VwID0gdGhpcy5fZ3JvdXBlZExheWVyc1tncm91cElkXTtcbiAgICAgIGNvbnN0IGluZGV4ID0gZ3JvdXAuaW5kZXhPZihsYXllcik7XG5cbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHsgXG4gICAgICAgIGdyb3VwLnNwbGljZShsYXllciwgMSk7IFxuICAgICAgfVxuXG4gICAgICBpZiAoIWdyb3VwLmxlbmd0aCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fZ3JvdXBlZExheWVyc1tncm91cElkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGBUcmFja2AgaW5zdGFuY2UgZnJvbSBpdCdzIGdpdmVuIGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHJhY2tJZFxuICAgKiBAcmV0dXJuIHtUcmFja31cbiAgICovXG4gIGdldFRyYWNrQnlJZCh0cmFja0lkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWNrQnlJZFt0cmFja0lkXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0cmFjayBjb250YWluaW5nIGEgZ2l2ZW4gRE9NIEVsZW1lbnQsIHJldHVybnMgbnVsbCBpZiBubyBtYXRjaCBmb3VuZC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSAkZWwgLSBUaGUgRE9NIEVsZW1lbnQgdG8gYmUgdGVzdGVkLlxuICAgKiBAcmV0dXJuIHtUcmFja31cbiAgICovXG4gIGdldFRyYWNrRnJvbURPTUVsZW1lbnQoJGVsKSB7XG4gICAgXG4gICAgZm9yICh2YXIgaT0wOyBpPHRoaXMudHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy50cmFja3NbaV0uJHN0YWdlLmNvbnRlbnQgPT09ICRlbClcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBsYXllcnMgZnJvbSB0aGVpciBnaXZlbiBncm91cCBpZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwSWQgLSBUaGUgaWQgb2YgdGhlIGdyb3VwIGFzIGRlZmluZWQgaW4gYGFkZExheWVyYC5cbiAgICogQHJldHVybiB7KEFycmF5fHVuZGVmaW5lZCl9XG4gICAqL1xuICBnZXRMYXllcnNCeUdyb3VwKGdyb3VwSWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3JvdXBlZExheWVyc1tncm91cElkXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyB0aHJvdWdoIHRoZSBhZGRlZCB0cmFja3MuXG4gICAqL1xuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgeWllbGQqIHRoaXMudHJhY2tzW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IExheWVyIGZyb20gJy4vbGF5ZXInO1xuXG4vKipcbiAqIENvbGxlY3Rpb24gaG9zdGluZyBhbGwgdGhlIGBUcmFja2AgaW5zdGFuY2VzIHJlZ2lzdGVyZWQgaW50byB0aGUgdGltZWxpbmUuXG4gKiBJdCBwcm92aWRlcyBzaG9yY3V0cyB0byB0cmlnZ2VyIGByZW5kZXJgIC8gYHVwZGF0ZWAgbWV0aG9kcyBvbiB0cmFja3Mgb3JcbiAqIGxheWVycy4gRXh0ZW5kIGJ1aWx0LWluIEFycmF5XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYWNrQ29sbGVjdGlvbiBleHRlbmRzIEFycmF5IHtcbiAgY29uc3RydWN0b3IodGltZWxpbmUpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fdGltZWxpbmUgPSB0aW1lbGluZTtcbiAgfVxuXG4gIC8vIEBub3RlIC0gc2hvdWxkIGJlIGluIHRoZSB0aW1lbGluZSA/XG4gIC8vIEB0b2RvIC0gYWxsb3cgdG8gcGFzcyBhbiBhcnJheSBvZiBsYXllcnNcbiAgX2dldExheWVyc09yR3JvdXBzKGxheWVyT3JHcm91cCkge1xuICAgIGlmIChsYXllck9yR3JvdXAgPT09IHVuZGVmaW5lZCkgXG4gICAgICBsYXllck9yR3JvdXAgPSBudWxsO1xuXG4gICAgbGV0IGxheWVycyA9IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIGxheWVyT3JHcm91cCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxheWVycyA9IHRoaXMuX3RpbWVsaW5lLmdyb3VwZWRMYXllcnNbbGF5ZXJPckdyb3VwXTtcbiAgICB9IGVsc2UgaWYgKGxheWVyT3JHcm91cCBpbnN0YW5jZW9mIExheWVyKSB7XG4gICAgICBsYXllcnMgPSBbbGF5ZXJPckdyb3VwXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5ZXJzID0gdGhpcy5sYXllcnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxheWVycztcbiAgfVxuXG4gIC8vIEBOT1RFIGtlZXAgdGhpcyA/XG4gIC8vIGNvdWxkIHByZXBhcmUgc29tZSB2ZXJ0aWNhbCByZXNpemluZyBhYmlsaXR5XG4gIC8vIHRoaXMgc2hvdWxkIGJlIGFibGUgdG8gbW9kaWZ5IHRoZSBsYXllcnMgeVNjYWxlIHRvIGJlIHJlYWxseSB1c2VmdWxsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9IC0gVXBkYXRlcyB0aGUgaGVpZ2h0IG9mIGFsbCB0cmFja3MgYXQgb25jZS5cbiAgICogQHRvZG8gLSBQcm9wYWdhdGUgdG8gbGF5ZXJzLCBub3QgdXNlZnVsbCBmb3Igbm93LlxuICAgKi9cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuZm9yRWFjaCgodHJhY2spID0+IHRyYWNrLmhlaWdodCA9IHZhbHVlKTtcbiAgfVxuXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBhbGwgcmVnaXN0ZXJlZCBsYXllcnMuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxMYXllcj59XG4gICAqL1xuICBnZXQgbGF5ZXJzKCkge1xuICAgIGxldCBsYXllcnMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5mb3JFYWNoKCh0cmFjaykgPT4gdHJhY2subGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiBsYXllcnMuYWRkKGxheWVyKSkpO1xuXG4gICAgcmV0dXJuIGxheWVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYWxsIHRyYWNrcyBhbmQgbGF5ZXJzLiBXaGVuIGRvbmUsIHRoZSB0aW1lbGluZSB0cmlnZ2VycyBhIGByZW5kZXJgIGV2ZW50LlxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuZm9yRWFjaCgodHJhY2spID0+IHRyYWNrLnJlbmRlcigpKTtcbiAgICB0aGlzLl90aW1lbGluZS5lbWl0KCdyZW5kZXInKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGFsbCB0cmFja3MgYW5kIGxheWVycy4gV2hlbiBkb25lLCB0aGUgdGltZWxpbmUgdHJpZ2dlcnMgYVxuICAgKiBgdXBkYXRlYCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtMYXllcnxTdHJpbmd9IGxheWVyT3JHcm91cCAtIEZpbHRlciB0aGUgbGF5ZXJzIHRvIHVwZGF0ZSBieVxuICAgKiAgICBwYXNzaW5nIHRoZSBgTGF5ZXJgIGluc3RhbmNlIHRvIHVwZGF0ZSBvciBhIGBncm91cElkYFxuICAgKi9cbiAgdXBkYXRlKGxheWVyT3JHcm91cCkge1xuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuX2dldExheWVyc09yR3JvdXBzKGxheWVyT3JHcm91cCk7XG4gICAgdGhpcy5mb3JFYWNoKCh0cmFjaykgPT4gdHJhY2sudXBkYXRlKGxheWVycykpO1xuICAgIHRoaXMuX3RpbWVsaW5lLmVtaXQoJ3VwZGF0ZScsIGxheWVycyk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBhbGwgYFRyYWNrYCBjb250YWluZXJzLCBsYXllcnMgYXJlIG5vdCB1cGRhdGVkIHdpdGggdGhpcyBtZXRob2QuXG4gICAqIFdoZW4gZG9uZSwgdGhlIHRpbWVsaW5lIHRyaWdnZXJzIGEgYHVwZGF0ZTpjb250YWluZXJzYCBldmVudC5cbiAgICovXG4gIHVwZGF0ZUNvbnRhaW5lcigvKiB0cmFja09yVHJhY2tJZHMgKi8pIHtcbiAgICB0aGlzLmZvckVhY2goKHRyYWNrKSA9PiB0cmFjay51cGRhdGVDb250YWluZXIoKSk7XG4gICAgdGhpcy5fdGltZWxpbmUuZW1pdCgndXBkYXRlOmNvbnRhaW5lcnMnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGFsbCBsYXllcnMuIFdoZW4gZG9uZSwgdGhlIHRpbWVsaW5lIHRyaWdnZXJzIGEgYHVwZGF0ZTpsYXllcnNgIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0xheWVyfFN0cmluZ30gbGF5ZXJPckdyb3VwIC0gRmlsdGVyIHRoZSBsYXllcnMgdG8gdXBkYXRlIGJ5XG4gICAqICAgIHBhc3NpbmcgdGhlIGBMYXllcmAgaW5zdGFuY2UgdG8gdXBkYXRlIG9yIGEgYGdyb3VwSWRgXG4gICAqL1xuICB1cGRhdGVMYXllcnMobGF5ZXJPckdyb3VwKSB7XG4gICAgY29uc3QgbGF5ZXJzID0gdGhpcy5fZ2V0TGF5ZXJzT3JHcm91cHMobGF5ZXJPckdyb3VwKTtcbiAgICB0aGlzLmZvckVhY2goKHRyYWNrKSA9PiB0cmFjay51cGRhdGVMYXllcnMobGF5ZXJzKSk7XG4gICAgdGhpcy5fdGltZWxpbmUuZW1pdCgndXBkYXRlOmxheWVycycsIGxheWVycyk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBldmVudHMgZnJvbSAnZXZlbnRzJztcbmltcG9ydCBLb252YSBmcm9tICdrb252YSc7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhY2sgZXh0ZW5kcyBldmVudHMuRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gJGVsXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0ID0gMTAwXVxuICAgKi9cbiAgY29uc3RydWN0b3IoJGVsLCBoZWlnaHQpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgaWYgKCFoZWlnaHQpXG4gICAgICBoZWlnaHQgPSAxMDA7XG5cbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgRE9NIGVsZW1lbnQgaW4gd2hpY2ggdGhlIHRyYWNrIGlzIGNyZWF0ZWQuXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy4kZWwgPSAkZWw7XG5cbiAgICB0aGlzLiRzdGFnZSA9IG51bGw7XG5cbiAgICB0aGlzLiRkcmFnTGF5ZXIgPSBudWxsO1xuICAgIFxuICAgIHRoaXMuJGludGVyYWN0aW9uc0xheWVyID0gbnVsbDtcblxuICAgIHRoaXMuJGJhY2tncm91bmRMYXllciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIHNldCBvZiBhbGwgdGhlIGxheWVycyBiZWxvbmdpbmcgdG8gdGhlIHRyYWNrLlxuICAgICAqIEB0eXBlIHtTZXQ8TGF5ZXI+fVxuICAgICAqL1xuICAgIHRoaXMubGF5ZXJzID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIFRoZSBjb250ZXh0IHVzZWQgdG8gbWFpbnRhaW4gdGhlIERPTSBzdHJ1Y3R1cmUgb2YgdGhlIHRyYWNrLlxuICAgICAqIEB0eXBlIHtUaW1lbGluZVRpbWVDb250ZXh0fVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyaW5nQ29udGV4dCA9IG51bGw7XG5cbiAgICB0aGlzLl9jcmVhdGVDb250YWluZXIoKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgdHJhY2suXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSB0cmFjay5cbiAgICpcbiAgICogQHRvZG8gcHJvcGFnYXRlIHRvIGxheWVycywga2VlcGluZyByYXRpbz8gY291bGQgYmUgaGFuZHkgZm9yIHZlcnRpY2FsXG4gICAqICAgIHJlc2l6ZS4gVGhpcyBpcyB3aHkgYSBzZXQvZ2V0IGlzIGltcGxlbWVudGVkIGhlcmUuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIHRyYWNrIGlzIGFkZGVkIHRvIHRoZSB0aW1lbGluZS4gVGhlXG4gICAqIHRyYWNrIGNhbm5vdCBiZSB1cGRhdGVkIHdpdGhvdXQgYmVpbmcgYWRkZWQgdG8gYSB0aW1lbGluZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUaW1lbGluZVRpbWVDb250ZXh0fSByZW5kZXJpbmdDb250ZXh0XG4gICAqL1xuICBjb25maWd1cmUocmVuZGVyaW5nQ29udGV4dCkge1xuICAgIHRoaXMucmVuZGVyaW5nQ29udGV4dCA9IHJlbmRlcmluZ0NvbnRleHQ7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgdHJhY2sgYW5kIGl0cyBsYXllcnMuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMubGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiBsYXllci5kZXN0cm95KCkpO1xuICAgIHRoaXMubGF5ZXJzLmNsZWFyKCk7XG5cbiAgICB0aGlzLiRzdGFnZS5kZXN0cm95KCk7XG4gICAgdGhpcy4kaW50ZXJhY3Rpb25zTGF5ZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuJGJhY2tncm91bmRMYXllci5kZXN0cm95KCk7XG5cbiAgICB0aGlzLl9oZWlnaHQgPSBudWxsO1xuICAgIHRoaXMuJGVsID0gbnVsbDtcbiAgICB0aGlzLiRzdGFnZSA9IG51bGw7XG4gICAgdGhpcy4kaW50ZXJhY3Rpb25zTGF5ZXIgPSBudWxsO1xuICAgIHRoaXMuJGJhY2tncm91bmRMYXllciA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJpbmdDb250ZXh0ID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBiYXNpYyBLb252YSBzdHJ1Y3R1cmUgb2YgdGhlIHRyYWNrLlxuICAgKi9cbiAgX2NyZWF0ZUNvbnRhaW5lcigpIHtcbiAgICB0aGlzLiRzdGFnZSA9IG5ldyBLb252YS5TdGFnZSh7XG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LCBcbiAgICAgIGNvbnRhaW5lcjogdGhpcy4kZWxcbiAgICB9KTtcbiAgICB0aGlzLiRzdGFnZS5hZGROYW1lKCd0cmFjay1zdGFnZScpO1xuXG4gICAgdGhpcy4kaW50ZXJhY3Rpb25zTGF5ZXIgPSBuZXcgS29udmEuTGF5ZXIoe30pO1xuICAgIHRoaXMuJGludGVyYWN0aW9uc0xheWVyLmFkZE5hbWUoJ3RyYWNrLWludGVyYWN0aW9ucycpO1xuXG4gICAgdGhpcy4kYmFja2dyb3VuZExheWVyID0gbmV3IEtvbnZhLkxheWVyKHt9KTtcbiAgICB0aGlzLiRiYWNrZ3JvdW5kTGF5ZXIuYWRkTmFtZSgndHJhY2stYmFja2dyb3VuZCcpO1xuICAgIHRoaXMuJGJhY2tncm91bmRMYXllci5hZGQobmV3IEtvbnZhLlJlY3Qoe30pKTtcbiAgICAvLyB0aGlzLiRiYWNrZ3JvdW5kTGF5ZXIuY2hpbGRyZW5bMF0uc2hhcGUgPSB7IGxheWVyOiB7IHRyYWNrOiB0aGlzIH0gfTsgLy8gU2hhbWUhISEgLi4uLi4gU2hhbWUhISEgLi4uLiBTaGFtZSEhIVxuXG4gICAgdGhpcy4kZHJhZ0xheWVyID0gbmV3IEtvbnZhLkxheWVyKHt9KTtcbiAgICB0aGlzLiRkcmFnTGF5ZXIuYWRkTmFtZSgndHJhY2stZHJhZy1sYXllcicpO1xuXG4gICAgdGhpcy4kc3RhZ2UuYWRkKHRoaXMuJGRyYWdMYXllcik7XG4gICAgdGhpcy4kc3RhZ2UuYWRkKHRoaXMuJGludGVyYWN0aW9uc0xheWVyKTtcbiAgICB0aGlzLiRzdGFnZS5hZGQodGhpcy4kYmFja2dyb3VuZExheWVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbGF5ZXIgdG8gdGhlIHRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge0xheWVyfSBsYXllciAtIHRoZSBsYXllciB0byBhZGQgdG8gdGhlIHRyYWNrLlxuICAgKi9cbiAgYWRkKGxheWVyKSB7XG4gICAgaWYgKCF0aGlzLmxheWVycy5oYXMobGF5ZXIpKSB7XG4gICAgICBsYXllci5jcmVhdGVDb250YWluZXIodGhpcy4kc3RhZ2UpO1xuICAgICAgdGhpcy5sYXllcnMuYWRkKGxheWVyKTtcbiAgICAgIHRoaXMubW92ZVRvVG9wKGxheWVyKTtcbiAgICAgIHRoaXMuZW1pdCgnYWRkJywgbGF5ZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgbGF5ZXIgZnJvbSB0aGUgdHJhY2sgYW5kIGRlc3Ryb3lzIHRoYXQgYWx5ZXJcbiAgICpcbiAgICogQHBhcmFtIHtMYXllcn0gbGF5ZXIgLSB0aGUgbGF5ZXIgdG8gcmVtb3ZlIGZyb20gdGhlIHRyYWNrLlxuICAgKi9cbiAgcmVtb3ZlKGxheWVyKSB7XG4gICAgLy8gVE9ET1xuICAgIGlmICh0aGlzLmxheWVycy5oYXMobGF5ZXIpKSB7XG4gICAgICB0aGlzLmxheWVycy5kZWxldGUobGF5ZXIpO1xuICAgICAgbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5lbWl0KCdyZW1vdmUnLCBsYXllcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTGF5ZXIgbm90IGZvdW5kJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRlc3RzIGlmIGEgZ2l2ZW4gZWxlbWVudCBiZWxvbmdzIHRvIHRoZSB0cmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSAkZWxcbiAgICogQHJldHVybiB7Ym9vbH1cbiAgICovXG4gIGhhc0VsZW1lbnQoJGVsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGVwcmVjYXRlZFwiKTtcblxuICAgIC8vIGRvIHtcbiAgICAvLyAgIGlmICgkZWwgPT09IHRoaXMuJGVsKSB7XG4gICAgLy8gICAgIHJldHVybiB0cnVlO1xuICAgIC8vICAgfVxuXG4gICAgLy8gICAkZWwgPSAkZWwucGFyZW50Tm9kZTtcbiAgICAvLyB9IHdoaWxlICgkZWwgIT09IG51bGwpO1xuXG4gICAgLy8gcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaGFzTGF5ZXIobGF5ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllcnMuaGFzKGxheWVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYWxsIHRoZSBsYXllcnMgYWRkZWQgdG8gdGhlIHRyYWNrLlxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIGZvciAobGV0IGxheWVyIG9mIHRoaXMpIHsgbGF5ZXIucmVuZGVyKCk7IH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB0cmFjayBLb252YSBzdHJ1Y3R1cmUgYW5kIHVwZGF0ZXMgdGhlIGxheWVycy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxMYXllcj59IFtsYXllcnM9bnVsbF0gLSBpZiBub3QgbnVsbCwgYSBzdWJzZXQgb2YgdGhlIGxheWVycyB0byB1cGRhdGUuXG4gICAqL1xuICB1cGRhdGUobGF5ZXJzKSB7XG4gICAgaWYgKGxheWVycyA9PT0gdW5kZWZpbmVkKVxuICAgICAgbGF5ZXJzID0gbnVsbDtcblxuICAgIHRoaXMudXBkYXRlQ29udGFpbmVyKCk7XG4gICAgdGhpcy51cGRhdGVMYXllcnMobGF5ZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB0cmFjayBLb252YSBzdHJ1Y3R1cmUuXG4gICAqL1xuICB1cGRhdGVDb250YWluZXIoKSB7XG4gICAgLy8gU2hvdWxkIGJlIGluIHNvbWUgdXBkYXRlIGxheW91dFxuICAgIGNvbnN0IHJlbmRlcmluZ0NvbnRleHQgPSB0aGlzLnJlbmRlcmluZ0NvbnRleHQ7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLnJvdW5kKHJlbmRlcmluZ0NvbnRleHQudmlzaWJsZVdpZHRoKTtcbiAgICBjb25zdCBvZmZzZXRYID0gLU1hdGgucm91bmQocmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbChyZW5kZXJpbmdDb250ZXh0Lm9mZnNldCkpO1xuXG4gICAgdGhpcy4kc3RhZ2Uud2lkdGgod2lkdGgpLmhlaWdodCh0aGlzLmhlaWdodCkub2Zmc2V0WChvZmZzZXRYKTtcbiAgICB0aGlzLiRpbnRlcmFjdGlvbnNMYXllci5vZmZzZXRYKC1vZmZzZXRYKTtcbiAgICB0aGlzLiRiYWNrZ3JvdW5kTGF5ZXIub2Zmc2V0WCgtb2Zmc2V0WCk7XG4gICAgdGhpcy4kYmFja2dyb3VuZExheWVyLmNoaWxkcmVuWzBdLngoMCkueSgwKS53aWR0aCh3aWR0aCkuaGVpZ2h0KHRoaXMuaGVpZ2h0KS5vcGFjaXR5KDApLm1vdmVUb0JvdHRvbSgpO1xuICAgIHRoaXMuJGJhY2tncm91bmRMYXllci5iYXRjaERyYXcoKTtcblxuICAgIC8qXG4gICAgICogQ2hhbmdlIHRoZSBsYXllciBzdGFjayBvcmRlciBhY2NvcmRpbmcgdG8gTGF5ZXIuekluZGV4LlxuICAgICAqL1xuICAgIC8vIHZhciB6SW5kZXhDb3VudGVyID0gMDtcbiAgICAvLyB2YXIgbWF4WkluZGV4ID0gLUluZmluaXR5O1xuICAgIC8vIHRoaXMuJGJhY2tncm91bmRMYXllci5zZXRaSW5kZXgoekluZGV4Q291bnRlcisrKTtcbiAgICAvLyB0aGlzLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgIC8vICAgbGF5ZXIuX2NvbnRleHRMYXllci5zZXRaSW5kZXgobGF5ZXIuekluZGV4ICsgekluZGV4Q291bnRlcisrKTtcbiAgICAvLyAgIGxheWVyLl9jb21tb25TaGFwZUxheWVyLnNldFpJbmRleChsYXllci56SW5kZXggKyB6SW5kZXhDb3VudGVyKyspO1xuICAgIC8vICAgbGF5ZXIuY29udGVudExheWVycy5mb3JFYWNoKChrb252YUxheWVyKSA9PiBrb252YUxheWVyLnNldFpJbmRleChsYXllci56SW5kZXggKyB6SW5kZXhDb3VudGVyKyspKTtcbiAgICAvLyAgIGxheWVyLl9kcmFnTGF5ZXIuc2V0WkluZGV4KGxheWVyLnpJbmRleCArIHpJbmRleENvdW50ZXIrKyk7XG4gICAgLy8gICBtYXhaSW5kZXggPSBNYXRoLm1heChtYXhaSW5kZXgsIGxheWVyLnpJbmRleCk7XG4gICAgLy8gfSlcbiAgICAvLyB0aGlzLiRpbnRlcmFjdGlvbnNMYXllci5zZXRaSW5kZXgobWF4WkluZGV4ICsgekluZGV4Q291bnRlcik7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbGF5ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PExheWVyPn0gW2xheWVycz1udWxsXSAtIGlmIG5vdCBudWxsLCBhIHN1YnNldCBvZiB0aGUgbGF5ZXJzIHRvIHVwZGF0ZS5cbiAgICovXG4gIHVwZGF0ZUxheWVycyhsYXllcnMpIHtcbiAgICBpZiAobGF5ZXJzID09PSB1bmRlZmluZWQpIFxuICAgICAgbGF5ZXJzID0gbnVsbDtcblxuICAgIGxheWVycyA9IChsYXllcnMgPT09IG51bGwpID8gdGhpcy5sYXllcnMgOiBsYXllcnM7XG5cbiAgICBpZiAoIShsYXllcnMgaW5zdGFuY2VvZiBTZXQpICYmICEobGF5ZXJzIGluc3RhbmNlb2YgQXJyYXkpKSBcbiAgICAgIGxheWVycyA9IFtsYXllcnNdO1xuXG4gICAgbGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiB7XG4gICAgICBpZiAoIXRoaXMubGF5ZXJzLmhhcyhsYXllcikpIHsgcmV0dXJuOyB9XG4gICAgICBsYXllci51cGRhdGUoKTtcbiAgICB9KTtcbiAgICB0aGlzLiRiYWNrZ3JvdW5kTGF5ZXIubW92ZVRvQm90dG9tKCk7XG4gIH1cblxuICBtaW5pbWl6ZSgpIHtcbiAgICAvLyBUT0RPXG4gIH1cblxuICBtYXhpbWl6ZSgpIHtcbiAgICAvLyBUT0RPXG4gIH1cblxuICBtb3ZlVG9Ub3AobGF5ZXIpIHtcbiAgICBsYXllci5fY29udGV4dExheWVyLm1vdmVUb1RvcCgpO1xuICAgIGxheWVyLl9jb21tb25TaGFwZUxheWVyLm1vdmVUb1RvcCgpO1xuICAgIGxheWVyLmNvbnRlbnRMYXllcnMuZm9yRWFjaCgoa29udmFMYXllcikgPT4ga29udmFMYXllci5tb3ZlVG9Ub3AoKSk7XG5cbiAgICB0aGlzLiRpbnRlcmFjdGlvbnNMYXllci5tb3ZlVG9Ub3AoKTtcbiAgICB0aGlzLiRiYWNrZ3JvdW5kTGF5ZXIubW92ZVRvQm90dG9tKCk7XG4gIH1cblxuICBtb3ZlVG9Cb3R0b20obGF5ZXIpIHtcbiAgICB0aGlzLiRpbnRlcmFjdGlvbnNMYXllci5tb3ZlVG9Ub3AoKTtcbiAgICBcbiAgICBsYXllci5jb250ZW50TGF5ZXJzLmZvckVhY2goKGtvbnZhTGF5ZXIpID0+IGtvbnZhTGF5ZXIubW92ZVRvQm90dG9tKCkpO1xuICAgIGxheWVyLl9jb21tb25TaGFwZUxheWVyLm1vdmVUb0JvdHRvbSgpO1xuICAgIGxheWVyLl9jb250ZXh0TGF5ZXIubW92ZVRvQm90dG9tKCk7XG4gICAgXG4gICAgdGhpcy4kYmFja2dyb3VuZExheWVyLm1vdmVUb0JvdHRvbSgpO1xuICB9XG5cblxuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyB0aHJvdWdoIHRoZSBhZGRlZCBsYXllcnMuXG4gICAqL1xuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgeWllbGQqIHRoaXMubGF5ZXJzW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxufVxuIiwiaW1wb3J0IEFubm90YXRlZE1hcmtlciBmcm9tICcuLi9zaGFwZXMvYW5ub3RhdGVkLW1hcmtlcic7XG5pbXBvcnQgTGF5ZXIgZnJvbSAnLi4vY29yZS9sYXllcic7XG5pbXBvcnQgTWFya2VyQmVoYXZpb3IgZnJvbSAnLi4vYmVoYXZpb3JzL21hcmtlci1iZWhhdmlvcic7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5ub3RhdGVkTWFya2VyTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCdjb2xsZWN0aW9uJywgZGF0YSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmNvbmZpZ3VyZVNoYXBlKEFubm90YXRlZE1hcmtlcik7XG4gICAgdGhpcy5zZXRCZWhhdmlvcihuZXcgTWFya2VyQmVoYXZpb3IoKSk7XG4gIH1cbn1cbiIsImltcG9ydCBMYXllciBmcm9tICcuLi9jb3JlL2xheWVyJztcbmltcG9ydCBBbm5vdGF0ZWRTZWdtZW50IGZyb20gJy4uL3NoYXBlcy9hbm5vdGF0ZWQtc2VnbWVudCc7XG5pbXBvcnQgU2VnbWVudEJlaGF2aW9yIGZyb20gJy4uL2JlaGF2aW9ycy9zZWdtZW50LWJlaGF2aW9yJztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbm5vdGF0ZWRTZWdtZW50TGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMgPSB7fSwgYWNjZXNzb3JzID0ge30pIHtcbiAgICBzdXBlcignY29sbGVjdGlvbicsIGRhdGEsIG9wdGlvbnMpO1xuXG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgZGlzcGxheUhhbmRsZXJzOiB0cnVlLFxuICAgICAgb3BhY2l0eTogMC42XG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmNvbmZpZ3VyZVNoYXBlKEFubm90YXRlZFNlZ21lbnQsIGFjY2Vzc29ycywge1xuICAgICAgZGlzcGxheUhhbmRsZXJzOiBvcHRpb25zLmRpc3BsYXlIYW5kbGVycyxcbiAgICAgIG9wYWNpdHk6IG9wdGlvbnMub3BhY2l0eSxcbiAgICB9KTtcblxuICAgIHRoaXMuc2V0QmVoYXZpb3IobmV3IFNlZ21lbnRCZWhhdmlvcigpKTtcbiAgfVxufVxuIiwiaW1wb3J0IExheWVyIGZyb20gJy4uL2NvcmUvbGF5ZXInO1xuaW1wb3J0IE1hcmtlciBmcm9tICcuLi9zaGFwZXMvbWFya2VyJztcbmltcG9ydCBCcmVha3BvaW50QmVoYXZpb3IgZnJvbSAnLi4vYmVoYXZpb3JzL21hcmtlci1iZWhhdmlvcic7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmVhdEdyaWRMYXllciBleHRlbmRzIExheWVyIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucyA9IHt9LCBhY2Nlc3NvcnMgPSB7fSkge1xuICAgIHN1cGVyKCdjb2xsZWN0aW9uJywgZGF0YSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnNvcnRfZGF0YSA9IG9wdGlvbnMuc29ydF9kYXRhO1xuICAgIHRoaXMudmlzaWJsZV9kYXRhID0gb3B0aW9ucy52aXNpYmxlX2RhdGE7XG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGRpc3BsYXlIYW5kbGVyczogdHJ1ZSB9LCBvcHRpb25zKTtcbiAgICBjb25zdCBjb2xvciA9IG9wdGlvbnMuY29sb3I7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBhY2Nlc3NvcnMuY29sb3IgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbG9yOyB9O1xuICAgIH1cblxuICAgIHRoaXMuY29uZmlndXJlU2hhcGUoTWFya2VyLCBhY2Nlc3NvcnMsIHtcbiAgICAgIGRpc3BsYXlIYW5kbGVyczogb3B0aW9ucy5kaXNwbGF5SGFuZGxlcnNcbiAgICB9KTtcblxuICAgIHRoaXMuc2V0QmVoYXZpb3IobmV3IEJyZWFrcG9pbnRCZWhhdmlvcigpKTtcbiAgfVxufVxuIiwiaW1wb3J0IEJyZWFrcG9pbnRCZWhhdmlvciBmcm9tICcuLi9iZWhhdmlvcnMvYnJlYWtwb2ludC1iZWhhdmlvcic7XG5pbXBvcnQgRG90IGZyb20gJy4uL3NoYXBlcy9kb3QnO1xuaW1wb3J0IExheWVyIGZyb20gJy4uL2NvcmUvbGF5ZXInO1xuaW1wb3J0IExpbmUgZnJvbSAnLi4vc2hhcGVzL2xpbmUnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJyZWFrcG9pbnRMYXllciBleHRlbmRzIExheWVyIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucyA9IHt9LCBhY2Nlc3NvcnMgPSB7fSkge1xuICAgIHN1cGVyKCdjb2xsZWN0aW9uJywgZGF0YSwgb3B0aW9ucyk7XG4gICAgXG4gICAgdGhpcy5zb3J0X2RhdGEgPSBvcHRpb25zLnNvcnRfZGF0YTtcbiAgICB0aGlzLnZpc2libGVfZGF0YSA9IG9wdGlvbnMudmlzaWJsZV9kYXRhO1xuXG4gICAgY29uc3QgY29sb3IgPSBvcHRpb25zLmNvbG9yO1xuICAgIGxldCBjb21tb25TaGFwZU9wdGlvbnMgPSB7fTtcblxuICAgIGlmIChjb2xvcikge1xuICAgICAgYWNjZXNzb3JzLmNvbG9yID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb2xvcjsgfTtcbiAgICAgIGNvbW1vblNoYXBlT3B0aW9ucy5jb2xvciA9IGNvbG9yO1xuICAgIH1cblxuICAgIHRoaXMuY29uZmlndXJlQ29tbW9uU2hhcGUoTGluZSwgYWNjZXNzb3JzLCBjb21tb25TaGFwZU9wdGlvbnMpO1xuICAgIHRoaXMuY29uZmlndXJlU2hhcGUoRG90LCBhY2Nlc3NvcnMsIHt9KTtcbiAgICB0aGlzLnNldEJlaGF2aW9yKG5ldyBCcmVha3BvaW50QmVoYXZpb3IoKSk7XG4gIH1cbn1cbiIsImltcG9ydCBMYXllciBmcm9tICcuLi9jb3JlL2xheWVyJztcbmltcG9ydCBDdXJzb3IgZnJvbSAnLi4vc2hhcGVzL2N1cnNvcic7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3Vyc29yTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgICAgY29sb3I6ICdyZWQnLFxuICAgICAgaGl0dGFibGU6IGZhbHNlLCAvLyBraW5kIG9mIHBhc3MgdGhyb3VnaCBsYXllclxuICAgIH07XG5cbiAgICBjb25zdCBkYXRhID0geyBjdXJyZW50UG9zaXRpb246IDAgfTtcblxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICBzdXBlcignZW50aXR5JywgZGF0YSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmNvbmZpZ3VyZVNoYXBlKEN1cnNvciwgeyB4OiAoZCkgPT4gZC5jdXJyZW50UG9zaXRpb24gfSwge1xuICAgICAgY29sb3I6IG9wdGlvbnMuY29sb3JcbiAgICB9KTtcblxuICAgIHRoaXMuZGF0YVswXSA9IGRhdGE7XG4gIH1cblxuICBzZXQgY3VycmVudFBvc2l0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5kYXRhWzBdLmN1cnJlbnRQb3NpdGlvbiA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhWzBdLmN1cnJlbnRQb3NpdGlvbjtcbiAgfVxufVxuIiwiaW1wb3J0IEF4aXNMYXllciBmcm9tICcuLi9heGlzL2F4aXMtbGF5ZXInO1xuaW1wb3J0IFRpY2tzIGZyb20gJy4uL3NoYXBlcy90aWNrcyc7XG5pbXBvcnQgZ3JpZEF4aXNHZW5lcmF0b3IgZnJvbSAnLi4vYXhpcy9ncmlkLWF4aXMtZ2VuZXJhdG9yJztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmlkQXhpc0xheWVyIGV4dGVuZHMgQXhpc0xheWVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNvbG9yOiAnc3RlZWxibHVlJyxcbiAgICAgIGJwbTogNjAsXG4gICAgICBzaWduYXR1cmU6ICc0LzQnXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICBzdXBlcihncmlkQXhpc0dlbmVyYXRvcihvcHRpb25zLmJwbSwgb3B0aW9ucy5zaWduYXR1cmUpLCBvcHRpb25zKTtcblxuICAgIHRoaXMuY29uZmlndXJlU2hhcGUoVGlja3MsIHt9LCB7XG4gICAgICBjb2xvcjogb3B0aW9ucy5jb2xvclxuICAgIH0pO1xuICB9XG59IiwiaW1wb3J0IExheWVyIGZyb20gJy4uL2NvcmUvbGF5ZXInO1xuaW1wb3J0IE1hcmtlciBmcm9tICcuLi9zaGFwZXMvbWFya2VyJztcbmltcG9ydCBNYXJrZXJCZWhhdmlvciBmcm9tICcuLi9iZWhhdmlvcnMvbWFya2VyLWJlaGF2aW9yJztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXJrZXJMYXllciBleHRlbmRzIExheWVyIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucyA9IHt9LCBhY2Nlc3NvcnMgPSB7fSkge1xuICAgIHN1cGVyKCdjb2xsZWN0aW9uJywgZGF0YSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnNvcnRfZGF0YSA9IG9wdGlvbnMuc29ydF9kYXRhO1xuICAgIHRoaXMudmlzaWJsZV9kYXRhID0gb3B0aW9ucy52aXNpYmxlX2RhdGE7XG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGRpc3BsYXlIYW5kbGVyczogdHJ1ZSB9LCBvcHRpb25zKTtcbiAgICBjb25zdCBjb2xvciA9IG9wdGlvbnMuY29sb3I7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBhY2Nlc3NvcnMuY29sb3IgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbG9yOyB9O1xuICAgIH1cblxuICAgIHRoaXMuY29uZmlndXJlU2hhcGUoTWFya2VyLCBhY2Nlc3NvcnMsIHtcbiAgICAgIGRpc3BsYXlIYW5kbGVyczogb3B0aW9ucy5kaXNwbGF5SGFuZGxlcnNcbiAgICB9KTtcblxuICAgIHRoaXMuc2V0QmVoYXZpb3IobmV3IE1hcmtlckJlaGF2aW9yKCkpO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgVGltZWxpbmUgZnJvbSAnLi4vY29yZS90aW1lbGluZSc7XG5pbXBvcnQgVHJhY2sgZnJvbSAnLi4vY29yZS90cmFjayc7XG5pbXBvcnQgTGF5ZXIgZnJvbSAnLi4vY29yZS9sYXllcic7XG5pbXBvcnQgTGF5ZXJUaW1lQ29udGV4dCBmcm9tICcuLi9jb3JlL2xheWVyLXRpbWUtY29udGV4dCc7XG5pbXBvcnQgU2Nyb2xsU2VnbWVudEJlaGF2aW9yIGZyb20gJy4uL2JlaGF2aW9ycy9zY3JvbGwtc2VnbWVudC1iZWhhdmlvcic7XG5pbXBvcnQgU2VnbWVudCBmcm9tICcuLi9zaGFwZXMvc2VnbWVudCc7XG5pbXBvcnQgU2ltcGxlRWRpdGlvblN0YXRlIGZyb20gJy4uL3N0YXRlcy9zaW1wbGUtZWRpdGlvbi1zdGF0ZSc7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Nyb2xsZXIge1xuXHRjb25zdHJ1Y3RvcigkZWwsIHRhcmdldFRpbWVsaW5lLCBwaXhlbHNQZXJTZWNvbmQsIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR0aGlzLmF1eFRpbWVsaW5lID0gbmV3IFRpbWVsaW5lKHBpeGVsc1BlclNlY29uZCwgd2lkdGgpO1xuXHRcdHZhciB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0dC5jbGFzc0xpc3QuYWRkKFwic2Nyb2xsLWRpdlwiKTtcblx0XHQkZWwuYXBwZW5kQ2hpbGQodCk7XG5cblx0XHR0aGlzLmF1eFRyYWNrID0gbmV3IFRyYWNrKHQsIDIwLCB3aWR0aCk7XG5cblx0XHR0aGlzLmF1eFNjcm9sbExheWVyID0gbmV3IExheWVyKCdjb2xsZWN0aW9uJywgW10sIHtcblx0XHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdFx0eURvbWFpbjogWzAsIDFdXG5cdFx0fSk7XG5cdFx0dGhpcy5hdXhTY3JvbGxMYXllci5zZXRCZWhhdmlvcihuZXcgU2Nyb2xsU2VnbWVudEJlaGF2aW9yKHRhcmdldFRpbWVsaW5lKSk7XG5cdFx0dGhpcy5hdXhTY3JvbGxMYXllci5zZXRUaW1lQ29udGV4dChuZXcgTGF5ZXJUaW1lQ29udGV4dCh0aGlzLmF1eFRpbWVsaW5lLnRpbWVDb250ZXh0KSk7XG5cdFx0dGhpcy5hdXhTY3JvbGxMYXllci5jb25maWd1cmVTaGFwZShTZWdtZW50LCB7fSk7XG5cdFx0dGhpcy5hdXhTY3JvbGxMYXllci50aW1lQ29udGV4dC5sb2NrZWRUb1BhcmVudEludGVydmFsID0gdHJ1ZTtcblxuXHRcdHRoaXMuYXV4U2Nyb2xsTGF5ZXIuc29ydF9kYXRhID0gZnVuY3Rpb24oZGF0YSkge307XG5cdFx0dGhpcy5hdXhTY3JvbGxMYXllci52aXNpYmxlX2RhdGEgPSBmdW5jdGlvbih0aW1lQ29udGV4dCwgZGF0YSkgeyByZXR1cm4gWzAsIGRhdGEubGVuZ3RoLTFdOyB9O1xuXHRcdHRoaXMuYXV4U2Nyb2xsTGF5ZXIudGltZUNvbnRleHQubG9ja2VkVG9QYXJlbnRJbnRlcnZhbCA9IHRydWU7XG5cblx0XHR0aGlzLnNjcm9sbERhdHVtID0ge3g6dGFyZ2V0VGltZWxpbmUudmlzaWJsZUludGVydmFsLnN0YXJ0LCBkdXJhdGlvbjp0YXJnZXRUaW1lbGluZS52aXNpYmxlSW50ZXJ2YWwuZHVyYXRpb259O1xuXHRcdHRoaXMuYXV4U2Nyb2xsTGF5ZXIuYWRkKHRoaXMuc2Nyb2xsRGF0dW0pO1xuXG5cdFx0Y29uc29sZS5sb2codGFyZ2V0VGltZWxpbmUudmlzaWJsZUludGVydmFsKTtcblx0XHRjb25zb2xlLmxvZyh0aGlzLnNjcm9sbERhdHVtKTtcblxuXHRcdHRoaXMuYXV4VGltZWxpbmUudmlzaWJsZUludGVydmFsID0gdGFyZ2V0VGltZWxpbmUudmlzaWJsZUludGVydmFsO1xuXHRcdHRoaXMuYXV4VHJhY2suYWRkKHRoaXMuYXV4U2Nyb2xsTGF5ZXIpO1xuXHRcdHRoaXMuYXV4VGltZWxpbmUuYWRkKHRoaXMuYXV4VHJhY2spO1xuXHRcdHRoaXMuYXV4VGltZWxpbmUudHJhY2tzLnVwZGF0ZSgpO1xuXG5cdFx0dGhpcy5hdXhTY3JvbGxMYXllci5lZGl0KFt0aGlzLnNjcm9sbERhdHVtXSwgMCwgMCwgdGhpcy5hdXhTY3JvbGxMYXllci5nZXRTaGFwZUZyb21EYXR1bSh0aGlzLnNjcm9sbERhdHVtKS4kc2VnbWVudCk7XG5cblx0XHR0aGlzLmF1eFRpbWVsaW5lLnN0YXRlID0gbmV3IFNpbXBsZUVkaXRpb25TdGF0ZSh0aGlzLmF1eFRpbWVsaW5lKTtcblxuXHRcdGNvbnN0IHRoYXQgPSB0aGlzO1xuXHRcdHRoaXMuYXV4VGltZWxpbmUub24oJ2V2ZW50JywgKGUpPT4ge1xuXHRcdFx0aWYgKGUudHlwZSA9PSAnY2xpY2snICYmIGUudGFyZ2V0ICYmICFlLnRhcmdldC5zaGFwZSkge1xuXHRcdFx0XHRjb25zdCBvZmZzZXQgPSAoLXRoYXQuYXV4VGltZWxpbmUudGltZUNvbnRleHQub2Zmc2V0KTtcblx0XHRcdFx0Y29uc3QgdGltZSA9IHRoYXQuYXV4VGltZWxpbmUudGltZUNvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KGUueCk7XG5cdFx0XHRcdGNvbnN0IGN1cnJlbnRUaW1lID0gb2Zmc2V0ICsgdGltZTtcblx0XHRcdFx0Y29uc3QgZHggPSBlLnggLSB0aGF0LmF1eFRpbWVsaW5lLnRpbWVDb250ZXh0LnRpbWVUb1BpeGVsKHRoYXQuc2Nyb2xsRGF0dW0ueCk7XG5cdFx0XHRcdGNvbnN0IHNoYXBlID0gdGhhdC5hdXhTY3JvbGxMYXllci5nZXRTaGFwZUZyb21EYXR1bSh0aGF0LnNjcm9sbERhdHVtKTtcblxuXHRcdFx0XHR0aGF0LmF1eFNjcm9sbExheWVyLmVkaXQoW3RoYXQuc2Nyb2xsRGF0dW1dLCBkeCwgMCwgc2hhcGUuJHNlZ21lbnQpO1xuXHRcdFx0XHR0aGF0LmF1eFRpbWVsaW5lLnRyYWNrcy51cGRhdGUoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdHNldCBhdmFpbGFibGVTY3JvbGxSYW5nZShpbnRlcnZhbCkge1xuXHRcdHRoaXMuYXV4VGltZWxpbmUudmlzaWJsZUludGVydmFsID0gaW50ZXJ2YWw7XG5cdFx0dGhpcy5hdXhUaW1lbGluZS50cmFja3MudXBkYXRlKCk7XG5cdH1cblx0XG5cdGdldCBhdmFpbGFibGVTY3JvbGxSYW5nZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5hdXhUaW1lbGluZS52aXNpYmxlSW50ZXJ2YWw7XG5cdH1cblxuXHRzZXQgdmlzaWJsZVJhbmdlKGludGVydmFsKSB7XG5cdFx0Y29uc3QgdGFyZ2V0WCA9IHRoaXMuYXV4VGltZWxpbmUudGltZUNvbnRleHQudGltZVRvUGl4ZWwoaW50ZXJ2YWwuc3RhcnQpO1xuXHRcdGNvbnN0IHggPSB0aGlzLmF1eFRpbWVsaW5lLnRpbWVDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMuc2Nyb2xsRGF0dW0ueCk7XG5cdFx0Y29uc3QgZHggPSB0YXJnZXRYIC0geDtcblx0XHR0aGlzLnNjcm9sbERhdHVtLndpZHRoID0gaW50ZXJ2YWwuZHVyYXRpb247XG5cblx0XHRjb25zdCBzaGFwZSA9IHRoaXMuYXV4U2Nyb2xsTGF5ZXIuZ2V0U2hhcGVGcm9tRGF0dW0odGhpcy5zY3JvbGxEYXR1bSk7XG5cdFx0dGhpcy5hdXhTY3JvbGxMYXllci5lZGl0KFt0aGlzLnNjcm9sbERhdHVtXSwgZHgsIDAsIHNoYXBlLiRzZWdtZW50KTtcblxuXHRcdHRoaXMuYXV4VGltZWxpbmUudHJhY2tzLnVwZGF0ZSgpO1xuXHR9XG5cblx0Z2V0IHZpc2libGVSYW5nZSgpIHtcblx0XHRyZXR1cm4ge3N0YXJ0OiB0aGlzLnNjcm9sbERhdHVtLngsIGR1cmF0aW9uOiB0aGlzLnNjcm9sbERhdHVtLndpZHRofTtcblx0fVxuXG5cdHNldCBjb2xvcih2YWx1ZSkge1xuXHRcdHRoaXMuYXV4U2Nyb2xsTGF5ZXIuZ2V0U2hhcGVGcm9tRGF0dW0odGhpcy5zY3JvbGxEYXR1bSkucGFyYW1zLmNvbG9yID0gdmFsdWU7XG5cdFx0dGhpcy5hdXhUaW1lbGluZS50cmFja3MudXBkYXRlKCk7XG5cdH1cblxuXHRnZXQgY29sb3IoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXV4U2Nyb2xsTGF5ZXIuZ2V0U2hhcGVGcm9tRGF0dW0odGhpcy5zY3JvbGxEYXR1bSkucGFyYW1zLmNvbG9yO1xuXHR9XG59IiwiaW1wb3J0IExheWVyIGZyb20gJy4uL2NvcmUvbGF5ZXInO1xuaW1wb3J0IFNlZ21lbnQgZnJvbSAnLi4vc2hhcGVzL3NlZ21lbnQnO1xuaW1wb3J0IFNlZ21lbnRCZWhhdmlvciBmcm9tICcuLi9iZWhhdmlvcnMvc2VnbWVudC1iZWhhdmlvcic7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VnbWVudExheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBjb25zdHJ1Y3RvcihkYXRhLCBvcHRpb25zID0ge30sIGFjY2Vzc29ycyA9IHt9KSB7XG4gICAgc3VwZXIoJ2NvbGxlY3Rpb24nLCBkYXRhLCBvcHRpb25zKTtcblxuICAgIHRoaXMuc29ydF9kYXRhID0gb3B0aW9ucy5zb3J0X2RhdGE7XG4gICAgdGhpcy52aXNpYmxlX2RhdGEgPSBvcHRpb25zLnZpc2libGVfZGF0YTtcblxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGRpc3BsYXlIYW5kbGVyczogdHJ1ZSxcbiAgICAgIG9wYWNpdHk6IDAuNlxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5jb25maWd1cmVTaGFwZShTZWdtZW50LCBhY2Nlc3NvcnMsIHtcbiAgICAgIGRpc3BsYXlIYW5kbGVyczogb3B0aW9ucy5kaXNwbGF5SGFuZGxlcnMsXG4gICAgICBvcGFjaXR5OiBvcHRpb25zLm9wYWNpdHksXG4gICAgfSk7XG5cbiAgICB0aGlzLnNldEJlaGF2aW9yKG5ldyBTZWdtZW50QmVoYXZpb3IoKSk7XG4gIH1cbn1cbiIsImltcG9ydCBMYXllciBmcm9tICcuLi9jb3JlL2xheWVyJztcbmltcG9ydCBUaWNrcyBmcm9tICcuLi9zaGFwZXMvdGlja3MnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpY2tMYXllciBleHRlbmRzIExheWVyIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucywgYWNjZXNzb3JzKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICBzdXBlcignZW50aXR5JywgZGF0YSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnNvcnRfZGF0YSA9IG9wdGlvbnMuc29ydF9kYXRhO1xuICAgIHRoaXMudmlzaWJsZV9kYXRhID0gb3B0aW9ucy52aXNpYmxlX2RhdGE7XG5cbiAgICBjb25zdCBjb25maWcgPSBvcHRpb25zLmNvbG9yID8geyBjb2xvcjogb3B0aW9ucy5jb2xvciB9IDogdW5kZWZpbmVkO1xuICAgIHRoaXMuY29uZmlndXJlU2hhcGUoVGlja3MsIGFjY2Vzc29ycywgY29uZmlnKTtcbiAgfVxufSIsImltcG9ydCBBeGlzTGF5ZXIgZnJvbSAnLi4vYXhpcy9heGlzLWxheWVyJztcbmltcG9ydCBUaWNrcyBmcm9tICcuLi9zaGFwZXMvdGlja3MnO1xuaW1wb3J0IHRpbWVBeGlzR2VuZXJhdG9yIGZyb20gJy4uL2F4aXMvdGltZS1heGlzLWdlbmVyYXRvcic7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZUF4aXNMYXllciBleHRlbmRzIEF4aXNMYXllciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGNvbG9yOiAnc3RlZWxibHVlJyB9LCBvcHRpb25zKTtcbiAgICBzdXBlcih0aW1lQXhpc0dlbmVyYXRvcigpLCBvcHRpb25zKTtcblxuICAgIHRoaXMuc29ydF9kYXRhID0gb3B0aW9ucy5zb3J0X2RhdGE7XG4gICAgdGhpcy52aXNpYmxlX2RhdGEgPSBvcHRpb25zLnZpc2libGVfZGF0YTtcblxuICAgIHRoaXMuY29uZmlndXJlU2hhcGUoVGlja3MsIHt9LCB7XG4gICAgICBjb2xvcjogb3B0aW9ucy5jb2xvclxuICAgIH0pO1xuICB9XG59IiwiaW1wb3J0IExheWVyIGZyb20gJy4uL2NvcmUvbGF5ZXInO1xuaW1wb3J0IFRyYWNlUGF0aCBmcm9tICcuLi9zaGFwZXMvdHJhY2UtcGF0aCc7XG5pbXBvcnQgVHJhY2VEb3RzIGZyb20gJy4uL3NoYXBlcy90cmFjZS1kb3RzJztcbmltcG9ydCBUcmFjZUJlaGF2aW9yIGZyb20gJy4uL2JlaGF2aW9ycy90cmFjZS1iZWhhdmlvcic7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhY2VMYXllciBleHRlbmRzIExheWVyIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucyA9IHt9LCBhY2Nlc3NvcnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgZGlzcGxheURvdHM6IHRydWUgfSwgb3B0aW9ucyk7XG4gICAgc3VwZXIob3B0aW9ucy5kaXNwbGF5RG90cyA/ICdjb2xsZWN0aW9uJyA6ICdlbnRpdHknLCBkYXRhLCBvcHRpb25zKTtcblxuICAgIHRoaXMuc29ydF9kYXRhID0gb3B0aW9ucy5zb3J0X2RhdGE7XG4gICAgdGhpcy52aXNpYmxlX2RhdGEgPSBvcHRpb25zLnZpc2libGVfZGF0YTtcblxuICAgIGNvbnN0IHNoYXBlT3B0aW9ucyA9IHt9O1xuICAgIGlmIChvcHRpb25zLm1lYW5Db2xvciAhPT0gdW5kZWZpbmVkKSB7IHNoYXBlT3B0aW9ucy5tZWFuQ29sb3IgPSBvcHRpb25zLm1lYW5Db2xvcjsgfVxuICAgIGlmIChvcHRpb25zLnJhbmdlQ29sb3IgIT09IHVuZGVmaW5lZCkgeyBzaGFwZU9wdGlvbnMucmFuZ2VDb2xvciA9IG9wdGlvbnMucmFuZ2VDb2xvcjsgfVxuICAgIGlmIChvcHRpb25zLmRpc3BsYXlNZWFuICE9PSB1bmRlZmluZWQpIHsgc2hhcGVPcHRpb25zLmRpc3BsYXlNZWFuID0gb3B0aW9ucy5kaXNwbGF5TWVhbjsgfVxuXG4gICAgaWYgKG9wdGlvbnMuZGlzcGxheURvdHMpIHtcbiAgICAgIHRoaXMuY29uZmlndXJlQ29tbW9uU2hhcGUoVHJhY2VQYXRoLCBhY2Nlc3NvcnMsIHNoYXBlT3B0aW9ucyk7XG4gICAgICB0aGlzLmNvbmZpZ3VyZVNoYXBlKFRyYWNlRG90cywgYWNjZXNzb3JzLCBzaGFwZU9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbmZpZ3VyZVNoYXBlKFRyYWNlUGF0aCwgYWNjZXNzb3JzLCBzaGFwZU9wdGlvbnMpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QmVoYXZpb3IobmV3IFRyYWNlQmVoYXZpb3IoKSk7XG4gIH1cbn0iLCJpbXBvcnQgTGF5ZXIgZnJvbSAnLi4vY29yZS9sYXllcic7XG5pbXBvcnQgV2F2ZWZvcm0gZnJvbSAnLi4vc2hhcGVzL3dhdmVmb3JtJztcblxuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgeURvbWFpbjogWy0xLCAxXSxcbiAgY2hhbm5lbDogMCxcbiAgY29sb3I6ICdzdGVlbGJsdWUnLFxuICByZW5kZXJpbmdTdHJhdGVneTogJ3N2Zydcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdhdmVmb3JtTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgc3VwZXIoJ2NvbGxlY3Rpb24nLCBkYXRhLCBvcHRpb25zKTtcblxuICAgIHRoaXMuc29ydF9kYXRhID0gb3B0aW9ucy5zb3J0X2RhdGE7XG4gICAgdGhpcy52aXNpYmxlX2RhdGEgPSBvcHRpb25zLnZpc2libGVfZGF0YTtcblxuICAgIHRoaXMuY29uZmlndXJlU2hhcGUoV2F2ZWZvcm0sIHt9LCB7XG4gICAgICBzYW1wbGVSYXRlOiBidWZmZXIuc2FtcGxlUmF0ZSxcbiAgICAgIGNvbG9yOiBvcHRpb25zLmNvbG9yLFxuICAgICAgcmVuZGVyaW5nU3RyYXRlZ3k6IG9wdGlvbnMucmVuZGVyaW5nU3RyYXRlZ3lcbiAgICB9KTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IGV2ZW50cyBmcm9tICdldmVudHMnO1xuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIHRvIGV4dGVuZCB0byBjcmVhdGUgbmV3IHNvdXJjZXMgb2YgaW50ZXJhY3Rpb25zLlxuICogQSBgU3VyZmFjZWAgYW5kIGBLZXlib2FyZGAgZXZlbnQgc291cmNlcyBhcmUgcHJvdmlkZWQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50U291cmNlIGV4dGVuZHMgZXZlbnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCRlbCkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogVGhlIGVsZW1lbnQgb24gd2hpY2ggdGhlIGxpc3RlbmVyIGlzIGFkZGVkXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy4kZWwgPSAkZWw7XG5cbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gIH1cblxuICBfY3JlYXRlRXZlbnQodHlwZSwgZSkge31cblxuICBfYmluZEV2ZW50cygpIHt9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgRXZlbnRTb3VyY2UgZnJvbSAnLi9ldmVudC1zb3VyY2UnO1xuaW1wb3J0IFdhdmVFdmVudCBmcm9tICcuL3dhdmUtZXZlbnQnO1xuXG4vKipcbiAqIEEgZ2xvYmFsIGV2ZW50IHNvdXJ2ZSBmb3IgdGhlIGtleWJvYXJkLiBPbmx5IG9uZSBpbnN0YW5jZSBvZiB0aGlzIHNvdXJjZVxuICogY2FuIGJlIGNyZWF0ZWQuIFRoZSBmaXJzdCBjcmVhdGVkIHRpbWVsaW5lIGluc3RhbmNpYXRlIHRoZSBzaW5nbGV0b24sIGVhY2hcbiAqIHN1YnNlcXVlbnQgaW5zdGFuY2lhdGlvbiByZXR1cm5zIHRoZSBmaXJzdCBjcmVhdGVkIGluc3RhbmNlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLZXlib2FyZCBleHRlbmRzIEV2ZW50U291cmNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gJGVsIC0gVGhlIGVsZW1lbnQgb24gd2hpY2ggdG8gaW5zdGFsbCB0aGUgbGlzdGVuZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigkZWwpIHtcbiAgICAvLyBraW5kIG9mIHNpbmdsZXRvblxuICAgIGlmIChLZXlib2FyZC5faW5zdGFuY2UpIHsgcmV0dXJuIEtleWJvYXJkLl9pbnN0YW5jZTsgfVxuXG4gICAgc3VwZXIoJGVsKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgc291cmNlXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZU5hbWUgPSAna2V5Ym9hcmQnO1xuXG4gICAgS2V5Ym9hcmQuX2luc3RhbmNlID0gdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVFdmVudCh0eXBlLCBlKSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgV2F2ZUV2ZW50KHRoaXMuc291cmNlTmFtZSwgdHlwZSwgZSk7XG5cbiAgICBldmVudC5zaGlmdEtleSA9IGUuc2hpZnRLZXk7XG4gICAgZXZlbnQuY3RybEtleSA9IGUuY3RybEtleTtcbiAgICBldmVudC5hbHRLZXkgPSBlLmFsdEtleTtcbiAgICBldmVudC5tZXRhS2V5ID0gZS5tZXRhS2V5O1xuICAgIGV2ZW50LmNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUua2V5Q29kZSk7XG5cbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cblxuICBfYmluZEV2ZW50cygpIHtcbiAgICBjb25zdCBvbktleURvd24gPSAoZSkgPT4ge1xuICAgICAgbGV0IGV2ZW50ID0gdGhpcy5fY3JlYXRlRXZlbnQoJ2tleWRvd24nLCBlKTtcbiAgICAgIHRoaXMuZW1pdCgnZXZlbnQnLCBldmVudCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uS2V5VXAgPSAoZSkgPT4ge1xuICAgICAgbGV0IGV2ZW50ID0gdGhpcy5fY3JlYXRlRXZlbnQoJ2tleXVwJywgZSk7XG4gICAgICB0aGlzLmVtaXQoJ2V2ZW50JywgZXZlbnQpO1xuICAgIH07XG5cbiAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25LZXlEb3duLCBmYWxzZSk7XG4gICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBvbktleVVwLCBmYWxzZSk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBFdmVudFNvdXJjZSBmcm9tICcuL2V2ZW50LXNvdXJjZSc7XG5pbXBvcnQgS29udmFXYXZlRXZlbnQgZnJvbSAnLi9rb252YS13YXZlLWV2ZW50JztcblxuLyoqXG4gKiBOb3JtYWxpemVzIG1vdXNlIHVzZXIgaW50ZXJhY3Rpb25zIHdpdGggdGhlIHRpbWVsaW5lIHVwb24gdGhlIERPTVxuICogY29udGFpbmVyIGVsZW1lbnQgb2YgYFRyYWNrYCBpbnN0YW5jZXMuIEFzIHNvb24gYXMgYSBgdHJhY2tgIGlzIGFkZGVkIHRvIGFcbiAqIGB0aW1lbGluZWAsIGl0cyBhdHRhY2hlZCBgU3VyZmFjZWAgaW5zdGFuY2Ugd2lsbCBlbWl0IHRoZSBtb3VzZSBldmVudHMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN1cmZhY2UgZXh0ZW5kcyBFdmVudFNvdXJjZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsIC0gVGhlIERPTSBlbGVtZW50IHRvIGxpc3Rlbi5cbiAgICogQHRvZG8gLSBBZGQgc29tZSBwYWRkaW5nIHRvIHRoZSBzdXJmYWNlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoJGVsKSB7XG4gICAgc3VwZXIoJGVsKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBldmVudCBzb3VyY2UuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZU5hbWUgPSAnc3VyZmFjZSc7XG4gICAgdGhpcy5fbW91c2VEb3duRXZlbnQgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogRmFjdG9yeSBtZXRob2QgZm9yIGBFdmVudGAgY2xhc3NcbiAgICovXG4gIF9jcmVhdGVFdmVudCh0eXBlLCBlKSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgS29udmFXYXZlRXZlbnQodGhpcy5zb3VyY2VOYW1lLCB0eXBlLCBlKTtcblxuICAgIGNvbnN0IHBvcyA9IHRoaXMuX2dldFJlbGF0aXZlUG9zaXRpb24oZSk7XG4gICAgZXZlbnQueCA9IHBvcy54O1xuICAgIGV2ZW50LnkgPSBwb3MueTtcblxuICAgIHJldHVybiBldmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB4LCB5IGNvb3JkaW5hdGVzIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIHRoZSBzdXJmYWNlIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgLSBSYXcgZXZlbnQgZnJvbSBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAdG9kbyAtIGhhbmRsZSBwYWRkaW5nLlxuICAgKi9cbiAgX2dldFJlbGF0aXZlUG9zaXRpb24oZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgTW91c2VFdmVudCkge1xuICAgICAgbGV0IHggPSBlLm9mZnNldFg7XG4gICAgICBsZXQgeSA9IGUub2Zmc2V0WTtcbiAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHggPSBlLmV2dC5vZmZzZXRYO1xuICAgICAgbGV0IHkgPSBlLmV2dC5vZmZzZXRZO1xuICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH1cbiAgfVxuXG4gIF9kZWZpbmVBcmVhKGUsIG1vdXNlRG93bkV2ZW50LCBsYXN0RXZlbnQpIHtcbiAgICBpZiAoIW1vdXNlRG93bkV2ZW50IHx8ICFsYXN0RXZlbnQpIHsgcmV0dXJuOyB9XG4gICAgZS5keCA9IGUueCAtIGxhc3RFdmVudC54O1xuICAgIGUuZHkgPSBlLnkgLSBsYXN0RXZlbnQueTtcblxuICAgIGNvbnN0IGxlZnQgPSBtb3VzZURvd25FdmVudC54IDwgZS54ID8gbW91c2VEb3duRXZlbnQueCA6IGUueDtcbiAgICBjb25zdCB0b3AgID0gbW91c2VEb3duRXZlbnQueSA8IGUueSA/IG1vdXNlRG93bkV2ZW50LnkgOiBlLnk7XG4gICAgY29uc3Qgd2lkdGggID0gTWF0aC5hYnMoTWF0aC5yb3VuZChlLnggLSBtb3VzZURvd25FdmVudC54KSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5hYnMoTWF0aC5yb3VuZChlLnkgLSBtb3VzZURvd25FdmVudC55KSk7XG5cbiAgICBlLmFyZWEgPSB7IGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEtlZXAgdGhpcyBwcml2YXRlIHRvIGF2b2lkIGRvdWJsZSBldmVudCBiaW5kaW5nLiBNYWluIGxvZ2ljIG9mIHRoZSBzdXJmYWNlXG4gICAqIGlzIGhlcmUuIFNob3VsZCBiZSBleHRlbmRlZCB3aXRoIG5lZWRlZCBldmVudHMgKG1vdXNlZW50ZXIsIG1vdXNlbGVhdmUsXG4gICAqIHdoZWVsIC4uLikuXG4gICAqL1xuICBfYmluZEV2ZW50cygpIHtcbiAgICBcbiAgICBjb25zdCBvbk1vdXNlRHJhZyA9IChlKSA9PiB7XG5cbiAgICAgIGxldCBldmVudCA9IHRoaXMuX2NyZWF0ZUV2ZW50KCdtb3VzZW1vdmUnLCBlKTtcbiAgICAgIHRoaXMuX2RlZmluZUFyZWEoZXZlbnQsIHRoaXMuX21vdXNlRG93bkV2ZW50LCB0aGlzLl9sYXN0RXZlbnQpO1xuICAgICAgLy8gVXBkYXRlIGBsYXN0RXZlbnRgIGZvciBuZXh0IGNhbGxcbiAgICAgIHRoaXMuX2xhc3RFdmVudCA9IGV2ZW50O1xuXG4gICAgICB0aGlzLmVtaXQoJ2V2ZW50JywgZXZlbnQpO1xuICAgIH07XG5cbiAgICBjb25zdCBvbk1vdXNlVXAgPSAoZSkgPT4ge1xuXG4gICAgICBpZiAodGhpcy5fbGFzdEV2ZW50LnR5cGUgPT0gJ21vdXNlbW92ZScpIHtcblxuICAgICAgICBsZXQgZXZlbnQgPSB0aGlzLl9jcmVhdGVFdmVudCgnbW91c2V1cCcsIGUpO1xuICAgICAgICB0aGlzLl9kZWZpbmVBcmVhKGV2ZW50LCB0aGlzLl9tb3VzZURvd25FdmVudCwgdGhpcy5fbGFzdEV2ZW50KTtcblxuICAgICAgICB0aGlzLl9tb3VzZURvd25FdmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG4gICAgICAgIC8vIFJlbW92ZSBtb3VzZW1vdmUgYW5kIG1vdXNldXAgbGlzdGVuZXJzIG9uIHdpbmRvd1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG5cbiAgICAgICAgdGhpcy5lbWl0KCdldmVudCcsIGV2ZW50KTtcblxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9sYXN0RXZlbnQudHlwZSA9PSAnbW91c2Vkb3duJykge1xuXG4gICAgICAgIGxldCBldmVudDEgPSB0aGlzLl9jcmVhdGVFdmVudCgnbW91c2V1cCcsIGUpO1xuICAgICAgICBsZXQgZXZlbnQyID0gdGhpcy5fY3JlYXRlRXZlbnQoJ2NsaWNrJywgZSk7XG4gICAgICAgIGV2ZW50Mi50YXJnZXQgPSB0aGlzLl9tb3VzZURvd25FdmVudC50YXJnZXQ7XG5cbiAgICAgICAgdGhpcy5fbW91c2VEb3duRXZlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuXG4gICAgICAgIC8vIFJlbW92ZSBtb3VzZW1vdmUgYW5kIG1vdXNldXAgbGlzdGVuZXJzIG9uIHdpbmRvd1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG5cbiAgICAgICAgdGhpcy5lbWl0KCdldmVudCcsIGV2ZW50MSk7XG4gICAgICAgIHRoaXMuZW1pdCgnZXZlbnQnLCBldmVudDIpO1xuXG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG9uTW91c2VEb3duID0gKGUpID0+IHtcbiAgICAgIC8vIEJ5IHJlbW92aW5nIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24gd2UgcHJldmVudCBieXBhc3NpbmcgdGhlIG1vdXNlbW92ZSBldmVudHMgY29taW5nIGZyb20gU1ZHIGluIEZpcmVmb3guXG4gICAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICBjb25zdCBldmVudCA9IHRoaXMuX2NyZWF0ZUV2ZW50KCdtb3VzZWRvd24nLCBlKTtcblxuXG4gICAgICB0aGlzLl9tb3VzZURvd25FdmVudCA9IGV2ZW50O1xuICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gZXZlbnQ7XG4gICAgICAvLyBSZWdpc3RlciBtb3VzZW1vdmUgYW5kIG1vdXNldXAgbGlzdGVuZXJzIG9uIHdpbmRvd1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnLCBmYWxzZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCwgZmFsc2UpO1xuXG4gICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuXG4gICAgICB0aGlzLmVtaXQoJ2V2ZW50JywgZXZlbnQpO1xuICAgIH07XG5cbiAgICBjb25zdCBvbkNsaWNrID0gKGUpID0+IHtcbiAgICAgIGxldCBldmVudCA9IHRoaXMuX2NyZWF0ZUV2ZW50KCdjbGljaycsIGUpO1xuICAgICAgdGhpcy5lbWl0KCdldmVudCcsIGV2ZW50KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb25EYmxDbGljayA9IChlKSA9PiB7XG4gICAgICBsZXQgZXZlbnQgPSB0aGlzLl9jcmVhdGVFdmVudCgnZGJsY2xpY2snLCBlKTtcbiAgICAgIHRoaXMuZW1pdCgnZXZlbnQnLCBldmVudCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uTW91c2VPdmVyID0gKGUpID0+IHtcbiAgICAgIGxldCBldmVudCA9IHRoaXMuX2NyZWF0ZUV2ZW50KCdtb3VzZW92ZXInLCBlKTtcbiAgICAgIHRoaXMuZW1pdCgnZXZlbnQnLCBldmVudCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uTW91c2VPdXQgPSAoZSkgPT4ge1xuICAgICAgbGV0IGV2ZW50ID0gdGhpcy5fY3JlYXRlRXZlbnQoJ21vdXNlb3V0JywgZSk7XG4gICAgICB0aGlzLmVtaXQoJ2V2ZW50JywgZXZlbnQpO1xuICAgIH07XG5cbiAgICBjb25zdCBvbk1vdXNlRG93blRpbWVsaW5lID0gKGUpID0+IHtcbiAgICAgIGxldCBldmVudCA9IHRoaXMuX2NyZWF0ZUV2ZW50KCdtb3VzZWRvd24nLCBlKTtcbiAgICAgIHRoaXMuZW1pdCgnZXZlbnQnLCBldmVudCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uRG9tRHJhZ1N0YXJ0ID0gKGUpID0+IHtcbiAgICAgIGxldCBldmVudCA9IHRoaXMuX2NyZWF0ZUV2ZW50KCdkcmFnc3RhcnQnLCBlKTtcbiAgICAgIHRoaXMuZW1pdCgnZXZlbnQnLCBldmVudCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uRG9tRHJhZ092ZXIgPSAoZSkgPT4ge1xuICAgICAgbGV0IGV2ZW50ID0gdGhpcy5fY3JlYXRlRXZlbnQoJ2RyYWdvdmVyJywgZSk7XG4gICAgICB0aGlzLmVtaXQoJ2V2ZW50JywgZXZlbnQpO1xuICAgIH07XG5cbiAgICBjb25zdCBvbkRvbURyb3AgPSAoZSkgPT4ge1xuICAgICAgbGV0IGV2ZW50ID0gdGhpcy5fY3JlYXRlRXZlbnQoJ2Ryb3AnLCBlKTtcbiAgICAgIHRoaXMuZW1pdCgnZXZlbnQnLCBldmVudCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uRG9tRHJhZ0xlYXZlID0gKGUpID0+IHtcbiAgICAgIGxldCBldmVudCA9IHRoaXMuX2NyZWF0ZUV2ZW50KCdkcmFnbGVhdmUnLCBlKTtcbiAgICAgIHRoaXMuZW1pdCgnZXZlbnQnLCBldmVudCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uRG9tRHJhZ0VudGVyID0gKGUpID0+IHtcbiAgICAgIGxldCBldmVudCA9IHRoaXMuX2NyZWF0ZUV2ZW50KCdkcmFnZW50ZXInLCBlKTtcbiAgICAgIHRoaXMuZW1pdCgnZXZlbnQnLCBldmVudCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogV2hlbiBJIGxpc3RlbiBmb3IgdGhlICdjbGljaycgZXZlbnQsIHRoZXJlIGlzIHRoZSBmb2xsb3dpbmcgaXNzdWUgZm9yICdkcmFnJyBzZXF1ZW5jZXM6XG4gICAgICpcbiAgICAgKiAoMSkgW21vdXNlZG93biAtPiBtb3VzZW1vdmUgLT4gY2xpY2sgLT4gbW91c2V1cF0gXG4gICAgICogIGluc3RlYWQgb2YgXG4gICAgICogKDIpIFttb3VzZWRvd24gLT4gbW91c2Vtb3ZlIC0+IG1vdXNldXBdXG4gICAgICogXG4gICAgICogRm9yIHRoaXMgcmVhc29uLCBpbnN0ZWFkIG9mIGRpcmVjdGx5IGxpc3RlbmluZyBmb3IgJ2NsaWNrJywgSSBhZGFwdGVkIHRoZSAnbW91c2V1cCcgXG4gICAgICogbGlzdGVuZXIgdG8gZW5mb3JjZSB0aGUgc2VxdWVuY2UgKDIpIGFuZCBbbW91c2Vkb3duIC0+IG1vdXNldXAgLT4gY2xpY2tdIC5cbiAgICAgKi9cblxuICAgIC8vIEJpbmQgY2FsbGJhY2tzXG4gICAgLy8gdGhpcy4kZWwuJHN0YWdlLm9uKCdjb250ZW50TW91c2Vkb3duJywgb25Nb3VzZURvd25UaW1lbGluZSk7XG4gICAgdGhpcy4kZWwuJHN0YWdlLm9uKCdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XG4gICAgLy8gdGhpcy4kZWwuJHN0YWdlLm9uKCdjbGljaycsIG9uQ2xpY2spOyBcbiAgICB0aGlzLiRlbC4kc3RhZ2Uub24oJ2RibGNsaWNrJywgb25EYmxDbGljayk7XG4gICAgdGhpcy4kZWwuJHN0YWdlLm9uKCdtb3VzZW92ZXInLCBvbk1vdXNlT3Zlcik7XG4gICAgdGhpcy4kZWwuJHN0YWdlLm9uKCdtb3VzZW91dCcsIG9uTW91c2VPdXQpO1xuICAgIHRoaXMuJGVsLiRzdGFnZS5vbignbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpO1xuICAgIHRoaXMuJGVsLiRzdGFnZS5jb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIG9uRG9tRHJhZ1N0YXJ0KTtcbiAgICB0aGlzLiRlbC4kc3RhZ2UuY29udGVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCBvbkRvbURyYWdFbnRlcik7XG4gICAgdGhpcy4kZWwuJHN0YWdlLmNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIG9uRG9tRHJvcCk7XG4gICAgdGhpcy4kZWwuJHN0YWdlLmNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCBvbkRvbURyYWdPdmVyKTtcbiAgICB0aGlzLiRlbC4kc3RhZ2UuY29udGVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLCBvbkRvbURyYWdMZWF2ZSk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBXYXZlRXZlbnQgZnJvbSAnLi93YXZlLWV2ZW50JztcblxuLyoqXG4gKiBPYmplY3QgdGVtcGxhdGUgZm9yIGFsbCBldmVudHMuIEV2ZW50IHNvdXJjZXMgc2hvdWxkIHVzZSB0aGlzIGV2ZW50IHRlbXBsYXRlXG4gKiBpbiBvcmRlciB0byBrZWVwIGNvbnNpc3RlbmN5IHdpdGggZXhpc3Rpbmcgc291cmNlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS29udmFXYXZlRXZlbnQgZXh0ZW5kcyBXYXZlRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZSAtIFRoZSBuYW1lIG9mIHRoZSBzb3VyY2UgKGBrZXlib2FyZGAsIGBzdXJmYWNlYCwgLi4uKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgc291cmNlIChgbW91c2Vkb3duYCwgYGtleXVwYCwgLi4uKS5cbiAgICogQHBhcmFtIHtFdmVudH0gb3JpZ2luYWxFdmVudCAtIFRoZSBvcmlnaW5hbCBldmVudCBhcyBlbWl0dGVkIGJ5IHRoZSBicm93c2VyLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc291cmNlLCB0eXBlLCBvcmlnaW5hbEV2ZW50KSB7XG4gICAgc3VwZXIoc291cmNlLCB0eXBlLCBvcmlnaW5hbEV2ZW50KTtcbiAgICBpZiAoIShvcmlnaW5hbEV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCkpIHtcbiAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQuZXZ0O1xuICAgICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gb3JpZ2luYWxFdmVudC5ldnQuY3VycmVudFRhcmdldDtcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBPYmplY3QgdGVtcGxhdGUgZm9yIGFsbCBldmVudHMuIEV2ZW50IHNvdXJjZXMgc2hvdWxkIHVzZSB0aGlzIGV2ZW50IHRlbXBsYXRlXG4gKiBpbiBvcmRlciB0byBrZWVwIGNvbnNpc3RlbmN5IHdpdGggZXhpc3Rpbmcgc291cmNlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2F2ZUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2UgLSBUaGUgbmFtZSBvZiB0aGUgc291cmNlIChga2V5Ym9hcmRgLCBgc3VyZmFjZWAsIC4uLikuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgdGhlIHNvdXJjZSAoYG1vdXNlZG93bmAsIGBrZXl1cGAsIC4uLikuXG4gICAqIEBwYXJhbSB7RXZlbnR9IG9yaWdpbmFsRXZlbnQgLSBUaGUgb3JpZ2luYWwgZXZlbnQgYXMgZW1pdHRlZCBieSB0aGUgYnJvd3Nlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgdHlwZSwgb3JpZ2luYWxFdmVudCkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcblxuICAgIHRoaXMudGFyZ2V0ID0gb3JpZ2luYWxFdmVudC50YXJnZXQ7XG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gb3JpZ2luYWxFdmVudC5jdXJyZW50VGFyZ2V0O1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgTWFya2VyIGZyb20gJy4vbWFya2VyJztcbmltcG9ydCBLb252YSBmcm9tICdrb252YSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFubm90YXRlZE1hcmtlciBleHRlbmRzIE1hcmtlciB7XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiRsYWJlbC5kZXN0cm95KCk7XG4gICAgdGhpcy4kbGFiZWwgPSBudWxsO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuXG4gIGdldENsYXNzTmFtZSgpIHsgcmV0dXJuICdhbm5vdGF0ZWQtc2VnbWVudCc7IH1cblxuICBfZ2V0QWNjZXNzb3JMaXN0KCkge1xuICAgIGxldCBsaXN0ID0gc3VwZXIuX2dldEFjY2Vzc29yTGlzdCgpO1xuICAgIGxpc3QudGV4dCA9ICdkZWZhdWx0JztcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuXG4gIHJlbmRlcihyZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgaWYgKHRoaXMuJGVsKSB7IHJldHVybiB0aGlzLiRlbDsgfVxuICAgIFxuICAgIHRoaXMuJGVsID0gc3VwZXIucmVuZGVyKHJlbmRlcmluZ0NvbnRleHQpO1xuXG4gICAgdGhpcy4kbGFiZWwgPSBuZXcgS29udmEuVGV4dCh7IGxpc3RlbmluZzogZmFsc2UgfSk7XG4gICAgdGhpcy4kbGFiZWwuYWRkTmFtZSgndGV4dCcpO1xuXG4gICAgdGhpcy4kZWwucHVzaCh0aGlzLiRsYWJlbCk7XG5cbiAgICByZXR1cm4gdGhpcy4kZWw7XG4gIH1cblxuICB1cGRhdGUocmVuZGVyaW5nQ29udGV4dCwgZGF0dW0pIHtcbiAgICB2YXIgZCA9IGRhdHVtIHx8IHRoaXMuZGF0dW07XG5cbiAgICBzdXBlci51cGRhdGUocmVuZGVyaW5nQ29udGV4dCwgZCk7XG5cbiAgICBjb25zdCB3aWR0aCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwodGhpcy53aWR0aChkKSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5hYnMocmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwodGhpcy55KGQpICsgdGhpcy5oZWlnaHQoZCkpIC0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwodGhpcy55KGQpKSk7XG4gICAgY29uc3QgeCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwodGhpcy54KGQpKTtcbiAgICBjb25zdCB5ID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwodGhpcy55KGQpICsgdGhpcy5oZWlnaHQoZCkpO1xuICAgIGNvbnN0IHRleHQgPSB0aGlzLnRleHQoZCk7XG5cbiAgICB0aGlzLiRsYWJlbC54KHggKyAzKS55KHkgKyAxMSk7XG4gICAgdGhpcy4kbGFiZWwuaGVpZ2h0KHkpO1xuICAgIHRoaXMuJGxhYmVsLmZpbGwoJyMyNDI0MjQnKTtcbiAgICB0aGlzLiRsYWJlbC5mb250U2l6ZSgxMCk7XG4gICAgdGhpcy4kbGFiZWwuZm9udEZhbWlseSgnbW9ub3NwYWNlJyk7XG4gICAgdGhpcy4kbGFiZWwudGV4dCh0ZXh0KTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IFNlZ21lbnQgZnJvbSAnLi9zZWdtZW50JztcbmltcG9ydCBLb252YSBmcm9tICdrb252YSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFubm90YXRlZFNlZ21lbnQgZXh0ZW5kcyBTZWdtZW50IHtcblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuJGxhYmVsLmRlc3Ryb3koKTtcbiAgICB0aGlzLiRsYWJlbCA9IG51bGw7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG5cbiAgZ2V0Q2xhc3NOYW1lKCkgeyByZXR1cm4gJ2Fubm90YXRlZC1zZWdtZW50JzsgfVxuXG4gIF9nZXRBY2Nlc3Nvckxpc3QoKSB7XG4gICAgbGV0IGxpc3QgPSBzdXBlci5fZ2V0QWNjZXNzb3JMaXN0KCk7XG4gICAgbGlzdC50ZXh0ID0gJ2RlZmF1bHQnO1xuICAgIHJldHVybiBsaXN0O1xuICB9XG5cbiAgcmVuZGVyKHJlbmRlcmluZ0NvbnRleHQpIHtcbiAgICBpZiAodGhpcy4kZWwpIHsgcmV0dXJuIHRoaXMuJGVsOyB9XG4gICAgXG4gICAgdGhpcy4kZWwgPSBzdXBlci5yZW5kZXIocmVuZGVyaW5nQ29udGV4dCk7XG5cbiAgICB0aGlzLiRsYWJlbCA9IG5ldyBLb252YS5UZXh0KHsgbGlzdGVuaW5nOiBmYWxzZSB9KTtcbiAgICB0aGlzLiRsYWJlbC5hZGROYW1lKCd0ZXh0Jyk7XG5cbiAgICB0aGlzLiRlbC5wdXNoKHRoaXMuJGxhYmVsKTtcblxuICAgIHJldHVybiB0aGlzLiRlbDtcbiAgfVxuXG4gIHVwZGF0ZShyZW5kZXJpbmdDb250ZXh0LCBkYXR1bSkge1xuICAgIHZhciBkID0gZGF0dW0gfHwgdGhpcy5kYXR1bTtcblxuICAgIHN1cGVyLnVwZGF0ZShyZW5kZXJpbmdDb250ZXh0LCBkKTtcblxuICAgIGNvbnN0IHdpZHRoID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLndpZHRoKGQpKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmFicyhyZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbCh0aGlzLnkoZCkgKyB0aGlzLmhlaWdodChkKSkgLSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbCh0aGlzLnkoZCkpKTtcbiAgICBjb25zdCB4ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLngoZCkpO1xuICAgIGNvbnN0IHkgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbCh0aGlzLnkoZCkgKyB0aGlzLmhlaWdodChkKSk7XG4gICAgY29uc3QgdGV4dCA9IHRoaXMudGV4dChkKTtcblxuICAgIHRoaXMuJGxhYmVsLngoeCArIDMpLnkoeSArIDExKTtcbiAgICB0aGlzLiRsYWJlbC5oZWlnaHQoeSk7XG4gICAgdGhpcy4kbGFiZWwuZmlsbCgnIzI0MjQyNCcpO1xuICAgIHRoaXMuJGxhYmVsLmZvbnRTaXplKDEwKTtcbiAgICB0aGlzLiRsYWJlbC5mb250RmFtaWx5KCdtb25vc3BhY2UnKTtcbiAgICB0aGlzLiRsYWJlbC50ZXh0KHRleHQpO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgU2VnbWVudCBmcm9tICcuL3NlZ21lbnQnO1xuaW1wb3J0IEtvbnZhIGZyb20gJ2tvbnZhJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZVNoYXBlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3ZlcnJpZGUgZGVmYXVsdCBjb25maWd1cmF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgXG4gICAgICBvcHRpb25zID0ge307XG4gICAgLyoqIEB0eXBlIHtFbGVtZW50fSAtIEtvbnZhLkdyb3VwIHRvIGJlIHJldHVybmVkIGJ5IHRoZSBgcmVuZGVyYCBtZXRob2QuICovXG4gICAgdGhpcy4kZWwgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAtIE9iamVjdCBjb250YWluaW5nIHRoZSBnbG9iYWwgcGFyYW1ldGVycyBvZiB0aGUgc2hhcGUgKi9cbiAgICB0aGlzLnBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2dldERlZmF1bHRzKCksIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5sYXllciA9IG51bGw7XG5cbiAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLl9oaWdobGlnaHQgPSBmYWxzZTtcbiAgICB0aGlzLl9kYXR1bSA9IG51bGw7XG5cbiAgICAvLyBjcmVhdGUgYWNjZXNzb3JzIG1ldGhvZHMgYW5kIHNldCBkZWZhdWx0IGFjY2Vzc29yIGZ1bmN0aW9uc1xuICAgIGNvbnN0IGFjY2Vzc29ycyA9IHRoaXMuX2dldEFjY2Vzc29yTGlzdCgpO1xuICAgIHRoaXMuX2NyZWF0ZUFjY2Vzc29ycyhhY2Nlc3NvcnMpO1xuICAgIHRoaXMuX3NldERlZmF1bHRBY2Nlc3NvcnMoYWNjZXNzb3JzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBzaGFwZSBhbmQgY2xlYW4gcmVmZXJlbmNlcy4gSW50ZXJmYWNlIG1ldGhvZCBjYWxsZWQgZnJvbSB0aGUgYGxheWVyYC5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuJGVsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLiRlbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLiRlbFtpXS5zaGFwZSA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLiRlbC5sZW5ndGggPSAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy4kZWwpIHtcbiAgICAgIHRoaXMuJGVsLnNoYXBlID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4kZWwgPSBudWxsO1xuICAgIHRoaXMuJHBhcmFtcyA9IG51bGw7XG4gICAgdGhpcy5fYWNjZXNzb3JzID0gbnVsbDtcbiAgICB0aGlzLl9kYXR1bSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJmYWNlIG1ldGhvZCB0byBvdmVycmlkZSB3aGVuIGV4dGVuZGluZyB0aGlzIGJhc2UgY2xhc3MuIFRoZSBtZXRob2RcbiAgICogaXMgY2FsbGVkIGJ5IHRoZSBgTGF5ZXJ+cmVuZGVyYCBtZXRob2QuIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHNoYXBlLFxuICAgKiB1c2VkIGFzIGEgY2xhc3MgaW4gdGhlIGVsZW1lbnQgZ3JvdXAgKGRlZmF1bHRzIHRvIGAnc2hhcGUnYCkuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldENsYXNzTmFtZSgpIHsgcmV0dXJuICdzaGFwZSc7IH1cblxuICAvKipcbiAgICogQHRvZG8gbm90IGltcGxlbWVudGVkXG4gICAqIGFsbG93IHRvIGluc3RhbGwgZGVmcyBpbiB0aGUgdHJhY2sgc3ZnIGVsZW1lbnQuIFNob3VsZCBiZSBjYWxsZWQgd2hlblxuICAgKiBhZGRpbmcgdGhlIGBMYXllcmAgdG8gdGhlIGBUcmFja2AuXG4gICAqL1xuICAvLyBzZXRTdmdEZWZpbml0aW9uKGRlZnMpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlZmF1bHRzIGZvciBnbG9iYWwgY29uZmlndXJhdGlvbiBvZiB0aGUgc2hhcGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgX2dldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aGVyZSBrZXlzIGFyZSB0aGUgYWNjZXNzb3JzIG1ldGhvZHMgbmFtZXMgdG8gY3JlYXRlXG4gICAqIGFuZCB2YWx1ZXMgYXJlIHRoZSBkZWZhdWx0IHZhbHVlcyBmb3IgZWFjaCBnaXZlbiBhY2Nlc3Nvci5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKiBAdG9kbyByZW5hbWUgP1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBfZ2V0QWNjZXNzb3JMaXN0KCkgeyByZXR1cm4ge307IH1cblxuXG4gIC8qKlxuICAgKiBJbnRlcmZhY2UgbWV0aG9kIGNhbGxlZCBieSBMYXllciB3aGVuIGNyZWF0aW5nIGEgc2hhcGUuIEluc3RhbGwgdGhlXG4gICAqIGdpdmVuIGFjY2Vzc29ycyBvbiB0aGUgc2hhcGUsIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHQgYWNjZXNzb3JzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdDxTdHJpbmcsIGZ1bmN0aW9uPn0gYWNjZXNzb3JzXG4gICAqL1xuICBpbnN0YWxsKGFjY2Vzc29ycykge1xuICAgIGZvciAobGV0IGtleSBpbiBhY2Nlc3NvcnMpIHsgdGhpc1trZXldID0gYWNjZXNzb3JzW2tleV07IH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmljIG1ldGhvZCB0byBjcmVhdGUgYWNjZXNzb3JzLiBBZGRzIGdldHRlcnMgZW4gc2V0dGVycyB0byB0aGVcbiAgICogcHJvdG90eXBlIGlmIG5vdCBhbHJlYWR5IHByZXNlbnQuXG4gICAqL1xuICBfY3JlYXRlQWNjZXNzb3JzKGFjY2Vzc29ycykge1xuICAgIHRoaXMuX2FjY2Vzc29ycyA9IHt9O1xuICAgIC8vIGFkZCBpdCB0byB0aGUgcHJvdG90eXBlXG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7XG4gICAgLy8gY3JlYXRlIGEgZ2V0dGVyIC8gc2V0dGVyIGZvciBlYWNoIGFjY2Vzc29yc1xuICAgIC8vIHNldHRlciA6IGB0aGlzLnggPSBjYWxsYmFja2BcbiAgICAvLyBnZXR0ZXIgOiBgdGhpcy54KGRhdHVtKWBcbiAgICBPYmplY3Qua2V5cyhhY2Nlc3NvcnMpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgeyByZXR1cm47IH1cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBuYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9hY2Nlc3NvcnNbbmFtZV07IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgIHRoaXMuX2FjY2Vzc29yc1tuYW1lXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgYXMgYSBkZWZhdWx0IGFjY2Vzc29yIGZvciBlYWNoIGFjY2Vzb3JzXG4gICAqL1xuICBfc2V0RGVmYXVsdEFjY2Vzc29ycyhhY2Nlc3NvcnMpIHtcbiAgICBPYmplY3Qua2V5cyhhY2Nlc3NvcnMpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGFjY2Vzc29yc1tuYW1lXTtcbiAgICAgIGxldCBhY2Nlc3NvciA9IGZ1bmN0aW9uKGQsIHYpIHtcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkgdiA9IG51bGw7XG4gICAgICAgIGlmICh2ID09PSBudWxsKSB7IHJldHVybiBkW25hbWVdIHx8IGRlZmF1bHRWYWx1ZTsgfVxuICAgICAgICBkW25hbWVdID0gdjtcbiAgICAgIH07XG4gICAgICAvLyBzZXQgYWNjZXNzb3IgYXMgdGhlIGRlZmF1bHQgb25lXG4gICAgICB0aGlzW25hbWVdID0gYWNjZXNzb3I7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJmYWNlIG1ldGhvZCBjYWxsZWQgYnkgYExheWVyfnJlbmRlcmAuIENyZWF0ZXMgdGhlIERPTSBzdHJ1Y3R1cmUgb2ZcbiAgICogdGhlIHNoYXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVuZGVyaW5nQ29udGV4dCAtIHRoZSByZW5kZXJpbmdDb250ZXh0IG9mIHRoZSBsYXllclxuICAgKiAgICB3aGljaCBvd25zIHRoaXMgc2hhcGUuXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IC0gdGhlIERPTSBlbGVtZW50IHRvIGluc2VydCBpbiB0aGUgaXRlbSdzIGdyb3VwLlxuICAgKi9cbiAgcmVuZGVyKHJlbmRlcmluZ0NvbnRleHQpIHt9XG5cbiAgLyoqXG4gICAqIEludGVyZmFjZSBtZXRob2QgY2FsbGVkIGJ5IGBMYXllcn51cGRhdGVgLiBVcGRhdGVzIHRoZSBET00gc3RydWN0dXJlIG9mIHRoZSBzaGFwZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlbmRlcmluZ0NvbnRleHQgLSBUaGUgYHJlbmRlcmluZ0NvbnRleHRgIG9mIHRoZSBsYXllclxuICAgKiAgICB3aGljaCBvd25zIHRoaXMgc2hhcGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBkYXR1bSAtIFRoZSBkYXR1bSBhc3NvY2lhdGVkIHRvIHRoZSBzaGFwZS5cbiAgICovXG4gIHVwZGF0ZShyZW5kZXJpbmdDb250ZXh0LCBkYXR1bSkge31cblxuICAvKipcbiAgICogIFRPRE9cbiAgICovXG4gIGRyYXcoKSB7XG4gICAgaWYgKHRoaXMuJGVsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLiRlbC5sZW5ndGg7IGkrKykgXG4gICAgICAgIHRoaXMuJGVsW2ldLmRyYXcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kZWwuZHJhdygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcmZhY2UgbWV0aG9kIHRvIG92ZXJyaWRlIGNhbGxlZCBieSBgTGF5ZXJ+Z2V0SXRlbXNJbkFyZWFgLiBEZWZpbmVzIGlmXG4gICAqIHRoZSBzaGFwZSBpcyBjb25zaWRlcmVkIHRvIGJlIHRoZSBnaXZlbiBhcmVhLiBBcmd1bWVudHMgYXJlIHBhc3NlZCBpbiBwaXhlbCBkb21haW4uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZW5kZXJpbmdDb250ZXh0IC0gdGhlIHJlbmRlcmluZ0NvbnRleHQgb2YgdGhlIGxheWVyIHdoaWNoXG4gICAqICAgIG93bnMgdGhpcyBzaGFwZS5cbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGRhdHVtIC0gVGhlIGRhdHVtIGFzc29jaWF0ZWQgdG8gdGhlIHNoYXBlLlxuICAgKiBAcGFyYW0ge051bWJlcn0geDEgLSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgYXJlYSB0byB0ZXN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0geTEgLSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgYXJlYSB0byB0ZXN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0geDIgLSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIGJvdHRvbS1yaWdodCBjb3JuZXIgb2YgdGhlIGFyZWEgdG8gdGVzdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkyIC0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSBib3R0b20tcmlnaHQgY29ybmVyIG9mIHRoZSBhcmVhIHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IC0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGlzIGNvbnNpZGVyZWQgdG8gYmUgaW4gdGhlIGdpdmVuIGFyZWEsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKi9cbiAgaW5BcmVhKHJlbmRlcmluZ0NvbnRleHQsIGRhdHVtLCB4MSwgeTEsIHgyLCB5Mikge31cblxuICAvKlxuICAgKiBUT0RPXG4gICAqL1xuICBtaW5pbWl6ZSgpIHt9XG5cbiAgbWF4aW1pemUoKSB7fVxuXG4gIC8qXG4gICAqIFRPRE9cbiAgICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICB9XG5cbiAgc2V0IHZpc2libGUoaXNWaXNpYmxlKSB7XG4gICAgdGhpcy5fdmlzaWJsZSA9IGlzVmlzaWJsZTtcbiAgfVxuXG4gIC8qXG4gICAqIFRPRE9cbiAgICovXG4gIGdldCBkYXR1bSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0dW07XG4gIH1cblxuICBzZXQgZGF0dW0oZGF0dW0pIHtcbiAgICB0aGlzLl9kYXR1bSA9IGRhdHVtO1xuICB9XG5cblxuICBzdGFydERyYWcoKSB7XG4gICAgaWYgKHRoaXMuJGVsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHRoaXMuJGVsLmZvckVhY2goKGVsKSA9PiBlbC5zdGFydERyYWcoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGVsLnN0YXJ0RHJhZygpO1xuICAgIH1cbiAgfVxuXG4gIHN0b3BEcmFnKCkge1xuICAgIGlmICh0aGlzLiRlbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB0aGlzLiRlbC5mb3JFYWNoKChlbCkgPT4gZWwuc3RvcERyYWcoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGVsLnN0b3BEcmFnKCk7XG4gICAgfVxuICB9XG59IiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEJhc2VTaGFwZSBmcm9tICcuL2Jhc2Utc2hhcGUnO1xuaW1wb3J0IEtvbnZhIGZyb20gJ2tvbnZhJztcblxuLyoqXG4gKiBBIHNoYXBlIHRvIGRpc3BsYXkgYSBjdXJzb3IuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1cnNvciBleHRlbmRzIEJhc2VTaGFwZSB7XG4gIGdldENsYXNzTmFtZSgpIHsgcmV0dXJuICdjdXJzb3InOyB9XG5cbiAgX2dldEFjY2Vzc29yTGlzdCgpIHtcbiAgICByZXR1cm4geyB4OiAwIH07XG4gIH1cblxuICBfZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbG9yOiAnIzAwMDAwMCcsXG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgd2lkdGg6IDJcbiAgICB9O1xuICB9XG5cbiAgcmVuZGVyKHJlbmRlcmluZ0NvbnRleHQpIHtcbiAgICBpZiAodGhpcy4kZWwpIHsgcmV0dXJuIHRoaXMuJGVsOyB9XG5cbiAgICB0aGlzLiRlbCA9IG5ldyBLb252YS5SZWN0KHt9KTtcblxuICAgIHJldHVybiB0aGlzLiRlbDtcbiAgfVxuXG4gIHVwZGF0ZShyZW5kZXJpbmdDb250ZXh0LCBkYXR1bSkge1xuICAgIC8vIGNvbnN0IHggPSBNYXRoLnJvdW5kKHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwodGhpcy54KGRhdHVtKSkpICsgMC41O1xuICAgIGNvbnN0IHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMueChkYXR1bSkpO1xuXG4gICAgdGhpcy4kZWwueCh4KVxuICAgICAgICAgICAgLnkoMClcbiAgICAgICAgICAgIC53aWR0aCh0aGlzLnBhcmFtcy53aWR0aClcbiAgICAgICAgICAgIC5oZWlnaHQocmVuZGVyaW5nQ29udGV4dC5oZWlnaHQpXG4gICAgICAgICAgICAuZmlsbCh0aGlzLnBhcmFtcy5jb2xvcilcbiAgICAgICAgICAgIC5vcGFjaXR5KHRoaXMucGFyYW1zLm9wYWNpdHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJzb3IgY2Fubm90IGJlIHNlbGVjdGVkLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBmYWxzZVxuICAgKi9cbiAgaW5BcmVhKCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlU2hhcGUgZnJvbSAnLi9iYXNlLXNoYXBlJztcbmltcG9ydCBLb252YSBmcm9tICdrb252YSc7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG90IGV4dGVuZHMgQmFzZVNoYXBlIHtcblxuXHRkZXN0cm95KCkge1xuXHRcdHRoaXMuJGVsLmRlc3Ryb3koKTtcblx0XHRzdXBlci5kZXN0cm95KCk7XG5cdH1cblxuXHRnZXRDbGFzc05hbWUoKSB7IHJldHVybiAnZG90JzsgfVxuXG5cdC8vIEBUT0RPIHJlbmFtZSA6IGNvbmZ1c2lvbiBiZXR3ZWVuIGFjY2Vzc29ycyBhbmQgbWV0YS1hY2Nlc3NvcnNcblx0X2dldEFjY2Vzc29yTGlzdCgpIHtcblx0XHRyZXR1cm4geyB4OiAwLCB5OiAwIH07XG5cdH1cblxuXHRfZ2V0RGVmYXVsdHMoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGNvbG9yOiAnYmxhY2snLCBcblx0XHRcdHI6IDNcblx0XHR9O1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGlmICh0aGlzLiRlbCkgeyByZXR1cm4gdGhpcy4kZWw7IH1cblxuXHRcdHRoaXMuJGVsID0gbmV3IEtvbnZhLkNpcmNsZSh7fSk7XG5cdFx0dGhpcy4kZWwuc2hhcGUgPSB0aGlzO1xuXHRcdHRoaXMuJGVsLnBlcmZlY3REcmF3RW5hYmxlZChmYWxzZSk7XG5cblx0XHRyZXR1cm4gdGhpcy4kZWw7XG5cdH1cblxuXHR1cGRhdGUocmVuZGVyaW5nQ29udGV4dCwgZGF0dW0pIHtcblx0XHRjb25zdCBkID0gZGF0dW0gfHwgdGhpcy5kYXR1bTtcblxuXHRcdGNvbnN0IHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMueChkKSk7XG5cdFx0Y29uc3QgeSA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHRoaXMueShkKSk7XG5cdFx0Ly8gY29uc3Qgclx0PSB0aGlzLnIoZCk7XG5cdFx0Ly8gY29uc3QgY29sb3IgPSB0aGlzLmNvbG9yKGQpO1xuXHRcdGNvbnN0IHIgPSB0aGlzLnBhcmFtcy5yO1xuXHRcdGNvbnN0IGNvbG9yID0gdGhpcy5wYXJhbXMuY29sb3I7XG5cdFx0XG5cdFx0dGhpcy4kZWwueCh4KTtcblx0XHR0aGlzLiRlbC55KHkpO1xuXHRcdHRoaXMuJGVsLnJhZGl1cyhyKTtcblx0XHR0aGlzLiRlbC5maWxsKGNvbG9yKTtcblx0fVxuXG5cdC8vIHgxLCB4MiwgeTEsIHkyID0+IGluIHBpeGVsIGRvbWFpblxuXHRpbkFyZWEocmVuZGVyaW5nQ29udGV4dCwgZGF0dW0sIHgxLCB5MSwgeDIsIHkyKSB7XG5cdFx0Y29uc3QgeCA9IHRoaXMuJGVsLmdldEFic29sdXRlUG9zaXRpb24oKS54O1xuXHRcdGNvbnN0IHkgPSB0aGlzLiRlbC5nZXRBYnNvbHV0ZVBvc2l0aW9uKCkueTtcblxuXHRcdGlmICgoeCA+PSB4MSAmJiB4IDw9IHgyKSAmJiAoeSA+PSB5MSAmJiB5IDw9IHkyKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgQmFzZVNoYXBlIGZyb20gJy4vYmFzZS1zaGFwZSc7XG5pbXBvcnQgS29udmEgZnJvbSAna29udmEnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmUgZXh0ZW5kcyBCYXNlU2hhcGUge1xuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4kZWwuZGVzdHJveSgpO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuXG4gIGdldENsYXNzTmFtZSgpIHsgcmV0dXJuICdsaW5lJzsgfVxuXG4gIF9nZXRBY2Nlc3Nvckxpc3QoKSB7XG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICB9XG5cbiAgX2dldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7IGNvbG9yOiAnIzAwMDAwMCcsIHN0cm9rZVdpZHRoOiAxIH07XG4gIH1cblxuICByZW5kZXIocmVuZGVyaW5nQ29udGV4dCkge1xuICAgIGlmICh0aGlzLiRlbCkgeyByZXR1cm4gdGhpcy4kZWw7IH1cblxuICAgIHRoaXMuJGVsID0gbmV3IEtvbnZhLlBhdGgoe30pO1xuICAgIHRoaXMuJGVsLnBlcmZlY3REcmF3RW5hYmxlZChmYWxzZSk7XG5cbiAgICByZXR1cm4gdGhpcy4kZWw7XG4gIH1cblxuICB1cGRhdGUocmVuZGVyaW5nQ29udGV4dCwgZGF0YSkge1xuXG4gICAgZGF0YSA9IGRhdGEuc2xpY2UoMCk7XG4gICAgZGF0YS5zb3J0KChhLCBiKSA9PiB0aGlzLngoYSkgPCB0aGlzLngoYikgPyAtMSA6IDEpO1xuXG4gICAgdGhpcy4kZWwuZGF0YSh0aGlzLl9idWlsZExpbmUocmVuZGVyaW5nQ29udGV4dCwgZGF0YSkpO1xuICAgIHRoaXMuJGVsLnN0cm9rZSh0aGlzLnBhcmFtcy5jb2xvcik7XG4gICAgdGhpcy4kZWwuc3Ryb2tlV2lkdGgodGhpcy5wYXJhbXMuc3Ryb2tlV2lkdGgpO1xuXG4gICAgZGF0YSA9IG51bGw7XG4gIH1cblxuICAvLyBidWlsZHMgdGhlIGBwYXRoLmRgIGF0dHJpYnV0ZVxuICAvLyBAVE9ETyBjcmVhdGUgc29tZSBTaGFwZUhlbHBlciA/XG4gIF9idWlsZExpbmUocmVuZGVyaW5nQ29udGV4dCwgZGF0YSkge1xuICAgIGlmICghZGF0YS5sZW5ndGgpIHsgcmV0dXJuICcnOyB9XG4gICAgLy8gc29ydCBkYXRhXG4gICAgbGV0IGluc3RydWN0aW9ucyA9IGRhdGEubWFwKChkYXR1bSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMueChkYXR1bSkpO1xuICAgICAgY29uc3QgeSA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHRoaXMueShkYXR1bSkpIC0gMC41O1xuICAgICAgcmV0dXJuIGAke3h9LCR7eX1gO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuICdNJyArIGluc3RydWN0aW9ucy5qb2luKCdMJyk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlU2hhcGUgZnJvbSAnLi9iYXNlLXNoYXBlJztcbmltcG9ydCBLb252YSBmcm9tICdrb252YSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcmtlciBleHRlbmRzIEJhc2VTaGFwZSB7XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiRsaW5lLmRlc3Ryb3koKTtcbiAgICB0aGlzLiRsaW5lID0gbnVsbDtcbiAgICB0aGlzLiRoYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLiRoYW5kbGVyID0gbnVsbDtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cblxuICBnZXRDbGFzc05hbWUoKSB7IHJldHVybiAnbWFya2VyJzsgfVxuXG4gIF9nZXRBY2Nlc3Nvckxpc3QoKSB7XG4gICAgcmV0dXJuIHsgeDogMCB9O1xuICB9XG5cbiAgX2dldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBoYW5kbGVyV2lkdGg6IDcsXG4gICAgICBoYW5kbGVySGVpZ2h0OiAxMCxcbiAgICAgIGRpc3BsYXlIYW5kbGVyczogdHJ1ZSxcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICBzdHJva2VXaWR0aDogMiwgXG4gICAgICBjb2xvcjogJ2JsYWNrJyxcbiAgICAgIGhhbmRsZXJDb2xvcjogJ2JsYWNrJ1xuICAgIH07XG4gIH1cblxuICByZW5kZXIocmVuZGVyaW5nQ29udGV4dCkge1xuICAgIGlmICh0aGlzLiRlbCkgeyByZXR1cm4gdGhpcy4kZWw7IH1cblxuICAgIHRoaXMuJGVsID0gW107XG5cbiAgICB0aGlzLiRsaW5lID0gbmV3IEtvbnZhLlJlY3Qoe30pO1xuICAgIHRoaXMuJGxpbmUuYWRkTmFtZSgnbWFya2VyJyk7XG4gICAgdGhpcy4kbGluZS5zaGFwZSA9IHRoaXM7XG5cbiAgICB0aGlzLiRoYW5kbGVyID0gbmV3IEtvbnZhLlJlY3Qoe30pO1xuICAgIHRoaXMuJGhhbmRsZXIuYWRkTmFtZSgnaGFuZGxlcicpO1xuICAgIHRoaXMuJGhhbmRsZXIuc2hhcGUgPSB0aGlzO1xuXG4gICAgdGhpcy4kZWwucHVzaCh0aGlzLiRsaW5lKTtcbiAgICB0aGlzLiRlbC5wdXNoKHRoaXMuJGhhbmRsZXIpO1xuXG4gICAgcmV0dXJuIHRoaXMuJGVsO1xuICB9XG5cbiAgdXBkYXRlKHJlbmRlcmluZ0NvbnRleHQsIGRhdHVtKSB7XG4gICAgY29uc3QgZCA9IGRhdHVtIHx8IHRoaXMuZGF0dW07XG5cbiAgICB0aGlzLiRsaW5lLnZpc2libGUodGhpcy52aXNpYmxlKTtcbiAgICB0aGlzLiRoYW5kbGVyLnZpc2libGUodGhpcy52aXNpYmxlICYmIHRoaXMucGFyYW1zLmRpc3BsYXlIYW5kbGVycyk7XG5cbiAgICBpZiAoIXRoaXMudmlzaWJsZSkgIHJldHVybjtcblxuICAgIGNvbnN0IHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMueChkKSkgLSAwLjU7XG4gICAgY29uc3QgaGVpZ2h0ID0gcmVuZGVyaW5nQ29udGV4dC5oZWlnaHQ7XG5cbiAgICB0aGlzLiRsaW5lLngoeCkueSgwKS53aWR0aCh0aGlzLnBhcmFtcy5zdHJva2VXaWR0aCk7XG4gICAgdGhpcy4kbGluZS5oZWlnaHQoaGVpZ2h0KTtcbiAgICB0aGlzLiRsaW5lLmZpbGwodGhpcy5wYXJhbXMuY29sb3IpO1xuXG4gICAgdGhpcy4kaGFuZGxlci54KHgpLnkoMCkud2lkdGgodGhpcy5wYXJhbXMuaGFuZGxlcldpZHRoKS5oZWlnaHQodGhpcy5wYXJhbXMuaGFuZGxlckhlaWdodCkuZmlsbCh0aGlzLnBhcmFtcy5oYW5kbGVyQ29sb3IpO1xuICB9XG5cbiAgaW5BcmVhKHJlbmRlcmluZ0NvbnRleHQsIGRhdHVtLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIGNvbnN0IGQgPSBkYXR1bSB8fCB0aGlzLmRhdHVtO1xuXG4gICAgLy8gaGFuZGxlcnMgb25seSBhcmUgc2VsZWN0YWJsZVxuICAgIGNvbnN0IHggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMueChkKSk7XG4gICAgY29uc3Qgc2hhcGVYMSA9IHggLSAodGhpcy5wYXJhbXMuaGFuZGxlcldpZHRoIC0gMSkgLyAyO1xuICAgIGNvbnN0IHNoYXBlWDIgPSBzaGFwZVgxICsgdGhpcy5wYXJhbXMuaGFuZGxlcldpZHRoO1xuICAgIGNvbnN0IHNoYXBlWTEgPSByZW5kZXJpbmdDb250ZXh0LmhlaWdodCAtIHRoaXMucGFyYW1zLmhhbmRsZXJIZWlnaHQ7XG4gICAgY29uc3Qgc2hhcGVZMiA9IHJlbmRlcmluZ0NvbnRleHQuaGVpZ2h0O1xuXG4gICAgY29uc3QgeE92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih4Miwgc2hhcGVYMikgLSBNYXRoLm1heCh4MSwgc2hhcGVYMSkpO1xuICAgIGNvbnN0IHlPdmVybGFwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oeTIsIHNoYXBlWTIpIC0gTWF0aC5tYXgoeTEsIHNoYXBlWTEpKTtcbiAgICBjb25zdCBhcmVhID0geE92ZXJsYXAgKiB5T3ZlcmxhcDtcblxuICAgIHJldHVybiBhcmVhID4gMDtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEJhc2VTaGFwZSBmcm9tICcuL2Jhc2Utc2hhcGUnO1xuaW1wb3J0IEtvbnZhIGZyb20gJ2tvbnZhJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VnbWVudCBleHRlbmRzIEJhc2VTaGFwZSB7XG5cblx0ZGVzdHJveSgpIHtcblx0XHR0aGlzLiRzZWdtZW50LmRlc3Ryb3koKTtcblx0XHR0aGlzLiRzZWdtZW50ID0gbnVsbDtcblx0XHR0aGlzLiRsZWZ0SGFuZGxlci5kZXN0cm95KCk7XG5cdFx0dGhpcy4kbGVmdEhhbmRsZXIgPSBudWxsO1xuXHRcdHRoaXMuJHJpZ2h0SGFuZGxlci5kZXN0cm95KCk7XG5cdFx0dGhpcy4kcmlnaHRIYW5kbGVyID0gbnVsbDtcblx0XHRzdXBlci5kZXN0cm95KCk7XG5cdH1cblxuXHRnZXRDbGFzc05hbWUoKSB7IHJldHVybiAnc2VnbWVudCc7IH1cblxuXHRfZ2V0QWNjZXNzb3JMaXN0KCkge1xuXHRcdHJldHVybiB7IHg6IDAsIHk6IDAsIHdpZHRoOiAxLCBoZWlnaHQ6IDEgfTtcblx0fVxuXG5cdF9nZXREZWZhdWx0cygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGlzcGxheUhhbmRsZXJzOiB0cnVlLFxuXHRcdFx0aGFuZGxlcldpZHRoOiAyLFxuXHRcdFx0aGFuZGxlck9wYWNpdHk6IDAuOCxcblx0XHRcdG9wYWNpdHk6IDAuNiwgXG5cdFx0XHRoYW5kbGVyQ29sb3I6ICcjMDAwMDAwJywgXG5cdFx0XHRjb2xvcjogJyMwMDAwMDAnLFxuXHRcdH07XG5cdH1cblxuXHRyZW5kZXIocmVuZGVyaW5nQ29udGV4dCkge1xuXHRcdGlmICh0aGlzLiRlbCkgeyByZXR1cm4gdGhpcy4kZWw7IH1cblxuXHRcdHRoaXMuJGVsID0gW107XG5cblx0XHR0aGlzLiRzZWdtZW50ID0gbmV3IEtvbnZhLlJlY3Qoe30pO1xuXHRcdHRoaXMuJHNlZ21lbnQubmFtZSgnc2VnbWVudCcpO1xuXHRcdC8vIHRoaXMuJHNlZ21lbnQub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGUpIHsgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7IH0pO1xuXHRcdC8vIHRoaXMuJHNlZ21lbnQub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZSkgeyBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JzsgfSk7XG5cdFx0dGhpcy4kc2VnbWVudC5zaGFwZSA9IHRoaXM7XG5cblx0XHR0aGlzLiRlbC5wdXNoKHRoaXMuJHNlZ21lbnQpO1xuXG5cdFx0dGhpcy4kbGVmdEhhbmRsZXIgPSBuZXcgS29udmEuUmVjdCh7fSk7XG5cdFx0dGhpcy4kbGVmdEhhbmRsZXIuYWRkTmFtZSgnbGVmdCcpO1xuXHRcdHRoaXMuJGxlZnRIYW5kbGVyLmFkZE5hbWUoJ2hhbmRsZXInKTtcblx0XHQvLyB0aGlzLiRsZWZ0SGFuZGxlci5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oKSB7IGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJ2V3LXJlc2l6ZSc7IH0pO1xuXHRcdC8vIHRoaXMuJGxlZnRIYW5kbGVyLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKCkgeyBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JzsgfSk7XG5cdFx0dGhpcy4kbGVmdEhhbmRsZXIuc2hhcGUgPSB0aGlzO1xuXG5cdFx0dGhpcy4kcmlnaHRIYW5kbGVyID0gbmV3IEtvbnZhLlJlY3Qoe30pO1xuXHRcdHRoaXMuJHJpZ2h0SGFuZGxlci5hZGROYW1lKCdyaWdodCcpO1xuXHRcdHRoaXMuJHJpZ2h0SGFuZGxlci5hZGROYW1lKCdoYW5kbGVyJyk7XG5cdFx0Ly8gdGhpcy4kcmlnaHRIYW5kbGVyLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbigpIHsgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnZXctcmVzaXplJzsgfSk7XG5cdFx0Ly8gdGhpcy4kcmlnaHRIYW5kbGVyLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKCkgeyBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JzsgfSk7XG5cdFx0dGhpcy4kcmlnaHRIYW5kbGVyLnNoYXBlID0gdGhpcztcblxuXHRcdHRoaXMuJHNlZ21lbnQucGVyZmVjdERyYXdFbmFibGVkKGZhbHNlKTtcblx0XHR0aGlzLiRsZWZ0SGFuZGxlci5wZXJmZWN0RHJhd0VuYWJsZWQoZmFsc2UpO1xuXHRcdHRoaXMuJHJpZ2h0SGFuZGxlci5wZXJmZWN0RHJhd0VuYWJsZWQoZmFsc2UpO1xuXG5cdFx0dGhpcy4kZWwucHVzaCh0aGlzLiRsZWZ0SGFuZGxlcik7XG5cdFx0dGhpcy4kZWwucHVzaCh0aGlzLiRyaWdodEhhbmRsZXIpO1xuXG5cdFx0cmV0dXJuIHRoaXMuJGVsO1xuXHR9XG5cblx0dXBkYXRlKHJlbmRlcmluZ0NvbnRleHQsIGRhdHVtKSB7XG5cdFx0Y29uc3QgZCA9IGRhdHVtIHx8IHRoaXMuZGF0dW07XG5cblx0XHR0aGlzLiRzZWdtZW50LnZpc2libGUodGhpcy52aXNpYmxlKTtcblx0XHR0aGlzLiRsZWZ0SGFuZGxlci52aXNpYmxlKHRoaXMudmlzaWJsZSAmJiB0aGlzLnBhcmFtcy5kaXNwbGF5SGFuZGxlcnMpO1xuXHRcdHRoaXMuJHJpZ2h0SGFuZGxlci52aXNpYmxlKHRoaXMudmlzaWJsZSAmJiB0aGlzLnBhcmFtcy5kaXNwbGF5SGFuZGxlcnMpO1xuXG5cdFx0aWYgKCF0aGlzLnZpc2libGUpXHRyZXR1cm47XG5cblx0XHRjb25zdCB3aWR0aCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwodGhpcy53aWR0aChkKSk7XG5cdFx0Y29uc3QgaGVpZ2h0ID0gTWF0aC5hYnMocmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwodGhpcy55KGQpICsgdGhpcy5oZWlnaHQoZCkpIC0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwodGhpcy55KGQpKSk7XG5cdFx0Y29uc3QgeCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwodGhpcy54KGQpKTtcblx0XHRjb25zdCB5ID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwodGhpcy55KGQpICsgdGhpcy5oZWlnaHQoZCkpO1xuXG5cdFx0dGhpcy4kc2VnbWVudFxuXHRcdFx0XHQueCh4KVxuXHRcdFx0XHQueSh5KVxuXHRcdFx0XHQud2lkdGgoTWF0aC5tYXgod2lkdGgsIDApKVxuXHRcdFx0XHQuaGVpZ2h0KGhlaWdodClcblx0XHRcdFx0LmZpbGwodGhpcy5wYXJhbXMuY29sb3IpXG5cdFx0XHRcdC5vcGFjaXR5KHRoaXMucGFyYW1zLm9wYWNpdHkpO1xuXG5cdFx0dGhpcy4kbGVmdEhhbmRsZXJcblx0XHRcdFx0LngoeClcblx0XHRcdFx0LnkoeSlcblx0XHRcdFx0LndpZHRoKHRoaXMucGFyYW1zLmhhbmRsZXJXaWR0aClcblx0XHRcdFx0LmhlaWdodChoZWlnaHQpXG5cdFx0XHRcdC5maWxsKHRoaXMucGFyYW1zLmhhbmRsZXJDb2xvcilcblx0XHRcdFx0Lm9wYWNpdHkodGhpcy5wYXJhbXMuaGFuZGxlck9wYWNpdHkpO1xuXHRcdFx0XHRcblx0XHR0aGlzLiRyaWdodEhhbmRsZXJcblx0XHRcdFx0LngoeCArIHdpZHRoIC0gdGhpcy5wYXJhbXMuaGFuZGxlcldpZHRoKVxuXHRcdFx0XHQueSh5KVxuXHRcdFx0XHQuaGVpZ2h0KGhlaWdodClcblx0XHRcdFx0LndpZHRoKHRoaXMucGFyYW1zLmhhbmRsZXJXaWR0aClcblx0XHRcdFx0LmZpbGwodGhpcy5wYXJhbXMuaGFuZGxlckNvbG9yKVxuXHRcdFx0XHQub3BhY2l0eSh0aGlzLnBhcmFtcy5oYW5kbGVyT3BhY2l0eSk7XG5cdH1cblxuXHRpbkFyZWEocmVuZGVyaW5nQ29udGV4dCwgZGF0dW0sIHgxLCB5MSwgeDIsIHkyKSB7XG5cdFx0Y29uc3QgZCA9IGRhdHVtIHx8IHRoaXMuZGF0dW07XG5cblx0XHRjb25zdCBzaGFwZVgxID0gdGhpcy4kc2VnbWVudC5nZXRBYnNvbHV0ZVBvc2l0aW9uKCkueDtcblx0XHRjb25zdCBzaGFwZVkxID0gdGhpcy4kc2VnbWVudC5nZXRBYnNvbHV0ZVBvc2l0aW9uKCkueTtcblx0XHRjb25zdCBzaGFwZVgyID0gc2hhcGVYMSArIHRoaXMuJHNlZ21lbnQud2lkdGgoKTtcblx0XHRjb25zdCBzaGFwZVkyID0gc2hhcGVZMSArIHRoaXMuJHNlZ21lbnQuaGVpZ2h0KCk7XG5cblx0XHQvKlxuXHRcdCAqXHRUaGUgc2VnbWVudCBpcyBlbnRpcmVseSB3aXRoaW4gdGhlIHByb3ZpZGVkIGFyZWEuXG5cdFx0ICovXG5cdFx0Ly8gaWYgKHgxIDw9IHNoYXBlWDEgJiYgeDIgPj0gc2hhcGVYMiAmJiB5MSA8PSBzaGFwZVkxICYmIHkyID49IHNoYXBlWTIpXG5cdFx0Ly8gXHRyZXR1cm4gdHJ1ZTtcblx0XHQvLyBlbHNlXG5cdFx0Ly8gXHRyZXR1cm4gZmFsc2U7XG5cblx0XHQvKlxuXHRcdCAqXHRUaGUgc2VnbWVudCBvdmVybGFwcyB0aGUgcHJvdmlkZWQgYXJlYS5cblx0XHQgKi9cblx0XHRjb25zdCB4T3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHgyLCBzaGFwZVgyKSAtIE1hdGgubWF4KHgxLCBzaGFwZVgxKSk7XG5cdFx0Y29uc3QgeU92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih5Miwgc2hhcGVZMikgLSBNYXRoLm1heCh5MSwgc2hhcGVZMSkpO1xuXHRcdGNvbnN0IGFyZWEgPSB4T3ZlcmxhcCAqIHlPdmVybGFwO1xuXG5cdFx0cmV0dXJuIGFyZWEgPiAwO1xuXHR9XG5cbn0iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgQmFzZVNoYXBlIGZyb20gJy4vYmFzZS1zaGFwZSc7XG5pbXBvcnQgS29udmEgZnJvbSAna29udmEnO1xuXG4vKipcbiAqIEtpbmQgb2YgTWFya2VyIGZvciBlbnRpdHkgb3JpZW50ZWQgZGF0YS4gVXNlZnVsIHRvIGRpc3BsYXkgYSBncmlkLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaWNrcyBleHRlbmRzIEJhc2VTaGFwZSB7XG4gIF9nZXRDbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuICd0aWNrJztcbiAgfVxuXG4gIF9nZXRBY2Nlc3Nvckxpc3QoKSB7XG4gICAgcmV0dXJuIHsgdGltZTogMCwgbGFiZWw6ICcnLCBmb2N1c2VkOiBmYWxzZSB9O1xuICB9XG5cbiAgX2dldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbG9yOiAnc3RlZWxibHVlJyxcbiAgICAgICAgb3BhY2l0eTogMC4zLFxuICAgICAgICB3aWR0aDogMSxcbiAgICAgIH0sXG4gICAgICBmb2N1c2VkOiB7XG4gICAgICAgIGNvbG9yOiAnYmxhY2snLFxuICAgICAgICBvcGFjaXR5OiAwLjgsXG4gICAgICAgIHdpZHRoOiAyLFxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZW5kZXIocmVuZGVyaW5nQ29udGV4dCkge1xuICAgIHRoaXMuJGVsID0gbmV3IFNldCgpO1xuXG4gICAgdGhpcy4kY3VycmVudFRpY2tzICA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLiRjdXJyZW50TGFiZWxzID0gbmV3IFNldCgpO1xuICAgIFxuICAgIHJldHVybiB0aGlzLiRlbDtcbiAgfVxuXG4gIHVwZGF0ZShyZW5kZXJpbmdDb250ZXh0LCBkYXRhKSB7XG5cbiAgICAvKlxuICAgICAqIE1haW50YWluIHRoZSBzYW1lIG51bWJlciBvZiB0aWNrcyBhbmQgbGFiZWxzIGluIHRoZSBTaGFwZSBtZW1vcnkgYXMgdGhlIG51bWJlciBvZiBkYXR1bXMuXG4gICAgICogRGVzdHJveSB0aGUgcmVtYWluaW5nIGtvbnZhIG5vZGVzLlxuICAgICAqL1xuXG4gICAgaWYgKHRoaXMuJGVsLnNpemUgPCBkYXRhLmxlbmd0aCAqIDIpIHtcbiAgICAgIHdoaWxlICh0aGlzLiRlbC5zaXplIDwgZGF0YS5sZW5ndGggKiAyKSB7XG4gICAgICAgIGNvbnN0IHIgPSBuZXcgS29udmEuUmVjdCh7IGxpc3RlbmluZzogZmFsc2UgfSk7XG4gICAgICAgIHIuYWRkTmFtZSgndGljaycpO1xuICAgICAgICBjb25zdCB0ID0gbmV3IEtvbnZhLlRleHQoeyBsaXN0ZW5pbmc6IGZhbHNlIH0pO1xuICAgICAgICB0LmFkZE5hbWUoJ2xhYmVsJyk7XG4gICAgICAgIHRoaXMuJGN1cnJlbnRUaWNrcy5hZGQocik7XG4gICAgICAgIHRoaXMuJGN1cnJlbnRMYWJlbHMuYWRkKHQpO1xuICAgICAgICB0aGlzLiRlbC5hZGQocik7XG4gICAgICAgIHRoaXMuJGVsLmFkZCh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuJGVsLnNpemUgPiBkYXRhLmxlbmd0aCAqIDIpIHtcbiAgICAgIGNvbnN0IHRpMSA9IHRoaXMuJGN1cnJlbnRUaWNrcy52YWx1ZXMoKTtcbiAgICAgIGNvbnN0IGxpMiA9IHRoaXMuJGN1cnJlbnRMYWJlbHMudmFsdWVzKCk7XG4gICAgICB3aGlsZSAodGhpcy4kZWwuc2l6ZSA+IGRhdGEubGVuZ3RoICogMikge1xuICAgICAgICBjb25zdCB0aWNrID0gdGkxLm5leHQoKS52YWx1ZTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBsaTIubmV4dCgpLnZhbHVlO1xuICAgICAgICB0aGlzLiRjdXJyZW50VGlja3MuZGVsZXRlKHRpY2spO1xuICAgICAgICB0aGlzLiRjdXJyZW50TGFiZWxzLmRlbGV0ZShsYWJlbCk7XG4gICAgICAgIHRoaXMuJGVsLmRlbGV0ZSh0aWNrKTtcbiAgICAgICAgdGhpcy4kZWwuZGVsZXRlKGxhYmVsKTtcbiAgICAgICAgdGljay5kZXN0cm95KCk7XG4gICAgICAgIGxhYmVsLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0aGF0ID0gdGhpcztcbiAgICBjb25zdCBsYXllckhlaWdodCA9IHJlbmRlcmluZ0NvbnRleHQuaGVpZ2h0OyBcbiAgICBjb25zdCB0aWNrc0l0ZXJhdG9yID0gdGhpcy4kY3VycmVudFRpY2tzLnZhbHVlcygpO1xuICAgIGNvbnN0IGxhYmVsc0l0ZXJhdG9yID0gdGhpcy4kY3VycmVudExhYmVscy52YWx1ZXMoKTtcblxuICAgIGRhdGEuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsID0gbGFiZWxzSXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgICAgY29uc3QgdGljayA9IHRpY2tzSXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuXG4gICAgICBjb25zdCB4ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLnRpbWUoZGF0dW0pKTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGxheWVySGVpZ2h0O1xuICAgICAgY29uc3QgaXNGb2N1c2VkID0gdGhhdC5mb2N1c2VkKGRhdHVtKTtcbiAgICAgIGNvbnN0IGhhc0xhYmVsID0gdGhhdC5sYWJlbChkYXR1bSk7XG5cbiAgICAgIHRpY2sueCh4KS5oZWlnaHQoaGVpZ2h0KTtcblxuICAgICAgaWYgKGlzRm9jdXNlZCkge1xuICAgICAgICB0aWNrLndpZHRoKHRoYXQucGFyYW1zLmZvY3VzZWQud2lkdGgpXG4gICAgICAgICAgICAuZmlsbCh0aGF0LnBhcmFtcy5mb2N1c2VkLmNvbG9yKVxuICAgICAgICAgICAgLm9wYWNpdHkodGhhdC5wYXJhbXMuZm9jdXNlZC5vcGFjaXR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpY2sud2lkdGgodGhhdC5wYXJhbXMuZGVmYXVsdC53aWR0aClcbiAgICAgICAgICAgIC5maWxsKHRoYXQucGFyYW1zLmRlZmF1bHQuY29sb3IpXG4gICAgICAgICAgICAub3BhY2l0eSh0aGF0LnBhcmFtcy5kZWZhdWx0Lm9wYWNpdHkpO1xuICAgICAgfVxuXG4gICAgICBsYWJlbC54KHgrNSlcbiAgICAgICAgICAgIC55KDUpXG4gICAgICAgICAgICAudGV4dCh0aGF0LmxhYmVsKGRhdHVtKSlcbiAgICAgICAgICAgIC8vIC5oZWlnaHQoaGVpZ2h0KVxuICAgICAgICAgICAgLmZvbnRGYW1pbHkoJ21vbm9zcGFjZScpXG4gICAgICAgICAgICAubGluZUhlaWdodCgnMTBweCcpXG4gICAgICAgICAgICAuZm9udFNpemUoJzEwcHgnKVxuICAgICAgICAgICAgLmZpbGwoJyM2NzY3NjcnKVxuICAgICAgICAgICAgLm9wYWNpdHkoMC45KTtcblxuICAgICAgaWYgKGhhc0xhYmVsKSB7XG4gICAgICAgIGxhYmVsLnZpc2libGUodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYWJlbC52aXNpYmxlKGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgXG4gICAgfSk7XG5cbiAgfVxufSIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlU2hhcGUgZnJvbSAnLi9iYXNlLXNoYXBlJztcbmltcG9ydCBLb252YSBmcm9tICdrb252YSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYWNlRG90cyBleHRlbmRzIEJhc2VTaGFwZSB7XG4gIGdldENsYXNzTmFtZSgpIHsgcmV0dXJuICd0cmFjZS1kb3RzJzsgfVxuXG4gIF9nZXRBY2Nlc3Nvckxpc3QoKSB7XG4gICAgcmV0dXJuIHsgeDogMCwgbWVhbjogMCwgcmFuZ2U6IDAgfTtcbiAgfVxuXG4gIF9nZXREZWZhdWx0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWVhblJhZGl1czogMyxcbiAgICAgIHJhbmdlUmFkaXVzOiAzLFxuICAgICAgbWVhbkNvbG9yOiAnIzIzMjMyMycsXG4gICAgICByYW5nZUNvbG9yOiAnc3RlZWxibHVlJ1xuICAgIH07XG4gIH1cblxuICByZW5kZXIocmVuZGVyaW5nQ29udGV4dCkge1xuICAgIGlmICh0aGlzLiRlbCkgeyByZXR1cm4gdGhpcy4kZWw7IH1cbiAgICAvLyBjb250YWluZXJcbiAgICB0aGlzLiRlbCA9IFtdO1xuICAgIC8vIGRyYXcgbWVhbiBkb3RcbiAgICB0aGlzLiRtZWFuID0gbmV3IEtvbnZhLkNpcmNsZSh7fSk7XG4gICAgdGhpcy4kbWVhbi5zaGFwZSA9IHRoaXM7XG5cbiAgICAvLyByYW5nZSBkb3RzICgwID0+IHRvcCwgMSA9PiBib3R0b20pXG4gICAgdGhpcy4kbWF4ID0gbmV3IEtvbnZhLkNpcmNsZSh7fSk7XG4gICAgdGhpcy4kbWF4LnNoYXBlID0gdGhpcztcblxuICAgIHRoaXMuJG1pbiA9IG5ldyBLb252YS5DaXJjbGUoe30pO1xuICAgIHRoaXMuJG1pbi5zaGFwZSA9IHRoaXM7XG5cbiAgICB0aGlzLiRlbC5wdXNoKHRoaXMuJG1lYW4pO1xuICAgIHRoaXMuJGVsLnB1c2godGhpcy4kbWF4KTtcbiAgICB0aGlzLiRlbC5wdXNoKHRoaXMuJG1pbik7XG5cbiAgICByZXR1cm4gdGhpcy4kZWw7XG4gIH1cblxuICAvLyBAVE9ETyB1c2UgYWNjZXNzb3JzXG4gIHVwZGF0ZShyZW5kZXJpbmdDb250ZXh0LCBkYXR1bSkge1xuICAgIGNvbnN0IG1lYW4gPSB0aGlzLm1lYW4oZGF0dW0pO1xuICAgIGNvbnN0IHJhbmdlID0gdGhpcy5yYW5nZShkYXR1bSk7XG4gICAgY29uc3QgeCA9IHRoaXMueChkYXR1bSk7XG4gICAgY29uc3QgbWVhblBvcyA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKG1lYW4pO1xuICAgIGNvbnN0IGhhbGZSYW5nZSA9IHJhbmdlIC8gMjtcbiAgICBjb25zdCBtYXggPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbChtZWFuICsgaGFsZlJhbmdlKTtcbiAgICBjb25zdCBtaW4gPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbChtZWFuIC0gaGFsZlJhbmdlKTtcbiAgICBjb25zdCB4UG9zID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbCh4KTtcbiAgICBcblxuICAgIHRoaXMuJG1lYW4ueCh4UG9zKVxuICAgICAgICAgICAgICAueShtZWFuUG9zKVxuICAgICAgICAgICAgICAucmFkaXVzKHRoaXMucGFyYW1zLm1lYW5SYWRpdXMpXG4gICAgICAgICAgICAgIC5zdHJva2UodGhpcy5wYXJhbXMucmFuZ2VDb2xvcilcbiAgICAgICAgICAgICAgLmZpbGwoJ3RyYW5zcGFyZW50JylcbiAgICAgICAgICAgICAgLmFkZE5hbWUoJ21lYW4nKTtcblxuICAgIHRoaXMuJG1heC54KHhQb3MpXG4gICAgICAgICAgICAgIC55KG1heClcbiAgICAgICAgICAgICAgLnJhZGl1cyh0aGlzLnBhcmFtcy5tZWFuUmFkaXVzKVxuICAgICAgICAgICAgICAuc3Ryb2tlKHRoaXMucGFyYW1zLnJhbmdlQ29sb3IpXG4gICAgICAgICAgICAgIC5maWxsKCd0cmFuc3BhcmVudCcpXG4gICAgICAgICAgICAgIC5hZGROYW1lKCdtYXgnKTtcblxuICAgIFxuICAgIHRoaXMuJG1pbi54KHhQb3MpXG4gICAgICAgICAgICAgIC55KG1pbilcbiAgICAgICAgICAgICAgLnJhZGl1cyh0aGlzLnBhcmFtcy5tZWFuUmFkaXVzKVxuICAgICAgICAgICAgICAuc3Ryb2tlKHRoaXMucGFyYW1zLnJhbmdlQ29sb3IpXG4gICAgICAgICAgICAgIC5maWxsKCd0cmFuc3BhcmVudCcpXG4gICAgICAgICAgICAgIC5hZGROYW1lKCdtaW4nKTtcbiAgfVxuXG4gIGluQXJlYShyZW5kZXJpbmdDb250ZXh0LCBkYXR1bSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICBjb25zdCB4ID0gcmVuZGVyaW5nQ29udGV4dC50aW1lVG9QaXhlbCh0aGlzLngoZGF0dW0pKTtcbiAgICBjb25zdCBtZWFuID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwodGhpcy5tZWFuKGRhdHVtKSk7XG4gICAgY29uc3QgcmFuZ2UgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbCh0aGlzLnJhbmdlKGRhdHVtKSk7XG4gICAgY29uc3QgbWluID0gbWVhbiAtIChyYW5nZSAvIDIpO1xuICAgIGNvbnN0IG1heCA9IG1lYW4gKyAocmFuZ2UgLyAyKTtcblxuICAgIGlmICh4ID4geDEgJiYgeCA8IHgyICYmIChtaW4gPiB5MSB8fCBtYXggPCB5MikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEJhc2VTaGFwZSBmcm9tICcuL2Jhc2Utc2hhcGUnO1xuaW1wb3J0IEtvbnZhIGZyb20gJ2tvbnZhJztcblxuLyoqXG4gKiBBIHNoYXBlIHRvIGRpc3BsYXkgcGF0aHMgaW4gYSB0cmFjZSB2aXN1YWxpemF0aW9uIChtZWFuIC8gcmFuZ2UpLiAoZW50aXR5IHNoYXBlKVxuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhY2VQYXRoIGV4dGVuZHMgQmFzZVNoYXBlIHtcbiAgZ2V0Q2xhc3NOYW1lKCkgeyByZXR1cm4gJ3RyYWNlLWNvbW1vbic7IH1cblxuICBfZ2V0QWNjZXNzb3JMaXN0KCkge1xuICAgIHJldHVybiB7IHg6IDAsIG1lYW46IDAsIHJhbmdlOiAwIH07XG4gIH1cblxuICBfZ2V0RGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJhbmdlQ29sb3I6ICdzdGVlbGJsdWUnLFxuICAgICAgbWVhbkNvbG9yOiAnIzIzMjMyMycsXG4gICAgICBkaXNwbGF5TWVhbjogdHJ1ZVxuICAgIH07XG4gIH1cblxuICByZW5kZXIocmVuZGVyaW5nQ29udGV4dCkge1xuICAgIGlmICh0aGlzLiRlbCkgeyByZXR1cm4gdGhpcy4kZWw7IH1cblxuICAgIHRoaXMuJGVsID0gW107XG5cbiAgICB0aGlzLiRyYW5nZSA9IG5ldyBLb252YS5QYXRoKHt9KTtcbiAgICB0aGlzLiRyYW5nZS5zaGFwZSA9IHRoaXM7XG5cbiAgICB0aGlzLiRtZWFuID0gbmV3IEtvbnZhLlBhdGgoe30pO1xuICAgIHRoaXMuJG1lYW4uc2hhcGUgPSB0aGlzO1xuXG4gICAgdGhpcy4kZWwucHVzaCh0aGlzLiRyYW5nZSk7XG4gICAgdGhpcy4kZWwucHVzaCh0aGlzLiRtZWFuKTtcblxuICAgIHJldHVybiB0aGlzLiRlbDtcbiAgfVxuXG4gIHVwZGF0ZShyZW5kZXJpbmdDb250ZXh0LCBkYXRhKSB7XG4gICAgLy8gb3JkZXIgZGF0YSBieSB4IHBvc2l0aW9uXG4gICAgZGF0YSA9IGRhdGEuc2xpY2UoMCk7XG4gICAgZGF0YS5zb3J0KChhLCBiKSA9PiB0aGlzLngoYSkgPCB0aGlzLngoYikgPyAtMSA6IDEpO1xuXG4gICAgaWYgKHRoaXMucGFyYW1zLmRpc3BsYXlNZWFuKSB7XG4gICAgICB0aGlzLiRtZWFuLnZpc2libGUodHJ1ZSlcbiAgICAgICAgICAgICAgICAuZGF0YSh0aGlzLl9idWlsZE1lYW5MaW5lKHJlbmRlcmluZ0NvbnRleHQsIGRhdGEpKVxuICAgICAgICAgICAgICAgIC5zdHJva2UodGhpcy5wYXJhbXMubWVhbkNvbG9yKVxuICAgICAgICAgICAgICAgIC5maWxsKCdub25lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJG1lYW4udmlzaWJsZShmYWxzZSk7XG4gICAgfVxuXG4gICAgdGhpcy4kcmFuZ2UudmlzaWJsZSh0cnVlKVxuICAgICAgICAgICAgICAuZGF0YSh0aGlzLl9idWlsZFJhbmdlWm9uZShyZW5kZXJpbmdDb250ZXh0LCBkYXRhKSlcbiAgICAgICAgICAgICAgLnN0cm9rZSgnbm9uZScpXG4gICAgICAgICAgICAgIC5maWxsKHRoaXMucGFyYW1zLnJhbmdlQ29sb3IpXG4gICAgICAgICAgICAgIC5vcGFjaXR5KDAuNCk7XG5cbiAgICBkYXRhID0gbnVsbDtcbiAgfVxuXG4gIF9idWlsZE1lYW5MaW5lKHJlbmRlcmluZ0NvbnRleHQsIGRhdGEpIHtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25zID0gZGF0YS5tYXAoKGRhdHVtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgeCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwodGhpcy54KGRhdHVtKSk7XG4gICAgICBjb25zdCB5ID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwodGhpcy5tZWFuKGRhdHVtKSk7XG4gICAgICByZXR1cm4gYCR7eH0sJHt5fWA7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gJ00nICsgaW5zdHJ1Y3Rpb25zLmpvaW4oJ0wnKTtcbiAgfVxuXG4gIF9idWlsZFJhbmdlWm9uZShyZW5kZXJpbmdDb250ZXh0LCBkYXRhKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgLy8gY29uc3QgbGFzdEluZGV4ID0gZGF0YVxuICAgIGxldCBpbnN0cnVjdGlvbnNTdGFydCA9ICcnO1xuICAgIGxldCBpbnN0cnVjdGlvbnNFbmQgPSAnJztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGRhdHVtID0gZGF0YVtpXTtcbiAgICAgIGNvbnN0IG1lYW4gPSB0aGlzLm1lYW4oZGF0dW0pO1xuICAgICAgY29uc3QgaGFsZlJhbmdlID0gdGhpcy5yYW5nZShkYXR1bSkgLyAyO1xuXG4gICAgICBjb25zdCB4ICA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwodGhpcy54KGRhdHVtKSk7XG4gICAgICBjb25zdCB5MCA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKG1lYW4gKyBoYWxmUmFuZ2UpO1xuICAgICAgY29uc3QgeTEgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbChtZWFuIC0gaGFsZlJhbmdlKTtcblxuICAgICAgY29uc3Qgc3RhcnQgPSBgJHt4fSwke3kwfWA7XG4gICAgICBjb25zdCBlbmQgICA9IGAke3h9LCR7eTF9YDtcblxuICAgICAgaW5zdHJ1Y3Rpb25zU3RhcnQgPSBpbnN0cnVjdGlvbnNTdGFydCA9PT0gJycgP1xuICAgICAgICBzdGFydCA6IGAke2luc3RydWN0aW9uc1N0YXJ0fUwke3N0YXJ0fWA7XG5cbiAgICAgIGluc3RydWN0aW9uc0VuZCA9IGluc3RydWN0aW9uc0VuZCA9PT0gJycgP1xuICAgICAgICBlbmQgOiBgJHtlbmR9TCR7aW5zdHJ1Y3Rpb25zRW5kfWA7XG4gICAgfVxuXG4gICAgbGV0IGluc3RydWN0aW9ucyA9IGBNJHtpbnN0cnVjdGlvbnNTdGFydH1MJHtpbnN0cnVjdGlvbnNFbmR9WmA7XG4gICAgcmV0dXJuIGluc3RydWN0aW9ucztcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEJhc2VTaGFwZSBmcm9tICcuL2Jhc2Utc2hhcGUnO1xuaW1wb3J0IHNjYWxlcyBmcm9tICcuLi91dGlscy9zY2FsZXMnXG5pbXBvcnQgS29udmEgZnJvbSAna29udmEnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXYXZlZm9ybSBleHRlbmRzIEJhc2VTaGFwZSB7XG5cblx0ZGVzdHJveSgpIHtcblx0XHR0aGlzLiRsYWJlbC5kZXN0cm95KCk7XG5cdFx0dGhpcy4kbGFiZWwgPSBudWxsO1xuXG5cdFx0dGhpcy4kaGVhZGVyLmRlc3Ryb3koKTtcblx0XHR0aGlzLiRoZWFkZXIgPSBudWxsO1xuXG5cdFx0dGhpcy4kYm9keS5kZXN0cm95KCk7XG5cdFx0dGhpcy4kYm9keSA9IG51bGw7XG5cblx0XHR0aGlzLiRsZWZ0SGFuZGxlci5kZXN0cm95KCk7XG5cdFx0dGhpcy4kbGVmdEhhbmRsZXIgPSBudWxsO1xuXG5cdFx0dGhpcy4kcmlnaHRIYW5kbGVyLmRlc3Ryb3koKTtcblx0XHR0aGlzLiRyaWdodEhhbmRsZXIgPSBudWxsO1xuXG5cdFx0dGhpcy4kd2F2ZWZvcm0uZGVzdHJveSgpO1xuXHRcdHRoaXMuJHdhdmVmb3JtID0gbnVsbDtcblxuXHRcdHN1cGVyLmRlc3Ryb3koKTtcblx0fVxuXG5cdGdldENsYXNzTmFtZSgpIHsgcmV0dXJuICd3YXZlZm9ybSc7IH1cblxuXHRfZ2V0QWNjZXNzb3JMaXN0KCkge1xuXHRcdC8vIHJldHVybiB7IHk6IDAgfTtcblx0XHQvLyBUT0RPOiBkZWxldGUgYWxsIGJ1dCBzYW1wbGVSYXRlLlxuXHRcdHJldHVybiB7IGRhdGE6IFtdLCB4OiAwLCB3aWR0aDogMTAwMDAsIGJ1ZmZlclN0YXJ0OiAwLCBidWZmZXJFbmQ6IDAsIHNhbXBsZVJhdGU6IDQ0MTAwLCBjb2xvcjogJ2JsYWNrJywgdGV4dDogXCJcIiB9O1xuXHR9XG5cblx0X2dldERlZmF1bHRzKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR3YXZlZm9ybVF1YWxpdHk6IDIwMDAsIFxuXHRcdFx0c3F1YXJpbmdGYWN0b3I6IDEsIFxuXHRcdFx0ZGlzcGxheUhhbmRsZXJzOiB0cnVlLCBcblx0XHRcdGRpc3BsYXlCb2R5OiB0cnVlLCBcblx0XHRcdGRpc3BsYXlMYWJlbDogdHJ1ZSwgXG5cdFx0XHRkaXNwbGF5SGVhZGVyOiB0cnVlLCBcblx0XHRcdGhlYWRlckhlaWdodFJhdGlvOiAwLjEsIC8vIDEwJSBvZiB0aGUgYm9keSBoZWlnaHRcblx0XHRcdHdhdmVmb3JtOiB7XG5cdFx0XHRcdGNvbG9yOiAnIzAwMDAwMCcsXG5cdFx0XHRcdG9wYWNpdHk6IDEsIFxuXHRcdFx0fSxcblx0XHRcdGhlYWRlcjoge1xuXHRcdFx0XHRjb2xvcjogJ2dyZWVuJyxcblx0XHRcdFx0b3BhY2l0eTogMC40LCBcblx0XHRcdH0sXG5cdFx0XHRib2R5OiB7XG5cdFx0XHRcdGNvbG9yOiAneWVsbG93Jyxcblx0XHRcdFx0b3BhY2l0eTogMC4xLCBcblx0XHRcdH0sXG5cdFx0XHRoYW5kbGVyOiB7XG5cdFx0XHRcdHdpZHRoOiAyLCBcblx0XHRcdFx0b3BhY2l0eTogMSxcblx0XHRcdFx0Y29sb3I6ICdvcmFuZ2UnXG5cdFx0XHR9LFxuXHRcdH07XG5cdH1cblxuXHRyZW5kZXIocmVuZGVyaW5nQ29udGV4dCkge1xuXHRcdGlmICh0aGlzLiRlbCkgeyByZXR1cm4gdGhpcy4kZWw7IH1cblxuXHRcdHRoaXMuJGVsID0gW107XG5cblx0XHR0aGlzLiRoZWFkZXIgPSBuZXcgS29udmEuUmVjdCh7fSk7XG5cdFx0dGhpcy4kaGVhZGVyLmFkZE5hbWUoJ2hlYWRlcicpO1xuXHRcdHRoaXMuJGhlYWRlci5zaGFwZSA9IHRoaXM7XG5cdFx0Ly8gdGhpcy4kaGVhZGVyLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbigpIHsgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7IH0pO1xuXHRcdC8vIHRoaXMuJGhlYWRlci5vbignbW91c2VvdXQnLCBmdW5jdGlvbigpIHsgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7IH0pO1x0XHRcblxuXHRcdHRoaXMuJGJvZHlcdCA9IG5ldyBLb252YS5SZWN0KHt9KTtcblx0XHR0aGlzLiRib2R5LmFkZE5hbWUoJ2JvZHknKTtcblx0XHR0aGlzLiRib2R5LnNoYXBlID0gdGhpcztcblx0XHQvLyB0aGlzLiRib2R5Lm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbigpIHsgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7IH0pO1xuXHRcdC8vIHRoaXMuJGJvZHkub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oKSB7IGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnOyB9KTtcblxuXHRcdHRoaXMuJGxlZnRIYW5kbGVyID0gbmV3IEtvbnZhLlJlY3Qoe30pO1xuXHRcdHRoaXMuJGxlZnRIYW5kbGVyLmFkZE5hbWUoJ2hhbmRsZXInKTtcblx0XHR0aGlzLiRsZWZ0SGFuZGxlci5hZGROYW1lKCdsZWZ0Jyk7XG5cdFx0dGhpcy4kbGVmdEhhbmRsZXIuc2hhcGUgPSB0aGlzO1xuXHRcdC8vIHRoaXMuJGxlZnRIYW5kbGVyLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbigpIHsgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnZXctcmVzaXplJzsgfSk7XG5cdFx0Ly8gdGhpcy4kbGVmdEhhbmRsZXIub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oKSB7IGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnOyB9KTtcblxuXHRcdHRoaXMuJHJpZ2h0SGFuZGxlciA9IG5ldyBLb252YS5SZWN0KHt9KTtcblx0XHR0aGlzLiRyaWdodEhhbmRsZXIuYWRkTmFtZSgnaGFuZGxlcicpO1xuXHRcdHRoaXMuJHJpZ2h0SGFuZGxlci5hZGROYW1lKCdyaWdodCcpO1xuXHRcdHRoaXMuJHJpZ2h0SGFuZGxlci5zaGFwZSA9IHRoaXM7XG5cdFx0Ly8gdGhpcy4kcmlnaHRIYW5kbGVyLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbigpIHsgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnZXctcmVzaXplJzsgfSk7XG5cdFx0Ly8gdGhpcy4kcmlnaHRIYW5kbGVyLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKCkgeyBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JzsgfSk7XG5cblx0XHR0aGlzLiRsYWJlbCA9IG5ldyBLb252YS5UZXh0KHsgbGlzdGVuaW5nOiBmYWxzZSB9KTtcblx0XHR0aGlzLiRsYWJlbC5zaGFwZSA9IHRoaXM7XG5cblx0XHR0aGlzLiR3YXZlZm9ybSA9IG5ldyBLb252YS5QYXRoKHsgbGlzdGVuaW5nOiBmYWxzZSB9KTtcblx0XHR0aGlzLiR3YXZlZm9ybS5zaGFwZSA9IHRoaXM7XG5cblx0XHR0aGlzLiRlbC5wdXNoKHRoaXMuJGJvZHkpO1xuXHRcdHRoaXMuJGVsLnB1c2godGhpcy4kd2F2ZWZvcm0pO1xuXHRcdHRoaXMuJGVsLnB1c2godGhpcy4kaGVhZGVyKTtcblx0XHR0aGlzLiRlbC5wdXNoKHRoaXMuJGxhYmVsKTtcblx0XHR0aGlzLiRlbC5wdXNoKHRoaXMuJGxlZnRIYW5kbGVyKTtcblx0XHR0aGlzLiRlbC5wdXNoKHRoaXMuJHJpZ2h0SGFuZGxlcik7XG5cblx0XHRyZXR1cm4gdGhpcy4kZWw7XG5cdH1cblxuXHR1cGRhdGUocmVuZGVyaW5nQ29udGV4dCwgZGF0dW0pIHtcblx0XHRjb25zdCBkID0gZGF0dW0gfHwgdGhpcy5kYXR1bTtcblxuXHRcdHRoaXMuJGhlYWRlci52aXNpYmxlKHRoaXMudmlzaWJsZSAmJiB0aGlzLnBhcmFtcy5kaXNwbGF5SGVhZGVyKTtcblx0XHR0aGlzLiRsYWJlbC52aXNpYmxlKHRoaXMudmlzaWJsZSAmJiB0aGlzLnBhcmFtcy5kaXNwbGF5TGFiZWwpO1xuXHRcdHRoaXMuJGJvZHkudmlzaWJsZSh0aGlzLnZpc2libGUgJiYgdGhpcy5wYXJhbXMuZGlzcGxheUJvZHkpO1xuXHRcdHRoaXMuJGxlZnRIYW5kbGVyLnZpc2libGUodGhpcy52aXNpYmxlICYmIHRoaXMucGFyYW1zLmRpc3BsYXlIYW5kbGVycyk7XG5cdFx0dGhpcy4kcmlnaHRIYW5kbGVyLnZpc2libGUodGhpcy52aXNpYmxlICYmIHRoaXMucGFyYW1zLmRpc3BsYXlIYW5kbGVycyk7XG5cdFx0dGhpcy4kd2F2ZWZvcm0udmlzaWJsZSh0aGlzLnZpc2libGUpO1xuXG5cdFx0aWYgKCF0aGlzLnZpc2libGUpXHRyZXR1cm47XG5cblxuXHRcdHZhciAgeCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwodGhpcy54KGQpKTtcblx0XHR2YXIgd2lkdGggPSByZW5kZXJpbmdDb250ZXh0LnRpbWVUb1BpeGVsKHRoaXMud2lkdGgoZCkpO1xuXHRcdHZhciBoZWlnaHQgPSByZW5kZXJpbmdDb250ZXh0LmhlaWdodDtcblx0XHR2YXIgY29sb3IgPSB0aGlzLnBhcmFtcy53YXZlZm9ybS5jb2xvcjtcblxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy4kZWwpIHtcblx0XHRcdHRoaXMuJGVsW2ldLngoeCkueSgwKTtcblx0XHR9XG5cdFx0dGhpcy4kZWwuZm9yRWFjaCgoZWwpID0+IGVsLngoeCkueSgwKSk7XG5cblx0XHR0aGlzLiRsYWJlbC50ZXh0KHRoaXMudGV4dChkKSkueCh4KzEwKS55KDUpO1xuXG5cdFx0dGhpcy4kaGVhZGVyLndpZHRoKE1hdGgubWF4KHdpZHRoLCAwKSlcblx0XHRcdFx0XHRcdFx0XHQuaGVpZ2h0KGhlaWdodCAqIHRoaXMucGFyYW1zLmhlYWRlckhlaWdodFJhdGlvKVxuXHRcdFx0XHRcdFx0XHRcdC5maWxsKHRoaXMucGFyYW1zLmhlYWRlci5jb2xvcilcblx0XHRcdFx0XHRcdFx0XHQub3BhY2l0eSh0aGlzLnBhcmFtcy5oZWFkZXIub3BhY2l0eSk7XG5cdFx0dGhpcy4kYm9keS53aWR0aChNYXRoLm1heCh3aWR0aCwgMCkpXG5cdFx0XHRcdFx0XHRcdFx0LmhlaWdodChoZWlnaHQpXG5cdFx0XHRcdFx0XHRcdFx0LmZpbGwodGhpcy5wYXJhbXMuYm9keS5jb2xvcilcblx0XHRcdFx0XHRcdFx0XHQub3BhY2l0eSh0aGlzLnBhcmFtcy5ib2R5Lm9wYWNpdHkpO1xuXG5cdFx0dGhpcy4kbGVmdEhhbmRsZXIud2lkdGgodGhpcy5wYXJhbXMuaGFuZGxlci53aWR0aCkuaGVpZ2h0KGhlaWdodCkuZmlsbCh0aGlzLnBhcmFtcy5oYW5kbGVyLmNvbG9yKTtcblxuXHRcdHRoaXMuJHJpZ2h0SGFuZGxlci54KHggKyB3aWR0aCAtIHRoaXMucGFyYW1zLmhhbmRsZXIud2lkdGgpLndpZHRoKHRoaXMucGFyYW1zLmhhbmRsZXIud2lkdGgpLmhlaWdodChoZWlnaHQpLmZpbGwodGhpcy5wYXJhbXMuaGFuZGxlci5jb2xvcik7XG5cblx0XHR0aGlzLiR3YXZlZm9ybS5maWxsKHRoaXMucGFyYW1zLndhdmVmb3JtLmNvbG9yKS5vcGFjaXR5KHRoaXMucGFyYW1zLndhdmVmb3JtLm9wYWNpdHkpLnkoMCk7XG5cblx0XHR0aGlzLiR3YXZlZm9ybS5wZXJmZWN0RHJhd0VuYWJsZWQodHJ1ZSk7XG5cblxuXHRcdC8vIFdBVkVGT1JNIFBBUlRcblxuXG5cdFx0Ly8gZGVmaW5lIG5iciBvZiBzYW1wbGVzIHBlciBwaXhlbHNcblx0ICAgIGNvbnN0IHNsaWNlTWV0aG9kID0gdGhpcy5kYXRhKGQpIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ID8gJ3N1YmFycmF5JyA6ICdzbGljZSc7XG5cdCAgICBjb25zdCBuYnJTYW1wbGVzID0gdGhpcy5idWZmZXJFbmQoZCkgLSB0aGlzLmJ1ZmZlclN0YXJ0KGQpO1xuXHQgICAgY29uc3QgZHVyYXRpb24gPSBuYnJTYW1wbGVzIC8gdGhpcy5zYW1wbGVSYXRlKGQpO1xuXHQgICAgY29uc3Qgc2FtcGxlc1BlclBpeGVsID0gbmJyU2FtcGxlcyAvIHdpZHRoO1xuXG5cdCAgICBpZiAoIXNhbXBsZXNQZXJQaXhlbCB8fCB0aGlzLmRhdGEoZCkubGVuZ3RoIDwgc2FtcGxlc1BlclBpeGVsKSB7IHJldHVybjsgfVxuXG5cdCAgICAvLyBjb21wdXRlL2RyYXcgdmlzaWJsZSBhcmVhIG9ubHlcblx0ICAgIC8vIEBUT0RPIHJlZmFjdG9yIHRoaXMgdW51bmRlcnN0YW5kYWJsZSBtZXNzXG5cdCAgICBsZXQgbWluWCA9IE1hdGgubWF4KC1yZW5kZXJpbmdDb250ZXh0Lm9mZnNldFgsIHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwodGhpcy54KGQpKSk7XG5cblx0ICAgIGxldCBtYXhYID0gTWF0aC5taW4oLXJlbmRlcmluZ0NvbnRleHQub2Zmc2V0WCArIHJlbmRlcmluZ0NvbnRleHQud2lkdGgsIHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwodGhpcy54KGQpICsgdGhpcy53aWR0aChkKSkpO1xuXG5cdCAgICAvLyBnZXQgbWluL21heCBwZXIgcGl4ZWxzLCBjbGFtcGVkIHRvIHRoZSB2aXNpYmxlIGFyZWFcblx0ICAgIGNvbnN0IGludmVydCA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0O1xuXHQgICAgY29uc3Qgc2FtcGxlUmF0ZSA9IHRoaXMuc2FtcGxlUmF0ZShkKTtcblx0ICAgIGNvbnN0IG1pbk1heCA9IFtdO1xuXG5cdCAgICBmb3IgKGxldCBweCA9IG1pblg7IHB4IDwgbWF4WDsgcHgrKykge1xuXHQgICAgICBjb25zdCBzdGFydFRpbWUgPSBpbnZlcnQocHgpO1xuXHQgICAgICBjb25zdCBzdGFydFNhbXBsZSA9IHN0YXJ0VGltZSAqIHNhbXBsZVJhdGU7XG5cdCAgICAgIGNvbnN0IGV4dHJhY3QgPSB0aGlzLmRhdGEoZClbc2xpY2VNZXRob2RdKHN0YXJ0U2FtcGxlLCBzdGFydFNhbXBsZSArIHNhbXBsZXNQZXJQaXhlbCk7XG5cblx0ICAgICAgbGV0IG1pbiA9IEluZmluaXR5O1xuXHQgICAgICBsZXQgbWF4ID0gLUluZmluaXR5O1xuXG5cdCAgICAgIGZvciAobGV0IGogPSAwLCBsID0gZXh0cmFjdC5sZW5ndGg7IGogPCBsOyBqKyspIHtcblx0ICAgICAgICBsZXQgc2FtcGxlID0gZXh0cmFjdFtqXTtcblx0ICAgICAgICBpZiAoc2FtcGxlIDwgbWluKSB7IG1pbiA9IHNhbXBsZTsgfVxuXHQgICAgICAgIGlmIChzYW1wbGUgPiBtYXgpIHsgbWF4ID0gc2FtcGxlOyB9XG5cdCAgICAgIH1cblx0ICAgICAgLy8gZGlzYWxsb3cgSW5maW5pdHlcblx0ICAgICAgbWluID0gIWlzRmluaXRlKG1pbikgPyAwIDogbWluO1xuXHQgICAgICBtYXggPSAhaXNGaW5pdGUobWF4KSA/IDAgOiBtYXg7XG5cdCAgICAgIGlmIChtaW4gPT09IDAgJiYgbWF4ID09PSAwKSB7IGNvbnRpbnVlOyB9XG5cblx0ICAgICAgbWluTWF4LnB1c2goW3B4LCBtaW4sIG1heF0pO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIW1pbk1heC5sZW5ndGgpIHsgcmV0dXJuOyB9XG5cblx0ICAgIC8vIGNvbnN0IE1JRCA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKChyZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbC5kb21haW4oKVsxXSAtIHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsLmRvbWFpbigpWzBdKSAvIDIpXG5cdCAgICBjb25zdCBNSUQgPSAwO1xuXHQgICAgY29uc3QgUElYRUwgPSAwO1xuXHQgICAgY29uc3QgTUlOICAgPSAxO1xuXHQgICAgY29uc3QgTUFYICAgPSAyO1xuXHQgICAgY29uc3QgWkVSTyAgPSByZW5kZXJpbmdDb250ZXh0LnZhbHVlVG9QaXhlbCgwKTtcblx0ICAgIC8vIHJlbmRlcmluZyBzdHJhdGVnaWVzXG5cdCAgICAvLyBpZiAodGhpcy5wYXJhbXMucmVuZGVyaW5nU3RyYXRlZ3kgPT09ICdzdmcnKSB7XG5cblx0ICAgIGxldCBpbnN0cnVjdGlvbnMgPSBtaW5NYXgubWFwKChkYXR1bSwgaW5kZXgpID0+IHtcblx0ICAgICAgICBjb25zdCB4ICA9IGRhdHVtW1BJWEVMXTtcblx0ICAgICAgICBsZXQgeTEgPSBNYXRoLnJvdW5kKHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKGRhdHVtW01JTl0pKTtcblx0ICAgICAgICBsZXQgeTIgPSBNYXRoLnJvdW5kKHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKGRhdHVtW01BWF0pKTtcblx0ICAgICAgICAvLyByZXR1cm4gYCR7eH0sJHtaRVJPfUwke3h9LCR7eTF9TCR7eH0sJHt5Mn1MJHt4fSwke1pFUk99YDtcblx0ICAgICAgICByZXR1cm4gYCR7eH0sJHt5MS1NSUR9TCR7eH0sJHt5Mi1NSUR9YDtcblx0ICAgIH0pO1xuXG5cdCAgICBjb25zdCBwYXRoID0gJ00nICsgaW5zdHJ1Y3Rpb25zLmpvaW4oJ0wnKTtcblx0ICAgIHRoaXMuJHdhdmVmb3JtLmRhdGEoJ00nICsgYCR7MH0sJHtoZWlnaHQvMn1MYCArIGluc3RydWN0aW9ucy5qb2luKCdMJykgKyBgTCR7bWluTWF4W21pbk1heC5sZW5ndGgtMV1bMF19LCR7aGVpZ2h0LzJ9YCArICd6Jyk7XG5cdH1cblxuXHRpbkFyZWEocmVuZGVyaW5nQ29udGV4dCwgZGF0dW0sIHgxLCB5MSwgeDIsIHkyKSB7XG5cdFx0Y29uc3Qgc2hhcGVYMSA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwodGhpcy54KGRhdHVtKSk7XG5cdFx0Y29uc3Qgc2hhcGVYMiA9IHJlbmRlcmluZ0NvbnRleHQudGltZVRvUGl4ZWwodGhpcy54KGRhdHVtKSArIHRoaXMud2lkdGgoZGF0dW0pKTtcblx0XHRjb25zdCBzaGFwZVkxID0gcmVuZGVyaW5nQ29udGV4dC52YWx1ZVRvUGl4ZWwoMCk7XG5cdFx0Y29uc3Qgc2hhcGVZMiA9IHJlbmRlcmluZ0NvbnRleHQudmFsdWVUb1BpeGVsKHJlbmRlcmluZ0NvbnRleHQuaGVpZ2h0KTtcblxuXHRcdC8vIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvdXRoeVovIC0gY2hlY2sgb3ZlcmxhcGluZyBhcmVhXG5cdFx0Y29uc3QgeE92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih4Miwgc2hhcGVYMikgLSBNYXRoLm1heCh4MSwgc2hhcGVYMSkpO1xuXHRcdGNvbnN0IHlPdmVybGFwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oeTIsIHNoYXBlWTIpIC0gTWF0aC5tYXgoeTEsIHNoYXBlWTEpKTtcblx0XHRjb25zdCBhcmVhID0geE92ZXJsYXAgKiB5T3ZlcmxhcDtcblxuXHRcdHJldHVybiBhcmVhID4gMDtcblx0fVxuXG5cdGxpbmVhcl9pbnRlcnBvbGF0aW9uKGFyciwgcG9zKSB7XG5cdFx0Y29uc3QgZmlyc3RcdCA9IE1hdGguZmxvb3IocG9zKTtcblx0XHRjb25zdCBmcmFjXHRcdD0gcG9zIC0gZmlyc3Q7XG5cdFx0Y29uc3Qgc2Vjb25kXHQ9IChmaXJzdCArIDEpIDwgYXJyLmxlbmd0aCA/IChmaXJzdCArIDEpIDogMDtcblxuXHRcdHJldHVybiBhcnJbZmlyc3RdICogKDEgLSBmcmFjKSArIGFycltzZWNvbmRdICogZnJhYztcblx0fVxufSIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBgU3RhdGVgIGluc3RhbmNlcyBhcmUgdXNlZCB0byBkZWZpbmUgdGhlIGFwcGxpY2F0aW9uIGxvZ2ljIGJ5IHByZWNpc2luZ1xuICogc3BlY2lmaWMgdXNlciBpbnRlcmFjdGlvbiBjYXNlcywgYW5kIGhvdyB0aGV5IGltcGFjdCB0aGUgb3ZlcmFsIHRlbXBvcmFsXG4gKiByZXByZXNlbnRhdGlvbi4gVGhlIGFic3RyYWN0aW9ucyBleHRlbmRpbmcgdGhpcyBiYXNlIGNsYXNzIHNob3VsZCBiZVxuICogY29uc2lkZXJlZCBhcyB0aGUgbWFpbiBpbnRlcmZhY2UgYmV0d2VlbiB0aGUgdmlzdWFsaXphdGlvbiBhbmQgdGhlXG4gKiBhcHBsaWNhdGlvbiBsb2dpYy4gQWxsIHByb3ZpZGVkIHN0YXRlcyBzaG91bGQgYmUgc2VlbiBhcyBzaW1wbGUgZXhhbXBsZXMgZm9yXG4gKiByYXBpZCBwcm90b3R5cGluZyxcbiAqXG4gKiBTdGF0ZXMgbWFuYWdlIGludGVyYWN0aW9ucyBsaWtlIHpvb21pbmcsIGJyb3dzaW5nLCBvciBlZGl0aW5nIHRoZSB0aW1lbGluZS5cbiAqIEN1c3RvbWl6ZWQgc3RhdGVzIHNob3VsZCBleHRlbmQgdGhpcyBCYXNlU3RhdGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VTdGF0ZSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRpbWVsaW5lIHRyYWNrcyBjb2xsZWN0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7VHJhY2tDb2xsZWN0aW9ufVxuICAgKi9cbiAgY29uc3RydWN0b3IodGltZWxpbmUpIHtcbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgdGltZWxpbmUgb24gd2hpY2ggdGhlIHN0YXRlIHNob3VsZCBiZSBpbnN0YWxsZWQuXG4gICAgICogQHR5cGUge1RpbWVsaW5lfVxuICAgICAqL1xuICAgIHRoaXMudGltZWxpbmUgPSB0aW1lbGluZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRpbWVsaW5lIHRyYWNrcyBjb2xsZWN0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7VHJhY2tDb2xsZWN0aW9uPFRyYWNrPn1cbiAgICovXG4gIGdldCB0cmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudGltZWxpbmUudHJhY2tzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIHJlZ2lzdGVyZWQgbGF5ZXJzLlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8TGF5ZXI+fVxuICAgKi9cbiAgZ2V0IGxheWVycygpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lbGluZS50cmFja3MubGF5ZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSB0aW1lbGluZSBpcyBlbnRlcmluZyB0aGUgc3RhdGUuXG4gICAqL1xuICBlbnRlcigpIHt9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSB0aW1lbGluZSBpcyBsZWF2aW5nIHRoZSBzdGF0ZS5cbiAgICovXG4gIGV4aXQoKSB7fVxuXG4gIC8qKlxuICAgKiBNYWluIGludGVyZmFjZSBtZXRob2QgdG8gb3ZlcnJpZGUgd2hlbiBjcmVhdGluZyBhIG5ldyBgU3RhdGVgLiBIYW5kbGUgZXZlbnRcbiAgICogZnJvbSBtb3VzZSBvciBrZXlib2FyZCwgc2hvdWxkIGRlZmluZSBiZWhhdmlvciBhY2NvcmRpbmcgdG8gdGhlIGV2ZW50XG4gICAqIChha2EuIG1vdXNlZG93biwgbW91c2V1cCwgLi4uKS5cbiAgICpcbiAgICogQHBhcmFtIHtXYXZlRXZlbnR9IGUgLSB0aGUgZXZlbnQgdG8gcHJvY2Vzcy5cbiAgICogQHBhcmFtIHtBcnJheX0gaGl0TGF5ZXJzIC0gdGhlIGxheWVycyBoaXQgYnkgdGhlIG1vdXNlIGV2ZW50IChpZiBzdXJmYWNlXG4gICAqIGV2ZW50KS5cbiAgICovXG4gIGhhbmRsZUV2ZW50KGUsIGhpdExheWVycykge31cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlU3RhdGUgZnJvbSAnLi9iYXNlLXN0YXRlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJlYWtwb2ludFN0YXRlIGV4dGVuZHMgQmFzZVN0YXRlIHtcbiAgY29uc3RydWN0b3IodGltZWxpbmUsIGRhdHVtR2VuZXJhdG9yKSB7XG4gICAgc3VwZXIodGltZWxpbmUpO1xuXG4gICAgdGhpcy5kYXR1bUdlbmVyYXRvciA9IGRhdHVtR2VuZXJhdG9yO1xuICAgIHRoaXMuY3VycmVudEVkaXRlZExheWVyID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICB9XG5cbiAgZW50ZXIoKSB7fVxuICBleGl0KCkge31cblxuICBoYW5kbGVFdmVudChlLCBoaXRMYXllcnMpIHtcbiAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlRG93bihlLCBoaXRMYXllcnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmUoZSwgaGl0TGF5ZXJzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlVXAoZSwgaGl0TGF5ZXJzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgb25Nb3VzZURvd24oZSwgaGl0TGF5ZXJzKSB7XG5cbiAgICB0aGlzLm1vdXNlRG93biA9IHRydWU7XG4gICAgLy8ga2VlcCB0YXJnZXQgY29uc2lzdGVudCB3aXRoIG1vdXNlIGRvd25cbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBlLnRhcmdldDtcbiAgICBsZXQgdXBkYXRlZExheWVyID0gbnVsbDtcblxuICAgIGNvbnN0IGxheWVycyA9IGhpdExheWVycztcblxuICAgIGxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgICAgbGF5ZXIudW5zZWxlY3QoKTtcbiAgICAgIGNvbnN0IGl0ZW0gPSBlLnRhcmdldDtcblxuICAgICAgaWYgKGl0ZW0gPT09IG51bGwgfHwgaXRlbSA9PT0gdW5kZWZpbmVkIHx8IGxheWVyLmdldERhdHVtRnJvbVNoYXBlKGl0ZW0uc2hhcGUpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gY3JlYXRlIGFuIGl0ZW1cbiAgICAgICAgY29uc3QgdGltZSA9IGxheWVyLnRpbWVUb1BpeGVsLmludmVydChlLngpIC0gdGhpcy50aW1lbGluZS5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGF5ZXIudmFsdWVUb1BpeGVsLmludmVydChlLnkpO1xuICAgICAgICBjb25zdCBkYXR1bSA9IHRoaXMuZGF0dW1HZW5lcmF0b3IodGltZSwgdmFsdWUpO1xuXG4gICAgICAgIGxheWVyLmFkZChkYXR1bSk7XG4gICAgICAgIHVwZGF0ZWRMYXllciA9IGxheWVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgc2hpZnQgaXMgcHJlc3NlZCwgcmVtb3ZlIHRoZSBpdGVtXG4gICAgICAgIGlmIChlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICBjb25zdCBkYXR1bSA9IGxheWVyLmdldERhdHVtRnJvbVNoYXBlKGl0ZW0uc2hhcGUpO1xuICAgICAgICAgIGxheWVyLnJlbW92ZShkYXR1bSk7XG4gICAgICAgICAgdXBkYXRlZExheWVyID0gbGF5ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50RWRpdGVkTGF5ZXIgPSBsYXllcjtcbiAgICAgICAgICBjb25zdCBkYXR1bSA9IGxheWVyLmdldERhdHVtRnJvbVNoYXBlKGl0ZW0uc2hhcGUpO1xuICAgICAgICAgIGxheWVyLnNlbGVjdChbZGF0dW1dKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsYXllci5zZWxlY3RlZERhdHVtcy5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICBsYXllci5nZXRTaGFwZUZyb21EYXR1bShkYXR1bSkuc3RvcERyYWcoKTtcbiAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgICBcblxuICAgIGlmICh1cGRhdGVkTGF5ZXIpIHtcbiAgICAgIHRoaXMudGltZWxpbmUudHJhY2tzLnVwZGF0ZSh1cGRhdGVkTGF5ZXIpO1xuICAgIH1cbiAgfVxuXG4gIG9uTW91c2VNb3ZlKGUsIGhpdExheWVycykge1xuICAgIGlmICghdGhpcy5tb3VzZURvd24gfHwgIXRoaXMuY3VycmVudEVkaXRlZExheWVyKSB7IHJldHVybjsgfVxuXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmN1cnJlbnRFZGl0ZWRMYXllcjtcbiAgICBjb25zdCBkYXR1bXMgPSBsYXllci5zZWxlY3RlZERhdHVtcztcbiAgICAvLyB0aGUgbG9vcCBzaG91bGQgYmUgaW4gbGF5ZXIgdG8gbWF0Y2ggc2VsZWN0IC8gdW5zZWxlY3QgQVBJXG4gICAgbGF5ZXIuZWRpdChkYXR1bXMsIGUuZHgsIGUuZHksIHRoaXMuY3VycmVudFRhcmdldCk7XG5cbiAgICBsYXllci51cGRhdGVTaGFwZXMoZGF0dW1zKTtcbiAgfVxuXG4gIG9uTW91c2VVcChlLCBoaXRMYXllcnMpIHtcbiAgICBjb25zdCB0aGF0ID0gdGhpcztcbiAgICBoaXRMYXllcnMuZm9yRWFjaCgobGF5ZXIpID0+IHtcbiAgICAgIGxheWVyLnNlbGVjdGVkRGF0dW1zLmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICAgIGxheWVyLmdldFNoYXBlRnJvbURhdHVtKGRhdHVtKS5zdG9wRHJhZygpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5jdXJyZW50RWRpdGVkTGF5ZXIgPSBudWxsO1xuICAgIHRoaXMubW91c2VEb3duID0gZmFsc2U7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlU3RhdGUgZnJvbSAnLi9iYXNlLXN0YXRlJztcbmltcG9ydCBLb252YSBmcm9tICdrb252YSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJydXNoWm9vbVN0YXRlIGV4dGVuZHMgQmFzZVN0YXRlIHtcblx0Y29uc3RydWN0b3IodGltZWxpbmUpIHtcblx0XHRzdXBlcih0aW1lbGluZSk7XG5cdH1cblxuXHRoYW5kbGVFdmVudChlKSB7XG5cdFx0c3dpdGNoKGUudHlwZSkge1xuXHRcdFx0Y2FzZSAnbW91c2Vkb3duJzpcblx0XHRcdFx0dGhpcy5vbk1vdXNlRG93bihlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdtb3VzZW1vdmUnOlxuXHRcdFx0XHR0aGlzLm9uTW91c2VNb3ZlKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ21vdXNldXAnOlxuXHRcdFx0XHR0aGlzLm9uTW91c2VVcChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdrZXlkb3duJzpcblx0XHRcdFx0dGhpcy5vbktleURvd24oZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdG9uTW91c2VEb3duKGUpIHtcblx0XHR0aGlzLmJydXNoZXMgPSBbXTtcblx0XHR0aGlzLnN0YXJ0WCA9IGUueDtcblx0XHQvLyBjcmVhdGUgYnJ1c2ggaW4gZWFjaCBjb250YWluZXJzXG5cdFx0dGhpcy50cmFja3MuZm9yRWFjaCgodHJhY2spID0+IHtcblx0XHRcdGNvbnN0IGludGVyYWN0aW9ucyA9IHRyYWNrLiRpbnRlcmFjdGlvbnNMYXllcjtcblxuXHRcdFx0Y29uc3QgYnJ1c2ggPSBuZXcgS29udmEuUmVjdCh7fSk7XG5cdFx0XHRicnVzaC5oZWlnaHQodHJhY2suaGVpZ2h0KVxuXHRcdFx0XHQueSgwKVxuXHRcdFx0XHQuZmlsbCgnIzc4Nzg3OCcpXG5cdFx0XHRcdC5vcGFjaXR5KDAuMik7XG5cdFx0XHRicnVzaC50cmFjayA9IHRyYWNrO1xuXG5cdFx0XHRpbnRlcmFjdGlvbnMuYWRkKGJydXNoKTtcblxuXHRcdFx0dGhpcy5icnVzaGVzLnB1c2goYnJ1c2gpO1xuXG5cdFx0XHRpbnRlcmFjdGlvbnMuYmF0Y2hEcmF3KCk7XG5cdFx0XHQvLyBpbnRlcmFjdGlvbnMubW92ZVRvVG9wKCk7XG5cdFx0fSk7XG5cdH1cblxuXHRvbk1vdXNlTW92ZShlKSB7XG5cdFx0Ly8gdXBkYXRlIGJydXNoXG5cdFx0Y29uc3Qgd2lkdGggPSBNYXRoLmFicyhlLnggLSB0aGlzLnN0YXJ0WCk7XG5cdFx0Y29uc3QgeCA9IE1hdGgubWluKGUueCwgdGhpcy5zdGFydFgpO1xuXG5cdFx0dGhpcy5icnVzaGVzLmZvckVhY2goKGJydXNoKSA9PiB7XG5cdFx0XHRicnVzaC54KHgpLndpZHRoKHdpZHRoKTtcblx0XHRcdGJydXNoLnRyYWNrLiRpbnRlcmFjdGlvbnNMYXllci5iYXRjaERyYXcoKTtcblx0XHR9KTtcblx0fVxuXG5cdG9uTW91c2VVcChlKSB7XG5cdFx0Ly8gcmVtb3ZlIGJydXNoXG5cdFx0dGhpcy5icnVzaGVzLmZvckVhY2goKGJydXNoKSA9PiB7XG5cdFx0XHRicnVzaC5kZXN0cm95KCk7XG5cdFx0XHRicnVzaC50cmFjay4kaW50ZXJhY3Rpb25zTGF5ZXIuYmF0Y2hEcmF3KCk7XG5cdFx0XHRicnVzaC50cmFjayA9IG51bGw7XG5cdFx0fSk7XG5cdFx0dGhpcy5icnVzaGVzLmxlbmd0aCA9IDA7XG5cblx0XHQvLyB1cGRhdGUgdGltZUNvbnRleHRcblx0XHRjb25zdCBzdGFydFggPSB0aGlzLnN0YXJ0WDtcblx0XHRjb25zdCBlbmRYID0gZS54O1xuXHRcdC8vIHJldHVybiBpZiBubyBkcmFnXG5cdFx0aWYgKE1hdGguYWJzKHN0YXJ0WCAtIGVuZFgpIDwgMSkgeyByZXR1cm47IH1cblxuXHRcdGNvbnN0IGxlZnRYID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc3RhcnRYLCBlbmRYKSk7XG5cdFx0Y29uc3QgcmlnaHRYID0gTWF0aC5tYXgoc3RhcnRYLCBlbmRYKTtcblxuXHRcdGxldCBtaW5UaW1lID0gdGhpcy50aW1lbGluZS50aW1lVG9QaXhlbC5pbnZlcnQobGVmdFgpO1xuXHRcdGxldCBtYXhUaW1lID0gdGhpcy50aW1lbGluZS50aW1lVG9QaXhlbC5pbnZlcnQocmlnaHRYKTtcblxuXHRcdGNvbnN0IGRlbHRhRHVyYXRpb24gPSBtYXhUaW1lIC0gbWluVGltZTtcblx0XHRjb25zdCB6b29tID0gdGhpcy50aW1lbGluZS52aXNpYmxlRHVyYXRpb24gLyBkZWx0YUR1cmF0aW9uO1xuXG5cdFx0dGhpcy50aW1lbGluZS5vZmZzZXQgLT0gbWluVGltZTtcblx0XHR0aGlzLnRpbWVsaW5lLnpvb20gKj0gem9vbTtcblxuXHRcdHRoaXMudHJhY2tzLnVwZGF0ZSgpO1xuXHR9XG5cblx0b25LZXlEb3duKGUpIHtcblx0XHQvLyByZXNldCBvbiBzcGFjZSBiYXJcblx0XHRpZiAoZS5vcmlnaW5hbEV2ZW50LmtleUNvZGUgPT09IDMyKSB7XG5cdFx0XHR0aGlzLnRpbWVsaW5lLm9mZnNldCA9IDA7XG5cdFx0XHR0aGlzLnRpbWVsaW5lLnpvb20gPSAxO1xuXHRcdFx0dGhpcy50cmFja3MudXBkYXRlKCk7XG5cdFx0fVxuXHR9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgQmFzZVN0YXRlIGZyb20gJy4vYmFzZS1zdGF0ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENlbnRlcmVkU2Nyb2xsU3RhdGUgZXh0ZW5kcyBCYXNlU3RhdGUge1xuICBjb25zdHJ1Y3Rvcih0aW1lbGluZSkge1xuICAgIHN1cGVyKHRpbWVsaW5lKTtcbiAgICB0aGlzLmN1cnJlbnRMYXllciA9IG51bGw7XG4gICAgLy8gU2V0IG1heC9taW4gem9vbVxuICAgIC8vIG1heFpvb206IDFweCBwZXIgc2FtcGxlXG4gICAgLy8gbWluWm9vbTogMTAgMDAwIHB4IHBlciAxIGhvdXJcbiAgICAvLyB3aXRoIGEgZGVmYXVsdCB0byA0NC4xa0h6IHNhbXBsZSByYXRlXG4gICAgdGhpcy5tYXhab29tID0gNDQxMDAgKiAxIC8gdGhpcy50aW1lbGluZS50aW1lQ29udGV4dC5waXhlbHNQZXJTZWNvbmQ7XG4gICAgdGhpcy5taW5ab29tID0gMTAwMDAgLyAzNjAwIC8gdGhpcy50aW1lbGluZS50aW1lQ29udGV4dC5waXhlbHNQZXJTZWNvbmQ7XG4gIH1cblxuICBoYW5kbGVFdmVudChlKSB7XG4gICAgc3dpdGNoKGUudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlRG93bihlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICB0aGlzLm9uTW91c2VNb3ZlKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgICB0aGlzLm9uTW91c2VVcChlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgb25Nb3VzZURvd24oZSkge1xuICB9XG5cbiAgb25Nb3VzZU1vdmUoZSkge1xuICAgIC8vIHByZXZlbnQgYW5ub3lpbmcgdGV4dCBzZWxlY3Rpb24gd2hlbiBkcmFnZ2luZ1xuICAgIGUub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3QgdGltZUNvbnRleHQgPSB0aGlzLnRpbWVsaW5lLnRpbWVDb250ZXh0O1xuICAgIGNvbnN0IGxhc3RDZW50ZXJUaW1lID0gdGltZUNvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KGUueCk7XG5cbiAgICBjb25zdCBuZXdDZW50ZXJUaW1lID0gdGltZUNvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KGUueCk7XG4gICAgY29uc3QgZGVsdGEgPSBuZXdDZW50ZXJUaW1lIC0gbGFzdENlbnRlclRpbWU7XG5cbiAgICAvLyBBcHBseSBuZXcgb2Zmc2V0IHRvIGtlZXAgaXQgY2VudGVyZWQgdG8gdGhlIG1vdXNlXG4gICAgdGltZUNvbnRleHQub2Zmc2V0ICs9IChkZWx0YSArIHRpbWVDb250ZXh0LnRpbWVUb1BpeGVsLmludmVydChlLmR4KSk7XG5cbiAgICAvLyBPdGhlciBwb3NzaWJsZSBleHBlcmltZW50cyB3aXRoIGNlbnRlcmVkLXpvb20tc3RhdGVcbiAgICAvL1xuICAgIC8vIEV4YW1wbGUgMTogUHJldmVudCB0aW1lbGluZS5vZmZzZXQgdG8gYmUgbmVnYXRpdmVcbiAgICB0aW1lQ29udGV4dC5vZmZzZXQgPSBNYXRoLm1pbih0aW1lQ29udGV4dC5vZmZzZXQsIDApO1xuICAgIFxuXG4gICAgdGhpcy50aW1lbGluZS50cmFja3MudXBkYXRlKCk7XG4gIH1cblxuICBvbk1vdXNlVXAoZSkge31cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlU3RhdGUgZnJvbSAnLi9iYXNlLXN0YXRlJztcbmltcG9ydCBzY2FsZXMgZnJvbSAnLi4vdXRpbHMvc2NhbGVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2VudGVyZWRab29tU3RhdGUgZXh0ZW5kcyBCYXNlU3RhdGUge1xuICBjb25zdHJ1Y3Rvcih0aW1lbGluZSkge1xuICAgIHN1cGVyKHRpbWVsaW5lKTtcbiAgICB0aGlzLmN1cnJlbnRMYXllciA9IG51bGw7XG4gICAgLy8gU2V0IG1heC9taW4gem9vbVxuICAgIC8vIG1heFpvb206IDFweCBwZXIgc2FtcGxlXG4gICAgLy8gbWluWm9vbTogMTAgMDAwIHB4IHBlciAxIGhvdXJcbiAgICAvLyB3aXRoIGEgZGVmYXVsdCB0byA0NC4xa0h6IHNhbXBsZSByYXRlXG4gICAgdGhpcy5tYXhab29tID0gNDQxMDAgKiAxIC8gdGhpcy50aW1lbGluZS50aW1lQ29udGV4dC5waXhlbHNQZXJTZWNvbmQ7XG4gICAgdGhpcy5taW5ab29tID0gMTAwMDAgLyAzNjAwIC8gdGhpcy50aW1lbGluZS50aW1lQ29udGV4dC5waXhlbHNQZXJTZWNvbmQ7XG4gIH1cblxuICBoYW5kbGVFdmVudChlKSB7XG4gICAgc3dpdGNoKGUudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlRG93bihlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICB0aGlzLm9uTW91c2VNb3ZlKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgICB0aGlzLm9uTW91c2VVcChlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgb25Nb3VzZURvd24oZSkge1xuICAgIHRoaXMuaW5pdGlhbFpvb20gPSB0aGlzLnRpbWVsaW5lLnRpbWVDb250ZXh0Lnpvb207XG4gICAgdGhpcy5pbml0aWFsWSA9IGUueTtcblxuICAgIHRoaXMuX3BpeGVsVG9FeHBvbmVudCA9IHNjYWxlcy5saW5lYXIoKVxuICAgICAgLmRvbWFpbihbMCwgMTAwXSkgLy8gMTAwcHggPT4gZmFjdG9yIDJcbiAgICAgIC5yYW5nZShbMCwgMV0pO1xuICB9XG5cbiAgb25Nb3VzZU1vdmUoZSkge1xuICAgIC8vIHByZXZlbnQgYW5ub3lpbmcgdGV4dCBzZWxlY3Rpb24gd2hlbiBkcmFnZ2luZ1xuICAgIGUub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3QgdGltZUNvbnRleHQgPSB0aGlzLnRpbWVsaW5lLnRpbWVDb250ZXh0O1xuICAgIGNvbnN0IGxhc3RDZW50ZXJUaW1lID0gdGltZUNvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KGUueCk7XG4gICAgY29uc3QgZXhwb25lbnQgPSB0aGlzLl9waXhlbFRvRXhwb25lbnQoZS55IC0gdGhpcy5pbml0aWFsWSk7XG4gICAgY29uc3QgdGFyZ2V0Wm9vbSA9IHRoaXMuaW5pdGlhbFpvb20gKiBNYXRoLnBvdygyLCBleHBvbmVudCk7IC8vIC0xLi4uMSAtPiAxLzIuLi4yXG5cbiAgICB0aW1lQ29udGV4dC56b29tID0gTWF0aC5taW4oTWF0aC5tYXgodGFyZ2V0Wm9vbSwgdGhpcy5taW5ab29tKSwgdGhpcy5tYXhab29tKTtcblxuICAgIGNvbnN0IG5ld0NlbnRlclRpbWUgPSB0aW1lQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQoZS54KTtcbiAgICBjb25zdCBkZWx0YSA9IG5ld0NlbnRlclRpbWUgLSBsYXN0Q2VudGVyVGltZTtcblxuICAgIC8vIEFwcGx5IG5ldyBvZmZzZXQgdG8ga2VlcCBpdCBjZW50ZXJlZCB0byB0aGUgbW91c2VcbiAgICB0aW1lQ29udGV4dC5vZmZzZXQgKz0gKGRlbHRhICsgdGltZUNvbnRleHQudGltZVRvUGl4ZWwuaW52ZXJ0KGUuZHgpKTtcblxuICAgIC8vIE90aGVyIHBvc3NpYmxlIGV4cGVyaW1lbnRzIHdpdGggY2VudGVyZWQtem9vbS1zdGF0ZVxuICAgIC8vXG4gICAgLy8gRXhhbXBsZSAxOiBQcmV2ZW50IHRpbWVsaW5lLm9mZnNldCB0byBiZSBuZWdhdGl2ZVxuICAgIC8vIHRpbWVDb250ZXh0Lm9mZnNldCA9IE1hdGgubWluKHRpbWVDb250ZXh0Lm9mZnNldCwgMCk7XG4gICAgLy9cbiAgICAvLyBFeGFtcGxlIDI6IEtlZXAgaW4gY29udGFpbmVyIHdoZW4gem9vbWVkIG91dFxuICAgIGlmICh0aW1lQ29udGV4dC5zdHJldGNoUmF0aW8gPCAxKSB7XG4gICAgICBjb25zdCBtaW5PZmZzZXQgPSB0aW1lQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQoMCk7XG4gICAgICBjb25zdCBtYXhPZmZzZXQgPSB0aW1lQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQodmlldy53aWR0aCAtIHRpbWVDb250ZXh0LnRpbWVUb1BpeGVsKHRpbWVDb250ZXh0LmR1cmF0aW9uKSk7XG4gICAgICB0aW1lQ29udGV4dC5vZmZzZXQgPSBNYXRoLm1heCh0aW1lQ29udGV4dC5vZmZzZXQsIG1pbk9mZnNldCk7XG4gICAgICB0aW1lQ29udGV4dC5vZmZzZXQgPSBNYXRoLm1pbih0aW1lQ29udGV4dC5vZmZzZXQsIG1heE9mZnNldCk7XG4gICAgfVxuXG4gICAgdGhpcy50aW1lbGluZS50cmFja3MudXBkYXRlKCk7XG4gIH1cblxuICBvbk1vdXNlVXAoZSkge31cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlU3RhdGUgZnJvbSAnLi9iYXNlLXN0YXRlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udGV4dEVkaXRpb25TdGF0ZSBleHRlbmRzIEJhc2VTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKHRpbWVsaW5lKSB7XG4gICAgc3VwZXIodGltZWxpbmUpO1xuICB9XG5cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIHN3aXRjaChlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICAgIHRoaXMub25Nb3VzZURvd24oZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlTW92ZShlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlVXAoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIG9uTW91c2VEb3duKGUpIHtcbiAgICB0aGlzLm1vdXNlRG93biA9IHRydWU7XG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgdGhpcy5jdXJyZW50TGF5ZXIgPSAodGhpcy5jdXJyZW50VGFyZ2V0LnNoYXBlKT8gdGhpcy5jdXJyZW50VGFyZ2V0LnNoYXBlLmxheWVyIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgb25Nb3VzZU1vdmUoZSkge1xuICAgIGlmICghdGhpcy5tb3VzZURvd24gfHwgIXRoaXMuY3VycmVudExheWVyKSB7IHJldHVybjsgfVxuXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmN1cnJlbnRMYXllcjtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmN1cnJlbnRUYXJnZXQ7XG5cbiAgICAvLyBpbiB0aGlzIGV4YW1wbGUgdGhlIGNvbnRleHQgaXMgc3RyZXRjaGVkIHdoZW4gc2hpZnQgaXMgcHJlc3NlZFxuICAgIGlmICghZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICBsYXllci5lZGl0Q29udGV4dChlLmR4LCBlLmR5LCB0YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXllci5zdHJldGNoQ29udGV4dChlLmR4LCBlLmR5LCB0YXJnZXQpO1xuICAgIH1cblxuICAgIGxheWVyLnVwZGF0ZSgpO1xuICB9XG5cbiAgb25Nb3VzZVVwKGUpIHtcbiAgICB0aGlzLm1vdXNlRG93biA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50TGF5ZXIgPSBudWxsO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgQmFzZVN0YXRlIGZyb20gJy4vYmFzZS1zdGF0ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERyb3BBbmRBZGRTdGF0ZSBleHRlbmRzIEJhc2VTdGF0ZSB7XG5cdGNvbnN0cnVjdG9yKHRpbWVsaW5lKSB7XG5cdFx0c3VwZXIodGltZWxpbmUpO1xuXHRcdHRoaXMudGFyZ2V0TGF5ZXIgPSBuZXcgTWFwKCk7XG5cdH1cblxuXHRzZXRUYXJnZXRMYXllckZvclRyYWNrKHRyYWNrLCBsYXllcikge1xuXHRcdHRoaXMudGFyZ2V0TGF5ZXIuc2V0KHRyYWNrLCBsYXllcik7XG5cdH1cblxuXHRleGl0KCkge1xuXHRcdHRoaXMudGFyZ2V0TGF5ZXIuY2xlYXIoKTtcblx0XHQvLyBUT0RPOiByZW1vdmUgdHJhY2sgaGlnaGxpZ2h0ID9cblx0fVxuXG5cdGhhbmRsZUV2ZW50KGUpIHtcblx0XHRzd2l0Y2ggKGUudHlwZSkge1xuXHRcdFx0Y2FzZSAnZHJhZ3N0YXJ0Jzpcblx0XHRcdFx0dGhpcy5vbkRyYWdTdGFydChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdkcmFnZW5kJzpcblx0XHRcdFx0dGhpcy5vbkRyYWdFbmQoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnZHJhZ292ZXInOlxuXHRcdFx0XHR0aGlzLm9uRHJhZ092ZXIoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnZHJvcCc6XG5cdFx0XHRcdHRoaXMub25Ecm9wKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2RyYWdsZWF2ZSc6XG5cdFx0XHRcdHRoaXMub25EcmFnTGVhdmUoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdG9uRHJhZ1N0YXJ0KGUpIHtcblx0XHQvLyBOL0Fcblx0fVxuXG5cdG9uRHJhZ0VuZChlKSB7XG5cdFx0Ly8gVE9ETyA/XG5cdH1cblxuXHRvbkRyYWdPdmVyKGUpIHtcblx0XHQvLyBUT0RPOiBoaWdobGlnaHQgdHJhY2sgP1xuXHR9XG5cblx0b25EcmFnTGVhdmUoZSkge1xuXHRcdC8vIFRPRE86IHJlbW92ZSB0cmFjayBoaWdobGlnaHQgP1xuXHR9XG5cblx0b25Ecm9wKGUpIHtcblx0XHRjb25zdCBvZmZzZXQgPSAoLXRoaXMudGltZWxpbmUudGltZUNvbnRleHQub2Zmc2V0KTtcblx0XHRjb25zdCB0aW1lID0gdGhpcy50aW1lbGluZS50aW1lQ29udGV4dC50aW1lVG9QaXhlbC5pbnZlcnQoZS54KTtcblx0XHRjb25zdCBjdXJyZW50VGltZSA9IG9mZnNldCArIHRpbWU7XG5cblx0XHR2YXIgdHJhY2sgPSB0aGlzLnRpbWVsaW5lLmdldFRyYWNrRnJvbURPTUVsZW1lbnQoZS5jdXJyZW50VGFyZ2V0KTtcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLnRhcmdldExheWVyLmdldCh0cmFjayk7XG5cblx0XHRpZiAobGF5ZXIpIHtcblx0XHRcdHZhciBkYXR1bSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcIlRleHRcIikpLmdldERhdHVtKCk7XG5cdFx0XHRkYXR1bS54ID0gY3VycmVudFRpbWU7XG5cdFx0XHRsYXllci5hZGQoZGF0dW0pO1xuXHRcdFx0bGF5ZXIuZ2V0U2hhcGVGcm9tRGF0dW0oZGF0dW0pLnBhcmFtcy5jb2xvciA9IGRhdHVtLmNvbG9yO1xuXHRcdFx0bGF5ZXIudXBkYXRlKCk7XG5cdFx0fVxuXHRcdFxuXHRcdGUub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIuY2xlYXJEYXRhKCk7XG5cdH1cbn0iLCIndXNlIHN0cmljdCc7XG5pbXBvcnQgQmFzZVN0YXRlIGZyb20gJy4vYmFzZS1zdGF0ZSc7XG5cbi8qKlxuICogQSBzdGF0ZSB0byBlZGl0IHNoYXBlcyBpbiB0aGUgbW9yZSBnZW5lcmFsIHdheS4gSW50ZXJhY3Qgb25seSB3aXRoIHNlbGVjdGVkIHNoYXBlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWRpdGlvblN0YXRlIGV4dGVuZHMgQmFzZVN0YXRlIHtcbiAgY29uc3RydWN0b3IodGltZWxpbmUpIHtcbiAgICBzdXBlcih0aW1lbGluZSk7XG5cbiAgICB0aGlzLmN1cnJlbnRFZGl0ZWRMYXllciA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgfVxuXG4gIGVudGVyKCkge31cbiAgZXhpdCgpIHt9XG5cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgICB0aGlzLm9uTW91c2VEb3duKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmUoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICAgIHRoaXMub25Nb3VzZVVwKGUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBvbk1vdXNlRG93bihlKSB7XG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gZS50YXJnZXQ7XG4gIH1cblxuICBvbk1vdXNlTW92ZShlKSB7XG4gICAgdGhpcy5sYXllcnMuZm9yRWFjaCgobGF5ZXIpID0+IHtcbiAgICAgIGNvbnN0IGRhdHVtcyA9IGxheWVyLnNlbGVjdGVkRGF0dW1zO1xuXG4gICAgICBsYXllci5lZGl0KGRhdHVtcywgZS5keCwgZS5keSwgdGhpcy5jdXJyZW50VGFyZ2V0KTtcbiAgICAgIGxheWVyLnVwZGF0ZShkYXR1bXMpO1xuICAgIH0pO1xuICB9XG5cbiAgb25Nb3VzZVVwKGUpIHtcbiAgICB0aGlzLmN1cnJlbnRFZGl0ZWRMYXllciA9IG51bGw7XG4gICAgdGhpcy5tb3VzZURvd24gPSBmYWxzZTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IEJhc2VTdGF0ZSBmcm9tICcuL2Jhc2Utc3RhdGUnO1xuaW1wb3J0IEtvbnZhIGZyb20gJ2tvbnZhJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSG9yaXpvbnRhbFNlbGVjdGlvblN0YXRlIGV4dGVuZHMgQmFzZVN0YXRlIHtcblxuICBjb25zdHJ1Y3Rvcih0aW1lbGluZSAvKiwgb3B0aW9ucyA9IHt9ICovKSB7XG4gICAgc3VwZXIodGltZWxpbmUgLyosIG9wdGlvbnMgKi8pO1xuXG4gICAgdGhpcy5fbGF5ZXJTZWxlY3RlZEl0ZW1zTWFwID0gbmV3IE1hcCgpO1xuXG4gICAgdGhpcy5zaGlmdEtleSA9IGZhbHNlO1xuXG4gICAgdGhpcy53YXNNb3ZpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIGVudGVyKCkge1xuICAgIC8vIFRPRE9cbiAgfVxuXG4gIGV4aXQoKSB7XG4gICAgLy8gVE9ET1xuICAgIGNvbnN0IGNvbnRhaW5lcnMgPSB0aGlzLnRpbWVsaW5lLmNvbnRhaW5lcnM7XG5cbiAgICBmb3IgKGxldCBpZCBpbiBjb250YWluZXJzKSB7XG4gICAgICB0aGlzLl9yZW1vdmVCcnVzaChjb250YWluZXJzW2lkXSk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgICB0aGlzLm9uTW91c2VEb3duKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmUoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICAgIHRoaXMub25Nb3VzZVVwKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgICAgdGhpcy5vbkNsaWNrKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2tleWRvd24nOlxuICAgICAgICB0aGlzLm9uS2V5KGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgICAgdGhpcy5vbktleShlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgX2FkZEJydXNoKHRyYWNrKSB7XG4gICAgaWYgKHRyYWNrLiRicnVzaCkgeyByZXR1cm47IH1cblxuICAgIGNvbnN0IGJydXNoID0gbmV3IEtvbnZhLlJlY3Qoe30pO1xuICAgIGJydXNoLmZpbGwoJyM2ODY4NjgnKS5vcGFjaXR5KDAuNSk7XG5cbiAgICB0cmFjay4kaW50ZXJhY3Rpb25zTGF5ZXIuYWRkKGJydXNoKTtcbiAgICB0cmFjay4kaW50ZXJhY3Rpb25zTGF5ZXIubW92ZVRvVG9wKCk7XG5cbiAgICB0cmFjay4kYnJ1c2ggPSBicnVzaDtcblxuICAgIHRyYWNrLiRpbnRlcmFjdGlvbnNMYXllci5iYXRjaERyYXcoKTtcbiAgfVxuXG4gIF9yZW1vdmVCcnVzaCh0cmFjaykge1xuICAgIGlmICh0cmFjay4kYnJ1c2ggPT09IHVuZGVmaW5lZCkgeyByZXR1cm47IH1cblxuICAgIHRoaXMuX3Jlc2V0QnJ1c2godHJhY2spO1xuXG4gICAgdHJhY2suJGJydXNoLmRlc3Ryb3koKTtcblxuICAgIHRyYWNrLiRpbnRlcmFjdGlvbnNMYXllci5iYXRjaERyYXcoKTtcblxuICAgIGRlbGV0ZSB0cmFjay4kYnJ1c2g7XG4gIH1cblxuICBfcmVzZXRCcnVzaCh0cmFjaykge1xuICAgIGNvbnN0ICRicnVzaCA9IHRyYWNrLiRicnVzaDtcbiAgICAvLyByZXNldCBicnVzaCBlbGVtZW50XG4gICAgJGJydXNoLngoMCkueSgwKS53aWR0aCgwKS5oZWlnaHQoMCk7XG4gICAgdHJhY2suJGludGVyYWN0aW9uc0xheWVyLmJhdGNoRHJhdygpO1xuICB9XG5cbiAgX3VwZGF0ZUJydXNoKGUsIHRyYWNrKSB7XG4gICAgY29uc3QgJGJydXNoID0gdHJhY2suJGJydXNoO1xuXG4gICAgJGJydXNoLngoZS5hcmVhLmxlZnQpLnkoMCkud2lkdGgoZS5hcmVhLndpZHRoKS5oZWlnaHQodHJhY2suaGVpZ2h0KTtcbiAgICB0cmFjay4kaW50ZXJhY3Rpb25zTGF5ZXIuYmF0Y2hEcmF3KCk7XG4gIH1cblxuICBvbktleShlKSB7XG4gICAgdGhpcy5zaGlmdEtleSA9IGUuc2hpZnRLZXk7XG4gIH1cblxuICBvbk1vdXNlRG93bihlKSB7XG4gICAgdGhpcy5fY3VycmVudFRyYWNrID0gdGhpcy50aW1lbGluZS5nZXRUcmFja0Zyb21ET01FbGVtZW50KGUuY3VycmVudFRhcmdldCk7XG5cbiAgICBpZiAoIXRoaXMuX2N1cnJlbnRUcmFjaykgeyByZXR1cm47IH1cblxuICAgIHRoaXMuX2FkZEJydXNoKHRoaXMuX2N1cnJlbnRUcmFjayk7XG5cbiAgICAvLyByZWNyZWF0ZSB0aGUgbWFwXG4gICAgdGhpcy5fbGF5ZXJTZWxlY3RlZEl0ZW1zTWFwID0gbmV3IE1hcCgpO1xuICAgIFxuICAgIHRoaXMuX2N1cnJlbnRUcmFjay5sYXllcnMuZm9yRWFjaCgobGF5ZXIpID0+IHtcbiAgICAgIFxuICAgICAgaWYgKCFlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgY29uc3QgYXV4ID0gbmV3IFNldChsYXllci5zZWxlY3RlZERhdHVtcyk7XG4gICAgICAgIGxheWVyLnVuc2VsZWN0KGF1eCk7XG4gICAgICAgIGxheWVyLnVwZGF0ZVNoYXBlcyhhdXgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9sYXllclNlbGVjdGVkSXRlbXNNYXAuc2V0KGxheWVyLCBuZXcgU2V0KGxheWVyLnNlbGVjdGVkRGF0dW1zKSk7XG4gICAgICBcbiAgICB9KTtcblxuICAgIHRoaXMubW91c2Vkb3duID0gdHJ1ZTtcbiAgfVxuXG4gIG9uTW91c2VNb3ZlKGUpIHtcblxuICAgIGlmICghdGhpcy5tb3VzZWRvd24pIHJldHVybjtcblxuXG4gICAgdGhpcy53YXNNb3ZpbmcgPSB0cnVlO1xuXG4gICAgZS5hcmVhID0ge2xlZnQ6IGUuYXJlYS5sZWZ0LCB3aWR0aDplLmFyZWEud2lkdGgsIHRvcDogMCwgaGVpZ2h0OiB0aGlzLl9jdXJyZW50VHJhY2suaGVpZ2h0IH07XG4gICAgXG4gICAgdGhpcy5fdXBkYXRlQnJ1c2goZSwgdGhpcy5fY3VycmVudFRyYWNrKTtcblxuICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xuXG4gICAgdGhpcy5fY3VycmVudFRyYWNrLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IGxheWVyLnNlbGVjdGVkRGF0dW1zO1xuICAgICAgY29uc3QgZGF0dW1zSW5BcmVhID0gbGF5ZXIuZ2V0RGF0dW1zSW5BcmVhKGUuYXJlYSk7XG5cbiAgICAgIHZhciB0b1NlbGVjdDtcbiAgICAgIHZhciB0b1Vuc2VsZWN0O1xuXG4gICAgICAvLyBpZiBpcyBub3QgcHJlc3NlZFxuICAgICAgaWYgKCFlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkpIHsgICAgICAgIFxuXG4gICAgICAgIHRvVW5zZWxlY3QgPSBuZXcgU2V0KGN1cnJlbnRTZWxlY3Rpb24pO1xuICAgICAgICB0b1NlbGVjdCA9IG5ldyBTZXQoZGF0dW1zSW5BcmVhKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB0b1NlbGVjdCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdG9VbnNlbGVjdCA9IG5ldyBTZXQoKTtcbiAgICAgICAgLy8gdXNlIHRoZSBzZWxlY3Rpb24gZnJvbSB0aGUgcHJldmlvdXMgZHJhZ1xuICAgICAgICBjb25zdCBwcmV2aW91c1NlbGVjdGlvbiA9IHRoaXMuX2xheWVyU2VsZWN0ZWRJdGVtc01hcC5nZXQobGF5ZXIpO1xuICAgICAgICBcblxuICAgICAgICBkYXR1bXNJbkFyZWEuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgICAgICBpZiAoIXByZXZpb3VzU2VsZWN0aW9uLmhhcyhkYXR1bSkpIHtcbiAgICAgICAgICAgIHRvU2VsZWN0LmFkZChkYXR1bSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvVW5zZWxlY3QuYWRkKGRhdHVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGN1cnJlbnRTZWxlY3Rpb24uZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgICAgICBpZiAoIWRhdHVtc0luQXJlYS5oYXMoZGF0dW0pICYmICFwcmV2aW91c1NlbGVjdGlvbi5oYXMoZGF0dW0pKSB7XG4gICAgICAgICAgICB0b1Vuc2VsZWN0LmFkZChkYXR1bSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBwcmV2aW91c1NlbGVjdGlvbi5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICAgIGlmICghZGF0dW1zSW5BcmVhLmhhcyhkYXR1bSkpIHtcbiAgICAgICAgICAgIHRvU2VsZWN0LmFkZChkYXR1bSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgfVxuXG4gICAgICBsYXllci51bnNlbGVjdCh0b1Vuc2VsZWN0KTtcbiAgICAgIGxheWVyLnNlbGVjdCh0b1NlbGVjdCk7XG5cbiAgICAgIGxheWVyLnVwZGF0ZVNoYXBlcyhjdXJyZW50U2VsZWN0aW9uKTtcbiAgICAgIGxheWVyLnVwZGF0ZVNoYXBlcyhkYXR1bXNJbkFyZWEpO1xuICAgIH0pO1xuICB9XG5cbiAgb25Nb3VzZVVwKGUpIHtcbiAgICB0aGlzLl9yZW1vdmVCcnVzaCh0aGlzLl9jdXJyZW50VHJhY2spO1xuICAgIHRoaXMubW91c2Vkb3duID0gZmFsc2U7XG4gICAgdGhpcy53YXNNb3ZpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIG9uQ2xpY2soZSkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdjbGljaycpO1xuICAgIGlmICghdGhpcy5fY3VycmVudFRyYWNrKSB7IHJldHVybjsgfVxuICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xuXG4gICAgdGhpcy5fY3VycmVudFRyYWNrLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuXG4gICAgICBjb25zdCBzaGFwZSA9IGUudGFyZ2V0LnNoYXBlO1xuICAgICAgY29uc3QgZGF0dW0gPSBsYXllci5nZXREYXR1bUZyb21TaGFwZShzaGFwZSk7XG4gICAgICB2YXIgdG9VcGRhdGUgPSBuZXcgU2V0KCk7XG5cbiAgICAgIC8vVE9ETzogY29ycmVjdCB0aGlzIGJlY2F1c2UgaXQgaXMgbm90IHdvcmtpbmcgYXMgSSBleHBlY3RlZCB0by4gIFxuICAgICAgaWYgKCFlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgdG9VcGRhdGUgPSBuZXcgU2V0KGxheWVyLnNlbGVjdGVkRGF0dW1zKTtcbiAgICAgICAgbGF5ZXIudW5zZWxlY3QobGF5ZXIuc2VsZWN0ZWREYXR1bXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0dW0pIHtcbiAgICAgICAgdG9VcGRhdGUuYWRkKGRhdHVtKTtcbiAgICAgICAgbGF5ZXIudG9nZ2xlU2VsZWN0aW9uKFtkYXR1bV0pO1xuICAgICAgfVxuXG4gICAgICBsYXllci51cGRhdGVTaGFwZXModG9VcGRhdGUpO1xuXG4gICAgfSk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlU3RhdGUgZnJvbSAnLi9iYXNlLXN0YXRlJztcbmltcG9ydCBLb252YSBmcm9tICdrb252YSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlbGVjdGlvblN0YXRlIGV4dGVuZHMgQmFzZVN0YXRlIHtcblxuICBjb25zdHJ1Y3Rvcih0aW1lbGluZSAvKiwgb3B0aW9ucyA9IHt9ICovKSB7XG4gICAgc3VwZXIodGltZWxpbmUgLyosIG9wdGlvbnMgKi8pO1xuXG4gICAgdGhpcy5jdXJyZW50TGF5ZXIgPSB1bmRlZmluZWQ7XG4gICAgLy8gbmVlZCBhIGNhY2hlZFxuICAgIHRoaXMuc2VsZWN0ZWREYXR1bXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tb3VzZURvd24gPSBmYWxzZTtcbiAgICB0aGlzLnNoaWZ0S2V5ID0gZmFsc2U7XG5cbiAgICB0aGlzLl9sYXllclNlbGVjdGVkSXRlbXNNYXAgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBlbnRlcigpIHtcblxuICB9XG5cbiAgZXhpdCgpIHtcbiAgICBjb25zdCBjb250YWluZXJzID0gdGhpcy50aW1lbGluZS5jb250YWluZXJzO1xuXG4gICAgZm9yIChsZXQgaWQgaW4gY29udGFpbmVycykge1xuICAgICAgdGhpcy5fcmVtb3ZlQnJ1c2goY29udGFpbmVyc1tpZF0pO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlRG93bihlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICB0aGlzLm9uTW91c2VNb3ZlKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgICB0aGlzLm9uTW91c2VVcChlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjbGljayc6XG4gICAgICAgIHRoaXMub25DbGljayhlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdrZXlkb3duJzpcbiAgICAgICAgdGhpcy5vbktleShlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdrZXl1cCc6XG4gICAgICAgIHRoaXMub25LZXkoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIF9hZGRCcnVzaCh0cmFjaykge1xuICAgIGlmICh0cmFjay4kYnJ1c2gpIHsgcmV0dXJuOyB9XG5cbiAgICBjb25zdCBicnVzaCA9IG5ldyBLb252YS5SZWN0KHt9KTtcbiAgICBicnVzaC5maWxsKCcjNjg2ODY4Jykub3BhY2l0eSgwLjUpO1xuXG4gICAgdHJhY2suJGludGVyYWN0aW9uc0xheWVyLmFkZChicnVzaCk7XG4gICAgdHJhY2suJGludGVyYWN0aW9uc0xheWVyLm1vdmVUb1RvcCgpO1xuXG4gICAgdHJhY2suJGJydXNoID0gYnJ1c2g7XG5cbiAgICB0cmFjay4kaW50ZXJhY3Rpb25zTGF5ZXIuYmF0Y2hEcmF3KCk7XG4gIH1cblxuICBfcmVtb3ZlQnJ1c2godHJhY2spIHtcbiAgICBpZiAodHJhY2suJGJydXNoID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLl9yZXNldEJydXNoKHRyYWNrKTtcblxuICAgIHRyYWNrLiRicnVzaC5kZXN0cm95KCk7XG5cbiAgICB0cmFjay4kaW50ZXJhY3Rpb25zTGF5ZXIuYmF0Y2hEcmF3KCk7XG5cbiAgICBkZWxldGUgdHJhY2suJGJydXNoO1xuICB9XG5cbiAgX3Jlc2V0QnJ1c2godHJhY2spIHtcbiAgICBjb25zdCAkYnJ1c2ggPSB0cmFjay4kYnJ1c2g7XG4gICAgLy8gcmVzZXQgYnJ1c2ggZWxlbWVudFxuICAgICRicnVzaC54KDApLnkoMCkud2lkdGgoMCkuaGVpZ2h0KDApO1xuICAgIHRyYWNrLiRpbnRlcmFjdGlvbnNMYXllci5iYXRjaERyYXcoKTtcbiAgfVxuXG4gIF91cGRhdGVCcnVzaChlLCB0cmFjaykge1xuICAgIGNvbnN0ICRicnVzaCA9IHRyYWNrLiRicnVzaDtcblxuICAgICRicnVzaC54KGUuYXJlYS5sZWZ0KS55KGUuYXJlYS50b3ApLndpZHRoKGUuYXJlYS53aWR0aCkuaGVpZ2h0KGUuYXJlYS5oZWlnaHQpO1xuICAgIHRyYWNrLiRpbnRlcmFjdGlvbnNMYXllci5iYXRjaERyYXcoKTtcbiAgfVxuXG4gIG9uS2V5KGUpIHtcbiAgICB0aGlzLnNoaWZ0S2V5ID0gZS5zaGlmdEtleTtcbiAgfVxuXG4gIG9uTW91c2VEb3duKGUpIHtcbiAgICB0aGlzLl9jdXJyZW50VHJhY2sgPSB0aGlzLnRpbWVsaW5lLmdldFRyYWNrRnJvbURPTUVsZW1lbnQoZS5jdXJyZW50VGFyZ2V0KTtcblxuICAgIGlmICghdGhpcy5fY3VycmVudFRyYWNrKSB7IHJldHVybjsgfVxuXG4gICAgdGhpcy5fYWRkQnJ1c2godGhpcy5fY3VycmVudFRyYWNrKTtcblxuICAgIC8vIHJlY3JlYXRlIHRoZSBtYXBcbiAgICB0aGlzLl9sYXllclNlbGVjdGVkSXRlbXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fY3VycmVudFRyYWNrLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgICAgY29uc3QgYXV4ID0gW107XG4gICAgICBsYXllci5zZWxlY3RlZERhdHVtcy5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICBhdXgucHVzaChkYXR1bSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2xheWVyU2VsZWN0ZWRJdGVtc01hcC5zZXQobGF5ZXIsIGF1eC5zbGljZSgwKSk7XG4gICAgfSk7XG4gIH1cblxuICBvbk1vdXNlTW92ZShlKSB7XG4gICAgY29uc29sZS5sb2coZS5hcmVhKTtcbiAgICBcbiAgICB0aGlzLl91cGRhdGVCcnVzaChlLCB0aGlzLl9jdXJyZW50VHJhY2spO1xuXG4gICAgdGhpcy5fY3VycmVudFRyYWNrLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IGxheWVyLnNlbGVjdGVkRGF0dW1zO1xuICAgICAgY29uc3QgY3VycmVudEl0ZW1zID0gbGF5ZXIuZ2V0RGF0dW1zSW5BcmVhKGUuYXJlYSk7XG5cbiAgICAgIC8vIGlmIGlzIG5vdCBwcmVzc2VkXG4gICAgICBpZiAoIWUub3JpZ2luYWxFdmVudC5zaGlmdEtleSkge1xuICAgICAgICBsYXllci51bnNlbGVjdChjdXJyZW50U2VsZWN0aW9uKTtcbiAgICAgICAgbGF5ZXIuc2VsZWN0KGN1cnJlbnRJdGVtcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0b1NlbGVjdCA9IFtdO1xuICAgICAgICBjb25zdCB0b1Vuc2VsZWN0ID0gW107XG4gICAgICAgIC8vIHVzZSB0aGUgc2VsZWN0aW9uIGZyb20gdGhlIHByZXZpb3VzIGRyYWdcbiAgICAgICAgY29uc3QgcHJldmlvdXNTZWxlY3Rpb24gPSB0aGlzLl9sYXllclNlbGVjdGVkSXRlbXNNYXAuZ2V0KGxheWVyKTtcbiAgICAgICAgLy8gdG9VbnNlbGVjdCA9IHRvVW5zZWxlY3QuY29uY2F0KHByZXZpb3VzU2VsZWN0ZWRJdGVtcyk7XG5cbiAgICAgICAgY3VycmVudEl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICBpZiAocHJldmlvdXNTZWxlY3Rpb24uaW5kZXhPZihpdGVtKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRvU2VsZWN0LnB1c2goaXRlbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvVW5zZWxlY3QucHVzaChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGN1cnJlbnRTZWxlY3Rpb24uZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGN1cnJlbnRJdGVtcy5pbmRleE9mKGl0ZW0pID09PSAtMSAmJlxuICAgICAgICAgICAgcHJldmlvdXNTZWxlY3Rpb24uaW5kZXhPZihpdGVtKSA9PT0gLTFcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRvVW5zZWxlY3QucHVzaChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxheWVyLnVuc2VsZWN0KHRvVW5zZWxlY3QpO1xuICAgICAgICBsYXllci5zZWxlY3QodG9TZWxlY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgb25Nb3VzZVVwKGUpIHtcbiAgICB0aGlzLl9yZW1vdmVCcnVzaCh0aGlzLl9jdXJyZW50VHJhY2spO1xuICB9XG5cbiAgb25DbGljayhlKSB7XG4gICAgaWYgKCF0aGlzLl9jdXJyZW50VHJhY2spIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLl9jdXJyZW50VHJhY2subGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiB7XG4gICAgICBjb25zdCBzaGFwZSA9IGUudGFyZ2V0LnNoYXBlO1xuICAgICAgY29uc3QgZGF0dW0gPSBsYXllci5nZXREYXR1bUZyb21TaGFwZShzaGFwZSk7XG5cbiAgICAgIGlmICghZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgIGxheWVyLnVuc2VsZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXR1bSkge1xuICAgICAgICBsYXllci50b2dnbGVTZWxlY3Rpb24oW2RhdHVtXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlU3RhdGUgZnJvbSAnLi9iYXNlLXN0YXRlJztcbmltcG9ydCBLb252YSBmcm9tICdrb252YSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYXBlSW5zZXJ0aW9uU3RhdGUgZXh0ZW5kcyBCYXNlU3RhdGUge1xuXG4gIGNvbnN0cnVjdG9yKHRpbWVsaW5lIC8qLCBvcHRpb25zID0ge30gKi8pIHtcbiAgICBzdXBlcih0aW1lbGluZSAvKiwgb3B0aW9ucyAqLyk7XG5cbiAgICB0aGlzLl9sYXllclNlbGVjdGVkSXRlbXNNYXAgPSBuZXcgTWFwKCk7XG5cbiAgICB0aGlzLnNoaWZ0S2V5ID0gZmFsc2U7XG5cbiAgICB0aGlzLndhc01vdmluZyA9IGZhbHNlO1xuICB9XG5cbiAgc2V0IHRhcmdldExheWVyKGxheWVyKSB7XG4gICAgdGhpcy5fbGF5ZXIgPSBsYXllcjtcbiAgfVxuXG4gIGdldCB0YXJnZXRMYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5fbGF5ZXI7XG4gIH1cblxuICBlbnRlcigpIHtcbiAgICAvLyBUT0RPXG4gIH1cblxuICBleGl0KCkge1xuICAgIC8vIFRPRE9cbiAgICBjb25zdCBjb250YWluZXJzID0gdGhpcy50aW1lbGluZS5jb250YWluZXJzO1xuXG4gICAgZm9yIChsZXQgaWQgaW4gY29udGFpbmVycykge1xuICAgICAgdGhpcy5fcmVtb3ZlQnJ1c2goY29udGFpbmVyc1tpZF0pO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgdGhpcy5vbk1vdXNlRG93bihlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICB0aGlzLm9uTW91c2VNb3ZlKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgICB0aGlzLm9uTW91c2VVcChlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjbGljayc6XG4gICAgICAgIHRoaXMub25DbGljayhlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdrZXlkb3duJzpcbiAgICAgICAgdGhpcy5vbktleShlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdrZXl1cCc6XG4gICAgICAgIHRoaXMub25LZXkoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIF9hZGRCcnVzaCh0cmFjaykge1xuICAgIGlmICh0cmFjay4kYnJ1c2gpIHsgcmV0dXJuOyB9XG5cbiAgICBjb25zdCBicnVzaCA9IG5ldyBLb252YS5SZWN0KHt9KTtcbiAgICBicnVzaC5maWxsKCcjNjg2ODY4Jykub3BhY2l0eSgwLjUpO1xuXG4gICAgdHJhY2suJGludGVyYWN0aW9uc0xheWVyLmFkZChicnVzaCk7XG4gICAgdHJhY2suJGludGVyYWN0aW9uc0xheWVyLm1vdmVUb1RvcCgpO1xuXG4gICAgdHJhY2suJGJydXNoID0gYnJ1c2g7XG5cbiAgICB0cmFjay4kaW50ZXJhY3Rpb25zTGF5ZXIuYmF0Y2hEcmF3KCk7XG4gIH1cblxuICBfcmVtb3ZlQnJ1c2godHJhY2spIHtcbiAgICBpZiAodHJhY2suJGJydXNoID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLl9yZXNldEJydXNoKHRyYWNrKTtcblxuICAgIHRyYWNrLiRicnVzaC5kZXN0cm95KCk7XG5cbiAgICB0cmFjay4kaW50ZXJhY3Rpb25zTGF5ZXIuYmF0Y2hEcmF3KCk7XG5cbiAgICBkZWxldGUgdHJhY2suJGJydXNoO1xuICB9XG5cbiAgX3Jlc2V0QnJ1c2godHJhY2spIHtcbiAgICBjb25zdCAkYnJ1c2ggPSB0cmFjay4kYnJ1c2g7XG4gICAgLy8gcmVzZXQgYnJ1c2ggZWxlbWVudFxuICAgICRicnVzaC54KDApLnkoMCkud2lkdGgoMCkuaGVpZ2h0KDApO1xuICAgIHRyYWNrLiRpbnRlcmFjdGlvbnNMYXllci5iYXRjaERyYXcoKTtcbiAgfVxuXG4gIF91cGRhdGVCcnVzaChlLCB0cmFjaykge1xuICAgIGNvbnN0ICRicnVzaCA9IHRyYWNrLiRicnVzaDtcblxuICAgICRicnVzaC54KGUuYXJlYS5sZWZ0KS55KDApLndpZHRoKGUuYXJlYS53aWR0aCkuaGVpZ2h0KHRyYWNrLmhlaWdodCk7XG4gICAgdHJhY2suJGludGVyYWN0aW9uc0xheWVyLmJhdGNoRHJhdygpO1xuICB9XG5cbiAgb25LZXkoZSkge1xuICAgIHRoaXMuc2hpZnRLZXkgPSBlLnNoaWZ0S2V5O1xuICB9XG5cbiAgb25Nb3VzZURvd24oZSkge1xuICAgIHRoaXMuX2N1cnJlbnRUcmFjayA9IHRoaXMudGltZWxpbmUuZ2V0VHJhY2tGcm9tRE9NRWxlbWVudChlLmN1cnJlbnRUYXJnZXQpO1xuXG4gICAgaWYgKCF0aGlzLl9jdXJyZW50VHJhY2spIHsgcmV0dXJuOyB9XG5cbiAgICB0aGlzLl9hZGRCcnVzaCh0aGlzLl9jdXJyZW50VHJhY2spO1xuXG4gICAgLy8gcmVjcmVhdGUgdGhlIG1hcFxuICAgIHRoaXMuX2xheWVyU2VsZWN0ZWRJdGVtc01hcCA9IG5ldyBNYXAoKTtcbiAgICBcbiAgICB0aGlzLl9jdXJyZW50VHJhY2subGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiB7XG4gICAgICBcbiAgICAgIGlmICghZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgIGNvbnN0IGF1eCA9IG5ldyBTZXQobGF5ZXIuc2VsZWN0ZWREYXR1bXMpO1xuICAgICAgICBsYXllci51bnNlbGVjdChhdXgpO1xuICAgICAgICBsYXllci51cGRhdGVTaGFwZXMoYXV4KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbGF5ZXJTZWxlY3RlZEl0ZW1zTWFwLnNldChsYXllciwgbmV3IFNldChsYXllci5zZWxlY3RlZERhdHVtcykpO1xuICAgICAgXG4gICAgfSk7XG4gIH1cblxuICBvbk1vdXNlTW92ZShlKSB7XG5cbiAgICB0aGlzLndhc01vdmluZyA9IHRydWU7XG5cbiAgICBlLmFyZWEgPSB7bGVmdDogZS5hcmVhLmxlZnQsIHdpZHRoOmUuYXJlYS53aWR0aCwgdG9wOiAwLCBoZWlnaHQ6IHRoaXMuX2N1cnJlbnRUcmFjay5oZWlnaHQgfTtcbiAgICBcbiAgICB0aGlzLl91cGRhdGVCcnVzaChlLCB0aGlzLl9jdXJyZW50VHJhY2spO1xuXG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XG5cbiAgICB0aGlzLl9jdXJyZW50VHJhY2subGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50U2VsZWN0aW9uID0gbGF5ZXIuc2VsZWN0ZWREYXR1bXM7XG4gICAgICBjb25zdCBkYXR1bXNJbkFyZWEgPSBsYXllci5nZXREYXR1bXNJbkFyZWEoZS5hcmVhKTtcblxuICAgICAgdmFyIHRvU2VsZWN0O1xuICAgICAgdmFyIHRvVW5zZWxlY3Q7XG5cbiAgICAgIC8vIGlmIGlzIG5vdCBwcmVzc2VkXG4gICAgICBpZiAoIWUub3JpZ2luYWxFdmVudC5zaGlmdEtleSkgeyAgICAgICAgXG5cbiAgICAgICAgdG9VbnNlbGVjdCA9IG5ldyBTZXQoY3VycmVudFNlbGVjdGlvbik7XG4gICAgICAgIHRvU2VsZWN0ID0gbmV3IFNldChkYXR1bXNJbkFyZWEpO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHRvU2VsZWN0ID0gbmV3IFNldCgpO1xuICAgICAgICB0b1Vuc2VsZWN0ID0gbmV3IFNldCgpO1xuICAgICAgICAvLyB1c2UgdGhlIHNlbGVjdGlvbiBmcm9tIHRoZSBwcmV2aW91cyBkcmFnXG4gICAgICAgIGNvbnN0IHByZXZpb3VzU2VsZWN0aW9uID0gdGhpcy5fbGF5ZXJTZWxlY3RlZEl0ZW1zTWFwLmdldChsYXllcik7XG4gICAgICAgIFxuXG4gICAgICAgIGRhdHVtc0luQXJlYS5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICAgIGlmICghcHJldmlvdXNTZWxlY3Rpb24uaGFzKGRhdHVtKSkge1xuICAgICAgICAgICAgdG9TZWxlY3QuYWRkKGRhdHVtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9VbnNlbGVjdC5hZGQoZGF0dW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY3VycmVudFNlbGVjdGlvbi5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICAgIGlmICghZGF0dW1zSW5BcmVhLmhhcyhkYXR1bSkgJiYgIXByZXZpb3VzU2VsZWN0aW9uLmhhcyhkYXR1bSkpIHtcbiAgICAgICAgICAgIHRvVW5zZWxlY3QuYWRkKGRhdHVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByZXZpb3VzU2VsZWN0aW9uLmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICAgICAgaWYgKCFkYXR1bXNJbkFyZWEuaGFzKGRhdHVtKSkge1xuICAgICAgICAgICAgdG9TZWxlY3QuYWRkKGRhdHVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICB9XG5cbiAgICAgIGxheWVyLnVuc2VsZWN0KHRvVW5zZWxlY3QpO1xuICAgICAgbGF5ZXIuc2VsZWN0KHRvU2VsZWN0KTtcblxuICAgICAgbGF5ZXIudXBkYXRlU2hhcGVzKGN1cnJlbnRTZWxlY3Rpb24pO1xuICAgICAgbGF5ZXIudXBkYXRlU2hhcGVzKGRhdHVtc0luQXJlYSk7XG4gICAgfSk7XG4gIH1cblxuICBvbk1vdXNlVXAoZSkge1xuICAgIHRoaXMuX3JlbW92ZUJydXNoKHRoaXMuX2N1cnJlbnRUcmFjayk7XG4gICAgaWYgKHRoaXMud2FzTW92aW5nKSB7XG4gICAgICB0aGlzLndhc01vdmluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIG9uQ2xpY2soZSkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdjbGljaycpO1xuICAgIGlmICghdGhpcy5fY3VycmVudFRyYWNrKSB7IHJldHVybjsgfVxuICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xuXG4gICAgdGhpcy5fY3VycmVudFRyYWNrLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuXG4gICAgICBjb25zdCBzaGFwZSA9IGUudGFyZ2V0LnNoYXBlO1xuICAgICAgY29uc3QgZGF0dW0gPSBsYXllci5nZXREYXR1bUZyb21TaGFwZShzaGFwZSk7XG4gICAgICB2YXIgdG9VcGRhdGUgPSBuZXcgU2V0KCk7XG5cbiAgICAgIC8vVE9ETzogY29ycmVjdCB0aGlzIGJlY2F1c2UgaXQgaXMgbm90IHdvcmtpbmcgYXMgSSBleHBlY3RlZCB0by4gIFxuICAgICAgaWYgKCFlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgdG9VcGRhdGUgPSBuZXcgU2V0KGxheWVyLnNlbGVjdGVkRGF0dW1zKTtcbiAgICAgICAgbGF5ZXIudW5zZWxlY3QobGF5ZXIuc2VsZWN0ZWREYXR1bXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0dW0pIHtcbiAgICAgICAgdG9VcGRhdGUuYWRkKGRhdHVtKTtcbiAgICAgICAgbGF5ZXIudG9nZ2xlU2VsZWN0aW9uKFtkYXR1bV0pO1xuICAgICAgfVxuXG4gICAgICBsYXllci51cGRhdGVTaGFwZXModG9VcGRhdGUpO1xuXG4gICAgfSk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcbmltcG9ydCBCYXNlU3RhdGUgZnJvbSAnLi9iYXNlLXN0YXRlJztcblxuXG4vKipcbiAqIEEgc3RhdGUgdG8gc2VsZWN0IGFuZCBlZGl0IHNoYXBlcyBpbiBhIHNpbXBsZSB3YXkuIChraW5kIG9mIHBsdWcgbiBwbGF5IHN0YXRlKVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaW1wbGVFZGl0aW9uU3RhdGUgZXh0ZW5kcyBCYXNlU3RhdGUge1xuICBjb25zdHJ1Y3Rvcih0aW1lbGluZSkge1xuICAgIHN1cGVyKHRpbWVsaW5lKTtcblxuICAgIHRoaXMuY3VycmVudEVkaXRlZExheWVyID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICB9XG5cbiAgZW50ZXIoKSB7fVxuICBleGl0KCkge1xuICAgIHRoaXMuY3VycmVudEVkaXRlZExheWVyID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICB9XG5cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgICB0aGlzLm9uTW91c2VEb3duKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmUoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICAgIHRoaXMub25Nb3VzZVVwKGUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBvbk1vdXNlRG93bihlKSB7XG4gICAgLy8gVE9ETzogYWxsb3cgc2hhcGVzIGZyb20gbXVsdGlwbGUgbGF5ZXJzIHRvIGJlIGVkaXRlZCBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIC8vIFRPRE86IG1vdmUgdGFyZ2V0IHNoYXBlcyB0byB0aGUgZHJhZyBrb252YSBsYXllciBvZiBlYWNoIGxheWVyLlxuXG4gICAgLy8ga2VlcCB0YXJnZXQgY29uc2lzdGVudCB3aXRoIG1vdXNlIGRvd25cbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBlLnRhcmdldDtcblxuICAgIGlmICh0aGlzLmN1cnJlbnRUYXJnZXQuc2hhcGUgJiYgdGhpcy5jdXJyZW50VGFyZ2V0LnNoYXBlLmlzQ29udGV4dFNoYXBlKSB7XG4gICAgICBpZiAoIWUub3JpZ2luYWxFdmVudC5zaGlmdEtleSkgXG4gICAgICAgIHRoaXMudGltZWxpbmUuZ2V0VHJhY2tGcm9tRE9NRWxlbWVudChlLmN1cnJlbnRUYXJnZXQpLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgICAgICAgIGNvbnN0IGF1eCA9IG5ldyBTZXQobGF5ZXIuc2VsZWN0ZWREYXR1bXMpO1xuICAgICAgICAgIGxheWVyLnVuc2VsZWN0KGxheWVyLnNlbGVjdGVkRGF0dW1zKTtcbiAgICAgICAgICBsYXllci51cGRhdGVTaGFwZXMoYXV4KTtcbiAgICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICghdGhpcy5jdXJyZW50VGFyZ2V0LnNoYXBlKSB7XG4gICAgICBpZiAoIWUub3JpZ2luYWxFdmVudC5zaGlmdEtleSkgXG4gICAgICAgIHRoaXMudGltZWxpbmUuZ2V0VHJhY2tGcm9tRE9NRWxlbWVudChlLmN1cnJlbnRUYXJnZXQpLmxheWVycy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgICAgICAgIGNvbnN0IGF1eCA9IG5ldyBTZXQobGF5ZXIuc2VsZWN0ZWREYXR1bXMpO1xuICAgICAgICAgIGxheWVyLnVuc2VsZWN0KGxheWVyLnNlbGVjdGVkRGF0dW1zKTtcbiAgICAgICAgICBsYXllci51cGRhdGVTaGFwZXMoYXV4KTtcbiAgICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmN1cnJlbnRUYXJnZXQuc2hhcGUubGF5ZXI7XG5cbiAgICBjb25zdCBhID0gbmV3IFNldChsYXllci5zZWxlY3RlZERhdHVtcyk7XG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5jdXJyZW50VGFyZ2V0LnNoYXBlLmxheWVyKSB7XG4gICAgICBpZiAoIWUub3JpZ2luYWxFdmVudC5zaGlmdEtleSkge1xuICAgICAgICB0aGlzLnRpbWVsaW5lLmdldFRyYWNrRnJvbURPTUVsZW1lbnQoZS5jdXJyZW50VGFyZ2V0KS5sYXllcnMuZm9yRWFjaCgobGF5ZXIpID0+IGxheWVyLnVuc2VsZWN0KGxheWVyLnNlbGVjdGVkRGF0dW1zKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmN1cnJlbnRFZGl0ZWRMYXllciA9IGxheWVyO1xuICAgICAgY29uc3QgZGF0dW0gPSBsYXllci5nZXREYXR1bUZyb21TaGFwZSh0aGlzLmN1cnJlbnRUYXJnZXQuc2hhcGUpO1xuICAgICAgaWYgKGRhdHVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGF5ZXIuc2VsZWN0KFtkYXR1bV0pO1xuICAgICAgICBhLmFkZChkYXR1bSk7XG4gICAgICB9XG4gICAgICBsYXllci51cGRhdGVTaGFwZXMoYSk7XG4gICAgICB0aGlzLmN1cnJlbnRFZGl0ZWRMYXllci5zZWxlY3RlZERhdHVtcy5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICB0aGF0LmN1cnJlbnRFZGl0ZWRMYXllci5nZXRTaGFwZUZyb21EYXR1bShkYXR1bSkuc3RhcnREcmFnKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgIGxheWVyLnVuc2VsZWN0KGxheWVyLnNlbGVjdGVkRGF0dW1zKTtcbiAgICAgIGxheWVyLnVwZGF0ZVNoYXBlcyhhKTtcbiAgICAgIHRoaXMuY3VycmVudEVkaXRlZExheWVyLnNlbGVjdGVkRGF0dW1zLmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICAgIHRoYXQuY3VycmVudEVkaXRlZExheWVyLmdldFNoYXBlRnJvbURhdHVtKGRhdHVtKS5zdGFydERyYWcoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIG9uTW91c2VNb3ZlKGUpIHtcbiAgICAvLyBUT0RPOiBhbGxvdyBzaGFwZXMgZnJvbSBtdWx0aXBsZSBsYXllcnMgdG8gYmUgZWRpdGVkIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgLy8gVE9ETzogbW92ZSB0YXJnZXQgc2hhcGVzIHRvIHRoZSBkcmFnIGtvbnZhIGxheWVyIG9mIGVhY2ggbGF5ZXIuXG5cbiAgICBpZiAoIXRoaXMuY3VycmVudEVkaXRlZExheWVyKSB7IHJldHVybjsgfVxuXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmN1cnJlbnRFZGl0ZWRMYXllcjtcbiAgICBjb25zdCBkYXR1bXMgPSBsYXllci5zZWxlY3RlZERhdHVtcztcblxuICAgIGxheWVyLmVkaXQoZGF0dW1zLCBlLmR4LCBlLmR5LCB0aGlzLmN1cnJlbnRUYXJnZXQpO1xuICAgIGxheWVyLnVwZGF0ZVNoYXBlcyhkYXR1bXMpO1xuICB9XG5cbiAgb25Nb3VzZVVwKGUpIHtcbiAgICAvLyBUT0RPOiBhbGxvdyBzaGFwZXMgZnJvbSBtdWx0aXBsZSBsYXllcnMgdG8gYmUgZWRpdGVkIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgLy8gVE9ETzogdXNlIExheWVyLmFsbG9jYXRlU2hhcGVzVG9Db250ZW50TGF5ZXJzIHRvIG1vdmUgdGhlIHRhcmdldCBzaGFwZXMgZnJvbSB0aGUgZHJhZyBrb252YSBsYXllcnMgdG8gYSBjb250ZW50IGtvbnZhIGxheWVyLlxuXG4gICAgY29uc3QgdGhhdCA9IHRoaXM7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmN1cnJlbnRFZGl0ZWRMYXllcjtcblxuICAgIGlmICghbGF5ZXIpIHJldHVybjtcblxuICAgIGxheWVyLnVwZGF0ZVNoYXBlcyhsYXllci5zZWxlY3RlZERhdHVtcyk7XG4gICAgbGF5ZXIuc2VsZWN0ZWREYXR1bXMuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgIGxheWVyLmdldFNoYXBlRnJvbURhdHVtKGRhdHVtKS5zdG9wRHJhZygpO1xuICAgIH0pO1xuICAgIHRoaXMuY3VycmVudEVkaXRlZExheWVyID0gbnVsbDtcbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQge1xuICBwYWRMZWZ0KGlucHV0LCBzaWduLCBsZW5ndGgpIHtcbiAgICBpbnB1dCArPSAnJztcbiAgICB3aGlsZSAoaW5wdXQubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICBpbnB1dCA9IHNpZ24gKyBpbnB1dDtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE9ydGhvZ29uYWxEYXRhIHRyYW5zZm9ybXMgYW4gb2JqZWN0IG9mIGFycmF5cyBge2ZvbzogWzEsIDJdLCBiYXI6IFszLCA0XX1gXG4gKiB0byBvciBmcm9tIGFuIGFycmF5IG9mIG9iamVjdHMgYFt7Zm9vOiAxLCBiYXI6IDN9LCB7Zm9vOiAyLCBiYXI6IDR9XWBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3J0aG9nb25hbERhdGEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9jb2xzID0gbnVsbDsgLy8gT2JqZWN0IG9mIGFycmF5c1xuICAgIHRoaXMuX3Jvd3MgPSBudWxsOyAvLyBBcnJheSBvZiBvYmplY3RzXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgdGhlIGNvbnNpc3RlbmN5IG9mIHRoZSBkYXRhLlxuICAgKi9cbiAgX2NoZWNrQ29uc2lzdGVuY3koKSB7XG4gICAgbGV0IHNpemUgPSBudWxsO1xuXG4gICAgZm9yIChsZXQga2V5IGluIHRoaXMuX2NvbHMpIHtcbiAgICAgIGNvbnN0IGNvbCA9IHRoaXMuX2NvbHNba2V5XTtcbiAgICAgIGNvbnN0IGNvbExlbmd0aCA9IGNvbC5sZW5ndGg7XG5cbiAgICAgIGlmIChzaXplICE9PSBudWxsICYmIHNpemUgIT09IGNvbExlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5wcm90b3R5cGUuY29uc3RydWN0b3IubmFtZX06IGluY29uc2lzdGVudCBkYXRhYCk7XG4gICAgICB9IGVsc2UgaWYgKHNpemUgPT09IG51bGwpIHtcbiAgICAgICAgc2l6ZSA9IGNvbExlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBhcnJheSBvZiBvYmplY3RzIGZyb20gb2JqZWN0IG9mIGFycmF5cy5cbiAgICovXG4gIHVwZGF0ZUZyb21Db2xzKCkge1xuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5fY29scyk7XG5cbiAgICBrZXlzLmZvckVhY2goKGtleSwgaSkgPT4ge1xuICAgICAgY29uc3QgY29sID0gdGhpcy5fY29sc1trZXldO1xuXG4gICAgICBjb2wuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9yb3dzW2luZGV4XSA9PT0gdW5kZWZpbmVkKSB0aGlzLl9yb3dzW2luZGV4XSA9IHt9O1xuICAgICAgICB0aGlzLl9yb3dzW2luZGV4XVtrZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2NoZWNrQ29uc2lzdGVuY3koKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIG9iamVjdCBvZiBhcnJheXMgZnJvbSBhcnJheSBvZiBvYmplY3RzLlxuICAgKi9cbiAgdXBkYXRlRnJvbVJvd3MoKSB7XG4gICAgdGhpcy5fcm93cy5mb3JFYWNoKChvYmosIGluZGV4KSA9PiB7XG4gICAgICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkgdGhpcy5fY29sc1trZXldID0gW107XG4gICAgICAgIHRoaXMuX2NvbHNba2V5XS5wdXNoKG9ialtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX2NoZWNrQ29uc2lzdGVuY3koKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIG9iamVjdCBvZiBhcnJheXMuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3Q8U3RyaW5nLCBBcnJheT59XG4gICAqL1xuICBzZXQgY29scyhvYmopIHtcbiAgICB0aGlzLl9jb2xzID0gb2JqO1xuICAgIHRoaXMuX3Jvd3MgPSBbXTtcblxuICAgIHRoaXMudXBkYXRlRnJvbUNvbHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCBvZiBhcnJheXMuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3Q8U3RyaW5nLCBBcnJheT59XG4gICAqL1xuICBnZXQgY29scygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29scztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTxPYmplY3Q+fVxuICAgKi9cbiAgc2V0IHJvd3MoYXJyKSB7XG4gICAgdGhpcy5fcm93cyA9IGFycjtcbiAgICB0aGlzLl9jb2xzID0ge307XG5cbiAgICB0aGlzLnVwZGF0ZUZyb21Sb3dzKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzLlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8T2JqZWN0Pn1cbiAgICovXG4gIGdldCByb3dzKCkge1xuICAgIHJldHVybiB0aGlzLl9yb3dzO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbGluZWFyKCkge1xuICAgIGxldCBfZG9tYWluID0gWzAsIDFdO1xuICAgIGxldCBfcmFuZ2UgPSBbMCwgMV07XG5cbiAgICBsZXQgX3Nsb3BlID0gMTtcbiAgICBsZXQgX2ludGVyY2VwdCA9IDA7XG5cbiAgICBmdW5jdGlvbiBfdXBkYXRlQ29lZnMoKSB7XG4gICAgICBfc2xvcGUgPSAoX3JhbmdlWzFdIC0gX3JhbmdlWzBdKSAvIChfZG9tYWluWzFdIC0gX2RvbWFpblswXSk7XG4gICAgICBfaW50ZXJjZXB0ID0gX3JhbmdlWzBdIC0gKF9zbG9wZSAqIF9kb21haW5bMF0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYWxlICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIChfc2xvcGUgKiB2YWx1ZSkgKyBfaW50ZXJjZXB0O1xuICAgIH1cblxuICAgIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKHZhbHVlIC0gX2ludGVyY2VwdCkgLyBfc2xvcGU7XG4gICAgfTtcblxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKGFyciA9IG51bGwpIHtcbiAgICAgIGlmIChhcnIgPT09IG51bGwpIHsgcmV0dXJuIF9kb21haW47IH1cblxuICAgICAgX2RvbWFpbiA9IGFycjtcbiAgICAgIF91cGRhdGVDb2VmcygpO1xuXG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcblxuICAgIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oYXJyID0gbnVsbCkge1xuICAgICAgaWYgKGFyciA9PT0gbnVsbCkgeyByZXR1cm4gX3JhbmdlOyB9XG5cbiAgICAgIF9yYW5nZSA9IGFycjtcbiAgICAgIF91cGRhdGVDb2VmcygpO1xuXG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcblxuICAgIHJldHVybiBzY2FsZTtcbiAgfVxufTtcbiIsIi8vIGF4aXNcbmltcG9ydCBBeGlzTGF5ZXIgZnJvbSAnLi9heGlzL2F4aXMtbGF5ZXInO1xuaW1wb3J0IHRpbWVBeGlzR2VuZXJhdG9yIGZyb20gJy4vYXhpcy90aW1lLWF4aXMtZ2VuZXJhdG9yJztcbmltcG9ydCBncmlkQXhpc0dlbmVyYXRvciBmcm9tICcuL2F4aXMvZ3JpZC1heGlzLWdlbmVyYXRvcic7XG5cbi8vIGJlaGF2aW9yc1xuaW1wb3J0IEJhc2VCZWhhdmlvciBmcm9tICcuL2JlaGF2aW9ycy9iYXNlLWJlaGF2aW9yJztcbmltcG9ydCBCZWF0R3JpZFNuYXBTZWdtZW50QmVoYXZpb3IgZnJvbSAnLi9iZWhhdmlvcnMvYmVhdC1ncmlkLXNuYXAtc2VnbWVudC1iZWhhdmlvcic7XG5pbXBvcnQgQnJlYWtwb2ludEJlaGF2aW9yIGZyb20gJy4vYmVoYXZpb3JzL2JyZWFrcG9pbnQtYmVoYXZpb3InO1xuaW1wb3J0IE1hcmtlckJlaGF2aW9yIGZyb20gJy4vYmVoYXZpb3JzL21hcmtlci1iZWhhdmlvcic7XG5pbXBvcnQgU2Nyb2xsU2VnbWVudEJlaGF2aW9yIGZyb20gJy4vYmVoYXZpb3JzL3Njcm9sbC1zZWdtZW50LWJlaGF2aW9yJztcbmltcG9ydCBTZWdtZW50QmVoYXZpb3IgZnJvbSAnLi9iZWhhdmlvcnMvc2VnbWVudC1iZWhhdmlvcic7XG5pbXBvcnQgU2libGluZ0xvY2tlZFNlZ21lbnRCZWhhdmlvciBmcm9tICcuL2JlaGF2aW9ycy9zaWJsaW5nLWxvY2tlZC1zZWdtZW50LWJlaGF2aW9yJztcbmltcG9ydCBTaW1wbGVTbmFwU2VnbWVudEJlaGF2aW9yIGZyb20gJy4vYmVoYXZpb3JzL3NpbXBsZS1zbmFwLXNlZ21lbnQtYmVoYXZpb3InO1xuaW1wb3J0IFRpbWVDb250ZXh0QmVoYXZpb3IgZnJvbSAnLi9iZWhhdmlvcnMvdGltZS1jb250ZXh0LWJlaGF2aW9yJztcbmltcG9ydCBUcmFjZUJlaGF2aW9yIGZyb20gJy4vYmVoYXZpb3JzL3RyYWNlLWJlaGF2aW9yJztcbmltcG9ydCBXYXZlZm9ybUJlaGF2aW9yIGZyb20gJy4vYmVoYXZpb3JzL3dhdmVmb3JtLWJlaGF2aW9yJztcbmltcG9ydCBOb0JlaGF2aW9yIGZyb20gJy4vYmVoYXZpb3JzL25vLWJlaGF2aW9yJztcblxuLy8gY29yZVxuaW1wb3J0IExheWVyVGltZUNvbnRleHQgZnJvbSAnLi9jb3JlL2xheWVyLXRpbWUtY29udGV4dCc7XG5pbXBvcnQgTGF5ZXIgZnJvbSAnLi9jb3JlL2xheWVyJztcbmltcG9ydCBUaW1lbGluZVRpbWVDb250ZXh0IGZyb20gJy4vY29yZS90aW1lbGluZS10aW1lLWNvbnRleHQnO1xuaW1wb3J0IFRpbWVsaW5lIGZyb20gJy4vY29yZS90aW1lbGluZSc7XG5pbXBvcnQgVHJhY2tDb2xsZWN0aW9uIGZyb20gJy4vY29yZS90cmFjay1jb2xsZWN0aW9uJztcbmltcG9ydCBUcmFjayBmcm9tICcuL2NvcmUvdHJhY2snO1xuXG4vLyBoZWxwZXJzXG5pbXBvcnQgQW5ub3RhdGVkTWFya2VyTGF5ZXIgZnJvbSAnLi9oZWxwZXJzL2Fubm90YXRlZC1tYXJrZXItbGF5ZXInO1xuaW1wb3J0IEFubm90YXRlZFNlZ21lbnRMYXllciBmcm9tICcuL2hlbHBlcnMvYW5ub3RhdGVkLXNlZ21lbnQtbGF5ZXInO1xuaW1wb3J0IEJyZWFrcG9pbnRMYXllciBmcm9tICcuL2hlbHBlcnMvYnJlYWtwb2ludC1sYXllcic7XG5pbXBvcnQgQ3Vyc29yTGF5ZXIgZnJvbSAnLi9oZWxwZXJzL2N1cnNvci1sYXllcic7XG5pbXBvcnQgR3JpZEF4aXNMYXllciBmcm9tICcuL2hlbHBlcnMvZ3JpZC1heGlzLWxheWVyJztcbmltcG9ydCBNYXJrZXJMYXllciBmcm9tICcuL2hlbHBlcnMvbWFya2VyLWxheWVyJztcbmltcG9ydCBTZWdtZW50TGF5ZXIgZnJvbSAnLi9oZWxwZXJzL3NlZ21lbnQtbGF5ZXInO1xuaW1wb3J0IFRpY2tMYXllciBmcm9tICcuL2hlbHBlcnMvdGljay1sYXllcic7XG5pbXBvcnQgVGltZUF4aXNMYXllciBmcm9tICcuL2hlbHBlcnMvdGltZS1heGlzLWxheWVyJztcbmltcG9ydCBUcmFjZUxheWVyIGZyb20gJy4vaGVscGVycy90cmFjZS1sYXllcic7XG5pbXBvcnQgV2F2ZWZvcm1MYXllciBmcm9tICcuL2hlbHBlcnMvd2F2ZWZvcm0tbGF5ZXInO1xuaW1wb3J0IEJlYXRHcmlkTGF5ZXIgZnJvbSAnLi9oZWxwZXJzL2JlYXQtZ3JpZC1sYXllcic7XG5pbXBvcnQgU2Nyb2xsZXIgZnJvbSAnLi9oZWxwZXJzL3Njcm9sbGVyJztcblxuLy8gaW50ZXJhY3Rpb25zXG5pbXBvcnQgRXZlbnRTb3VyY2UgZnJvbSAnLi9pbnRlcmFjdGlvbnMvZXZlbnQtc291cmNlJztcbmltcG9ydCBLZXlib2FyZCBmcm9tICcuL2ludGVyYWN0aW9ucy9rZXlib2FyZCc7XG5pbXBvcnQgU3VyZmFjZSBmcm9tICcuL2ludGVyYWN0aW9ucy9rb252YS1zdXJmYWNlJztcbmltcG9ydCBLb252YVdhdmVFdmVudCBmcm9tICcuL2ludGVyYWN0aW9ucy9rb252YS13YXZlLWV2ZW50JztcbmltcG9ydCBXYXZlRXZlbnQgZnJvbSAnLi9pbnRlcmFjdGlvbnMvd2F2ZS1ldmVudCc7XG5cbi8vIHNoYXBlc1xuLy8gaW1wb3J0IEFubm90YXRlZE1hcmtlciBmcm9tICcuL3NoYXBlcy9hbm5vdGF0ZWQtbWFya2VyJztcbmltcG9ydCBBbm5vdGF0ZWRTZWdtZW50IGZyb20gJy4vc2hhcGVzL2Fubm90YXRlZC1zZWdtZW50JztcbmltcG9ydCBCYXNlU2hhcGUgZnJvbSAnLi9zaGFwZXMvYmFzZS1zaGFwZSc7XG5pbXBvcnQgQ3Vyc29yIGZyb20gJy4vc2hhcGVzL2N1cnNvcic7XG5pbXBvcnQgRG90IGZyb20gJy4vc2hhcGVzL2RvdCc7XG5pbXBvcnQgTGluZSBmcm9tICcuL3NoYXBlcy9saW5lJztcbmltcG9ydCBNYXJrZXIgZnJvbSAnLi9zaGFwZXMvbWFya2VyJztcbmltcG9ydCBTZWdtZW50IGZyb20gJy4vc2hhcGVzL3NlZ21lbnQnO1xuaW1wb3J0IFRpY2tzIGZyb20gJy4vc2hhcGVzL3RpY2tzJztcbmltcG9ydCBUcmFjZURvdHMgZnJvbSAnLi9zaGFwZXMvdHJhY2UtZG90cyc7XG5pbXBvcnQgVHJhY2VQYXRoIGZyb20gJy4vc2hhcGVzL3RyYWNlLXBhdGgnO1xuaW1wb3J0IFdhdmVmb3JtIGZyb20gJy4vc2hhcGVzL3dhdmVmb3JtJztcblxuLy8gc3RhdGVzXG5pbXBvcnQgQmFzZVN0YXRlIGZyb20gJy4vc3RhdGVzL2Jhc2Utc3RhdGUnO1xuaW1wb3J0IEJyZWFrcG9pbnRTdGF0ZSBmcm9tICcuL3N0YXRlcy9icmVha3BvaW50LXN0YXRlJztcbmltcG9ydCBCcnVzaFpvb21TdGF0ZSBmcm9tICcuL3N0YXRlcy9icnVzaC16b29tLXN0YXRlJztcbmltcG9ydCBDZW50ZXJlZFpvb21TdGF0ZSBmcm9tICcuL3N0YXRlcy9jZW50ZXJlZC16b29tLXN0YXRlJztcbmltcG9ydCBDZW50ZXJlZFNjcm9sbFN0YXRlIGZyb20gJy4vc3RhdGVzL2NlbnRlcmVkLXNjcm9sbC1zdGF0ZSc7XG5pbXBvcnQgQ29udGV4dEVkaXRpb25TdGF0ZSBmcm9tICcuL3N0YXRlcy9jb250ZXh0LWVkaXRpb24tc3RhdGUnO1xuaW1wb3J0IERyb3BBbmRBZGRTdGF0ZSBmcm9tICcuL3N0YXRlcy9kcm9wLWFuZC1hZGQtc3RhdGUnO1xuaW1wb3J0IEVkaXRpb25TdGF0ZSBmcm9tICcuL3N0YXRlcy9lZGl0aW9uLXN0YXRlJztcbmltcG9ydCBIb3Jpem9udGFsU2VsZWN0aW9uU3RhdGUgZnJvbSAnLi9zdGF0ZXMvaG9yaXpvbnRhbC1zZWxlY3Rpb24tc3RhdGUnO1xuaW1wb3J0IFNlbGVjdGlvblN0YXRlIGZyb20gJy4vc3RhdGVzL3NlbGVjdGlvbi1zdGF0ZSc7XG5pbXBvcnQgU2hhcGVJbnNlcnRpb25TdGF0ZSBmcm9tICcuL3N0YXRlcy9zaGFwZS1pbnNlcnRpb24tc3RhdGUnO1xuaW1wb3J0IFNpbXBsZUVkaXRpb25TdGF0ZSBmcm9tICcuL3N0YXRlcy9zaW1wbGUtZWRpdGlvbi1zdGF0ZSc7XG4vLyBpbXBvcnQgQmVhdEdyaWRFZGl0b3JJbnRlcmFjdGlvbnNTdGF0ZSBmcm9tICcuL3N0YXRlcy9iZWF0LWdyaWQtaW50ZXJhY3Rpb25zLXN0YXRlJztcblxuXG5cbi8vIHV0aWxzXG5pbXBvcnQgZm9ybWF0IGZyb20gJy4vdXRpbHMvZm9ybWF0JztcbmltcG9ydCBPcnRob2dvbmFsRGF0YSBmcm9tICcuL3V0aWxzL29ydGhvZ29uYWwtZGF0YSc7XG5pbXBvcnQgc2NhbGVzIGZyb20gJy4vdXRpbHMvc2NhbGVzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBheGlzOiB7XG4gICAgQXhpc0xheWVyLCB0aW1lQXhpc0dlbmVyYXRvciwgZ3JpZEF4aXNHZW5lcmF0b3IsIFxuICB9LCBcblxuICBiZWhhdmlvcnM6IHtcbiAgICBCYXNlQmVoYXZpb3IsIEJlYXRHcmlkU25hcFNlZ21lbnRCZWhhdmlvciwgXG4gICAgQnJlYWtwb2ludEJlaGF2aW9yLCBNYXJrZXJCZWhhdmlvciwgXG4gICAgU2Nyb2xsU2VnbWVudEJlaGF2aW9yLCBTZWdtZW50QmVoYXZpb3IsIFxuICAgIFNpYmxpbmdMb2NrZWRTZWdtZW50QmVoYXZpb3IsIFNpbXBsZVNuYXBTZWdtZW50QmVoYXZpb3IsIFxuICAgIFRpbWVDb250ZXh0QmVoYXZpb3IsIFRyYWNlQmVoYXZpb3IsIFdhdmVmb3JtQmVoYXZpb3IsIFxuICAgIE5vQmVoYXZpb3IgXG4gIH0sIFxuXG4gIGNvcmU6IHtcbiAgICBMYXllclRpbWVDb250ZXh0LCBMYXllciwgVGltZWxpbmVUaW1lQ29udGV4dCwgVGltZWxpbmUsIFxuICAgIFRyYWNrQ29sbGVjdGlvbiwgVHJhY2ssIFxuICB9LCBcblxuICBoZWxwZXJzOiB7XG4gICAgQW5ub3RhdGVkTWFya2VyTGF5ZXIsIFxuICAgIEFubm90YXRlZFNlZ21lbnRMYXllciwgXG4gICAgQnJlYWtwb2ludExheWVyLCBcbiAgICBDdXJzb3JMYXllciwgXG4gICAgR3JpZEF4aXNMYXllciwgXG4gICAgTWFya2VyTGF5ZXIsIFxuICAgIFNlZ21lbnRMYXllciwgXG4gICAgVGlja0xheWVyLCBcbiAgICBUaW1lQXhpc0xheWVyLCBcbiAgICBUcmFjZUxheWVyLCBcbiAgICBXYXZlZm9ybUxheWVyLCBcbiAgICBCZWF0R3JpZExheWVyLCBcbiAgICBTY3JvbGxlciwgXG4gIH0sXG5cbiAgaW50ZXJhY3Rpb25zOiB7XG4gICAgRXZlbnRTb3VyY2UsIEtleWJvYXJkLCBcbiAgICBTdXJmYWNlLCBLb252YVdhdmVFdmVudCwgV2F2ZUV2ZW50LCBcbiAgfSxcblxuICBzaGFwZXM6IHtcbiAgICAvLyBBbm5vdGF0ZWRNYXJrZXIsIFxuICAgIEFubm90YXRlZFNlZ21lbnQsIEJhc2VTaGFwZSwgQ3Vyc29yLCBcbiAgICBEb3QsIExpbmUsIE1hcmtlciwgU2VnbWVudCwgXG4gICAgVGlja3MsIFRyYWNlRG90cywgVHJhY2VQYXRoLCBXYXZlZm9ybSwgXG4gIH0sXG5cbiAgc3RhdGVzOiB7XG4gICAgQmFzZVN0YXRlLCBCcmVha3BvaW50U3RhdGUsIEJydXNoWm9vbVN0YXRlLCBDZW50ZXJlZFpvb21TdGF0ZSwgXG4gICAgQ2VudGVyZWRTY3JvbGxTdGF0ZSwgQ29udGV4dEVkaXRpb25TdGF0ZSwgRHJvcEFuZEFkZFN0YXRlLCBFZGl0aW9uU3RhdGUsIFxuICAgIFNlbGVjdGlvblN0YXRlLCBIb3Jpem9udGFsU2VsZWN0aW9uU3RhdGUsIFNoYXBlSW5zZXJ0aW9uU3RhdGUsIFNpbXBsZUVkaXRpb25TdGF0ZSwgXG4gIH0sXG5cbiAgdXRpbHM6IHtcbiAgICBmb3JtYXQsIE9ydGhvZ29uYWxEYXRhLCBzY2FsZXMsXG4gIH0gXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9tYXBcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5c1wiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3NldFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2xcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfT2JqZWN0JGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpW1wiZGVmYXVsdFwiXTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcblxuICAgICAgX09iamVjdCRkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSkoKTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpW1wiZGVmYXVsdFwiXTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7XG4gIHZhciBfYWdhaW4gPSB0cnVlO1xuXG4gIF9mdW5jdGlvbjogd2hpbGUgKF9hZ2Fpbikge1xuICAgIHZhciBvYmplY3QgPSBfeCxcbiAgICAgICAgcHJvcGVydHkgPSBfeDIsXG4gICAgICAgIHJlY2VpdmVyID0gX3gzO1xuICAgIF9hZ2FpbiA9IGZhbHNlO1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuICAgIHZhciBkZXNjID0gX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7XG5cbiAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF94ID0gcGFyZW50O1xuICAgICAgICBfeDIgPSBwcm9wZXJ0eTtcbiAgICAgICAgX3gzID0gcmVjZWl2ZXI7XG4gICAgICAgIF9hZ2FpbiA9IHRydWU7XG4gICAgICAgIGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRpbnVlIF9mdW5jdGlvbjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7XG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGdldHRlciA9IGRlc2MuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfT2JqZWN0JGNyZWF0ZSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBfT2JqZWN0JHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKVtcImRlZmF1bHRcIl07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IF9PYmplY3QkY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfT2JqZWN0JHNldFByb3RvdHlwZU9mID8gX09iamVjdCRzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgXCJkZWZhdWx0XCI6IG9ialxuICB9O1xufTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yJyk7IiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm1hcCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcubWFwLnRvLWpzb24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy8kLmNvcmUnKS5NYXA7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLk9iamVjdC5hc3NpZ247IiwidmFyICQgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpe1xuICByZXR1cm4gJC5jcmVhdGUoUCwgRCk7XG59OyIsInZhciAkID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy8kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2Mpe1xuICByZXR1cm4gJC5zZXREZXNjKGl0LCBrZXksIGRlc2MpO1xufTsiLCJ2YXIgJCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIHJldHVybiAkLmdldERlc2MoaXQsIGtleSk7XG59OyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuT2JqZWN0LmtleXM7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy8kLmNvcmUnKS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7IiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy8kLmNvcmUnKS5Qcm9taXNlOyIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvJC5jb3JlJykuU2V0OyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLlN5bWJvbDsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQud2tzJykoJ2l0ZXJhdG9yJyk7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59OyIsIi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciAkICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuLyQudG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vJC5pb2JqZWN0Jyk7XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuZmFpbHMnKShmdW5jdGlvbigpe1xuICB2YXIgYSA9IE9iamVjdC5hc3NpZ25cbiAgICAsIEEgPSB7fVxuICAgICwgQiA9IHt9XG4gICAgLCBTID0gU3ltYm9sKClcbiAgICAsIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihrKXsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gYSh7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cyhhKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCAgICAgPSB0b09iamVjdCh0YXJnZXQpXG4gICAgLCAkJCAgICA9IGFyZ3VtZW50c1xuICAgICwgJCRsZW4gPSAkJC5sZW5ndGhcbiAgICAsIGluZGV4ID0gMVxuICAgICwgZ2V0S2V5cyAgICA9ICQuZ2V0S2V5c1xuICAgICwgZ2V0U3ltYm9scyA9ICQuZ2V0U3ltYm9sc1xuICAgICwgaXNFbnVtICAgICA9ICQuaXNFbnVtO1xuICB3aGlsZSgkJGxlbiA+IGluZGV4KXtcbiAgICB2YXIgUyAgICAgID0gSU9iamVjdCgkJFtpbmRleCsrXSlcbiAgICAgICwga2V5cyAgID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBqICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBqKWlmKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpVFtrZXldID0gU1trZXldO1xuICB9XG4gIHJldHVybiBUO1xufSA6IE9iamVjdC5hc3NpZ247IiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuLyQuY29mJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuLyQud2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLy8gRVMzIHdyb25nIGhlcmVcbiAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IChPID0gT2JqZWN0KGl0KSlbVEFHXSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59OyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgaGlkZSAgICAgICAgID0gcmVxdWlyZSgnLi8kLmhpZGUnKVxuICAsIGN0eCAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5jdHgnKVxuICAsIHNwZWNpZXMgICAgICA9IHJlcXVpcmUoJy4vJC5zcGVjaWVzJylcbiAgLCBzdHJpY3ROZXcgICAgPSByZXF1aXJlKCcuLyQuc3RyaWN0LW5ldycpXG4gICwgZGVmaW5lZCAgICAgID0gcmVxdWlyZSgnLi8kLmRlZmluZWQnKVxuICAsIGZvck9mICAgICAgICA9IHJlcXVpcmUoJy4vJC5mb3Itb2YnKVxuICAsIHN0ZXAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyLXN0ZXAnKVxuICAsIElEICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC51aWQnKSgnaWQnKVxuICAsICRoYXMgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oYXMnKVxuICAsIGlzT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKVxuICAsIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgaXNPYmplY3RcbiAgLCBTVVBQT1JUX0RFU0MgPSByZXF1aXJlKCcuLyQuc3VwcG9ydC1kZXNjJylcbiAgLCBTSVpFICAgICAgICAgPSBTVVBQT1JUX0RFU0MgPyAnX3MnIDogJ3NpemUnXG4gICwgaWQgICAgICAgICAgID0gMDtcblxudmFyIGZhc3RLZXkgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZighaXNPYmplY3QoaXQpKXJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmKCEkaGFzKGl0LCBJRCkpe1xuICAgIC8vIGNhbid0IHNldCBpZCB0byBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBpZFxuICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBvYmplY3QgaWRcbiAgICBoaWRlKGl0LCBJRCwgKytpZCk7XG4gIC8vIHJldHVybiBvYmplY3QgaWQgd2l0aCBwcmVmaXhcbiAgfSByZXR1cm4gJ08nICsgaXRbSURdO1xufTtcblxudmFyIGdldEVudHJ5ID0gZnVuY3Rpb24odGhhdCwga2V5KXtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KSwgZW50cnk7XG4gIGlmKGluZGV4ICE9PSAnRicpcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yKGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgaWYoZW50cnkuayA9PSBrZXkpcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpe1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBpdGVyYWJsZSl7XG4gICAgICBzdHJpY3ROZXcodGhhdCwgQywgTkFNRSk7XG4gICAgICB0aGF0Ll9pID0gJC5jcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAgIC8vIGZpcnN0IGVudHJ5XG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAgICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZXF1aXJlKCcuLyQubWl4JykoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKXtcbiAgICAgICAgZm9yKHZhciB0aGF0ID0gdGhpcywgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYoZW50cnkucCllbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICAgLCBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmKGVudHJ5KXtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5cbiAgICAgICAgICAgICwgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYocHJldilwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmKG5leHQpbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZih0aGF0Ll9mID09IGVudHJ5KXRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmKHRoYXQuX2wgPT0gZW50cnkpdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMylcbiAgICAgICAgICAsIGVudHJ5O1xuICAgICAgICB3aGlsZShlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2Ype1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSl7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYoU1VQUE9SVF9ERVNDKSQuc2V0RGVzYyhDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBkZWZpbmVkKHRoaXNbU0laRV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpe1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSlcbiAgICAgICwgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYoZW50cnkpe1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYoIXRoYXQuX2YpdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYocHJldilwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYoaW5kZXggIT09ICdGJyl0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbihDLCBOQU1FLCBJU19NQVApe1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICByZXF1aXJlKCcuLyQuaXRlci1kZWZpbmUnKShDLCBOQU1FLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gICAgICB0aGlzLl90ID0gaXRlcmF0ZWQ7ICAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7IC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24oKXtcbiAgICAgIHZhciB0aGF0ICA9IHRoaXNcbiAgICAgICAgLCBraW5kICA9IHRoYXQuX2tcbiAgICAgICAgLCBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpe1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJyAsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzcGVjaWVzKEMpO1xuICAgIHNwZWNpZXMocmVxdWlyZSgnLi8kLmNvcmUnKVtOQU1FXSk7IC8vIGZvciB3cmFwcGVyXG4gIH1cbn07IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyIGZvck9mICAgPSByZXF1aXJlKCcuLyQuZm9yLW9mJylcbiAgLCBjbGFzc29mID0gcmVxdWlyZSgnLi8kLmNsYXNzb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSl7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKXtcbiAgICBpZihjbGFzc29mKHRoaXMpICE9IE5BTUUpdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICB2YXIgYXJyID0gW107XG4gICAgZm9yT2YodGhpcywgZmFsc2UsIGFyci5wdXNoLCBhcnIpO1xuICAgIHJldHVybiBhcnI7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCAkZGVmICAgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgaGlkZSAgICAgICA9IHJlcXVpcmUoJy4vJC5oaWRlJylcbiAgLCBmb3JPZiAgICAgID0gcmVxdWlyZSgnLi8kLmZvci1vZicpXG4gICwgc3RyaWN0TmV3ICA9IHJlcXVpcmUoJy4vJC5zdHJpY3QtbmV3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSwgd3JhcHBlciwgbWV0aG9kcywgY29tbW9uLCBJU19NQVAsIElTX1dFQUspe1xuICB2YXIgQmFzZSAgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylbTkFNRV1cbiAgICAsIEMgICAgID0gQmFzZVxuICAgICwgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnXG4gICAgLCBwcm90byA9IEMgJiYgQy5wcm90b3R5cGVcbiAgICAsIE8gICAgID0ge307XG4gIGlmKCFyZXF1aXJlKCcuLyQuc3VwcG9ydC1kZXNjJykgfHwgdHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJ1xuICAgIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFyZXF1aXJlKCcuLyQuZmFpbHMnKShmdW5jdGlvbigpeyBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7IH0pKVxuICApe1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQyA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICByZXF1aXJlKCcuLyQubWl4JykoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICB9IGVsc2Uge1xuICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgaXRlcmFibGUpe1xuICAgICAgc3RyaWN0TmV3KHRhcmdldCwgQywgTkFNRSk7XG4gICAgICB0YXJnZXQuX2MgPSBuZXcgQmFzZTtcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0YXJnZXRbQURERVJdLCB0YXJnZXQpO1xuICAgIH0pO1xuICAgICQuZWFjaC5jYWxsKCdhZGQsY2xlYXIsZGVsZXRlLGZvckVhY2gsZ2V0LGhhcyxzZXQsa2V5cyx2YWx1ZXMsZW50cmllcycuc3BsaXQoJywnKSxmdW5jdGlvbihLRVkpe1xuICAgICAgdmFyIGNoYWluID0gS0VZID09ICdhZGQnIHx8IEtFWSA9PSAnc2V0JztcbiAgICAgIGlmKEtFWSBpbiBwcm90byAmJiAhKElTX1dFQUsgJiYgS0VZID09ICdjbGVhcicpKWhpZGUoQy5wcm90b3R5cGUsIEtFWSwgZnVuY3Rpb24oYSwgYil7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9jW0tFWV0oYSA9PT0gMCA/IDAgOiBhLCBiKTtcbiAgICAgICAgcmV0dXJuIGNoYWluID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmKCdzaXplJyBpbiBwcm90bykkLnNldERlc2MoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5fYy5zaXplO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmVxdWlyZSgnLi8kLnRhZycpKEMsIE5BTUUpO1xuXG4gIE9bTkFNRV0gPSBDO1xuICAkZGVmKCRkZWYuRyArICRkZWYuVyArICRkZWYuRiwgTyk7XG5cbiAgaWYoIUlTX1dFQUspY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTsiLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcxLjIuMyd9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi8kLmEtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG4gIHN3aXRjaChsZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07IiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIGNvcmUgICAgICA9IHJlcXVpcmUoJy4vJC5jb3JlJylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBjdHggPSBmdW5jdGlvbihmbiwgdGhhdCl7XG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcbnZhciAkZGVmID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIGtleSwgb3duLCBvdXQsIGV4cFxuICAgICwgaXNHbG9iYWwgPSB0eXBlICYgJGRlZi5HXG4gICAgLCBpc1Byb3RvICA9IHR5cGUgJiAkZGVmLlBcbiAgICAsIHRhcmdldCAgID0gaXNHbG9iYWwgPyBnbG9iYWwgOiB0eXBlICYgJGRlZi5TXG4gICAgICAgID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwgZXhwb3J0cyAgPSBpc0dsb2JhbCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICBpZihpc0dsb2JhbClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gISh0eXBlICYgJGRlZi5GKSAmJiB0YXJnZXQgJiYga2V5IGluIHRhcmdldDtcbiAgICBpZihvd24gJiYga2V5IGluIGV4cG9ydHMpY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGlmKGlzR2xvYmFsICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nKWV4cCA9IHNvdXJjZVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgZWxzZSBpZih0eXBlICYgJGRlZi5CICYmIG93billeHAgPSBjdHgob3V0LCBnbG9iYWwpO1xuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgZWxzZSBpZih0eXBlICYgJGRlZi5XICYmIHRhcmdldFtrZXldID09IG91dCkhZnVuY3Rpb24oQyl7XG4gICAgICBleHAgPSBmdW5jdGlvbihwYXJhbSl7XG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgQyA/IG5ldyBDKHBhcmFtKSA6IEMocGFyYW0pO1xuICAgICAgfTtcbiAgICAgIGV4cFtQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgIH0ob3V0KTtcbiAgICBlbHNlIGV4cCA9IGlzUHJvdG8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXhwb3J0XG4gICAgZXhwb3J0c1trZXldID0gZXhwO1xuICAgIGlmKGlzUHJvdG8pKGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pKVtrZXldID0gb3V0O1xuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRkZWYuRiA9IDE7ICAvLyBmb3JjZWRcbiRkZWYuRyA9IDI7ICAvLyBnbG9iYWxcbiRkZWYuUyA9IDQ7ICAvLyBzdGF0aWNcbiRkZWYuUCA9IDg7ICAvLyBwcm90b1xuJGRlZi5CID0gMTY7IC8vIGJpbmRcbiRkZWYuVyA9IDMyOyAvLyB3cmFwXG5tb2R1bGUuZXhwb3J0cyA9ICRkZWY7IiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59OyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59OyIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgJCA9IHJlcXVpcmUoJy4vJCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBrZXlzICAgICAgID0gJC5nZXRLZXlzKGl0KVxuICAgICwgZ2V0U3ltYm9scyA9ICQuZ2V0U3ltYm9scztcbiAgaWYoZ2V0U3ltYm9scyl7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxuICAgICAgLCBpc0VudW0gID0gJC5pc0VudW1cbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07IiwidmFyIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgY2FsbCAgICAgICAgPSByZXF1aXJlKCcuLyQuaXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vJC5pcy1hcnJheS1pdGVyJylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi8kLnRvLWxlbmd0aCcpXG4gICwgZ2V0SXRlckZuICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQpe1xuICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKGl0ZXJhYmxlKVxuICAgICwgZiAgICAgID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yO1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZihpc0FycmF5SXRlcihpdGVyRm4pKWZvcihsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICB9IGVsc2UgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7ICl7XG4gICAgY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gIH1cbn07IiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvU3RyaW5nICA9IHt9LnRvU3RyaW5nXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLWlvYmplY3QnKVxuICAsIGdldE5hbWVzICA9IHJlcXVpcmUoJy4vJCcpLmdldE5hbWVzO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdldE5hbWVzKGl0KTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIGlmKHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nKXJldHVybiBnZXRXaW5kb3dOYW1lcyhpdCk7XG4gIHJldHVybiBnZXROYW1lcyh0b0lPYmplY3QoaXQpKTtcbn07IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59OyIsInZhciAkICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi8kLnByb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLnN1cHBvcnQtZGVzYycpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuICQuc2V0RGVzYyhvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDsiLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIGFyZ3MsIHRoYXQpe1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaChhcmdzLmxlbmd0aCl7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07IiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuLyQuY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59OyIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJylcbiAgLCBJVEVSQVRPUiAgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIChJdGVyYXRvcnMuQXJyYXkgfHwgQXJyYXkucHJvdG90eXBlW0lURVJBVE9SXSkgPT09IGl0O1xufTsiLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vJC5jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihhcmcpe1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59OyIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaChlKXtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmKHJldCAhPT0gdW5kZWZpbmVkKWFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4vJCcpXG4gICwgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vJC5oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KXtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gJC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtuZXh0OiByZXF1aXJlKCcuLyQucHJvcGVydHktZGVzYycpKDEsbmV4dCl9KTtcbiAgcmVxdWlyZSgnLi8kLnRhZycpKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgID0gcmVxdWlyZSgnLi8kLmxpYnJhcnknKVxuICAsICRkZWYgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAsICRyZWRlZiAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5yZWRlZicpXG4gICwgaGlkZSAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmhpZGUnKVxuICAsIGhhcyAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oYXMnKVxuICAsIFNZTUJPTF9JVEVSQVRPUiA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIEl0ZXJhdG9ycyAgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyYXRvcnMnKVxuICAsIEJVR0dZICAgICAgICAgICA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKSAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gICwgRkZfSVRFUkFUT1IgICAgID0gJ0BAaXRlcmF0b3InXG4gICwgS0VZUyAgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgID0gJ3ZhbHVlcyc7XG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRSl7XG4gIHJlcXVpcmUoJy4vJC5pdGVyLWNyZWF0ZScpKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uKGtpbmQpe1xuICAgIHN3aXRjaChraW5kKXtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHICAgICAgPSBOQU1FICsgJyBJdGVyYXRvcidcbiAgICAsIHByb3RvICAgID0gQmFzZS5wcm90b3R5cGVcbiAgICAsIF9uYXRpdmUgID0gcHJvdG9bU1lNQk9MX0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXVxuICAgICwgX2RlZmF1bHQgPSBfbmF0aXZlIHx8IGNyZWF0ZU1ldGhvZChERUZBVUxUKVxuICAgICwgbWV0aG9kcywga2V5O1xuICAvLyBGaXggbmF0aXZlXG4gIGlmKF9uYXRpdmUpe1xuICAgIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHJlcXVpcmUoJy4vJCcpLmdldFByb3RvKF9kZWZhdWx0LmNhbGwobmV3IEJhc2UpKTtcbiAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgcmVxdWlyZSgnLi8kLnRhZycpKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgIC8vIEZGIGZpeFxuICAgIGlmKCFMSUJSQVJZICYmIGhhcyhwcm90bywgRkZfSVRFUkFUT1IpKWhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIFNZTUJPTF9JVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmKCFMSUJSQVJZIHx8IEZPUkNFKWhpZGUocHJvdG8sIFNZTUJPTF9JVEVSQVRPUiwgX2RlZmF1bHQpO1xuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IF9kZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSAgPSByZXR1cm5UaGlzO1xuICBpZihERUZBVUxUKXtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiAgREVGQVVMVCA9PSBWQUxVRVMgPyBfZGVmYXVsdCA6IGNyZWF0ZU1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICAgICAgICAgPyBfZGVmYXVsdCA6IGNyZWF0ZU1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6IERFRkFVTFQgIT0gVkFMVUVTID8gX2RlZmF1bHQgOiBjcmVhdGVNZXRob2QoJ2VudHJpZXMnKVxuICAgIH07XG4gICAgaWYoRk9SQ0UpZm9yKGtleSBpbiBtZXRob2RzKXtcbiAgICAgIGlmKCEoa2V5IGluIHByb3RvKSkkcmVkZWYocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGRlZigkZGVmLlAgKyAkZGVmLkYgKiBCVUdHWSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbn07IiwidmFyIFNZTUJPTF9JVEVSQVRPUiA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIFNBRkVfQ0xPU0lORyAgICA9IGZhbHNlO1xudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW1NZTUJPTF9JVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24oKXsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24oKXsgdGhyb3cgMjsgfSk7XG59IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMsIHNraXBDbG9zaW5nKXtcbiAgaWYoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgID0gWzddXG4gICAgICAsIGl0ZXIgPSBhcnJbU1lNQk9MX0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uKCl7IHNhZmUgPSB0cnVlOyB9O1xuICAgIGFycltTWU1CT0xfSVRFUkFUT1JdID0gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvbmUsIHZhbHVlKXtcbiAgcmV0dXJuIHt2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZX07XG59OyIsIm1vZHVsZS5leHBvcnRzID0ge307IiwidmFyICRPYmplY3QgPSBPYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlOiAgICAgJE9iamVjdC5jcmVhdGUsXG4gIGdldFByb3RvOiAgICRPYmplY3QuZ2V0UHJvdG90eXBlT2YsXG4gIGlzRW51bTogICAgIHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICBnZXREZXNjOiAgICAkT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgc2V0RGVzYzogICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcbiAgc2V0RGVzY3M6ICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLFxuICBnZXRLZXlzOiAgICAkT2JqZWN0LmtleXMsXG4gIGdldE5hbWVzOiAgICRPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgZ2V0U3ltYm9sczogJE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gIGVhY2g6ICAgICAgIFtdLmZvckVhY2hcbn07IiwidmFyICQgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLWlvYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBlbCl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwga2V5cyAgID0gJC5nZXRLZXlzKE8pXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaW5kZXggID0gMFxuICAgICwga2V5O1xuICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7IiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vJC50YXNrJykuc2V0XG4gICwgT2JzZXJ2ZXIgID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXJcbiAgLCBwcm9jZXNzICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIGlzTm9kZSAgICA9IHJlcXVpcmUoJy4vJC5jb2YnKShwcm9jZXNzKSA9PSAncHJvY2VzcydcbiAgLCBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbnZhciBmbHVzaCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBwYXJlbnQsIGRvbWFpbjtcbiAgaWYoaXNOb2RlICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpe1xuICAgIHByb2Nlc3MuZG9tYWluID0gbnVsbDtcbiAgICBwYXJlbnQuZXhpdCgpO1xuICB9XG4gIHdoaWxlKGhlYWQpe1xuICAgIGRvbWFpbiA9IGhlYWQuZG9tYWluO1xuICAgIGlmKGRvbWFpbilkb21haW4uZW50ZXIoKTtcbiAgICBoZWFkLmZuLmNhbGwoKTsgLy8gPC0gY3VycmVudGx5IHdlIHVzZSBpdCBvbmx5IGZvciBQcm9taXNlIC0gdHJ5IC8gY2F0Y2ggbm90IHJlcXVpcmVkXG4gICAgaWYoZG9tYWluKWRvbWFpbi5leGl0KCk7XG4gICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICBpZihwYXJlbnQpcGFyZW50LmVudGVyKCk7XG59O1xuXG4vLyBOb2RlLmpzXG5pZihpc05vZGUpe1xuICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICB9O1xuLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG59IGVsc2UgaWYoT2JzZXJ2ZXIpe1xuICB2YXIgdG9nZ2xlID0gMVxuICAgICwgbm9kZSAgID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBuZXcgT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwge2NoYXJhY3RlckRhdGE6IHRydWV9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAtdG9nZ2xlO1xuICB9O1xuLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbi8vIC0gc2V0SW1tZWRpYXRlXG4vLyAtIE1lc3NhZ2VDaGFubmVsXG4vLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4vLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuLy8gLSBzZXRUaW1lb3V0XG59IGVsc2Uge1xuICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhc2FwKGZuKXtcbiAgdmFyIHRhc2sgPSB7Zm46IGZuLCBuZXh0OiB1bmRlZmluZWQsIGRvbWFpbjogaXNOb2RlICYmIHByb2Nlc3MuZG9tYWlufTtcbiAgaWYobGFzdClsYXN0Lm5leHQgPSB0YXNrO1xuICBpZighaGVhZCl7XG4gICAgaGVhZCA9IHRhc2s7XG4gICAgbm90aWZ5KCk7XG4gIH0gbGFzdCA9IHRhc2s7XG59OyIsInZhciAkcmVkZWYgPSByZXF1aXJlKCcuLyQucmVkZWYnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGFyZ2V0LCBzcmMpe1xuICBmb3IodmFyIGtleSBpbiBzcmMpJHJlZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIHJldHVybiB0YXJnZXQ7XG59OyIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGV4ZWMpe1xuICB2YXIgJGRlZiA9IHJlcXVpcmUoJy4vJC5kZWYnKVxuICAgICwgZm4gICA9IChyZXF1aXJlKCcuLyQuY29yZScpLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXVxuICAgICwgZXhwICA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZGVmKCRkZWYuUyArICRkZWYuRiAqIHJlcXVpcmUoJy4vJC5mYWlscycpKGZ1bmN0aW9uKCl7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5oaWRlJyk7IiwibW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaXMgfHwgZnVuY3Rpb24gaXMoeCwgeSl7XG4gIHJldHVybiB4ID09PSB5ID8geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkgOiB4ICE9IHggJiYgeSAhPSB5O1xufTsiLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgZ2V0RGVzYyAgPSByZXF1aXJlKCcuLyQnKS5nZXREZXNjXG4gICwgaXNPYmplY3QgPSByZXF1aXJlKCcuLyQuaXMtb2JqZWN0JylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uKE8sIHByb3RvKXtcbiAgYW5PYmplY3QoTyk7XG4gIGlmKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24odGVzdCwgYnVnZ3ksIHNldCl7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuLyQuY3R4JykoRnVuY3Rpb24uY2FsbCwgZ2V0RGVzYyhPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoKGUpeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90byl7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYoYnVnZ3kpTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59OyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylcbiAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xuICAsIHN0b3JlICA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59OyIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxyXG52YXIgYW5PYmplY3QgID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpXHJcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLyQuYS1mdW5jdGlvbicpXHJcbiAgLCBTUEVDSUVTICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ3NwZWNpZXMnKTtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBEKXtcclxuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yLCBTO1xyXG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcclxufTsiLCIndXNlIHN0cmljdCc7XG52YXIgJCAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vJC53a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDKXtcbiAgaWYocmVxdWlyZSgnLi8kLnN1cHBvcnQtZGVzYycpICYmICEoU1BFQ0lFUyBpbiBDKSkkLnNldERlc2MoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSl7XG4gIGlmKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpdGhyb3cgVHlwZUVycm9yKG5hbWUgKyBcIjogdXNlIHRoZSAnbmV3JyBvcGVyYXRvciFcIik7XG4gIHJldHVybiBpdDtcbn07IiwiLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLyQudG8taW50ZWdlcicpXG4gICwgZGVmaW5lZCAgID0gcmVxdWlyZSgnLi8kLmRlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVE9fU1RSSU5HKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRoYXQsIHBvcyl7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSlcbiAgICAgICwgaSA9IHRvSW50ZWdlcihwb3MpXG4gICAgICAsIGwgPSBzLmxlbmd0aFxuICAgICAgLCBhLCBiO1xuICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsXG4gICAgICB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59OyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vJC5mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTsiLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi8kJykuc2V0RGVzY1xuICAsIGhhcyA9IHJlcXVpcmUoJy4vJC5oYXMnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vJC53a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcbiAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSlkZWYoaXQsIFRBRywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZ30pO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgaW52b2tlICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmludm9rZScpXG4gICwgaHRtbCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmh0bWwnKVxuICAsIGNlbCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5kb20tY3JlYXRlJylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIHNldFRhc2sgICAgICAgICAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcbiAgLCBjbGVhclRhc2sgICAgICAgICAgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGVcbiAgLCBNZXNzYWdlQ2hhbm5lbCAgICAgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWxcbiAgLCBjb3VudGVyICAgICAgICAgICAgPSAwXG4gICwgcXVldWUgICAgICAgICAgICAgID0ge31cbiAgLCBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJ1xuICAsIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpZCA9ICt0aGlzO1xuICBpZihxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpe1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdG5lciA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYoIXNldFRhc2sgfHwgIWNsZWFyVGFzayl7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pe1xuICAgIHZhciBhcmdzID0gW10sIGkgPSAxO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uKCl7XG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpe1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZihyZXF1aXJlKCcuLyQuY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZihNZXNzYWdlQ2hhbm5lbCl7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcbiAgICBwb3J0ICAgID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0bmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiAgIHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07IiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59OyIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuLyQuaW9iamVjdCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vJC5kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLyQudG8taW50ZWdlcicpXG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07IiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuLyQuZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCJ2YXIgaWQgPSAwXG4gICwgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH07IiwidmFyIHN0b3JlICA9IHJlcXVpcmUoJy4vJC5zaGFyZWQnKSgnd2tzJylcbiAgLCBTeW1ib2wgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJykuU3ltYm9sO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgU3ltYm9sICYmIFN5bWJvbFtuYW1lXSB8fCAoU3ltYm9sIHx8IHJlcXVpcmUoJy4vJC51aWQnKSkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTsiLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi8kLmNsYXNzb2YnKVxuICAsIElURVJBVE9SICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vJC5pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmNvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgIT0gdW5kZWZpbmVkKXJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07IiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpXG4gICwgZ2V0ICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuY29yZScpLmdldEl0ZXJhdG9yID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgaXRlckZuID0gZ2V0KGl0KTtcbiAgaWYodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICByZXR1cm4gYW5PYmplY3QoaXRlckZuLmNhbGwoaXQpKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHNldFVuc2NvcGUgPSByZXF1aXJlKCcuLyQudW5zY29wZScpXG4gICwgc3RlcCAgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyLXN0ZXAnKVxuICAsIEl0ZXJhdG9ycyAgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJylcbiAgLCB0b0lPYmplY3QgID0gcmVxdWlyZSgnLi8kLnRvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi8kLml0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBraW5kICA9IHRoaXMuX2tcbiAgICAsIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuc2V0VW5zY29wZSgna2V5cycpO1xuc2V0VW5zY29wZSgndmFsdWVzJyk7XG5zZXRVbnNjb3BlKCdlbnRyaWVzJyk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uLXN0cm9uZycpO1xuXG4vLyAyMy4xIE1hcCBPYmplY3RzXG5yZXF1aXJlKCcuLyQuY29sbGVjdGlvbicpKCdNYXAnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gTWFwKCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSl7XG4gICAgdmFyIGVudHJ5ID0gc3Ryb25nLmdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XG4gIH0sXG4gIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nLCB0cnVlKTsiLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRkZWYgPSByZXF1aXJlKCcuLyQuZGVmJyk7XG5cbiRkZWYoJGRlZi5TICsgJGRlZi5GLCAnT2JqZWN0Jywge2Fzc2lnbjogcmVxdWlyZSgnLi8kLmFzc2lnbicpfSk7IiwiLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vJC50by1pb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vJC5vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsIGZ1bmN0aW9uKCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ipe1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSU9iamVjdChpdCksIGtleSk7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vJC50by1vYmplY3QnKTtcblxucmVxdWlyZSgnLi8kLm9iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uKCRrZXlzKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpe1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7IiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZGVmID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuJGRlZigkZGVmLlMsICdPYmplY3QnLCB7c2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vJC5zZXQtcHJvdG8nKS5zZXR9KTsiLG51bGwsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBMSUJSQVJZICAgID0gcmVxdWlyZSgnLi8kLmxpYnJhcnknKVxuICAsIGdsb2JhbCAgICAgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylcbiAgLCBjdHggICAgICAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgY2xhc3NvZiAgICA9IHJlcXVpcmUoJy4vJC5jbGFzc29mJylcbiAgLCAkZGVmICAgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgaXNPYmplY3QgICA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ICAgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gID0gcmVxdWlyZSgnLi8kLmEtZnVuY3Rpb24nKVxuICAsIHN0cmljdE5ldyAgPSByZXF1aXJlKCcuLyQuc3RyaWN0LW5ldycpXG4gICwgZm9yT2YgICAgICA9IHJlcXVpcmUoJy4vJC5mb3Itb2YnKVxuICAsIHNldFByb3RvICAgPSByZXF1aXJlKCcuLyQuc2V0LXByb3RvJykuc2V0XG4gICwgc2FtZSAgICAgICA9IHJlcXVpcmUoJy4vJC5zYW1lJylcbiAgLCBzcGVjaWVzICAgID0gcmVxdWlyZSgnLi8kLnNwZWNpZXMnKVxuICAsIFNQRUNJRVMgICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ3NwZWNpZXMnKVxuICAsIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vJC5zcGVjaWVzLWNvbnN0cnVjdG9yJylcbiAgLCBSRUNPUkQgICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpKCdyZWNvcmQnKVxuICAsIGFzYXAgICAgICAgPSByZXF1aXJlKCcuLyQubWljcm90YXNrJylcbiAgLCBQUk9NSVNFICAgID0gJ1Byb21pc2UnXG4gICwgcHJvY2VzcyAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgaXNOb2RlICAgICA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXG4gICwgUCAgICAgICAgICA9IGdsb2JhbFtQUk9NSVNFXVxuICAsIFdyYXBwZXI7XG5cbnZhciB0ZXN0UmVzb2x2ZSA9IGZ1bmN0aW9uKHN1Yil7XG4gIHZhciB0ZXN0ID0gbmV3IFAoZnVuY3Rpb24oKXt9KTtcbiAgaWYoc3ViKXRlc3QuY29uc3RydWN0b3IgPSBPYmplY3Q7XG4gIHJldHVybiBQLnJlc29sdmUodGVzdCkgPT09IHRlc3Q7XG59O1xuXG52YXIgdXNlTmF0aXZlID0gZnVuY3Rpb24oKXtcbiAgdmFyIHdvcmtzID0gZmFsc2U7XG4gIGZ1bmN0aW9uIFAyKHgpe1xuICAgIHZhciBzZWxmID0gbmV3IFAoeCk7XG4gICAgc2V0UHJvdG8oc2VsZiwgUDIucHJvdG90eXBlKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICB0cnkge1xuICAgIHdvcmtzID0gUCAmJiBQLnJlc29sdmUgJiYgdGVzdFJlc29sdmUoKTtcbiAgICBzZXRQcm90byhQMiwgUCk7XG4gICAgUDIucHJvdG90eXBlID0gJC5jcmVhdGUoUC5wcm90b3R5cGUsIHtjb25zdHJ1Y3Rvcjoge3ZhbHVlOiBQMn19KTtcbiAgICAvLyBhY3R1YWwgRmlyZWZveCBoYXMgYnJva2VuIHN1YmNsYXNzIHN1cHBvcnQsIHRlc3QgdGhhdFxuICAgIGlmKCEoUDIucmVzb2x2ZSg1KS50aGVuKGZ1bmN0aW9uKCl7fSkgaW5zdGFuY2VvZiBQMikpe1xuICAgICAgd29ya3MgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gYWN0dWFsIFY4IGJ1ZywgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxNjJcbiAgICBpZih3b3JrcyAmJiByZXF1aXJlKCcuLyQuc3VwcG9ydC1kZXNjJykpe1xuICAgICAgdmFyIHRoZW5hYmxlVGhlbkdvdHRlbiA9IGZhbHNlO1xuICAgICAgUC5yZXNvbHZlKCQuc2V0RGVzYyh7fSwgJ3RoZW4nLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKXsgdGhlbmFibGVUaGVuR290dGVuID0gdHJ1ZTsgfVxuICAgICAgfSkpO1xuICAgICAgd29ya3MgPSB0aGVuYWJsZVRoZW5Hb3R0ZW47XG4gICAgfVxuICB9IGNhdGNoKGUpeyB3b3JrcyA9IGZhbHNlOyB9XG4gIHJldHVybiB3b3Jrcztcbn0oKTtcblxuLy8gaGVscGVyc1xudmFyIGlzUHJvbWlzZSA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiAodXNlTmF0aXZlID8gY2xhc3NvZihpdCkgPT0gJ1Byb21pc2UnIDogUkVDT1JEIGluIGl0KTtcbn07XG52YXIgc2FtZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24oYSwgYil7XG4gIC8vIGxpYnJhcnkgd3JhcHBlciBzcGVjaWFsIGNhc2VcbiAgaWYoTElCUkFSWSAmJiBhID09PSBQICYmIGIgPT09IFdyYXBwZXIpcmV0dXJuIHRydWU7XG4gIHJldHVybiBzYW1lKGEsIGIpO1xufTtcbnZhciBnZXRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKEMpe1xuICB2YXIgUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdO1xuICByZXR1cm4gUyAhPSB1bmRlZmluZWQgPyBTIDogQztcbn07XG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG52YXIgbm90aWZ5ID0gZnVuY3Rpb24ocmVjb3JkLCBpc1JlamVjdCl7XG4gIGlmKHJlY29yZC5uKXJldHVybjtcbiAgcmVjb3JkLm4gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSByZWNvcmQuYztcbiAgYXNhcChmdW5jdGlvbigpe1xuICAgIHZhciB2YWx1ZSA9IHJlY29yZC52XG4gICAgICAsIG9rICAgID0gcmVjb3JkLnMgPT0gMVxuICAgICAgLCBpICAgICA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uKHJlYWN0KXtcbiAgICAgIHZhciBjYiA9IG9rID8gcmVhY3Qub2sgOiByZWFjdC5mYWlsXG4gICAgICAgICwgcmV0LCB0aGVuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYoY2Ipe1xuICAgICAgICAgIGlmKCFvaylyZWNvcmQuaCA9IHRydWU7XG4gICAgICAgICAgcmV0ID0gY2IgPT09IHRydWUgPyB2YWx1ZSA6IGNiKHZhbHVlKTtcbiAgICAgICAgICBpZihyZXQgPT09IHJlYWN0LlApe1xuICAgICAgICAgICAgcmVhY3QucmVqKFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmV0KSl7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmV0LCByZWFjdC5yZXMsIHJlYWN0LnJlaik7XG4gICAgICAgICAgfSBlbHNlIHJlYWN0LnJlcyhyZXQpO1xuICAgICAgICB9IGVsc2UgcmVhY3QucmVqKHZhbHVlKTtcbiAgICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICAgcmVhY3QucmVqKGVycik7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZShjaGFpbi5sZW5ndGggPiBpKXJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcbiAgICBjaGFpbi5sZW5ndGggPSAwO1xuICAgIHJlY29yZC5uID0gZmFsc2U7XG4gICAgaWYoaXNSZWplY3Qpc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgdmFyIHByb21pc2UgPSByZWNvcmQucFxuICAgICAgICAsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgICBpZihpc1VuaGFuZGxlZChwcm9taXNlKSl7XG4gICAgICAgIGlmKGlzTm9kZSl7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBpZihoYW5kbGVyID0gZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKXtcbiAgICAgICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHZhbHVlfSk7XG4gICAgICAgIH0gZWxzZSBpZigoY29uc29sZSA9IGdsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKXtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gcmVjb3JkLmEgPSB1bmRlZmluZWQ7XG4gICAgfSwgMSk7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICB2YXIgcmVjb3JkID0gcHJvbWlzZVtSRUNPUkRdXG4gICAgLCBjaGFpbiAgPSByZWNvcmQuYSB8fCByZWNvcmQuY1xuICAgICwgaSAgICAgID0gMFxuICAgICwgcmVhY3Q7XG4gIGlmKHJlY29yZC5oKXJldHVybiBmYWxzZTtcbiAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSl7XG4gICAgcmVhY3QgPSBjaGFpbltpKytdO1xuICAgIGlmKHJlYWN0LmZhaWwgfHwgIWlzVW5oYW5kbGVkKHJlYWN0LlApKXJldHVybiBmYWxzZTtcbiAgfSByZXR1cm4gdHJ1ZTtcbn07XG52YXIgJHJlamVjdCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgdmFyIHJlY29yZCA9IHRoaXM7XG4gIGlmKHJlY29yZC5kKXJldHVybjtcbiAgcmVjb3JkLmQgPSB0cnVlO1xuICByZWNvcmQgPSByZWNvcmQuciB8fCByZWNvcmQ7IC8vIHVud3JhcFxuICByZWNvcmQudiA9IHZhbHVlO1xuICByZWNvcmQucyA9IDI7XG4gIHJlY29yZC5hID0gcmVjb3JkLmMuc2xpY2UoKTtcbiAgbm90aWZ5KHJlY29yZCwgdHJ1ZSk7XG59O1xudmFyICRyZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcmVjb3JkID0gdGhpc1xuICAgICwgdGhlbjtcbiAgaWYocmVjb3JkLmQpcmV0dXJuO1xuICByZWNvcmQuZCA9IHRydWU7XG4gIHJlY29yZCA9IHJlY29yZC5yIHx8IHJlY29yZDsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKXtcbiAgICAgIGFzYXAoZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7cjogcmVjb3JkLCBkOiBmYWxzZX07IC8vIHdyYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eCgkcmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eCgkcmVqZWN0LCB3cmFwcGVyLCAxKSk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjb3JkLnYgPSB2YWx1ZTtcbiAgICAgIHJlY29yZC5zID0gMTtcbiAgICAgIG5vdGlmeShyZWNvcmQsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgJHJlamVjdC5jYWxsKHtyOiByZWNvcmQsIGQ6IGZhbHNlfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmKCF1c2VOYXRpdmUpe1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICBQID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcil7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICB2YXIgcmVjb3JkID0ge1xuICAgICAgcDogc3RyaWN0TmV3KHRoaXMsIFAsIFBST01JU0UpLCAgICAgICAgIC8vIDwtIHByb21pc2VcbiAgICAgIGM6IFtdLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICAgIGE6IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgICAgczogMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgICBkOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gZG9uZVxuICAgICAgdjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICBoOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gaGFuZGxlZCByZWplY3Rpb25cbiAgICAgIG46IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgICB9O1xuICAgIHRoaXNbUkVDT1JEXSA9IHJlY29yZDtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoY3R4KCRyZXNvbHZlLCByZWNvcmQsIDEpLCBjdHgoJHJlamVjdCwgcmVjb3JkLCAxKSk7XG4gICAgfSBjYXRjaChlcnIpe1xuICAgICAgJHJlamVjdC5jYWxsKHJlY29yZCwgZXJyKTtcbiAgICB9XG4gIH07XG4gIHJlcXVpcmUoJy4vJC5taXgnKShQLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCl7XG4gICAgICB2YXIgcmVhY3QgPSB7XG4gICAgICAgIG9rOiAgIHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlLFxuICAgICAgICBmYWlsOiB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICA/IG9uUmVqZWN0ZWQgIDogZmFsc2VcbiAgICAgIH07XG4gICAgICB2YXIgcHJvbWlzZSA9IHJlYWN0LlAgPSBuZXcgKHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBQKSkoZnVuY3Rpb24ocmVzLCByZWope1xuICAgICAgICByZWFjdC5yZXMgPSByZXM7XG4gICAgICAgIHJlYWN0LnJlaiA9IHJlajtcbiAgICAgIH0pO1xuICAgICAgYUZ1bmN0aW9uKHJlYWN0LnJlcyk7XG4gICAgICBhRnVuY3Rpb24ocmVhY3QucmVqKTtcbiAgICAgIHZhciByZWNvcmQgPSB0aGlzW1JFQ09SRF07XG4gICAgICByZWNvcmQuYy5wdXNoKHJlYWN0KTtcbiAgICAgIGlmKHJlY29yZC5hKXJlY29yZC5hLnB1c2gocmVhY3QpO1xuICAgICAgaWYocmVjb3JkLnMpbm90aWZ5KHJlY29yZCwgZmFsc2UpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpe1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIGV4cG9ydFxuJGRlZigkZGVmLkcgKyAkZGVmLlcgKyAkZGVmLkYgKiAhdXNlTmF0aXZlLCB7UHJvbWlzZTogUH0pO1xucmVxdWlyZSgnLi8kLnRhZycpKFAsIFBST01JU0UpO1xuc3BlY2llcyhQKTtcbnNwZWNpZXMoV3JhcHBlciA9IHJlcXVpcmUoJy4vJC5jb3JlJylbUFJPTUlTRV0pO1xuXG4vLyBzdGF0aWNzXG4kZGVmKCRkZWYuUyArICRkZWYuRiAqICF1c2VOYXRpdmUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocil7XG4gICAgcmV0dXJuIG5ldyB0aGlzKGZ1bmN0aW9uKHJlcywgcmVqKXsgcmVqKHIpOyB9KTtcbiAgfVxufSk7XG4kZGVmKCRkZWYuUyArICRkZWYuRiAqICghdXNlTmF0aXZlIHx8IHRlc3RSZXNvbHZlKHRydWUpKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KXtcbiAgICByZXR1cm4gaXNQcm9taXNlKHgpICYmIHNhbWVDb25zdHJ1Y3Rvcih4LmNvbnN0cnVjdG9yLCB0aGlzKVxuICAgICAgPyB4IDogbmV3IHRoaXMoZnVuY3Rpb24ocmVzKXsgcmVzKHgpOyB9KTtcbiAgfVxufSk7XG4kZGVmKCRkZWYuUyArICRkZWYuRiAqICEodXNlTmF0aXZlICYmIHJlcXVpcmUoJy4vJC5pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpe1xuICBQLmFsbChpdGVyKVsnY2F0Y2gnXShmdW5jdGlvbigpe30pO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSl7XG4gICAgdmFyIEMgICAgICA9IGdldENvbnN0cnVjdG9yKHRoaXMpXG4gICAgICAsIHZhbHVlcyA9IFtdO1xuICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbihyZXMsIHJlail7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIHZhbHVlcy5wdXNoLCB2YWx1ZXMpO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHZhbHVlcy5sZW5ndGhcbiAgICAgICAgLCByZXN1bHRzICAgPSBBcnJheShyZW1haW5pbmcpO1xuICAgICAgaWYocmVtYWluaW5nKSQuZWFjaC5jYWxsKHZhbHVlcywgZnVuY3Rpb24ocHJvbWlzZSwgaW5kZXgpe1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXMocmVzdWx0cyk7XG4gICAgICAgIH0sIHJlaik7XG4gICAgICB9KTtcbiAgICAgIGVsc2UgcmVzKHJlc3VsdHMpO1xuICAgIH0pO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpe1xuICAgIHZhciBDID0gZ2V0Q29uc3RydWN0b3IodGhpcyk7XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uKHJlcywgcmVqKXtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKHJlcywgcmVqKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbnJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uJykoJ1NldCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSl7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgID0gcmVxdWlyZSgnLi8kLnN0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuLyQuaXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGluZGV4ID0gdGhpcy5faVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7dmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZX07XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgJCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaGFzJylcbiAgLCBTVVBQT1JUX0RFU0MgICA9IHJlcXVpcmUoJy4vJC5zdXBwb3J0LWRlc2MnKVxuICAsICRkZWYgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmRlZicpXG4gICwgJHJlZGVmICAgICAgICAgPSByZXF1aXJlKCcuLyQucmVkZWYnKVxuICAsICRmYWlscyAgICAgICAgID0gcmVxdWlyZSgnLi8kLmZhaWxzJylcbiAgLCBzaGFyZWQgICAgICAgICA9IHJlcXVpcmUoJy4vJC5zaGFyZWQnKVxuICAsIHNldFRhZyAgICAgICAgID0gcmVxdWlyZSgnLi8kLnRhZycpXG4gICwgdWlkICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQudWlkJylcbiAgLCB3a3MgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC53a3MnKVxuICAsIGtleU9mICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmtleW9mJylcbiAgLCAkbmFtZXMgICAgICAgICA9IHJlcXVpcmUoJy4vJC5nZXQtbmFtZXMnKVxuICAsIGVudW1LZXlzICAgICAgID0gcmVxdWlyZSgnLi8kLmVudW0ta2V5cycpXG4gICwgaXNBcnJheSAgICAgICAgPSByZXF1aXJlKCcuLyQuaXMtYXJyYXknKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuLyQudG8taW9iamVjdCcpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuLyQucHJvcGVydHktZGVzYycpXG4gICwgZ2V0RGVzYyAgICAgICAgPSAkLmdldERlc2NcbiAgLCBzZXREZXNjICAgICAgICA9ICQuc2V0RGVzY1xuICAsIF9jcmVhdGUgICAgICAgID0gJC5jcmVhdGVcbiAgLCBnZXROYW1lcyAgICAgICA9ICRuYW1lcy5nZXRcbiAgLCAkU3ltYm9sICAgICAgICA9IGdsb2JhbC5TeW1ib2xcbiAgLCAkSlNPTiAgICAgICAgICA9IGdsb2JhbC5KU09OXG4gICwgX3N0cmluZ2lmeSAgICAgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnlcbiAgLCBzZXR0ZXIgICAgICAgICA9IGZhbHNlXG4gICwgSElEREVOICAgICAgICAgPSB3a3MoJ19oaWRkZW4nKVxuICAsIGlzRW51bSAgICAgICAgID0gJC5pc0VudW1cbiAgLCBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5JylcbiAgLCBBbGxTeW1ib2xzICAgICA9IHNoYXJlZCgnc3ltYm9scycpXG4gICwgdXNlTmF0aXZlICAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXG4gICwgT2JqZWN0UHJvdG8gICAgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gU1VQUE9SVF9ERVNDICYmICRmYWlscyhmdW5jdGlvbigpe1xuICByZXR1cm4gX2NyZWF0ZShzZXREZXNjKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBzZXREZXNjKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcbiAgdmFyIHByb3RvRGVzYyA9IGdldERlc2MoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgc2V0RGVzYyhpdCwga2V5LCBEKTtcbiAgaWYocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bylzZXREZXNjKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogc2V0RGVzYztcblxudmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sLnByb3RvdHlwZSk7XG4gIHN5bS5fayA9IHRhZztcbiAgU1VQUE9SVF9ERVNDICYmIHNldHRlciAmJiBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCl7XG4gIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkpe1xuICAgIGlmKCFELmVudW1lcmFibGUpe1xuICAgICAgaWYoIWhhcyhpdCwgSElEREVOKSlzZXREZXNjKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0paXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7ZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSl9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBzZXREZXNjKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSlcbiAgICAsIGkgICAgPSAwXG4gICAgLCBsID0ga2V5cy5sZW5ndGhcbiAgICAsIGtleTtcbiAgd2hpbGUobCA+IGkpJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkpO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldXG4gICAgPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcbiAgdmFyIEQgPSBnZXREZXNjKGl0ID0gdG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKUQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ2V0TmFtZXModG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOKXJlc3VsdC5wdXNoKGtleSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ2V0TmFtZXModG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyICRzdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpe1xuICB2YXIgYXJncyA9IFtpdF1cbiAgICAsIGkgICAgPSAxXG4gICAgLCAkJCAgID0gYXJndW1lbnRzXG4gICAgLCByZXBsYWNlciwgJHJlcGxhY2VyO1xuICB3aGlsZSgkJC5sZW5ndGggPiBpKWFyZ3MucHVzaCgkJFtpKytdKTtcbiAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuICBpZih0eXBlb2YgcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykkcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgaWYoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSlyZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgIGlmKCRyZXBsYWNlcil2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIGlmKCFpc1N5bWJvbCh2YWx1ZSkpcmV0dXJuIHZhbHVlO1xuICB9O1xuICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbn07XG52YXIgYnVnZ3lKU09OID0gJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHthOiBTfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pO1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmKCF1c2VOYXRpdmUpe1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG4gICAgaWYoaXNTeW1ib2wodGhpcykpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbiAgICByZXR1cm4gd3JhcCh1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpKTtcbiAgfTtcbiAgJHJlZGVmKCRTeW1ib2wucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICBpc1N5bWJvbCA9IGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xuICB9O1xuXG4gICQuY3JlYXRlICAgICA9ICRjcmVhdGU7XG4gICQuaXNFbnVtICAgICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgJC5nZXREZXNjICAgID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJC5zZXREZXNjICAgID0gJGRlZmluZVByb3BlcnR5O1xuICAkLnNldERlc2NzICAgPSAkZGVmaW5lUHJvcGVydGllcztcbiAgJC5nZXROYW1lcyAgID0gJG5hbWVzLmdldCA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICAkLmdldFN5bWJvbHMgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmKFNVUFBPUlRfREVTQyAmJiAhcmVxdWlyZSgnLi8kLmxpYnJhcnknKSl7XG4gICAgJHJlZGVmKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG59XG5cbnZhciBzeW1ib2xTdGF0aWNzID0ge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihrZXkpe1xuICAgIHJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uKCl7IHNldHRlciA9IGZhbHNlOyB9XG59O1xuLy8gMTkuNC4yLjIgU3ltYm9sLmhhc0luc3RhbmNlXG4vLyAxOS40LjIuMyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlXG4vLyAxOS40LjIuNCBTeW1ib2wuaXRlcmF0b3Jcbi8vIDE5LjQuMi42IFN5bWJvbC5tYXRjaFxuLy8gMTkuNC4yLjggU3ltYm9sLnJlcGxhY2Vcbi8vIDE5LjQuMi45IFN5bWJvbC5zZWFyY2hcbi8vIDE5LjQuMi4xMCBTeW1ib2wuc3BlY2llc1xuLy8gMTkuNC4yLjExIFN5bWJvbC5zcGxpdFxuLy8gMTkuNC4yLjEyIFN5bWJvbC50b1ByaW1pdGl2ZVxuLy8gMTkuNC4yLjEzIFN5bWJvbC50b1N0cmluZ1RhZ1xuLy8gMTkuNC4yLjE0IFN5bWJvbC51bnNjb3BhYmxlc1xuJC5lYWNoLmNhbGwoKFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLCcgK1xuICAnc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgZnVuY3Rpb24oaXQpe1xuICB2YXIgc3ltID0gd2tzKGl0KTtcbiAgc3ltYm9sU3RhdGljc1tpdF0gPSB1c2VOYXRpdmUgPyBzeW0gOiB3cmFwKHN5bSk7XG59KTtcblxuc2V0dGVyID0gdHJ1ZTtcblxuJGRlZigkZGVmLkcgKyAkZGVmLlcsIHtTeW1ib2w6ICRTeW1ib2x9KTtcblxuJGRlZigkZGVmLlMsICdTeW1ib2wnLCBzeW1ib2xTdGF0aWNzKTtcblxuJGRlZigkZGVmLlMgKyAkZGVmLkYgKiAhdXNlTmF0aXZlLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZGVmKCRkZWYuUyArICRkZWYuRiAqICghdXNlTmF0aXZlIHx8IGJ1Z2d5SlNPTiksICdKU09OJywge3N0cmluZ2lmeTogJHN0cmluZ2lmeX0pO1xuXG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZGVmICA9IHJlcXVpcmUoJy4vJC5kZWYnKTtcblxuJGRlZigkZGVmLlAsICdNYXAnLCB7dG9KU09OOiByZXF1aXJlKCcuLyQuY29sbGVjdGlvbi10by1qc29uJykoJ01hcCcpfSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRkZWYgID0gcmVxdWlyZSgnLi8kLmRlZicpO1xuXG4kZGVmKCRkZWYuUCwgJ1NldCcsIHt0b0pTT046IHJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uLXRvLWpzb24nKSgnU2V0Jyl9KTsiLCJyZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vJC5pdGVyYXRvcnMnKTtcbkl0ZXJhdG9ycy5Ob2RlTGlzdCA9IEl0ZXJhdG9ycy5IVE1MQ29sbGVjdGlvbiA9IEl0ZXJhdG9ycy5BcnJheTsiLCIvLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPVxuICB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6XG4gIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHRoaXM7XG5cbi8vIFVzZSBgZ2V0T3duUHJvcGVydHlOYW1lc2AgYmVjYXVzZSBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY2FsbGluZ1xuLy8gYGhhc093blByb3BlcnR5YCBvbiB0aGUgZ2xvYmFsIGBzZWxmYCBvYmplY3QgaW4gYSB3b3JrZXIuIFNlZSAjMTgzLlxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnKS5pbmRleE9mKFwicmVnZW5lcmF0b3JSdW50aW1lXCIpID49IDA7XG5cbi8vIFNhdmUgdGhlIG9sZCByZWdlbmVyYXRvclJ1bnRpbWUgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZXN0b3JlZCBsYXRlci5cbnZhciBvbGRSdW50aW1lID0gaGFkUnVudGltZSAmJiBnLnJlZ2VuZXJhdG9yUnVudGltZTtcblxuLy8gRm9yY2UgcmVldmFsdXRhdGlvbiBvZiBydW50aW1lLmpzLlxuZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcnVudGltZVwiKTtcblxuaWYgKGhhZFJ1bnRpbWUpIHtcbiAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcnVudGltZS5cbiAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBvbGRSdW50aW1lO1xufSBlbHNlIHtcbiAgLy8gUmVtb3ZlIHRoZSBnbG9iYWwgcHJvcGVydHkgYWRkZWQgYnkgcnVudGltZS5qcy5cbiAgdHJ5IHtcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIGcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogbW9kdWxlLmV4cG9ydHMsIF9fZXNNb2R1bGU6IHRydWUgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX1N5bWJvbCA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIF9TeW1ib2wkaXRlcmF0b3IgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvclwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBfT2JqZWN0JGNyZWF0ZSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBfUHJvbWlzZSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZVwiKVtcImRlZmF1bHRcIl07XG5cbiEoZnVuY3Rpb24gKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciBpdGVyYXRvclN5bWJvbCA9IHR5cGVvZiBfU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgX1N5bWJvbCRpdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBnZW5lcmF0b3IgPSBfT2JqZWN0JGNyZWF0ZSgob3V0ZXJGbiB8fCBHZW5lcmF0b3IpLnByb3RvdHlwZSk7XG5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiB8fCBudWxsLCBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSkpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3IgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICBnZW5GdW4ucHJvdG90eXBlID0gX09iamVjdCRjcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGB2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnRgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLiBTb21lIG1heSBjb25zaWRlciB0aGUgbmFtZSBvZiB0aGlzIG1ldGhvZCB0b29cbiAgLy8gY3V0ZXN5LCBidXQgdGhleSBhcmUgY3VybXVkZ2VvbnMuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIG5ldyBBd2FpdEFyZ3VtZW50KGFyZyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gQXdhaXRBcmd1bWVudChhcmcpIHtcbiAgICB0aGlzLmFyZyA9IGFyZztcbiAgfVxuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgLy8gVGhpcyBpbnZva2UgZnVuY3Rpb24gaXMgd3JpdHRlbiBpbiBhIHN0eWxlIHRoYXQgYXNzdW1lcyBzb21lXG4gICAgLy8gY2FsbGluZyBmdW5jdGlvbiAob3IgUHJvbWlzZSkgd2lsbCBoYW5kbGUgZXhjZXB0aW9ucy5cbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnZW5lcmF0b3JbbWV0aG9kXShhcmcpO1xuICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudCA/IF9Qcm9taXNlLnJlc29sdmUodmFsdWUuYXJnKS50aGVuKGludm9rZU5leHQsIGludm9rZVRocm93KSA6IF9Qcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkge1xuICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gcHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBpbnZva2VOZXh0ID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcIm5leHRcIik7XG4gICAgdmFyIGludm9rZVRocm93ID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcInRocm93XCIpO1xuICAgIHZhciBpbnZva2VSZXR1cm4gPSBpbnZva2UuYmluZChnZW5lcmF0b3IsIFwicmV0dXJuXCIpO1xuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICB2YXIgZW5xdWV1ZVJlc3VsdCA9XG4gICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pIDogbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHJlc29sdmUoaW52b2tlKG1ldGhvZCwgYXJnKSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZW5xdWV1ZVJlc3VsdCBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieVxuICAgICAgLy8gbGF0ZXIgaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgcHJldmlvdXNQcm9taXNlID0gZW5xdWV1ZVJlc3VsdFtcImNhdGNoXCJdKGZ1bmN0aW9uIChpZ25vcmVkKSB7fSk7XG5cbiAgICAgIHJldHVybiBlbnF1ZXVlUmVzdWx0O1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIgfHwgbWV0aG9kID09PSBcInRocm93XCIgJiYgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBBIHJldHVybiBvciB0aHJvdyAod2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIHRocm93XG4gICAgICAgICAgICAvLyBtZXRob2QpIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgICB2YXIgcmV0dXJuTWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl07XG4gICAgICAgICAgICBpZiAocmV0dXJuTWV0aG9kKSB7XG4gICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChyZXR1cm5NZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBhcmcpO1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXR1cm4gbWV0aG9kIHRocmV3IGFuIGV4Y2VwdGlvbiwgbGV0IHRoYXRcbiAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gcHJldmFpbCBvdmVyIHRoZSBvcmlnaW5hbCByZXR1cm4gb3IgdGhyb3cuXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBvdXRlciByZXR1cm4sIG5vdyB0aGF0IHRoZSBkZWxlZ2F0ZVxuICAgICAgICAgICAgICAvLyBpdGVyYXRvciBoYXMgYmVlbiB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSwgZGVsZWdhdGUuaXRlcmF0b3IsIGFyZyk7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIExpa2UgcmV0dXJuaW5nIGdlbmVyYXRvci50aHJvdyh1bmNhdWdodCksIGJ1dCB3aXRob3V0IHRoZVxuICAgICAgICAgICAgLy8gb3ZlcmhlYWQgb2YgYW4gZXh0cmEgZnVuY3Rpb24gY2FsbC5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZWxlZ2F0ZSBnZW5lcmF0b3IgcmFuIGFuZCBoYW5kbGVkIGl0cyBvd24gZXhjZXB0aW9ucyBzb1xuICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUgbWV0aG9kIHdhcywgd2UgY29udGludWUgYXMgaWYgaXQgaXNcbiAgICAgICAgICAvLyBcIm5leHRcIiB3aXRoIGFuIHVuZGVmaW5lZCBhcmcuXG4gICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuICAgICAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCkge1xuICAgICAgICAgICAgY29udGV4dC5zZW50ID0gYXJnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LnNlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IEdlblN0YXRlQ29tcGxldGVkIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmRlbGVnYXRlICYmIG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICB0aGlzLnNlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcbiAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJiAodHlwZSA9PT0gXCJicmVha1wiIHx8IHR5cGUgPT09IFwiY29udGludWVcIikgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHwgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2godHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIGRlbGVnYXRlWWllbGQoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbi8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbi8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbnR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDogdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdW5kZWZpbmVkKTsiLCJcbi8qXG4gKiBLb252YSBKYXZhU2NyaXB0IEZyYW1ld29yayB2MC4xMS4xXG4gKiBodHRwOi8va29udmFqcy5naXRodWIuaW8vXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIG9yIEdQTCBWZXJzaW9uIDIgbGljZW5zZXMuXG4gKiBEYXRlOiBTYXQgSmFuIDE2IDIwMTZcbiAqXG4gKiBPcmlnaW5hbCB3b3JrIENvcHlyaWdodCAoQykgMjAxMSAtIDIwMTMgYnkgRXJpYyBSb3dlbGwgKEtpbmV0aWNKUylcbiAqIE1vZGlmaWVkIHdvcmsgQ29weXJpZ2h0IChDKSAyMDE0IC0gMjAxNSBieSBBbnRvbiBMYXZyZW5vdiAoS29udmEpXG4gKlxuICogQGxpY2Vuc2VcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLy8gcnVudGltZSBjaGVjayBmb3IgYWxyZWFkeSBpbmNsdWRlZCBLb252YVxuKGZ1bmN0aW9uKCl7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2UgS29udmFcbiAgICAgKi9cblxuICAgIHZhciBQSV9PVkVSXzE4MCA9IE1hdGguUEkgLyAxODA7XG5cbiAgICB2YXIgS29udmEgPSB7XG4gICAgICAgIC8vIHB1YmxpY1xuICAgICAgICB2ZXJzaW9uOiAnMC4xMS4xJyxcblxuICAgICAgICAvLyBwcml2YXRlXG4gICAgICAgIHN0YWdlczogW10sXG4gICAgICAgIGlkQ291bnRlcjogMCxcbiAgICAgICAgaWRzOiB7fSxcbiAgICAgICAgbmFtZXM6IHt9LFxuICAgICAgICBzaGFwZXM6IHt9LFxuICAgICAgICBsaXN0ZW5DbGlja1RhcDogZmFsc2UsXG4gICAgICAgIGluRGJsQ2xpY2tXaW5kb3c6IGZhbHNlLFxuXG4gICAgICAgIC8vIGNvbmZpZ3VyYXRpb25zXG4gICAgICAgIGVuYWJsZVRyYWNlOiBmYWxzZSxcbiAgICAgICAgdHJhY2VBcnJNYXg6IDEwMCxcbiAgICAgICAgZGJsQ2xpY2tXaW5kb3c6IDQwMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdsb2JhbCBwaXhlbCByYXRpbyBjb25maWd1cmF0aW9uLiBLb252YUpTIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHBpeGVsIHJhdGlvIG9mIGN1cnJlbnQgZGV2aWNlLlxuICAgICAgICAgKiBCdXQgeW91IG1heSBvdmVycmlkZSBzdWNoIHByb3BlcnR5LCBpZiB5b3Ugd2FudCB0byB1c2UgeW91ciB2YWx1ZS5cbiAgICAgICAgICogQHByb3BlcnR5IHBpeGVsUmF0aW9cbiAgICAgICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBLb252YS5waXhlbFJhdGlvID0gMTtcbiAgICAgICAgICovXG4gICAgICAgIHBpeGVsUmF0aW86IHVuZGVmaW5lZCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERyYWcgZGlzdGFuY2UgcHJvcGVydHkuIElmIHlvdSBzdGFydCB0byBkcmFnIGEgbm9kZSB5b3UgbWF5IHdhbnQgdG8gd2FpdCB1bnRpbCBwb2ludGVyIGlzIG1vdmVkIHRvIHNvbWUgZGlzdGFuY2UgZnJvbSBzdGFydCBwb2ludCxcbiAgICAgICAgICogb25seSB0aGVuIHN0YXJ0IGRyYWdnaW5nLlxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0Rpc3RhbmNlXG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIEtvbnZhLmRyYWdEaXN0YW5jZSA9IDEwO1xuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0Rpc3RhbmNlOiAwLFxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlIGRlZ3JlZSB2YWx1ZXMgZm9yIGFuZ2xlIHByb3BlcnRpZXMuIFlvdSBtYXkgc2V0IHRoaXMgcHJvcGVydHkgdG8gZmFsc2UgaWYgeW91IHdhbnQgdG8gdXNlIHJhZGlhbnQgdmFsdWVzLlxuICAgICAgICAgKiBAcHJvcGVydHkgYW5nbGVEZWdcbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogbm9kZS5yb3RhdGlvbig0NSk7IC8vIDQ1IGRlZ3JlZXNcbiAgICAgICAgICogS29udmEuYW5nbGVEZWcgPSBmYWxzZTtcbiAgICAgICAgICogbm9kZS5yb3RhdGlvbihNYXRoLlBJIC8gMik7IC8vIFBJLzIgcmFkaWFuXG4gICAgICAgICAqL1xuICAgICAgICBhbmdsZURlZzogdHJ1ZSxcbiAgICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IGRpZmZlcmVudCB3YXJuaW5ncyBhYm91dCBlcnJvcnMgb3Igd3JvbmcgQVBJIHVzYWdlXG4gICAgICAgICAqIEBwcm9wZXJ0eSBzaG93V2FybmluZ3NcbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogS29udmEuc2hvd1dhcm5pbmdzID0gZmFsc2U7XG4gICAgICAgICAqL1xuICAgICAgICBzaG93V2FybmluZ3M6IHRydWUsXG5cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZXNwYWNlIEZpbHRlcnNcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICAgICAqL1xuICAgICAgICBGaWx0ZXJzOiB7fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJucyB3aGV0aGVyIG9yIG5vdCBkcmFnIGFuZCBkcm9wIGlzIGN1cnJlbnRseSBhY3RpdmVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgICAgICovXG4gICAgICAgIGlzRHJhZ2dpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGRkID0gS29udmEuREQ7XG5cbiAgICAgICAgICAgIC8vIGlmIEREIGlzIG5vdCBpbmNsdWRlZCB3aXRoIHRoZSBidWlsZCwgdGhlblxuICAgICAgICAgICAgLy8gZHJhZyBhbmQgZHJvcCBpcyBub3QgZXZlbiBwb3NzaWJsZVxuICAgICAgICAgICAgaWYgKGRkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRkLmlzRHJhZ2dpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIHJldHVybnMgd2hldGhlciBvciBub3QgYSBkcmFnIGFuZCBkcm9wIG9wZXJhdGlvbiBpcyByZWFkeSwgYnV0IG1heVxuICAgICAgICAqICBub3QgbmVjZXNzYXJpbHkgaGF2ZSBzdGFydGVkXG4gICAgICAgICogQG1ldGhvZFxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAgICAqL1xuICAgICAgICBpc0RyYWdSZWFkeTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZGQgPSBLb252YS5ERDtcblxuICAgICAgICAgICAgLy8gaWYgREQgaXMgbm90IGluY2x1ZGVkIHdpdGggdGhlIGJ1aWxkLCB0aGVuXG4gICAgICAgICAgICAvLyBkcmFnIGFuZCBkcm9wIGlzIG5vdCBldmVuIHBvc3NpYmxlXG4gICAgICAgICAgICBpZiAoZGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFkZC5ub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBfYWRkSWQ6IGZ1bmN0aW9uKG5vZGUsIGlkKSB7XG4gICAgICAgICAgICBpZihpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHNbaWRdID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX3JlbW92ZUlkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgaWYoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmlkc1tpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9hZGROYW1lOiBmdW5jdGlvbihub2RlLCBuYW1lKSB7XG4gICAgICAgICAgICBpZihuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYoIXRoaXMubmFtZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lc1tuYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm5hbWVzW25hbWVdLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9yZW1vdmVOYW1lOiBmdW5jdGlvbihuYW1lLCBfaWQpIHtcbiAgICAgICAgICAgIGlmKCFuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5uYW1lc1tuYW1lXTtcbiAgICAgICAgICAgIGlmKCFub2Rlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcih2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgICAgIHZhciBubyA9IG5vZGVzW25dO1xuICAgICAgICAgICAgICAgIGlmKG5vLl9pZCA9PT0gX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShuLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5uYW1lc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0QW5nbGU6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmdsZURlZyA/IGFuZ2xlICogUElfT1ZFUl8xODAgOiBhbmdsZTtcbiAgICAgICAgfSxcbiAgICAgICAgX3BhcnNlVUE6IGZ1bmN0aW9uKHVzZXJBZ2VudCkge1xuICAgICAgICAgICAgdmFyIHVhID0gdXNlckFnZW50LnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgLy8galF1ZXJ5IFVBIHJlZ2V4XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSAvKGNocm9tZSlbIFxcL10oW1xcdy5dKykvLmV4ZWMoIHVhICkgfHxcbiAgICAgICAgICAgICAgICAvKHdlYmtpdClbIFxcL10oW1xcdy5dKykvLmV4ZWMoIHVhICkgfHxcbiAgICAgICAgICAgICAgICAvKG9wZXJhKSg/Oi4qdmVyc2lvbnwpWyBcXC9dKFtcXHcuXSspLy5leGVjKCB1YSApIHx8XG4gICAgICAgICAgICAgICAgLyhtc2llKSAoW1xcdy5dKykvLmV4ZWMoIHVhICkgfHxcbiAgICAgICAgICAgICAgICB1YS5pbmRleE9mKCdjb21wYXRpYmxlJykgPCAwICYmIC8obW96aWxsYSkoPzouKj8gcnY6KFtcXHcuXSspfCkvLmV4ZWMoIHVhICkgfHxcbiAgICAgICAgICAgICAgICBbXSxcblxuICAgICAgICAgICAgICAgIC8vIGFkZGluZyBtb2JpbGUgZmxhZyBhcyB3ZWxsXG4gICAgICAgICAgICAgICAgbW9iaWxlID0gISEodXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkfEJsYWNrQmVycnl8aVBob25lfGlQYWR8aVBvZHxPcGVyYSBNaW5pfElFTW9iaWxlL2kpKSxcbiAgICAgICAgICAgICAgICBpZU1vYmlsZSA9ICEhKHVzZXJBZ2VudC5tYXRjaCgvSUVNb2JpbGUvaSkpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJyb3dzZXI6IG1hdGNoWyAxIF0gfHwgJycsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogbWF0Y2hbIDIgXSB8fCAnMCcsXG5cbiAgICAgICAgICAgICAgICAvLyBhZGRpbmcgbW9iaWxlIGZsYWJcbiAgICAgICAgICAgICAgICBtb2JpbGU6IG1vYmlsZSxcbiAgICAgICAgICAgICAgICBpZU1vYmlsZTogaWVNb2JpbGUgIC8vIElmIHRoaXMgaXMgdHJ1ZSAoaS5lLiwgV1A4KSwgdGhlbiBLb252YSB0b3VjaCBldmVudHMgYXJlIGV4ZWN1dGVkIGluc3RlYWQgb2YgZXF1aXZhbGVudCBLb252YSBtb3VzZSBldmVudHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHVzZXIgYWdlbnRcbiAgICAgICAgVUE6IHVuZGVmaW5lZFxuICAgIH07XG5cbiAgICB2YXIgZ2xvYmFsID1cbiAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOlxuICAgICAgICB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6XG4gICAgICAgIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cblxuICAgIEtvbnZhLlVBID0gS29udmEuX3BhcnNlVUEoKGdsb2JhbC5uYXZpZ2F0b3IgJiYgZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpIHx8ICcnKTtcblxuICAgIGlmIChnbG9iYWwuS29udmEpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdLb252YSBpbnN0YW5jZSBpcyBhbHJlYWR5IGV4aXN0IGluIGN1cnJlbnQgZXZpcm9tZW50LiAnICtcbiAgICAgICAgICAgICdQbGVhc2UgdXNlIG9ubHkgb25lIGluc3RhbmNlLidcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZ2xvYmFsLktvbnZhID0gS29udmE7XG4gICAgS29udmEuZ2xvYmFsID0gZ2xvYmFsO1xuXG5cbiAgICBpZiggdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIHJ1bnRpbWUtY2hlY2sgZm9yIGJyb3dzZXJpZnkgYW5kIG53LmpzIChub2RlLXdlYmtpdClcbiAgICAgICAgaWYoZ2xvYmFsLndpbmRvdyAmJiBnbG9iYWwud2luZG93LmRvY3VtZW50KSB7XG4gICAgICAgICAgICBLb252YS5kb2N1bWVudCA9IGdsb2JhbC53aW5kb3cuZG9jdW1lbnQ7XG4gICAgICAgICAgICBLb252YS53aW5kb3cgPSBnbG9iYWwud2luZG93O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICAgICAgLy8gbGlrZSBOb2RlLlxuICAgICAgICAgICAgdmFyIENhbnZhcyA9IHJlcXVpcmUoJ2NhbnZhcycpO1xuICAgICAgICAgICAgdmFyIGpzZG9tID0gcmVxdWlyZSgnanNkb20nKS5qc2RvbTtcblxuICAgICAgICAgICAgS29udmEuZG9jdW1lbnQgPSBqc2RvbSgnPCFET0NUWVBFIGh0bWw+PGh0bWw+PGhlYWQ+PC9oZWFkPjxib2R5PjwvYm9keT48L2h0bWw+Jyk7XG4gICAgICAgICAgICBLb252YS53aW5kb3cgPSBLb252YS5kb2N1bWVudC5wYXJlbnRXaW5kb3c7XG4gICAgICAgICAgICBLb252YS53aW5kb3cuSW1hZ2UgPSBDYW52YXMuSW1hZ2U7XG4gICAgICAgICAgICBLb252YS5fbm9kZUNhbnZhcyA9IENhbnZhcztcbiAgICAgICAgfVxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEtvbnZhO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBLb252YTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIEtvbnZhLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgS29udmEud2luZG93ID0gd2luZG93O1xufSkoKTtcblxuLyplc2xpbnQtZGlzYWJsZSAgZXFlcWVxLCBuby1jb25kLWFzc2lnbiwgbm8tZW1wdHkqL1xuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBDb2xsZWN0aW9uIGNvbnN0cnVjdG9yLiAgQ29sbGVjdGlvbiBleHRlbmRzXG4gICAgICogIEFycmF5LiAgVGhpcyBjbGFzcyBpcyB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGgge0BsaW5rIEtvbnZhLkNvbnRhaW5lciNnZXR9XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICovXG4gICAgS29udmEuQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgbGVuZ3RoID0gYXJncy5sZW5ndGgsIGkgPSAwO1xuXG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICBmb3IoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXNbaV0gPSBhcmdzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgS29udmEuQ29sbGVjdGlvbi5wcm90b3R5cGUgPSBbXTtcbiAgICAvKipcbiAgICAgKiBpdGVyYXRlIHRocm91Z2ggbm9kZSBhcnJheSBhbmQgcnVuIGEgZnVuY3Rpb24gZm9yIGVhY2ggbm9kZS5cbiAgICAgKiAgVGhlIG5vZGUgYW5kIGluZGV4IGlzIHBhc3NlZCBpbnRvIHRoZSBmdW5jdGlvblxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29sbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgYWxsIG5vZGVzIHdpdGggbmFtZSBmb28gaW5zaWRlIGxheWVyLCBhbmQgc2V0IHggdG8gMTAgZm9yIGVhY2hcbiAgICAgKiBsYXllci5nZXQoJy5mb28nKS5lYWNoKGZ1bmN0aW9uKHNoYXBlLCBuKSB7XG4gICAgICogICBzaGFwZS5zZXRYKDEwKTtcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBLb252YS5Db2xsZWN0aW9uLnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24oZnVuYykge1xuICAgICAgICBmb3IodmFyIG4gPSAwOyBuIDwgdGhpcy5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgZnVuYyh0aGlzW25dLCBuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogY29udmVydCBjb2xsZWN0aW9uIGludG8gYW4gYXJyYXlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbGxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgS29udmEuQ29sbGVjdGlvbi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJyID0gW10sXG4gICAgICAgICAgICBsZW4gPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgIG47XG5cbiAgICAgICAgZm9yKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgIGFyci5wdXNoKHRoaXNbbl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IGFycmF5IGludG8gYSBjb2xsZWN0aW9uXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICovXG4gICAgS29udmEuQ29sbGVjdGlvbi50b0NvbGxlY3Rpb24gPSBmdW5jdGlvbihhcnIpIHtcbiAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSBuZXcgS29udmEuQ29sbGVjdGlvbigpLFxuICAgICAgICAgICAgbGVuID0gYXJyLmxlbmd0aCxcbiAgICAgICAgICAgIG47XG5cbiAgICAgICAgZm9yKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24ucHVzaChhcnJbbl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH07XG5cbiAgICAvLyBtYXAgb25lIG1ldGhvZCBieSBpdCdzIG5hbWVcbiAgICBLb252YS5Db2xsZWN0aW9uLl9tYXBNZXRob2QgPSBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgIEtvbnZhLkNvbGxlY3Rpb24ucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXNbaV1bbWV0aG9kTmFtZV0uYXBwbHkodGhpc1tpXSwgYXJncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMgPSBmdW5jdGlvbihjb25zdHJ1Y3Rvcikge1xuICAgICAgICB2YXIgcHJvdCA9IGNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgZm9yKHZhciBtZXRob2ROYW1lIGluIHByb3QpIHtcbiAgICAgICAgICAgIEtvbnZhLkNvbGxlY3Rpb24uX21hcE1ldGhvZChtZXRob2ROYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgICogTGFzdCB1cGRhdGVkIE5vdmVtYmVyIDIwMTFcbiAgICAqIEJ5IFNpbW9uIFNhcnJpc1xuICAgICogd3d3LnNpbW9uc2FycmlzLmNvbVxuICAgICogc2FycmlzQGFjbS5vcmdcbiAgICAqXG4gICAgKiBGcmVlIHRvIHVzZSBhbmQgZGlzdHJpYnV0ZSBhdCB3aWxsXG4gICAgKiBTbyBsb25nIGFzIHlvdSBhcmUgbmljZSB0byBwZW9wbGUsIGV0Y1xuICAgICovXG5cbiAgICAvKlxuICAgICogVGhlIHVzYWdlIG9mIHRoaXMgY2xhc3Mgd2FzIGluc3BpcmVkIGJ5IHNvbWUgb2YgdGhlIHdvcmsgZG9uZSBieSBhIGZvcmtlZFxuICAgICogcHJvamVjdCwgS2luZXRpY0pTLUV4dCBieSBXYXBwd29ya3MsIHdoaWNoIGlzIGJhc2VkIG9uIFNpbW9uJ3MgVHJhbnNmb3JtXG4gICAgKiBjbGFzcy4gIE1vZGlmaWVkIGJ5IEVyaWMgUm93ZWxsXG4gICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBjb25zdHJ1Y3RvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFttXSBPcHRpb25hbCBzaXgtZWxlbWVudCBtYXRyaXhcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKi9cbiAgICBLb252YS5UcmFuc2Zvcm0gPSBmdW5jdGlvbihtKSB7XG4gICAgICAgIHRoaXMubSA9IChtICYmIG0uc2xpY2UoKSkgfHwgWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgIH07XG5cbiAgICBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29weSBLb252YS5UcmFuc2Zvcm0gb2JqZWN0XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cbiAgICAgICAgICovXG4gICAgICAgIGNvcHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBLb252YS5UcmFuc2Zvcm0odGhpcy5tKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYW5zZm9ybSBwb2ludFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludCAyRCBwb2ludCh4LCB5KVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSAyRCBwb2ludCh4LCB5KVxuICAgICAgICAgKi9cbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMubTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogbVswXSAqIHBvaW50LnggKyBtWzJdICogcG9pbnQueSArIG1bNF0sXG4gICAgICAgICAgICAgICAgeTogbVsxXSAqIHBvaW50LnggKyBtWzNdICogcG9pbnQueSArIG1bNV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBseSB0cmFuc2xhdGlvblxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMubVs0XSArPSB0aGlzLm1bMF0gKiB4ICsgdGhpcy5tWzJdICogeTtcbiAgICAgICAgICAgIHRoaXMubVs1XSArPSB0aGlzLm1bMV0gKiB4ICsgdGhpcy5tWzNdICogeTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbHkgc2NhbGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3hcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHN5XG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICAgICAqL1xuICAgICAgICBzY2FsZTogZnVuY3Rpb24oc3gsIHN5KSB7XG4gICAgICAgICAgICB0aGlzLm1bMF0gKj0gc3g7XG4gICAgICAgICAgICB0aGlzLm1bMV0gKj0gc3g7XG4gICAgICAgICAgICB0aGlzLm1bMl0gKj0gc3k7XG4gICAgICAgICAgICB0aGlzLm1bM10gKj0gc3k7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGx5IHJvdGF0aW9uXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZCAgQW5nbGUgaW4gcmFkaWFuc1xuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuVHJhbnNmb3JtfVxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRlOiBmdW5jdGlvbihyYWQpIHtcbiAgICAgICAgICAgIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgICAgICAgICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICAgICAgICAgIHZhciBtMTEgPSB0aGlzLm1bMF0gKiBjICsgdGhpcy5tWzJdICogcztcbiAgICAgICAgICAgIHZhciBtMTIgPSB0aGlzLm1bMV0gKiBjICsgdGhpcy5tWzNdICogcztcbiAgICAgICAgICAgIHZhciBtMjEgPSB0aGlzLm1bMF0gKiAtcyArIHRoaXMubVsyXSAqIGM7XG4gICAgICAgICAgICB2YXIgbTIyID0gdGhpcy5tWzFdICogLXMgKyB0aGlzLm1bM10gKiBjO1xuICAgICAgICAgICAgdGhpcy5tWzBdID0gbTExO1xuICAgICAgICAgICAgdGhpcy5tWzFdID0gbTEyO1xuICAgICAgICAgICAgdGhpcy5tWzJdID0gbTIxO1xuICAgICAgICAgICAgdGhpcy5tWzNdID0gbTIyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2xhdGlvblxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IDJEIHBvaW50KHgsIHkpXG4gICAgICAgICAqL1xuICAgICAgICBnZXRUcmFuc2xhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMubVs0XSxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLm1bNV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBseSBza2V3XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHN4XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzeVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuVHJhbnNmb3JtfVxuICAgICAgICAgKi9cbiAgICAgICAgc2tldzogZnVuY3Rpb24oc3gsIHN5KSB7XG4gICAgICAgICAgICB2YXIgbTExID0gdGhpcy5tWzBdICsgdGhpcy5tWzJdICogc3k7XG4gICAgICAgICAgICB2YXIgbTEyID0gdGhpcy5tWzFdICsgdGhpcy5tWzNdICogc3k7XG4gICAgICAgICAgICB2YXIgbTIxID0gdGhpcy5tWzJdICsgdGhpcy5tWzBdICogc3g7XG4gICAgICAgICAgICB2YXIgbTIyID0gdGhpcy5tWzNdICsgdGhpcy5tWzFdICogc3g7XG4gICAgICAgICAgICB0aGlzLm1bMF0gPSBtMTE7XG4gICAgICAgICAgICB0aGlzLm1bMV0gPSBtMTI7XG4gICAgICAgICAgICB0aGlzLm1bMl0gPSBtMjE7XG4gICAgICAgICAgICB0aGlzLm1bM10gPSBtMjI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFuc2Zvcm0gbXVsdGlwbGljYXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0tvbnZhLlRyYW5zZm9ybX0gbWF0cml4XG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseTogZnVuY3Rpb24obWF0cml4KSB7XG4gICAgICAgICAgICB2YXIgbTExID0gdGhpcy5tWzBdICogbWF0cml4Lm1bMF0gKyB0aGlzLm1bMl0gKiBtYXRyaXgubVsxXTtcbiAgICAgICAgICAgIHZhciBtMTIgPSB0aGlzLm1bMV0gKiBtYXRyaXgubVswXSArIHRoaXMubVszXSAqIG1hdHJpeC5tWzFdO1xuXG4gICAgICAgICAgICB2YXIgbTIxID0gdGhpcy5tWzBdICogbWF0cml4Lm1bMl0gKyB0aGlzLm1bMl0gKiBtYXRyaXgubVszXTtcbiAgICAgICAgICAgIHZhciBtMjIgPSB0aGlzLm1bMV0gKiBtYXRyaXgubVsyXSArIHRoaXMubVszXSAqIG1hdHJpeC5tWzNdO1xuXG4gICAgICAgICAgICB2YXIgZHggPSB0aGlzLm1bMF0gKiBtYXRyaXgubVs0XSArIHRoaXMubVsyXSAqIG1hdHJpeC5tWzVdICsgdGhpcy5tWzRdO1xuICAgICAgICAgICAgdmFyIGR5ID0gdGhpcy5tWzFdICogbWF0cml4Lm1bNF0gKyB0aGlzLm1bM10gKiBtYXRyaXgubVs1XSArIHRoaXMubVs1XTtcblxuICAgICAgICAgICAgdGhpcy5tWzBdID0gbTExO1xuICAgICAgICAgICAgdGhpcy5tWzFdID0gbTEyO1xuICAgICAgICAgICAgdGhpcy5tWzJdID0gbTIxO1xuICAgICAgICAgICAgdGhpcy5tWzNdID0gbTIyO1xuICAgICAgICAgICAgdGhpcy5tWzRdID0gZHg7XG4gICAgICAgICAgICB0aGlzLm1bNV0gPSBkeTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW52ZXJ0IHRoZSBtYXRyaXhcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuVHJhbnNmb3JtfVxuICAgICAgICAgKi9cbiAgICAgICAgaW52ZXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkID0gMSAvICh0aGlzLm1bMF0gKiB0aGlzLm1bM10gLSB0aGlzLm1bMV0gKiB0aGlzLm1bMl0pO1xuICAgICAgICAgICAgdmFyIG0wID0gdGhpcy5tWzNdICogZDtcbiAgICAgICAgICAgIHZhciBtMSA9IC10aGlzLm1bMV0gKiBkO1xuICAgICAgICAgICAgdmFyIG0yID0gLXRoaXMubVsyXSAqIGQ7XG4gICAgICAgICAgICB2YXIgbTMgPSB0aGlzLm1bMF0gKiBkO1xuICAgICAgICAgICAgdmFyIG00ID0gZCAqICh0aGlzLm1bMl0gKiB0aGlzLm1bNV0gLSB0aGlzLm1bM10gKiB0aGlzLm1bNF0pO1xuICAgICAgICAgICAgdmFyIG01ID0gZCAqICh0aGlzLm1bMV0gKiB0aGlzLm1bNF0gLSB0aGlzLm1bMF0gKiB0aGlzLm1bNV0pO1xuICAgICAgICAgICAgdGhpcy5tWzBdID0gbTA7XG4gICAgICAgICAgICB0aGlzLm1bMV0gPSBtMTtcbiAgICAgICAgICAgIHRoaXMubVsyXSA9IG0yO1xuICAgICAgICAgICAgdGhpcy5tWzNdID0gbTM7XG4gICAgICAgICAgICB0aGlzLm1bNF0gPSBtNDtcbiAgICAgICAgICAgIHRoaXMubVs1XSA9IG01O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXR1cm4gbWF0cml4XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGdldE1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IHRvIGFic29sdXRlIHBvc2l0aW9uIHZpYSB0cmFuc2xhdGlvblxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICAgICAqIEBhdXRob3IgZXJpY2Ryb3dlbGxcbiAgICAgICAgICovXG4gICAgICAgIHNldEFic29sdXRlUG9zaXRpb246IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBtMCA9IHRoaXMubVswXSxcbiAgICAgICAgICAgICAgICBtMSA9IHRoaXMubVsxXSxcbiAgICAgICAgICAgICAgICBtMiA9IHRoaXMubVsyXSxcbiAgICAgICAgICAgICAgICBtMyA9IHRoaXMubVszXSxcbiAgICAgICAgICAgICAgICBtNCA9IHRoaXMubVs0XSxcbiAgICAgICAgICAgICAgICBtNSA9IHRoaXMubVs1XSxcbiAgICAgICAgICAgICAgICB5dCA9ICgobTAgKiAoeSAtIG01KSkgLSAobTEgKiAoeCAtIG00KSkpIC8gKChtMCAqIG0zKSAtIChtMSAqIG0yKSksXG4gICAgICAgICAgICAgICAgeHQgPSAoeCAtIG00IC0gKG0yICogeXQpKSAvIG0wO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGUoeHQsIHl0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDT05TVEFOVFNcbiAgICB2YXIgQ09OVEVYVF8yRCA9ICcyZCcsXG4gICAgICAgIE9CSkVDVF9BUlJBWSA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICAgIE9CSkVDVF9OVU1CRVIgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgICAgT0JKRUNUX1NUUklORyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgICAgICBQSV9PVkVSX0RFRzE4MCA9IE1hdGguUEkgLyAxODAsXG4gICAgICAgIERFRzE4MF9PVkVSX1BJID0gMTgwIC8gTWF0aC5QSSxcbiAgICAgICAgSEFTSCA9ICcjJyxcbiAgICAgICAgRU1QVFlfU1RSSU5HID0gJycsXG4gICAgICAgIFpFUk8gPSAnMCcsXG4gICAgICAgIEtPTlZBX1dBUk5JTkcgPSAnS29udmEgd2FybmluZzogJyxcbiAgICAgICAgS09OVkFfRVJST1IgPSAnS29udmEgZXJyb3I6ICcsXG4gICAgICAgIFJHQl9QQVJFTiA9ICdyZ2IoJyxcbiAgICAgICAgQ09MT1JTID0ge1xuICAgICAgICAgICAgYWxpY2VibHVlOiBbMjQwLCAyNDgsIDI1NV0sXG4gICAgICAgICAgICBhbnRpcXVld2hpdGU6IFsyNTAsIDIzNSwgMjE1XSxcbiAgICAgICAgICAgIGFxdWE6IFswLCAyNTUsIDI1NV0sXG4gICAgICAgICAgICBhcXVhbWFyaW5lOiBbMTI3LCAyNTUsIDIxMl0sXG4gICAgICAgICAgICBhenVyZTogWzI0MCwgMjU1LCAyNTVdLFxuICAgICAgICAgICAgYmVpZ2U6IFsyNDUsIDI0NSwgMjIwXSxcbiAgICAgICAgICAgIGJpc3F1ZTogWzI1NSwgMjI4LCAxOTZdLFxuICAgICAgICAgICAgYmxhY2s6IFswLCAwLCAwXSxcbiAgICAgICAgICAgIGJsYW5jaGVkYWxtb25kOiBbMjU1LCAyMzUsIDIwNV0sXG4gICAgICAgICAgICBibHVlOiBbMCwgMCwgMjU1XSxcbiAgICAgICAgICAgIGJsdWV2aW9sZXQ6IFsxMzgsIDQzLCAyMjZdLFxuICAgICAgICAgICAgYnJvd246IFsxNjUsIDQyLCA0Ml0sXG4gICAgICAgICAgICBidXJseXdvb2Q6IFsyMjIsIDE4NCwgMTM1XSxcbiAgICAgICAgICAgIGNhZGV0Ymx1ZTogWzk1LCAxNTgsIDE2MF0sXG4gICAgICAgICAgICBjaGFydHJldXNlOiBbMTI3LCAyNTUsIDBdLFxuICAgICAgICAgICAgY2hvY29sYXRlOiBbMjEwLCAxMDUsIDMwXSxcbiAgICAgICAgICAgIGNvcmFsOiBbMjU1LCAxMjcsIDgwXSxcbiAgICAgICAgICAgIGNvcm5mbG93ZXJibHVlOiBbMTAwLCAxNDksIDIzN10sXG4gICAgICAgICAgICBjb3Juc2lsazogWzI1NSwgMjQ4LCAyMjBdLFxuICAgICAgICAgICAgY3JpbXNvbjogWzIyMCwgMjAsIDYwXSxcbiAgICAgICAgICAgIGN5YW46IFswLCAyNTUsIDI1NV0sXG4gICAgICAgICAgICBkYXJrYmx1ZTogWzAsIDAsIDEzOV0sXG4gICAgICAgICAgICBkYXJrY3lhbjogWzAsIDEzOSwgMTM5XSxcbiAgICAgICAgICAgIGRhcmtnb2xkZW5yb2Q6IFsxODQsIDEzMiwgMTFdLFxuICAgICAgICAgICAgZGFya2dyYXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgICAgICAgICAgIGRhcmtncmVlbjogWzAsIDEwMCwgMF0sXG4gICAgICAgICAgICBkYXJrZ3JleTogWzE2OSwgMTY5LCAxNjldLFxuICAgICAgICAgICAgZGFya2toYWtpOiBbMTg5LCAxODMsIDEwN10sXG4gICAgICAgICAgICBkYXJrbWFnZW50YTogWzEzOSwgMCwgMTM5XSxcbiAgICAgICAgICAgIGRhcmtvbGl2ZWdyZWVuOiBbODUsIDEwNywgNDddLFxuICAgICAgICAgICAgZGFya29yYW5nZTogWzI1NSwgMTQwLCAwXSxcbiAgICAgICAgICAgIGRhcmtvcmNoaWQ6IFsxNTMsIDUwLCAyMDRdLFxuICAgICAgICAgICAgZGFya3JlZDogWzEzOSwgMCwgMF0sXG4gICAgICAgICAgICBkYXJrc2FsbW9uOiBbMjMzLCAxNTAsIDEyMl0sXG4gICAgICAgICAgICBkYXJrc2VhZ3JlZW46IFsxNDMsIDE4OCwgMTQzXSxcbiAgICAgICAgICAgIGRhcmtzbGF0ZWJsdWU6IFs3MiwgNjEsIDEzOV0sXG4gICAgICAgICAgICBkYXJrc2xhdGVncmF5OiBbNDcsIDc5LCA3OV0sXG4gICAgICAgICAgICBkYXJrc2xhdGVncmV5OiBbNDcsIDc5LCA3OV0sXG4gICAgICAgICAgICBkYXJrdHVycXVvaXNlOiBbMCwgMjA2LCAyMDldLFxuICAgICAgICAgICAgZGFya3Zpb2xldDogWzE0OCwgMCwgMjExXSxcbiAgICAgICAgICAgIGRlZXBwaW5rOiBbMjU1LCAyMCwgMTQ3XSxcbiAgICAgICAgICAgIGRlZXBza3libHVlOiBbMCwgMTkxLCAyNTVdLFxuICAgICAgICAgICAgZGltZ3JheTogWzEwNSwgMTA1LCAxMDVdLFxuICAgICAgICAgICAgZGltZ3JleTogWzEwNSwgMTA1LCAxMDVdLFxuICAgICAgICAgICAgZG9kZ2VyYmx1ZTogWzMwLCAxNDQsIDI1NV0sXG4gICAgICAgICAgICBmaXJlYnJpY2s6IFsxNzgsIDM0LCAzNF0sXG4gICAgICAgICAgICBmbG9yYWx3aGl0ZTogWzI1NSwgMjU1LCAyNDBdLFxuICAgICAgICAgICAgZm9yZXN0Z3JlZW46IFszNCwgMTM5LCAzNF0sXG4gICAgICAgICAgICBmdWNoc2lhOiBbMjU1LCAwLCAyNTVdLFxuICAgICAgICAgICAgZ2FpbnNib3JvOiBbMjIwLCAyMjAsIDIyMF0sXG4gICAgICAgICAgICBnaG9zdHdoaXRlOiBbMjQ4LCAyNDgsIDI1NV0sXG4gICAgICAgICAgICBnb2xkOiBbMjU1LCAyMTUsIDBdLFxuICAgICAgICAgICAgZ29sZGVucm9kOiBbMjE4LCAxNjUsIDMyXSxcbiAgICAgICAgICAgIGdyYXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgICAgICAgICAgIGdyZWVuOiBbMCwgMTI4LCAwXSxcbiAgICAgICAgICAgIGdyZWVueWVsbG93OiBbMTczLCAyNTUsIDQ3XSxcbiAgICAgICAgICAgIGdyZXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgICAgICAgICAgIGhvbmV5ZGV3OiBbMjQwLCAyNTUsIDI0MF0sXG4gICAgICAgICAgICBob3RwaW5rOiBbMjU1LCAxMDUsIDE4MF0sXG4gICAgICAgICAgICBpbmRpYW5yZWQ6IFsyMDUsIDkyLCA5Ml0sXG4gICAgICAgICAgICBpbmRpZ286IFs3NSwgMCwgMTMwXSxcbiAgICAgICAgICAgIGl2b3J5OiBbMjU1LCAyNTUsIDI0MF0sXG4gICAgICAgICAgICBraGFraTogWzI0MCwgMjMwLCAxNDBdLFxuICAgICAgICAgICAgbGF2ZW5kZXI6IFsyMzAsIDIzMCwgMjUwXSxcbiAgICAgICAgICAgIGxhdmVuZGVyYmx1c2g6IFsyNTUsIDI0MCwgMjQ1XSxcbiAgICAgICAgICAgIGxhd25ncmVlbjogWzEyNCwgMjUyLCAwXSxcbiAgICAgICAgICAgIGxlbW9uY2hpZmZvbjogWzI1NSwgMjUwLCAyMDVdLFxuICAgICAgICAgICAgbGlnaHRibHVlOiBbMTczLCAyMTYsIDIzMF0sXG4gICAgICAgICAgICBsaWdodGNvcmFsOiBbMjQwLCAxMjgsIDEyOF0sXG4gICAgICAgICAgICBsaWdodGN5YW46IFsyMjQsIDI1NSwgMjU1XSxcbiAgICAgICAgICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiBbMjUwLCAyNTAsIDIxMF0sXG4gICAgICAgICAgICBsaWdodGdyYXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgICAgICAgICAgIGxpZ2h0Z3JlZW46IFsxNDQsIDIzOCwgMTQ0XSxcbiAgICAgICAgICAgIGxpZ2h0Z3JleTogWzIxMSwgMjExLCAyMTFdLFxuICAgICAgICAgICAgbGlnaHRwaW5rOiBbMjU1LCAxODIsIDE5M10sXG4gICAgICAgICAgICBsaWdodHNhbG1vbjogWzI1NSwgMTYwLCAxMjJdLFxuICAgICAgICAgICAgbGlnaHRzZWFncmVlbjogWzMyLCAxNzgsIDE3MF0sXG4gICAgICAgICAgICBsaWdodHNreWJsdWU6IFsxMzUsIDIwNiwgMjUwXSxcbiAgICAgICAgICAgIGxpZ2h0c2xhdGVncmF5OiBbMTE5LCAxMzYsIDE1M10sXG4gICAgICAgICAgICBsaWdodHNsYXRlZ3JleTogWzExOSwgMTM2LCAxNTNdLFxuICAgICAgICAgICAgbGlnaHRzdGVlbGJsdWU6IFsxNzYsIDE5NiwgMjIyXSxcbiAgICAgICAgICAgIGxpZ2h0eWVsbG93OiBbMjU1LCAyNTUsIDIyNF0sXG4gICAgICAgICAgICBsaW1lOiBbMCwgMjU1LCAwXSxcbiAgICAgICAgICAgIGxpbWVncmVlbjogWzUwLCAyMDUsIDUwXSxcbiAgICAgICAgICAgIGxpbmVuOiBbMjUwLCAyNDAsIDIzMF0sXG4gICAgICAgICAgICBtYWdlbnRhOiBbMjU1LCAwLCAyNTVdLFxuICAgICAgICAgICAgbWFyb29uOiBbMTI4LCAwLCAwXSxcbiAgICAgICAgICAgIG1lZGl1bWFxdWFtYXJpbmU6IFsxMDIsIDIwNSwgMTcwXSxcbiAgICAgICAgICAgIG1lZGl1bWJsdWU6IFswLCAwLCAyMDVdLFxuICAgICAgICAgICAgbWVkaXVtb3JjaGlkOiBbMTg2LCA4NSwgMjExXSxcbiAgICAgICAgICAgIG1lZGl1bXB1cnBsZTogWzE0NywgMTEyLCAyMTldLFxuICAgICAgICAgICAgbWVkaXVtc2VhZ3JlZW46IFs2MCwgMTc5LCAxMTNdLFxuICAgICAgICAgICAgbWVkaXVtc2xhdGVibHVlOiBbMTIzLCAxMDQsIDIzOF0sXG4gICAgICAgICAgICBtZWRpdW1zcHJpbmdncmVlbjogWzAsIDI1MCwgMTU0XSxcbiAgICAgICAgICAgIG1lZGl1bXR1cnF1b2lzZTogWzcyLCAyMDksIDIwNF0sXG4gICAgICAgICAgICBtZWRpdW12aW9sZXRyZWQ6IFsxOTksIDIxLCAxMzNdLFxuICAgICAgICAgICAgbWlkbmlnaHRibHVlOiBbMjUsIDI1LCAxMTJdLFxuICAgICAgICAgICAgbWludGNyZWFtOiBbMjQ1LCAyNTUsIDI1MF0sXG4gICAgICAgICAgICBtaXN0eXJvc2U6IFsyNTUsIDIyOCwgMjI1XSxcbiAgICAgICAgICAgIG1vY2Nhc2luOiBbMjU1LCAyMjgsIDE4MV0sXG4gICAgICAgICAgICBuYXZham93aGl0ZTogWzI1NSwgMjIyLCAxNzNdLFxuICAgICAgICAgICAgbmF2eTogWzAsIDAsIDEyOF0sXG4gICAgICAgICAgICBvbGRsYWNlOiBbMjUzLCAyNDUsIDIzMF0sXG4gICAgICAgICAgICBvbGl2ZTogWzEyOCwgMTI4LCAwXSxcbiAgICAgICAgICAgIG9saXZlZHJhYjogWzEwNywgMTQyLCAzNV0sXG4gICAgICAgICAgICBvcmFuZ2U6IFsyNTUsIDE2NSwgMF0sXG4gICAgICAgICAgICBvcmFuZ2VyZWQ6IFsyNTUsIDY5LCAwXSxcbiAgICAgICAgICAgIG9yY2hpZDogWzIxOCwgMTEyLCAyMTRdLFxuICAgICAgICAgICAgcGFsZWdvbGRlbnJvZDogWzIzOCwgMjMyLCAxNzBdLFxuICAgICAgICAgICAgcGFsZWdyZWVuOiBbMTUyLCAyNTEsIDE1Ml0sXG4gICAgICAgICAgICBwYWxldHVycXVvaXNlOiBbMTc1LCAyMzgsIDIzOF0sXG4gICAgICAgICAgICBwYWxldmlvbGV0cmVkOiBbMjE5LCAxMTIsIDE0N10sXG4gICAgICAgICAgICBwYXBheWF3aGlwOiBbMjU1LCAyMzksIDIxM10sXG4gICAgICAgICAgICBwZWFjaHB1ZmY6IFsyNTUsIDIxOCwgMTg1XSxcbiAgICAgICAgICAgIHBlcnU6IFsyMDUsIDEzMywgNjNdLFxuICAgICAgICAgICAgcGluazogWzI1NSwgMTkyLCAyMDNdLFxuICAgICAgICAgICAgcGx1bTogWzIyMSwgMTYwLCAyMDNdLFxuICAgICAgICAgICAgcG93ZGVyYmx1ZTogWzE3NiwgMjI0LCAyMzBdLFxuICAgICAgICAgICAgcHVycGxlOiBbMTI4LCAwLCAxMjhdLFxuICAgICAgICAgICAgcmViZWNjYXB1cnBsZTogWzEwMiwgNTEsIDE1M10sXG4gICAgICAgICAgICByZWQ6IFsyNTUsIDAsIDBdLFxuICAgICAgICAgICAgcm9zeWJyb3duOiBbMTg4LCAxNDMsIDE0M10sXG4gICAgICAgICAgICByb3lhbGJsdWU6IFs2NSwgMTA1LCAyMjVdLFxuICAgICAgICAgICAgc2FkZGxlYnJvd246IFsxMzksIDY5LCAxOV0sXG4gICAgICAgICAgICBzYWxtb246IFsyNTAsIDEyOCwgMTE0XSxcbiAgICAgICAgICAgIHNhbmR5YnJvd246IFsyNDQsIDE2NCwgOTZdLFxuICAgICAgICAgICAgc2VhZ3JlZW46IFs0NiwgMTM5LCA4N10sXG4gICAgICAgICAgICBzZWFzaGVsbDogWzI1NSwgMjQ1LCAyMzhdLFxuICAgICAgICAgICAgc2llbm5hOiBbMTYwLCA4MiwgNDVdLFxuICAgICAgICAgICAgc2lsdmVyOiBbMTkyLCAxOTIsIDE5Ml0sXG4gICAgICAgICAgICBza3libHVlOiBbMTM1LCAyMDYsIDIzNV0sXG4gICAgICAgICAgICBzbGF0ZWJsdWU6IFsxMDYsIDkwLCAyMDVdLFxuICAgICAgICAgICAgc2xhdGVncmF5OiBbMTE5LCAxMjgsIDE0NF0sXG4gICAgICAgICAgICBzbGF0ZWdyZXk6IFsxMTksIDEyOCwgMTQ0XSxcbiAgICAgICAgICAgIHNub3c6IFsyNTUsIDI1NSwgMjUwXSxcbiAgICAgICAgICAgIHNwcmluZ2dyZWVuOiBbMCwgMjU1LCAxMjddLFxuICAgICAgICAgICAgc3RlZWxibHVlOiBbNzAsIDEzMCwgMTgwXSxcbiAgICAgICAgICAgIHRhbjogWzIxMCwgMTgwLCAxNDBdLFxuICAgICAgICAgICAgdGVhbDogWzAsIDEyOCwgMTI4XSxcbiAgICAgICAgICAgIHRoaXN0bGU6IFsyMTYsIDE5MSwgMjE2XSxcbiAgICAgICAgICAgIHRyYW5zcGFyZW50OiBbMjU1LCAyNTUsIDI1NSwgMF0sXG4gICAgICAgICAgICB0b21hdG86IFsyNTUsIDk5LCA3MV0sXG4gICAgICAgICAgICB0dXJxdW9pc2U6IFs2NCwgMjI0LCAyMDhdLFxuICAgICAgICAgICAgdmlvbGV0OiBbMjM4LCAxMzAsIDIzOF0sXG4gICAgICAgICAgICB3aGVhdDogWzI0NSwgMjIyLCAxNzldLFxuICAgICAgICAgICAgd2hpdGU6IFsyNTUsIDI1NSwgMjU1XSxcbiAgICAgICAgICAgIHdoaXRlc21va2U6IFsyNDUsIDI0NSwgMjQ1XSxcbiAgICAgICAgICAgIHllbGxvdzogWzI1NSwgMjU1LCAwXSxcbiAgICAgICAgICAgIHllbGxvd2dyZWVuOiBbMTU0LCAyMDUsIDVdXG4gICAgICAgIH0sXG5cbiAgICAgICAgUkdCX1JFR0VYID0gL3JnYlxcKChcXGR7MSwzfSksKFxcZHsxLDN9KSwoXFxkezEsM30pXFwpLztcblxuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2UgVXRpbFxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqL1xuICAgIEtvbnZhLlV0aWwgPSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIGNoZXJyeS1waWNrZWQgdXRpbGl0aWVzIGZyb20gdW5kZXJzY29yZS5qc1xuICAgICAgICAgKi9cbiAgICAgICAgX2lzRWxlbWVudDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PSAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2lzRnVuY3Rpb246IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuICEhKG9iaiAmJiBvYmouY29uc3RydWN0b3IgJiYgb2JqLmNhbGwgJiYgb2JqLmFwcGx5KTtcbiAgICAgICAgfSxcbiAgICAgICAgX2lzT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHJldHVybiAoISFvYmogJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3QpO1xuICAgICAgICB9LFxuICAgICAgICBfaXNBcnJheTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9BUlJBWTtcbiAgICAgICAgfSxcbiAgICAgICAgX2lzTnVtYmVyOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gT0JKRUNUX05VTUJFUjtcbiAgICAgICAgfSxcbiAgICAgICAgX2lzU3RyaW5nOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gT0JKRUNUX1NUUklORztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmNlXG4gICAgICAgIC8vIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLiBOb3JtYWxseSwgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsIHJ1blxuICAgICAgICAvLyBhcyBtdWNoIGFzIGl0IGNhbiwgd2l0aG91dCBldmVyIGdvaW5nIG1vcmUgdGhhbiBvbmNlIHBlciBgd2FpdGAgZHVyYXRpb247XG4gICAgICAgIC8vIGJ1dCBpZiB5b3UnZCBsaWtlIHRvIGRpc2FibGUgdGhlIGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlLCBwYXNzXG4gICAgICAgIC8vIGB7bGVhZGluZzogZmFsc2V9YC4gVG8gZGlzYWJsZSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2UsIGRpdHRvLlxuICAgICAgICBfdGhyb3R0bGU6IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdHMpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0LCBhcmdzLCByZXN1bHQ7XG4gICAgICAgICAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBvcHRzIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICAgICAgICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLypcbiAgICAgICAgICogb3RoZXIgdXRpbHNcbiAgICAgICAgICovXG4gICAgICAgIF9oYXNNZXRob2RzOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHZhciBuYW1lcyA9IFtdLFxuICAgICAgICAgICAgICAgIGtleTtcblxuICAgICAgICAgICAgZm9yKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZih0aGlzLl9pc0Z1bmN0aW9uKG9ialtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5hbWVzLmxlbmd0aCA+IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGlzVmFsaWRTZWxlY3RvcjogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZpcnN0Q2hhciA9IHNlbGVjdG9yWzBdO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0Q2hhciA9PT0gJyMnIHx8IGZpcnN0Q2hhciA9PT0gJy4nIHx8IGZpcnN0Q2hhciA9PT0gZmlyc3RDaGFyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZUNhbnZhc0VsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IEtvbnZhLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgLy8gb24gc29tZSBlbnZpcm9ubWVudHMgY2FudmFzLnN0eWxlIGlzIHJlYWRvbmx5XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhbnZhcy5zdHlsZSA9IGNhbnZhcy5zdHlsZSB8fCB7fTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICAgIH0sXG4gICAgICAgIGlzQnJvd3NlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiBleHBvcnRzICE9PSAnb2JqZWN0Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9pc0luRG9jdW1lbnQ6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICB3aGlsZShlbCA9IGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZihlbCA9PSBLb252YS5kb2N1bWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIF9zaW1wbGlmeUFycmF5OiBmdW5jdGlvbihhcnIpIHtcbiAgICAgICAgICAgIHZhciByZXRBcnIgPSBbXSxcbiAgICAgICAgICAgICAgICBsZW4gPSBhcnIubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHV0aWwgPSBLb252YS5VdGlsLFxuICAgICAgICAgICAgICAgIG4sIHZhbDtcblxuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gYXJyW25dO1xuICAgICAgICAgICAgICAgIGlmICh1dGlsLl9pc051bWJlcih2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IE1hdGgucm91bmQodmFsICogMTAwMCkgLyAxMDAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdXRpbC5faXNTdHJpbmcodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWwudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCh2YWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICB9LFxuICAgICAgICAvKlxuICAgICAgICAgKiBhcmcgY2FuIGJlIGFuIGltYWdlIG9iamVjdCBvciBpbWFnZSBkYXRhXG4gICAgICAgICAqL1xuICAgICAgICBfZ2V0SW1hZ2U6IGZ1bmN0aW9uKGFyZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpbWFnZU9iaiwgY2FudmFzO1xuXG4gICAgICAgICAgICAvLyBpZiBhcmcgaXMgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmKCFhcmcpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgYXJnIGlzIGFscmVhZHkgYW4gaW1hZ2Ugb2JqZWN0XG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMuX2lzRWxlbWVudChhcmcpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soYXJnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgYXJnIGlzIGEgc3RyaW5nLCB0aGVuIGl0J3MgYSBkYXRhIHVybFxuICAgICAgICAgICAgZWxzZSBpZih0aGlzLl9pc1N0cmluZyhhcmcpKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VPYmogPSBuZXcgS29udmEud2luZG93LkltYWdlKCk7XG4gICAgICAgICAgICAgICAgaW1hZ2VPYmoub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGltYWdlT2JqKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGltYWdlT2JqLnNyYyA9IGFyZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9pZiBhcmcgaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGRhdGEgcHJvcGVydHksIGl0J3MgYW4gaW1hZ2Ugb2JqZWN0XG4gICAgICAgICAgICBlbHNlIGlmKGFyZy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzID0gS29udmEuVXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gYXJnLndpZHRoO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBhcmcuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBfY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KENPTlRFWFRfMkQpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LnB1dEltYWdlRGF0YShhcmcsIDAsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dldEltYWdlKGNhbnZhcy50b0RhdGFVUkwoKSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRSR0JBU3RyaW5nOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHZhciByZWQgPSBvYmoucmVkIHx8IDAsXG4gICAgICAgICAgICAgICAgZ3JlZW4gPSBvYmouZ3JlZW4gfHwgMCxcbiAgICAgICAgICAgICAgICBibHVlID0gb2JqLmJsdWUgfHwgMCxcbiAgICAgICAgICAgICAgICBhbHBoYSA9IG9iai5hbHBoYSB8fCAxO1xuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICdyZ2JhKCcsXG4gICAgICAgICAgICAgICAgcmVkLFxuICAgICAgICAgICAgICAgICcsJyxcbiAgICAgICAgICAgICAgICBncmVlbixcbiAgICAgICAgICAgICAgICAnLCcsXG4gICAgICAgICAgICAgICAgYmx1ZSxcbiAgICAgICAgICAgICAgICAnLCcsXG4gICAgICAgICAgICAgICAgYWxwaGEsXG4gICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICBdLmpvaW4oRU1QVFlfU1RSSU5HKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3JnYlRvSGV4OiBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gKCgxIDw8IDI0KSArIChyIDw8IDE2KSArIChnIDw8IDgpICsgYikudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuICAgICAgICB9LFxuICAgICAgICBfaGV4VG9SZ2I6IGZ1bmN0aW9uKGhleCkge1xuICAgICAgICAgICAgaGV4ID0gaGV4LnJlcGxhY2UoSEFTSCwgRU1QVFlfU1RSSU5HKTtcbiAgICAgICAgICAgIHZhciBiaWdpbnQgPSBwYXJzZUludChoZXgsIDE2KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcjogKGJpZ2ludCA+PiAxNikgJiAyNTUsXG4gICAgICAgICAgICAgICAgZzogKGJpZ2ludCA+PiA4KSAmIDI1NSxcbiAgICAgICAgICAgICAgICBiOiBiaWdpbnQgJiAyNTVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXR1cm4gcmFuZG9tIGhleCBjb2xvclxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5VdGlsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0UmFuZG9tQ29sb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJhbmRDb2xvciA9IChNYXRoLnJhbmRvbSgpICogMHhGRkZGRkYgPDwgMCkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgd2hpbGUgKHJhbmRDb2xvci5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgICAgICAgcmFuZENvbG9yID0gWkVSTyArIHJhbmRDb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBIQVNIICsgcmFuZENvbG9yO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJuIHZhbHVlIHdpdGggZGVmYXVsdCBmYWxsYmFja1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5VdGlsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbih2YWwsIGRlZikge1xuICAgICAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgUkdCIGNvbXBvbmVudHMgb2YgYSBjb2xvclxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5VdGlsLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3JcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gZWFjaCBvZiB0aGUgZm9sbG93aW5nIGV4YW1wbGVzIHJldHVybiB7cjowLCBnOjAsIGI6MjU1fVxuICAgICAgICAgKiB2YXIgcmdiID0gS29udmEuVXRpbC5nZXRSR0IoJ2JsdWUnKTtcbiAgICAgICAgICogdmFyIHJnYiA9IEtvbnZhLlV0aWwuZ2V0UkdCKCcjMDAwMGZmJyk7XG4gICAgICAgICAqIHZhciByZ2IgPSBLb252YS5VdGlsLmdldFJHQigncmdiKDAsMCwyNTUpJyk7XG4gICAgICAgICAqL1xuICAgICAgICBnZXRSR0I6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICB2YXIgcmdiO1xuICAgICAgICAgICAgLy8gY29sb3Igc3RyaW5nXG4gICAgICAgICAgICBpZiAoY29sb3IgaW4gQ09MT1JTKSB7XG4gICAgICAgICAgICAgICAgcmdiID0gQ09MT1JTW2NvbG9yXTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByOiByZ2JbMF0sXG4gICAgICAgICAgICAgICAgICAgIGc6IHJnYlsxXSxcbiAgICAgICAgICAgICAgICAgICAgYjogcmdiWzJdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhleFxuICAgICAgICAgICAgZWxzZSBpZiAoY29sb3JbMF0gPT09IEhBU0gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGV4VG9SZ2IoY29sb3Iuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJnYiBzdHJpbmdcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbG9yLnN1YnN0cigwLCA0KSA9PT0gUkdCX1BBUkVOKSB7XG4gICAgICAgICAgICAgICAgcmdiID0gUkdCX1JFR0VYLmV4ZWMoY29sb3IucmVwbGFjZSgvIC9nLCAnJykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHI6IHBhcnNlSW50KHJnYlsxXSwgMTApLFxuICAgICAgICAgICAgICAgICAgICBnOiBwYXJzZUludChyZ2JbMl0sIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgYjogcGFyc2VJbnQocmdiWzNdLCAxMClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVmYXVsdFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcjogMCxcbiAgICAgICAgICAgICAgICAgICAgZzogMCxcbiAgICAgICAgICAgICAgICAgICAgYjogMFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGNvbnZlcnQgYW55IGNvbG9yIHN0cmluZyB0byBSR0JBIG9iamVjdFxuICAgICAgICAvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jb21wb25lbnQvY29sb3ItcGFyc2VyXG4gICAgICAgIGNvbG9yVG9SR0JBOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ciB8fCAnYmxhY2snO1xuICAgICAgICAgICAgcmV0dXJuIEtvbnZhLlV0aWwuX25hbWVkQ29sb3JUb1JCQShzdHIpXG4gICAgICAgICAgICAgICAgfHwgS29udmEuVXRpbC5faGV4M0NvbG9yVG9SR0JBKHN0cilcbiAgICAgICAgICAgICAgICB8fCBLb252YS5VdGlsLl9oZXg2Q29sb3JUb1JHQkEoc3RyKVxuICAgICAgICAgICAgICAgIHx8IEtvbnZhLlV0aWwuX3JnYkNvbG9yVG9SR0JBKHN0cilcbiAgICAgICAgICAgICAgICB8fCBLb252YS5VdGlsLl9yZ2JhQ29sb3JUb1JHQkEoc3RyKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUGFyc2UgbmFtZWQgY3NzIGNvbG9yLiBMaWtlIFwiZ3JlZW5cIlxuICAgICAgICBfbmFtZWRDb2xvclRvUkJBOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHZhciBjID0gQ09MT1JTW3N0ci50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgIGlmICghYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByOiBjWzBdLFxuICAgICAgICAgICAgICAgIGc6IGNbMV0sXG4gICAgICAgICAgICAgICAgYjogY1syXSxcbiAgICAgICAgICAgICAgICBhOiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvLyBQYXJzZSByZ2IobiwgbiwgbilcbiAgICAgICAgX3JnYkNvbG9yVG9SR0JBOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIGlmIChzdHIuaW5kZXhPZigncmdiKCcpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLm1hdGNoKC9yZ2JcXCgoW14pXSspXFwpLylbMV07XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KC8gKiwgKi8pLm1hcChOdW1iZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHI6IHBhcnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICBnOiBwYXJ0c1sxXSxcbiAgICAgICAgICAgICAgICAgICAgYjogcGFydHNbMl0sXG4gICAgICAgICAgICAgICAgICAgIGE6IDFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBQYXJzZSByZ2JhKG4sIG4sIG4sIG4pXG4gICAgICAgIF9yZ2JhQ29sb3JUb1JHQkE6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgaWYgKHN0ci5pbmRleE9mKCdyZ2JhKCcpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLm1hdGNoKC9yZ2JhXFwoKFteKV0rKVxcKS8pWzFdO1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgvICosICovKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByOiBwYXJ0c1swXSxcbiAgICAgICAgICAgICAgICAgICAgZzogcGFydHNbMV0sXG4gICAgICAgICAgICAgICAgICAgIGI6IHBhcnRzWzJdLFxuICAgICAgICAgICAgICAgICAgICBhOiBwYXJ0c1szXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcbiAgICAgICAgLy8gUGFyc2UgI25ubm5ublxuICAgICAgICBfaGV4NkNvbG9yVG9SR0JBOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIGlmICgoc3RyWzBdID09PSAnIycpICYmIChzdHIubGVuZ3RoID09PSA3KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHI6IHBhcnNlSW50KHN0ci5zbGljZSgxLCAzKSwgMTYpLFxuICAgICAgICAgICAgICAgICAgICBnOiBwYXJzZUludChzdHIuc2xpY2UoMywgNSksIDE2KSxcbiAgICAgICAgICAgICAgICAgICAgYjogcGFyc2VJbnQoc3RyLnNsaWNlKDUsIDcpLCAxNiksXG4gICAgICAgICAgICAgICAgICAgIGE6IDFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBQYXJzZSAjbm5uXG4gICAgICAgIF9oZXgzQ29sb3JUb1JHQkE6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgaWYgKChzdHJbMF0gPT09ICcjJykgJiYgKHN0ci5sZW5ndGggPT09IDQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcjogcGFyc2VJbnQoc3RyWzFdICsgc3RyWzFdLCAxNiksXG4gICAgICAgICAgICAgICAgICAgIGc6IHBhcnNlSW50KHN0clsyXSArIHN0clsyXSwgMTYpLFxuICAgICAgICAgICAgICAgICAgICBiOiBwYXJzZUludChzdHJbM10gKyBzdHJbM10sIDE2KSxcbiAgICAgICAgICAgICAgICAgICAgYTogMVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIG8xIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBvMlxuICAgICAgICBfbWVyZ2U6IGZ1bmN0aW9uKG8xLCBvMikge1xuICAgICAgICAgICAgdmFyIHJldE9iaiA9IHRoaXMuX2Nsb25lKG8yKTtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIG8xKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5faXNPYmplY3QobzFba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0T2JqW2tleV0gPSB0aGlzLl9tZXJnZShvMVtrZXldLCByZXRPYmpba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXRPYmpba2V5XSA9IG8xW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldE9iajtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvbmVPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgdmFyIHJldE9iaiA9IHt9O1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5faXNPYmplY3Qob2JqW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldE9ialtrZXldID0gdGhpcy5jbG9uZU9iamVjdChvYmpba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzQXJyYXkob2JqW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldE9ialtrZXldID0gdGhpcy5jbG9uZUFycmF5KG9ialtrZXldKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXRPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXRPYmo7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb25lQXJyYXk6IGZ1bmN0aW9uKGFycikge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5zbGljZSgwKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2RlZ1RvUmFkOiBmdW5jdGlvbihkZWcpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWcgKiBQSV9PVkVSX0RFRzE4MDtcbiAgICAgICAgfSxcbiAgICAgICAgX3JhZFRvRGVnOiBmdW5jdGlvbihyYWQpIHtcbiAgICAgICAgICAgIHJldHVybiByYWQgKiBERUcxODBfT1ZFUl9QSTtcbiAgICAgICAgfSxcbiAgICAgICAgX2NhcGl0YWxpemU6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGhyb3c6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEtPTlZBX0VSUk9SICsgc3RyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoS09OVkFfRVJST1IgKyBzdHIpO1xuICAgICAgICB9LFxuICAgICAgICB3YXJuOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBJRTkgb24gV2luZG93czcgNjRiaXQgd2lsbCB0aHJvdyBhIEpTIGVycm9yXG4gICAgICAgICAgICAgKiBpZiB3ZSBkb24ndCB1c2Ugd2luZG93LmNvbnNvbGUgaW4gdGhlIGNvbmRpdGlvbmFsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmKEtvbnZhLmdsb2JhbC5jb25zb2xlICYmIGNvbnNvbGUud2FybiAmJiBLb252YS5zaG93V2FybmluZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oS09OVkFfV0FSTklORyArIHN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVuZDogZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gQ3RvcigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgICAgICAgICB2YXIgb2xkUHJvdG8gPSBjaGlsZC5wcm90b3R5cGU7XG4gICAgICAgICAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgQ3RvcigpO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9sZFByb3RvKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZFByb3RvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQucHJvdG90eXBlW2tleV0gPSBvbGRQcm90b1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgICAgICAgICAvLyBjcmVhdGUgcmVmZXJlbmNlIHRvIHBhcmVudFxuICAgICAgICAgICAgY2hpbGQuc3VwZXIgPSBwYXJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhZGRzIG1ldGhvZHMgdG8gYSBjb25zdHJ1Y3RvciBwcm90b3R5cGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVXRpbC5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1ldGhvZHNcbiAgICAgICAgICovXG4gICAgICAgIGFkZE1ldGhvZHM6IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBtZXRob2RzKSB7XG4gICAgICAgICAgICB2YXIga2V5O1xuXG4gICAgICAgICAgICBmb3IgKGtleSBpbiBtZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlW2tleV0gPSBtZXRob2RzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRDb250cm9sUG9pbnRzOiBmdW5jdGlvbih4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB0KSB7XG4gICAgICAgICAgICB2YXIgZDAxID0gTWF0aC5zcXJ0KE1hdGgucG93KHgxIC0geDAsIDIpICsgTWF0aC5wb3coeTEgLSB5MCwgMikpLFxuICAgICAgICAgICAgICAgIGQxMiA9IE1hdGguc3FydChNYXRoLnBvdyh4MiAtIHgxLCAyKSArIE1hdGgucG93KHkyIC0geTEsIDIpKSxcbiAgICAgICAgICAgICAgICBmYSA9IHQgKiBkMDEgLyAoZDAxICsgZDEyKSxcbiAgICAgICAgICAgICAgICBmYiA9IHQgKiBkMTIgLyAoZDAxICsgZDEyKSxcbiAgICAgICAgICAgICAgICBwMXggPSB4MSAtIGZhICogKHgyIC0geDApLFxuICAgICAgICAgICAgICAgIHAxeSA9IHkxIC0gZmEgKiAoeTIgLSB5MCksXG4gICAgICAgICAgICAgICAgcDJ4ID0geDEgKyBmYiAqICh4MiAtIHgwKSxcbiAgICAgICAgICAgICAgICBwMnkgPSB5MSArIGZiICogKHkyIC0geTApO1xuXG4gICAgICAgICAgICByZXR1cm4gW3AxeCwgcDF5LCBwMngsIHAyeV07XG4gICAgICAgIH0sXG4gICAgICAgIF9leHBhbmRQb2ludHM6IGZ1bmN0aW9uKHAsIHRlbnNpb24pIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBwLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBhbGxQb2ludHMgPSBbXSxcbiAgICAgICAgICAgICAgICBuLCBjcDtcblxuICAgICAgICAgICAgZm9yIChuID0gMjsgbiA8IGxlbiAtIDI7IG4gKz0gMikge1xuICAgICAgICAgICAgICAgIGNwID0gS29udmEuVXRpbC5fZ2V0Q29udHJvbFBvaW50cyhwW24gLSAyXSwgcFtuIC0gMV0sIHBbbl0sIHBbbiArIDFdLCBwW24gKyAyXSwgcFtuICsgM10sIHRlbnNpb24pO1xuICAgICAgICAgICAgICAgIGFsbFBvaW50cy5wdXNoKGNwWzBdKTtcbiAgICAgICAgICAgICAgICBhbGxQb2ludHMucHVzaChjcFsxXSk7XG4gICAgICAgICAgICAgICAgYWxsUG9pbnRzLnB1c2gocFtuXSk7XG4gICAgICAgICAgICAgICAgYWxsUG9pbnRzLnB1c2gocFtuICsgMV0pO1xuICAgICAgICAgICAgICAgIGFsbFBvaW50cy5wdXNoKGNwWzJdKTtcbiAgICAgICAgICAgICAgICBhbGxQb2ludHMucHVzaChjcFszXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhbGxQb2ludHM7XG4gICAgICAgIH0sXG4gICAgICAgIF9yZW1vdmVMYXN0TGV0dGVyOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgZWFjaDogZnVuY3Rpb24ob2JqLCBmdW5jKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgZnVuYyhrZXksIG9ialtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2dldFByb2plY3Rpb25Ub1NlZ21lbnQ6IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgICAgICAgIHZhciB4LCB5LCBkaXN0O1xuXG4gICAgICAgICAgICB2YXIgcGQyID0gKHgxIC0geDIpICogKHgxIC0geDIpICsgKHkxIC0geTIpICogKHkxIC0geTIpO1xuICAgICAgICAgICAgaWYocGQyID09IDApIHtcbiAgICAgICAgICAgICAgICB4ID0geDE7XG4gICAgICAgICAgICAgICAgeSA9IHkxO1xuICAgICAgICAgICAgICAgIGRpc3QgPSAoeDMgLSB4MikgKiAoeDMgLSB4MikgKyAoeTMgLSB5MikgKiAoeTMgLSB5Mik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB1ID0gKCh4MyAtIHgxKSAqICh4MiAtIHgxKSArICh5MyAtIHkxKSAqICh5MiAtIHkxKSkgLyBwZDI7XG4gICAgICAgICAgICAgICAgaWYodSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHgxO1xuICAgICAgICAgICAgICAgICAgICB5ID0geTE7XG4gICAgICAgICAgICAgICAgICAgIGRpc3QgPSAoeDEgLSB4MykgKiAoeDEgLSB4MykgKyAoeTEgLSB5MykgKiAoeTEgLSB5Myk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh1ID4gMS4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSB4MjtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHkyO1xuICAgICAgICAgICAgICAgICAgICBkaXN0ID0gKHgyIC0geDMpICogKHgyIC0geDMpICsgKHkyIC0geTMpICogKHkyIC0geTMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSB4MSArIHUgKiAoeDIgLSB4MSk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB5MSArIHUgKiAoeTIgLSB5MSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3QgPSAoeCAtIHgzKSAqICh4IC0geDMpICsgKHkgLSB5MykgKiAoeSAtIHkzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3gsIHksIGRpc3RdO1xuICAgICAgICB9LFxuICAgICAgICAvLyBsaW5lIGFzIGFycmF5IG9mIHBvaW50cy5cbiAgICAgICAgLy8gbGluZSBtaWdodCBiZSBjbG9zZWRcbiAgICAgICAgX2dldFByb2plY3Rpb25Ub0xpbmU6IGZ1bmN0aW9uKHB0LCBsaW5lLCBpc0Nsb3NlZCkge1xuICAgICAgICAgICAgdmFyIHBjID0gS29udmEuVXRpbC5jbG9uZU9iamVjdChwdCk7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICBsaW5lLmZvckVhY2goZnVuY3Rpb24ocDEsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ2xvc2VkICYmIGkgPT09IGxpbmUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwMiA9IGxpbmVbKGkgKyAxKSAlIGxpbmUubGVuZ3RoXTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvaiA9IEtvbnZhLlV0aWwuX2dldFByb2plY3Rpb25Ub1NlZ21lbnQocDEueCwgcDEueSwgcDIueCwgcDIueSwgcHQueCwgcHQueSk7XG4gICAgICAgICAgICAgICAgdmFyIHB4ID0gcHJvalswXSwgcHkgPSBwcm9qWzFdLCBwZGlzdCA9IHByb2pbMl07XG4gICAgICAgICAgICAgICAgaWYgKHBkaXN0IDwgZGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBwYy54ID0gcHg7XG4gICAgICAgICAgICAgICAgICAgIHBjLnkgPSBweTtcbiAgICAgICAgICAgICAgICAgICAgZGlzdCA9IHBkaXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBjO1xuICAgICAgICB9LFxuICAgICAgICBfcHJlcGFyZUFycmF5Rm9yVHdlZW46IGZ1bmN0aW9uKHN0YXJ0QXJyYXksIGVuZEFycmF5LCBpc0Nsb3NlZCkge1xuICAgICAgICAgICAgdmFyIG4sIHN0YXJ0ID0gW10sIGVuZCA9IFtdO1xuICAgICAgICAgICAgaWYgKHN0YXJ0QXJyYXkubGVuZ3RoID4gZW5kQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBlbmRBcnJheTtcbiAgICAgICAgICAgICAgICBlbmRBcnJheSA9IHN0YXJ0QXJyYXk7XG4gICAgICAgICAgICAgICAgc3RhcnRBcnJheSA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgc3RhcnRBcnJheS5sZW5ndGg7IG4gKz0gMikge1xuICAgICAgICAgICAgICAgIHN0YXJ0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB4OiBzdGFydEFycmF5W25dLFxuICAgICAgICAgICAgICAgICAgICB5OiBzdGFydEFycmF5W24gKyAxXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IGVuZEFycmF5Lmxlbmd0aDsgbiArPSAyKSB7XG4gICAgICAgICAgICAgICAgZW5kLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB4OiBlbmRBcnJheVtuXSxcbiAgICAgICAgICAgICAgICAgICAgeTogZW5kQXJyYXlbbiArIDFdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgdmFyIG5ld1N0YXJ0ID0gW107XG4gICAgICAgICAgICBlbmQuZm9yRWFjaChmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgICAgIHZhciBwciA9IEtvbnZhLlV0aWwuX2dldFByb2plY3Rpb25Ub0xpbmUocG9pbnQsIHN0YXJ0LCBpc0Nsb3NlZCk7XG4gICAgICAgICAgICAgICAgbmV3U3RhcnQucHVzaChwci54KTtcbiAgICAgICAgICAgICAgICBuZXdTdGFydC5wdXNoKHByLnkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3U3RhcnQ7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBjYWxjdWxhdGUgcGl4ZWwgcmF0aW9cbiAgICB2YXIgY2FudmFzID0gS29udmEuVXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCksXG4gICAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgX3BpeGVsUmF0aW8gPSAoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBkZXZpY2VQaXhlbFJhdGlvID0gS29udmEud2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSxcbiAgICAgICAgICAgIGJhY2tpbmdTdG9yZVJhdGlvID0gY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvXG4gICAgICAgICAgICAgICAgfHwgY29udGV4dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvXG4gICAgICAgICAgICAgICAgfHwgY29udGV4dC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW9cbiAgICAgICAgICAgICAgICB8fCBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvXG4gICAgICAgICAgICAgICAgfHwgY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvXG4gICAgICAgICAgICAgICAgfHwgMTtcbiAgICAgICAgICAgIHJldHVybiBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG4gICAgICAgIH0pKCk7XG5cbiAgICAvKipcbiAgICAgKiBDYW52YXMgUmVuZGVyZXIgY29uc3RydWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy53aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuaGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5waXhlbFJhdGlvIEtvbnZhSlMgYXV0b21hdGljYWxseSBoYW5kbGVzIHBpeGVsIHJhdGlvIGFkanVzdG1lbnRzIGluIG9yZGVyIHRvIHJlbmRlciBjcmlzcCBkcmF3aW5nc1xuICAgICAqICBvbiBhbGwgZGV2aWNlcy4gTW9zdCBkZXNrdG9wcywgbG93IGVuZCB0YWJsZXRzLCBhbmQgbG93IGVuZCBwaG9uZXMsIGhhdmUgZGV2aWNlIHBpeGVsIHJhdGlvc1xuICAgICAqICBvZiAxLiAgU29tZSBoaWdoIGVuZCB0YWJsZXRzIGFuZCBwaG9uZXMsIGxpa2UgaVBob25lcyBhbmQgaVBhZHMgKG5vdCB0aGUgbWluaSkgaGF2ZSBhIGRldmljZSBwaXhlbCByYXRpb1xuICAgICAqICBvZiAyLiAgU29tZSBNYWNib29rIFByb3MsIGFuZCBpTWFjcyBhbHNvIGhhdmUgYSBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgMi4gIFNvbWUgaGlnaCBlbmQgQW5kcm9pZCBkZXZpY2VzIGhhdmUgcGl4ZWxcbiAgICAgKiAgcmF0aW9zIG9mIDIgb3IgMy4gIFNvbWUgYnJvd3NlcnMgbGlrZSBGaXJlZm94IGFsbG93IHlvdSB0byBjb25maWd1cmUgdGhlIHBpeGVsIHJhdGlvIG9mIHRoZSB2aWV3cG9ydC4gIFVubGVzcyBvdGhlcndpc2VcbiAgICAgKiAgc3BlY2lmaWVkLCB0aGUgcGl4ZWwgcmF0aW8gd2lsbCBiZSBkZWZhdWx0ZWQgdG8gdGhlIGFjdHVhbCBkZXZpY2UgcGl4ZWwgcmF0aW8uICBZb3UgY2FuIG92ZXJyaWRlIHRoZSBkZXZpY2UgcGl4ZWxcbiAgICAgKiAgcmF0aW8gZm9yIHNwZWNpYWwgc2l0dWF0aW9ucywgb3IsIGlmIHlvdSBkb24ndCB3YW50IHRoZSBwaXhlbCByYXRpbyB0byBiZSB0YWtlbiBpbnRvIGFjY291bnQsIHlvdSBjYW4gc2V0IGl0IHRvIDEuXG4gICAgICovXG4gICAgS29udmEuQ2FudmFzID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuaW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5DYW52YXMucHJvdG90eXBlID0ge1xuICAgICAgICBpbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIHZhciBjb25mID0gY29uZmlnIHx8IHt9O1xuXG4gICAgICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IGNvbmYucGl4ZWxSYXRpbyB8fCBLb252YS5waXhlbFJhdGlvIHx8IF9waXhlbFJhdGlvO1xuXG4gICAgICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzID0gS29udmEuVXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG5cbiAgICAgICAgICAgIC8vIHNldCBpbmxpbmUgc3R5bGVzXG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUucGFkZGluZyA9IDA7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUubWFyZ2luID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5ib3JkZXIgPSAwO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmJhY2tncm91bmQgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS50b3AgPSAwO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmxlZnQgPSAwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGNhbnZhcyBjb250ZXh0XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0NhbnZhc0NvbnRleHR9IGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBwaXhlbCByYXRpb1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHBpeGVsIHJhdGlvXG4gICAgICAgICAqL1xuICAgICAgICBnZXRQaXhlbFJhdGlvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBpeGVsUmF0aW87XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgcGl4ZWwgcmF0aW9cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ2FudmFzLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcGl4ZWxSYXRpbyBLb252YUpTIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBwaXhlbCByYXRpbyBhZHVzdG1lbnRzIGluIG9yZGVyIHRvIHJlbmRlciBjcmlzcCBkcmF3aW5nc1xuICAgICAgICAgKiAgb24gYWxsIGRldmljZXMuIE1vc3QgZGVza3RvcHMsIGxvdyBlbmQgdGFibGV0cywgYW5kIGxvdyBlbmQgcGhvbmVzLCBoYXZlIGRldmljZSBwaXhlbCByYXRpb3NcbiAgICAgICAgICogIG9mIDEuICBTb21lIGhpZ2ggZW5kIHRhYmxldHMgYW5kIHBob25lcywgbGlrZSBpUGhvbmVzIGFuZCBpUGFkcyBoYXZlIGEgZGV2aWNlIHBpeGVsIHJhdGlvXG4gICAgICAgICAqICBvZiAyLiAgU29tZSBNYWNib29rIFByb3MsIGFuZCBpTWFjcyBhbHNvIGhhdmUgYSBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgMi4gIFNvbWUgaGlnaCBlbmQgQW5kcm9pZCBkZXZpY2VzIGhhdmUgcGl4ZWxcbiAgICAgICAgICogIHJhdGlvcyBvZiAyIG9yIDMuICBTb21lIGJyb3dzZXJzIGxpa2UgRmlyZWZveCBhbGxvdyB5b3UgdG8gY29uZmlndXJlIHRoZSBwaXhlbCByYXRpbyBvZiB0aGUgdmlld3BvcnQuICBVbmxlc3Mgb3RoZXJ3aXNlXG4gICAgICAgICAqICBzcGVjaWZpY2VkLCB0aGUgcGl4ZWwgcmF0aW8gd2lsbCBiZSBkZWZhdWx0ZWQgdG8gdGhlIGFjdHVhbCBkZXZpY2UgcGl4ZWwgcmF0aW8uICBZb3UgY2FuIG92ZXJyaWRlIHRoZSBkZXZpY2UgcGl4ZWxcbiAgICAgICAgICogIHJhdGlvIGZvciBzcGVjaWFsIHNpdHVhdGlvbnMsIG9yLCBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgcGl4ZWwgcmF0aW8gdG8gYmUgdGFrZW4gaW50byBhY2NvdW50LCB5b3UgY2FuIHNldCBpdCB0byAxLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0UGl4ZWxSYXRpbzogZnVuY3Rpb24ocGl4ZWxSYXRpbykge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzUmF0aW8gPSB0aGlzLnBpeGVsUmF0aW87XG4gICAgICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgICAgICAgICAgdGhpcy5zZXRTaXplKHRoaXMuZ2V0V2lkdGgoKSAvIHByZXZpb3VzUmF0aW8sIHRoaXMuZ2V0SGVpZ2h0KCkgLyBwcmV2aW91c1JhdGlvKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCB3aWR0aFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICAgICAgICAvLyB0YWtlIGludG8gYWNjb3VudCBwaXhlbCByYXRpb1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuX2NhbnZhcy53aWR0aCA9IHdpZHRoICogdGhpcy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuXG4gICAgICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbyxcbiAgICAgICAgICAgICAgICBfY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dCgpLl9jb250ZXh0O1xuICAgICAgICAgICAgX2NvbnRleHQuc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgaGVpZ2h0XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIHRha2UgaW50byBhY2NvdW50IHBpeGVsIHJhdGlvXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIHZhciBwaXhlbFJhdGlvID0gdGhpcy5waXhlbFJhdGlvLFxuICAgICAgICAgICAgICAgIF9jb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KCkuX2NvbnRleHQ7XG4gICAgICAgICAgICBfY29udGV4dC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCB3aWR0aFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHdpZHRoXG4gICAgICAgICAqL1xuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBoZWlnaHRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ2FudmFzLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgc2l6ZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICAgICAqL1xuICAgICAgICBzZXRTaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnNldFdpZHRoKHdpZHRoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KGhlaWdodCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0byBkYXRhIHVybFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lVHlwZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcXVhbGl0eSBiZXR3ZWVuIDAgYW5kIDEgZm9yIGpwZyBtaW1lIHR5cGVzXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IGRhdGEgdXJsIHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdG9EYXRhVVJMOiBmdW5jdGlvbihtaW1lVHlwZSwgcXVhbGl0eSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGNhbGwgZmFpbHMgKGR1ZSB0byBicm93c2VyIGJ1ZywgbGlrZSBpbiBGaXJlZm94IDMuNiksXG4gICAgICAgICAgICAgICAgLy8gdGhlbiByZXZlcnQgdG8gcHJldmlvdXMgbm8tcGFyYW1ldGVyIGltYWdlL3BuZyBiZWhhdmlvclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYW52YXMudG9EYXRhVVJMKG1pbWVUeXBlLCBxdWFsaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdVbmFibGUgdG8gZ2V0IGRhdGEgVVJMLiAnICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtvbnZhLlNjZW5lQ2FudmFzID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHZhciBjb25mID0gY29uZmlnIHx8IHt9O1xuICAgICAgICB2YXIgd2lkdGggPSBjb25mLndpZHRoIHx8IDAsXG4gICAgICAgICAgICBoZWlnaHQgPSBjb25mLmhlaWdodCB8fCAwO1xuXG4gICAgICAgIEtvbnZhLkNhbnZhcy5jYWxsKHRoaXMsIGNvbmYpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBuZXcgS29udmEuU2NlbmVDb250ZXh0KHRoaXMpO1xuICAgICAgICB0aGlzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfTtcblxuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlNjZW5lQ2FudmFzLCBLb252YS5DYW52YXMpO1xuXG4gICAgS29udmEuSGl0Q2FudmFzID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHZhciBjb25mID0gY29uZmlnIHx8IHt9O1xuICAgICAgICB2YXIgd2lkdGggPSBjb25mLndpZHRoIHx8IDAsXG4gICAgICAgICAgICBoZWlnaHQgPSBjb25mLmhlaWdodCB8fCAwO1xuXG4gICAgICAgIEtvbnZhLkNhbnZhcy5jYWxsKHRoaXMsIGNvbmYpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBuZXcgS29udmEuSGl0Q29udGV4dCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmhpdENhbnZhcyA9IHRydWU7XG4gICAgfTtcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5IaXRDYW52YXMsIEtvbnZhLkNhbnZhcyk7XG5cbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIENPTU1BID0gJywnLFxuICAgICAgICBPUEVOX1BBUkVOID0gJygnLFxuICAgICAgICBDTE9TRV9QQVJFTiA9ICcpJyxcbiAgICAgICAgT1BFTl9QQVJFTl9CUkFDS0VUID0gJyhbJyxcbiAgICAgICAgQ0xPU0VfQlJBQ0tFVF9QQVJFTiA9ICddKScsXG4gICAgICAgIFNFTUlDT0xPTiA9ICc7JyxcbiAgICAgICAgRE9VQkxFX1BBUkVOID0gJygpJyxcbiAgICAgICAgLy8gRU1QVFlfU1RSSU5HID0gJycsXG4gICAgICAgIEVRVUFMUyA9ICc9JyxcbiAgICAgICAgLy8gU0VUID0gJ3NldCcsXG4gICAgICAgIENPTlRFWFRfTUVUSE9EUyA9IFtcbiAgICAgICAgICAgICdhcmMnLFxuICAgICAgICAgICAgJ2FyY1RvJyxcbiAgICAgICAgICAgICdiZWdpblBhdGgnLFxuICAgICAgICAgICAgJ2JlemllckN1cnZlVG8nLFxuICAgICAgICAgICAgJ2NsZWFyUmVjdCcsXG4gICAgICAgICAgICAnY2xpcCcsXG4gICAgICAgICAgICAnY2xvc2VQYXRoJyxcbiAgICAgICAgICAgICdjcmVhdGVMaW5lYXJHcmFkaWVudCcsXG4gICAgICAgICAgICAnY3JlYXRlUGF0dGVybicsXG4gICAgICAgICAgICAnY3JlYXRlUmFkaWFsR3JhZGllbnQnLFxuICAgICAgICAgICAgJ2RyYXdJbWFnZScsXG4gICAgICAgICAgICAnZmlsbCcsXG4gICAgICAgICAgICAnZmlsbFRleHQnLFxuICAgICAgICAgICAgJ2dldEltYWdlRGF0YScsXG4gICAgICAgICAgICAnY3JlYXRlSW1hZ2VEYXRhJyxcbiAgICAgICAgICAgICdsaW5lVG8nLFxuICAgICAgICAgICAgJ21vdmVUbycsXG4gICAgICAgICAgICAncHV0SW1hZ2VEYXRhJyxcbiAgICAgICAgICAgICdxdWFkcmF0aWNDdXJ2ZVRvJyxcbiAgICAgICAgICAgICdyZWN0JyxcbiAgICAgICAgICAgICdyZXN0b3JlJyxcbiAgICAgICAgICAgICdyb3RhdGUnLFxuICAgICAgICAgICAgJ3NhdmUnLFxuICAgICAgICAgICAgJ3NjYWxlJyxcbiAgICAgICAgICAgICdzZXRMaW5lRGFzaCcsXG4gICAgICAgICAgICAnc2V0VHJhbnNmb3JtJyxcbiAgICAgICAgICAgICdzdHJva2UnLFxuICAgICAgICAgICAgJ3N0cm9rZVRleHQnLFxuICAgICAgICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgICAgICAndHJhbnNsYXRlJ1xuICAgICAgICBdO1xuXG4gICAgdmFyIENPTlRFWFRfUFJPUEVSVElFUyA9IFsnZmlsbFN0eWxlJywgJ3N0cm9rZVN0eWxlJywgJ3NoYWRvd0NvbG9yJywgJ3NoYWRvd0JsdXInLCAnc2hhZG93T2Zmc2V0WCcsXG4gICAgICAgICdzaGFkb3dPZmZzZXRZJywgJ2xpbmVDYXAnLCAnbGluZUpvaW4nLCAnbGluZVdpZHRoJywgJ21pdGVyTGltaXQnLCAnZm9udCcsICd0ZXh0QWxpZ24nLCAndGV4dEJhc2VsaW5lJyxcbiAgICAgICAgJ2dsb2JhbEFscGhhJywgJ2dsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiddO1xuXG4gICAgLyoqXG4gICAgICogQ2FudmFzIENvbnRleHQgY29uc3RydWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKi9cbiAgICBLb252YS5Db250ZXh0ID0gZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICAgIHRoaXMuaW5pdChjYW52YXMpO1xuICAgIH07XG5cbiAgICBLb252YS5Db250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQgPSBjYW52YXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICBpZiAoS29udmEuZW5hYmxlVHJhY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlQXJyID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5hYmxlVHJhY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZpbGwgc2hhcGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGV4dC5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtLb252YS5TaGFwZX0gc2hhcGVcbiAgICAgICAgICovXG4gICAgICAgIGZpbGxTaGFwZTogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgICAgIGlmKHNoYXBlLmdldEZpbGxFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxsKHNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHN0cm9rZSBzaGFwZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0tvbnZhLlNoYXBlfSBzaGFwZVxuICAgICAgICAgKi9cbiAgICAgICAgc3Ryb2tlU2hhcGU6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgICAgICBpZihzaGFwZS5nZXRTdHJva2VFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJva2Uoc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZmlsbCB0aGVuIHN0cm9rZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0tvbnZhLlNoYXBlfSBzaGFwZVxuICAgICAgICAgKi9cbiAgICAgICAgZmlsbFN0cm9rZVNoYXBlOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgICAgICAgdmFyIGZpbGxFbmFibGVkID0gc2hhcGUuZ2V0RmlsbEVuYWJsZWQoKTtcbiAgICAgICAgICAgIGlmKGZpbGxFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsbChzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihzaGFwZS5nZXRTdHJva2VFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJva2Uoc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGNvbnRleHQgdHJhY2UgaWYgdHJhY2UgaXMgZW5hYmxlZFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbGF4ZWQgaWYgZmFsc2UsIHJldHVybiBzdHJpY3QgY29udGV4dCB0cmFjZSwgd2hpY2ggaW5jbHVkZXMgbWV0aG9kIG5hbWVzLCBtZXRob2QgcGFyYW1ldGVyc1xuICAgICAgICAgKiAgcHJvcGVydGllcywgYW5kIHByb3BlcnR5IHZhbHVlcy4gIElmIHRydWUsIHJldHVybiByZWxheGVkIGNvbnRleHQgdHJhY2UsIHdoaWNoIG9ubHkgcmV0dXJucyBtZXRob2QgbmFtZXMgYW5kXG4gICAgICAgICAqICBwcm9wZXJpdGVzLlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VHJhY2U6IGZ1bmN0aW9uKHJlbGF4ZWQpIHtcbiAgICAgICAgICAgIHZhciB0cmFjZUFyciA9IHRoaXMudHJhY2VBcnIsXG4gICAgICAgICAgICAgICAgbGVuID0gdHJhY2VBcnIubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHN0ciA9ICcnLFxuICAgICAgICAgICAgICAgIG4sIHRyYWNlLCBtZXRob2QsIGFyZ3M7XG5cbiAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgIHRyYWNlID0gdHJhY2VBcnJbbl07XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHJhY2UubWV0aG9kO1xuXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kc1xuICAgICAgICAgICAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IHRyYWNlLmFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSBtZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWxheGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gRE9VQkxFX1BBUkVOO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEtvbnZhLlV0aWwuX2lzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gT1BFTl9QQVJFTl9CUkFDS0VUICsgYXJncy5qb2luKENPTU1BKSArIENMT1NFX0JSQUNLRVRfUEFSRU47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gT1BFTl9QQVJFTiArIGFyZ3Muam9pbihDT01NQSkgKyBDTE9TRV9QQVJFTjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSB0cmFjZS5wcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWxheGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gRVFVQUxTICsgdHJhY2UudmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3RyICs9IFNFTUlDT0xPTjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNsZWFyIHRyYWNlIGlmIHRyYWNlIGlzIGVuYWJsZWRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGV4dC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyVHJhY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy50cmFjZUFyciA9IFtdO1xuICAgICAgICB9LFxuICAgICAgICBfdHJhY2U6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgdmFyIHRyYWNlQXJyID0gdGhpcy50cmFjZUFycixcbiAgICAgICAgICAgICAgICBsZW47XG5cbiAgICAgICAgICAgIHRyYWNlQXJyLnB1c2goc3RyKTtcbiAgICAgICAgICAgIGxlbiA9IHRyYWNlQXJyLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKGxlbiA+PSBLb252YS50cmFjZUFyck1heCkge1xuICAgICAgICAgICAgICAgIHRyYWNlQXJyLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXNldCBjYW52YXMgY29udGV4dCB0cmFuc2Zvcm1cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGV4dC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwaXhlbFJhdGlvID0gdGhpcy5nZXRDYW52YXMoKS5nZXRQaXhlbFJhdGlvKCk7XG4gICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybSgxICogcGl4ZWxSYXRpbywgMCwgMCwgMSAqIHBpeGVsUmF0aW8sIDAsIDApO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGNhbnZhc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuQ2FudmFzfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbnZhcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNsZWFyIGNhbnZhc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2JvdW5kc11cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMueF1cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMueV1cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMud2lkdGhdXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbYm91bmRzLmhlaWdodF1cbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbihib3VuZHMpIHtcbiAgICAgICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuXG4gICAgICAgICAgICBpZiAoYm91bmRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclJlY3QoYm91bmRzLnggfHwgMCwgYm91bmRzLnkgfHwgMCwgYm91bmRzLndpZHRoIHx8IDAsIGJvdW5kcy5oZWlnaHQgfHwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyUmVjdCgwLCAwLCBjYW52YXMuZ2V0V2lkdGgoKSAvIGNhbnZhcy5waXhlbFJhdGlvLCBjYW52YXMuZ2V0SGVpZ2h0KCkgLyBjYW52YXMucGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9hcHBseUxpbmVDYXA6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgbGluZUNhcCA9IHNoYXBlLmdldExpbmVDYXAoKTtcbiAgICAgICAgICAgIGlmKGxpbmVDYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHIoJ2xpbmVDYXAnLCBsaW5lQ2FwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2FwcGx5T3BhY2l0eTogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciBhYnNPcGFjaXR5ID0gc2hhcGUuZ2V0QWJzb2x1dGVPcGFjaXR5KCk7XG4gICAgICAgICAgICBpZihhYnNPcGFjaXR5ICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdnbG9iYWxBbHBoYScsIGFic09wYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfYXBwbHlMaW5lSm9pbjogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciBsaW5lSm9pbiA9IHNoYXBlLmdldExpbmVKb2luKCk7XG4gICAgICAgICAgICBpZihsaW5lSm9pbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cignbGluZUpvaW4nLCBsaW5lSm9pbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldEF0dHI6IGZ1bmN0aW9uKGF0dHIsIHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dFthdHRyXSA9IHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBjb250ZXh0IHBhc3MgdGhyb3VnaCBtZXRob2RzXG4gICAgICAgIGFyYzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuYXJjKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0pO1xuICAgICAgICB9LFxuICAgICAgICBiZWdpblBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgfSxcbiAgICAgICAgYmV6aWVyQ3VydmVUbzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJSZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbGVhclJlY3QoYVswXSwgYVsxXSwgYVsyXSwgYVszXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsaXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbGlwKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVJbWFnZURhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICBpZihhLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmNyZWF0ZUltYWdlRGF0YShhWzBdLCBhWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoYS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5jcmVhdGVJbWFnZURhdGEoYVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZUxpbmVhckdyYWRpZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoYVswXSwgYVsxXSwgYVsyXSwgYVszXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZVBhdHRlcm46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5jcmVhdGVQYXR0ZXJuKGFbMF0sIGFbMV0pO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVSYWRpYWxHcmFkaWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmNyZWF0ZVJhZGlhbEdyYWRpZW50KGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0pO1xuICAgICAgICB9LFxuICAgICAgICBkcmF3SW1hZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgX2NvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuXG4gICAgICAgICAgICBpZihhLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LmRyYXdJbWFnZShhWzBdLCBhWzFdLCBhWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoYS5sZW5ndGggPT09IDUpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5kcmF3SW1hZ2UoYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGEubGVuZ3RoID09PSA5KSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQuZHJhd0ltYWdlKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0sIGFbNl0sIGFbN10sIGFbOF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpc1BvaW50SW5QYXRoOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5pc1BvaW50SW5QYXRoKHgsIHkpO1xuICAgICAgICB9LFxuICAgICAgICBmaWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbCgpO1xuICAgICAgICB9LFxuICAgICAgICBmaWxsUmVjdDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5maWxsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlUmVjdDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zdHJva2VSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9LFxuICAgICAgICBmaWxsVGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFRleHQoYVswXSwgYVsxXSwgYVsyXSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1lYXN1cmVUZXh0OiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SW1hZ2VEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZ2V0SW1hZ2VEYXRhKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10pO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lVG86IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyhhWzBdLCBhWzFdKTtcbiAgICAgICAgfSxcbiAgICAgICAgbW92ZVRvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oYVswXSwgYVsxXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnJlY3QoYVswXSwgYVsxXSwgYVsyXSwgYVszXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHB1dEltYWdlRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQucHV0SW1hZ2VEYXRhKGFbMF0sIGFbMV0sIGFbMl0pO1xuICAgICAgICB9LFxuICAgICAgICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10pO1xuICAgICAgICB9LFxuICAgICAgICByZXN0b3JlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9LFxuICAgICAgICByb3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnJvdGF0ZShhWzBdKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2F2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNhdmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2NhbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNjYWxlKGFbMF0sIGFbMV0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXRMaW5lRGFzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICBfY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG5cbiAgICAgICAgICAgIC8vIHdvcmtzIGZvciBDaHJvbWUgYW5kIElFMTFcbiAgICAgICAgICAgIGlmKHRoaXMuX2NvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5zZXRMaW5lRGFzaChhWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHZlcmlmaWVkIHRoYXQgdGhpcyB3b3JrcyBpbiBmaXJlZm94XG4gICAgICAgICAgICBlbHNlIGlmKCdtb3pEYXNoJyBpbiBfY29udGV4dCkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm1vekRhc2ggPSBhWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9lcyBub3QgY3VycmVudGx5IHdvcmsgZm9yIFNhZmFyaVxuICAgICAgICAgICAgZWxzZSBpZignd2Via2l0TGluZURhc2gnIGluIF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQud2Via2l0TGluZURhc2ggPSBhWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBubyBzdXBwb3J0IGZvciBJRTkgYW5kIElFMTBcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TGluZURhc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZ2V0TGluZURhc2goKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0VHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zZXRUcmFuc2Zvcm0oYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICB9LFxuICAgICAgICBzdHJva2VUZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zdHJva2VUZXh0KGFbMF0sIGFbMV0sIGFbMl0pO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnRyYW5zZm9ybShhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC50cmFuc2xhdGUoYVswXSwgYVsxXSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9lbmFibGVUcmFjZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgbGVuID0gQ09OVEVYVF9NRVRIT0RTLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBfc2ltcGxpZnlBcnJheSA9IEtvbnZhLlV0aWwuX3NpbXBsaWZ5QXJyYXksXG4gICAgICAgICAgICAgICAgb3JpZ1NldHRlciA9IHRoaXMuc2V0QXR0cixcbiAgICAgICAgICAgICAgICBuLCBhcmdzO1xuXG4gICAgICAgICAgICAvLyB0byBwcmV2ZW50IGNyZWF0aW5nIHNjb3BlIGZ1bmN0aW9uIGF0IGVhY2ggbG9vcFxuICAgICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnTWV0aG9kID0gdGhhdFttZXRob2ROYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldDtcblxuICAgICAgICAgICAgICAgICAgICB0aGF0W21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gX3NpbXBsaWZ5QXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBvcmlnTWV0aG9kLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnY2xlYXJSZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbMl0gPSBhcmdzWzJdIC8gdGhhdC5jYW52YXMuZ2V0UGl4ZWxSYXRpbygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbM10gPSBhcmdzWzNdIC8gdGhhdC5jYW52YXMuZ2V0UGl4ZWxSYXRpbygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fdHJhY2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBtZXRob2RzXG4gICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICBmdW5jKENPTlRFWFRfTUVUSE9EU1tuXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGF0dHJzXG4gICAgICAgICAgICB0aGF0LnNldEF0dHIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBvcmlnU2V0dGVyLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgdGhhdC5fdHJhY2Uoe1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICB2YWw6IGFyZ3VtZW50c1sxXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDT05URVhUX1BST1BFUlRJRVMuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShLb252YS5Db250ZXh0LnByb3RvdHlwZSwgcHJvcCwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHRbcHJvcF07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dFtwcm9wXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBLb252YS5TY2VuZUNvbnRleHQgPSBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgICAgS29udmEuQ29udGV4dC5jYWxsKHRoaXMsIGNhbnZhcyk7XG4gICAgfTtcblxuICAgIEtvbnZhLlNjZW5lQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9maWxsQ29sb3I6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgZmlsbCA9IHNoYXBlLmZpbGwoKTtcblxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdmaWxsU3R5bGUnLCBmaWxsKTtcbiAgICAgICAgICAgIHNoYXBlLl9maWxsRnVuYyh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2ZpbGxQYXR0ZXJuOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgICAgICAgdmFyIGZpbGxQYXR0ZXJuWCA9IHNoYXBlLmdldEZpbGxQYXR0ZXJuWCgpLFxuICAgICAgICAgICAgICAgIGZpbGxQYXR0ZXJuWSA9IHNoYXBlLmdldEZpbGxQYXR0ZXJuWSgpLFxuICAgICAgICAgICAgICAgIGZpbGxQYXR0ZXJuU2NhbGUgPSBzaGFwZS5nZXRGaWxsUGF0dGVyblNjYWxlKCksXG4gICAgICAgICAgICAgICAgZmlsbFBhdHRlcm5Sb3RhdGlvbiA9IEtvbnZhLmdldEFuZ2xlKHNoYXBlLmdldEZpbGxQYXR0ZXJuUm90YXRpb24oKSksXG4gICAgICAgICAgICAgICAgZmlsbFBhdHRlcm5PZmZzZXQgPSBzaGFwZS5nZXRGaWxsUGF0dGVybk9mZnNldCgpO1xuXG4gICAgICAgICAgICBpZihmaWxsUGF0dGVyblggfHwgZmlsbFBhdHRlcm5ZKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2xhdGUoZmlsbFBhdHRlcm5YIHx8IDAsIGZpbGxQYXR0ZXJuWSB8fCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGZpbGxQYXR0ZXJuUm90YXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvdGF0ZShmaWxsUGF0dGVyblJvdGF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGZpbGxQYXR0ZXJuU2NhbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlKGZpbGxQYXR0ZXJuU2NhbGUueCwgZmlsbFBhdHRlcm5TY2FsZS55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGZpbGxQYXR0ZXJuT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2xhdGUoLTEgKiBmaWxsUGF0dGVybk9mZnNldC54LCAtMSAqIGZpbGxQYXR0ZXJuT2Zmc2V0LnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ2ZpbGxTdHlsZScsIHRoaXMuY3JlYXRlUGF0dGVybihzaGFwZS5nZXRGaWxsUGF0dGVybkltYWdlKCksIHNoYXBlLmdldEZpbGxQYXR0ZXJuUmVwZWF0KCkgfHwgJ3JlcGVhdCcpKTtcbiAgICAgICAgICAgIHRoaXMuZmlsbCgpO1xuICAgICAgICB9LFxuICAgICAgICBfZmlsbExpbmVhckdyYWRpZW50OiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gc2hhcGUuZ2V0RmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludCgpLFxuICAgICAgICAgICAgICAgIGVuZCA9IHNoYXBlLmdldEZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50KCksXG4gICAgICAgICAgICAgICAgY29sb3JTdG9wcyA9IHNoYXBlLmdldEZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMoKSxcbiAgICAgICAgICAgICAgICBncmQgPSB0aGlzLmNyZWF0ZUxpbmVhckdyYWRpZW50KHN0YXJ0LngsIHN0YXJ0LnksIGVuZC54LCBlbmQueSk7XG5cbiAgICAgICAgICAgIGlmIChjb2xvclN0b3BzKSB7XG4gICAgICAgICAgICAgICAgLy8gYnVpbGQgY29sb3Igc3RvcHNcbiAgICAgICAgICAgICAgICBmb3IodmFyIG4gPSAwOyBuIDwgY29sb3JTdG9wcy5sZW5ndGg7IG4gKz0gMikge1xuICAgICAgICAgICAgICAgICAgICBncmQuYWRkQ29sb3JTdG9wKGNvbG9yU3RvcHNbbl0sIGNvbG9yU3RvcHNbbiArIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdmaWxsU3R5bGUnLCBncmQpO1xuICAgICAgICAgICAgICAgIHNoYXBlLl9maWxsRnVuYyh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2ZpbGxSYWRpYWxHcmFkaWVudDogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHNoYXBlLmdldEZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnQoKSxcbiAgICAgICAgICAgICAgICBlbmQgPSBzaGFwZS5nZXRGaWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludCgpLFxuICAgICAgICAgICAgICAgIHN0YXJ0UmFkaXVzID0gc2hhcGUuZ2V0RmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXMoKSxcbiAgICAgICAgICAgICAgICBlbmRSYWRpdXMgPSBzaGFwZS5nZXRGaWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXMoKSxcbiAgICAgICAgICAgICAgICBjb2xvclN0b3BzID0gc2hhcGUuZ2V0RmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wcygpLFxuICAgICAgICAgICAgICAgIGdyZCA9IHRoaXMuY3JlYXRlUmFkaWFsR3JhZGllbnQoc3RhcnQueCwgc3RhcnQueSwgc3RhcnRSYWRpdXMsIGVuZC54LCBlbmQueSwgZW5kUmFkaXVzKTtcblxuICAgICAgICAgICAgLy8gYnVpbGQgY29sb3Igc3RvcHNcbiAgICAgICAgICAgIGZvcih2YXIgbiA9IDA7IG4gPCBjb2xvclN0b3BzLmxlbmd0aDsgbiArPSAyKSB7XG4gICAgICAgICAgICAgICAgZ3JkLmFkZENvbG9yU3RvcChjb2xvclN0b3BzW25dLCBjb2xvclN0b3BzW24gKyAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ2ZpbGxTdHlsZScsIGdyZCk7XG4gICAgICAgICAgICB0aGlzLmZpbGwoKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2ZpbGw6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgaGFzQ29sb3IgPSBzaGFwZS5maWxsKCksXG4gICAgICAgICAgICAgICAgaGFzUGF0dGVybiA9IHNoYXBlLmdldEZpbGxQYXR0ZXJuSW1hZ2UoKSxcbiAgICAgICAgICAgICAgICBoYXNMaW5lYXJHcmFkaWVudCA9IHNoYXBlLmdldEZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMoKSxcbiAgICAgICAgICAgICAgICBoYXNSYWRpYWxHcmFkaWVudCA9IHNoYXBlLmdldEZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMoKSxcbiAgICAgICAgICAgICAgICBmaWxsUHJpb3JpdHkgPSBzaGFwZS5nZXRGaWxsUHJpb3JpdHkoKTtcblxuICAgICAgICAgICAgLy8gcHJpb3JpdHkgZmlsbHNcbiAgICAgICAgICAgIGlmKGhhc0NvbG9yICYmIGZpbGxQcmlvcml0eSA9PT0gJ2NvbG9yJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGxDb2xvcihzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGhhc1BhdHRlcm4gJiYgZmlsbFByaW9yaXR5ID09PSAncGF0dGVybicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxsUGF0dGVybihzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGhhc0xpbmVhckdyYWRpZW50ICYmIGZpbGxQcmlvcml0eSA9PT0gJ2xpbmVhci1ncmFkaWVudCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxsTGluZWFyR3JhZGllbnQoc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihoYXNSYWRpYWxHcmFkaWVudCAmJiBmaWxsUHJpb3JpdHkgPT09ICdyYWRpYWwtZ3JhZGllbnQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsbFJhZGlhbEdyYWRpZW50KHNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vdyBqdXN0IHRyeSBhbmQgZmlsbCB3aXRoIHdoYXRldmVyIGlzIGF2YWlsYWJsZVxuICAgICAgICAgICAgZWxzZSBpZihoYXNDb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGxDb2xvcihzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGhhc1BhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxsUGF0dGVybihzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGhhc0xpbmVhckdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsbExpbmVhckdyYWRpZW50KHNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoaGFzUmFkaWFsR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxsUmFkaWFsR3JhZGllbnQoc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfc3Ryb2tlOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgICAgICAgdmFyIGRhc2ggPSBzaGFwZS5kYXNoKCksXG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIHN0cm9rZVNjYWxlRW5hYmxlZCBmb3IgVGV4dFxuICAgICAgICAgICAgICAgIHN0cm9rZVNjYWxlRW5hYmxlZCA9IChzaGFwZS5nZXRTdHJva2VTY2FsZUVuYWJsZWQoKSB8fCAoc2hhcGUgaW5zdGFuY2VvZiBLb252YS5UZXh0KSk7XG5cbiAgICAgICAgICAgIGlmKHNoYXBlLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdHJva2VTY2FsZUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5TGluZUNhcChzaGFwZSk7XG4gICAgICAgICAgICAgICAgaWYoZGFzaCAmJiBzaGFwZS5kYXNoRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0TGluZURhc2goZGFzaCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdsaW5lV2lkdGgnLCBzaGFwZS5zdHJva2VXaWR0aCgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3N0cm9rZVN0eWxlJywgc2hhcGUuc3Ryb2tlKCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzaGFwZS5nZXRTaGFkb3dGb3JTdHJva2VFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdzaGFkb3dDb2xvcicsICdyZ2JhKDAsMCwwLDApJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNoYXBlLl9zdHJva2VGdW5jKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzdHJva2VTY2FsZUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfYXBwbHlTaGFkb3c6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgdXRpbCA9IEtvbnZhLlV0aWwsXG4gICAgICAgICAgICAgICAgY29sb3IgPSB1dGlsLmdldChzaGFwZS5nZXRTaGFkb3dSR0JBKCksICdibGFjaycpLFxuICAgICAgICAgICAgICAgIGJsdXIgPSB1dGlsLmdldChzaGFwZS5nZXRTaGFkb3dCbHVyKCksIDUpLFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHV0aWwuZ2V0KHNoYXBlLmdldFNoYWRvd09mZnNldCgpLCB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBtID0gc2hhcGUuZ2V0QWJzb2x1dGVUcmFuc2Zvcm0oKS5tLFxuICAgICAgICAgICAgICAgIHNjYWxlWCA9IG1bMF0sXG4gICAgICAgICAgICAgICAgc2NhbGVZID0gbVszXTtcblxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdzaGFkb3dDb2xvcicsIGNvbG9yKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignc2hhZG93Qmx1cicsIGJsdXIpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdzaGFkb3dPZmZzZXRYJywgb2Zmc2V0LnggKiBzY2FsZVgpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdzaGFkb3dPZmZzZXRZJywgb2Zmc2V0LnkgKiBzY2FsZVkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5TY2VuZUNvbnRleHQsIEtvbnZhLkNvbnRleHQpO1xuXG4gICAgS29udmEuSGl0Q29udGV4dCA9IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgICBLb252YS5Db250ZXh0LmNhbGwodGhpcywgY2FudmFzKTtcbiAgICB9O1xuXG4gICAgS29udmEuSGl0Q29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9maWxsOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ2ZpbGxTdHlsZScsIHNoYXBlLmNvbG9yS2V5KTtcbiAgICAgICAgICAgIHNoYXBlLl9maWxsRnVuY0hpdCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgICB9LFxuICAgICAgICBfc3Ryb2tlOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgICAgICAgaWYoc2hhcGUuaGFzU3Ryb2tlKCkgJiYgc2hhcGUuc3Ryb2tlSGl0RW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIHN0cm9rZVNjYWxlRW5hYmxlZCBmb3IgVGV4dFxuICAgICAgICAgICAgICAgIHZhciBzdHJva2VTY2FsZUVuYWJsZWQgPSAoc2hhcGUuZ2V0U3Ryb2tlU2NhbGVFbmFibGVkKCkgfHwgKHNoYXBlIGluc3RhbmNlb2YgS29udmEuVGV4dCkpO1xuICAgICAgICAgICAgICAgIGlmICghc3Ryb2tlU2NhbGVFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlMaW5lQ2FwKHNoYXBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHIoJ2xpbmVXaWR0aCcsIHNoYXBlLnN0cm9rZVdpZHRoKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cignc3Ryb2tlU3R5bGUnLCBzaGFwZS5jb2xvcktleSk7XG4gICAgICAgICAgICAgICAgc2hhcGUuX3N0cm9rZUZ1bmNIaXQodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdHJva2VTY2FsZUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5IaXRDb250ZXh0LCBLb252YS5Db250ZXh0KTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gQ09OU1RBTlRTXG4gICAgdmFyIEdFVCA9ICdnZXQnLFxuICAgICAgICBTRVQgPSAnc2V0JztcblxuICAgIEtvbnZhLkZhY3RvcnkgPSB7XG4gICAgICAgIGFkZEdldHRlclNldHRlcjogZnVuY3Rpb24oY29uc3RydWN0b3IsIGF0dHIsIGRlZiwgdmFsaWRhdG9yLCBhZnRlcikge1xuICAgICAgICAgICAgdGhpcy5hZGRHZXR0ZXIoY29uc3RydWN0b3IsIGF0dHIsIGRlZik7XG4gICAgICAgICAgICB0aGlzLmFkZFNldHRlcihjb25zdHJ1Y3RvciwgYXR0ciwgdmFsaWRhdG9yLCBhZnRlcik7XG4gICAgICAgICAgICB0aGlzLmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoY29uc3RydWN0b3IsIGF0dHIpO1xuICAgICAgICB9LFxuICAgICAgICBhZGRHZXR0ZXI6IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBhdHRyLCBkZWYpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBHRVQgKyBLb252YS5VdGlsLl9jYXBpdGFsaXplKGF0dHIpO1xuXG4gICAgICAgICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLmF0dHJzW2F0dHJdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCA/IGRlZiA6IHZhbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGFkZFNldHRlcjogZnVuY3Rpb24oY29uc3RydWN0b3IsIGF0dHIsIHZhbGlkYXRvciwgYWZ0ZXIpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBTRVQgKyBLb252YS5VdGlsLl9jYXBpdGFsaXplKGF0dHIpO1xuXG4gICAgICAgICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsaWRhdG9yLmNhbGwodGhpcywgdmFsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRBdHRyKGF0dHIsIHZhbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXI6IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBhdHRyLCBjb21wb25lbnRzLCB2YWxpZGF0b3IsIGFmdGVyKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gY29tcG9uZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgY2FwaXRhbGl6ZSA9IEtvbnZhLlV0aWwuX2NhcGl0YWxpemUsXG4gICAgICAgICAgICAgICAgZ2V0dGVyID0gR0VUICsgY2FwaXRhbGl6ZShhdHRyKSxcbiAgICAgICAgICAgICAgICBzZXR0ZXIgPSBTRVQgKyBjYXBpdGFsaXplKGF0dHIpLFxuICAgICAgICAgICAgICAgIG4sIGNvbXBvbmVudDtcblxuICAgICAgICAgICAgLy8gZ2V0dGVyXG4gICAgICAgICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbZ2V0dGVyXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSB7fTtcblxuICAgICAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzW25dO1xuICAgICAgICAgICAgICAgICAgICByZXRbY29tcG9uZW50XSA9IHRoaXMuZ2V0QXR0cihhdHRyICsgY2FwaXRhbGl6ZShjb21wb25lbnQpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gc2V0dGVyXG4gICAgICAgICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbc2V0dGVyXSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRWYWwgPSB0aGlzLmF0dHJzW2F0dHJdLFxuICAgICAgICAgICAgICAgICAgICBrZXk7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbGlkYXRvci5jYWxsKHRoaXMsIHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEF0dHIoYXR0ciArIGNhcGl0YWxpemUoa2V5KSwgdmFsW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmVDaGFuZ2VFdmVudChhdHRyLCBvbGRWYWwsIHZhbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihjb25zdHJ1Y3RvciwgYXR0cik7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXI6IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBhdHRyKSB7XG4gICAgICAgICAgICB2YXIgY2FwaXRhbGl6ZWRBdHRyID0gS29udmEuVXRpbC5fY2FwaXRhbGl6ZShhdHRyKSxcbiAgICAgICAgICAgICAgICBzZXR0ZXIgPSBTRVQgKyBjYXBpdGFsaXplZEF0dHIsXG4gICAgICAgICAgICAgICAgZ2V0dGVyID0gR0VUICsgY2FwaXRhbGl6ZWRBdHRyO1xuXG4gICAgICAgICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbYXR0cl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBzZXR0aW5nXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tzZXR0ZXJdKGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBnZXR0aW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbZ2V0dGVyXSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkRGVwcmVjYXRlZEdldHRlclNldHRlcjogZnVuY3Rpb24oY29uc3RydWN0b3IsIGF0dHIsIGRlZiwgdmFsaWRhdG9yKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gR0VUICsgS29udmEuVXRpbC5fY2FwaXRhbGl6ZShhdHRyKTtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gYXR0ciArICcgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIHNvb24uIExvb2sgYXQgS29udmEgY2hhbmdlIGxvZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nO1xuICAgICAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBLb252YS5VdGlsLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLmF0dHJzW2F0dHJdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCA/IGRlZiA6IHZhbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmFkZFNldHRlcihjb25zdHJ1Y3RvciwgYXR0ciwgdmFsaWRhdG9yLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgS29udmEuVXRpbC5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKGNvbnN0cnVjdG9yLCBhdHRyKTtcbiAgICAgICAgfSxcbiAgICAgICAgYmFja0NvbXBhdDogZnVuY3Rpb24oY29uc3RydWN0b3IsIG1ldGhvZHMpIHtcbiAgICAgICAgICAgIEtvbnZhLlV0aWwuZWFjaChtZXRob2RzLCBmdW5jdGlvbihvbGRNZXRob2ROYW1lLCBuZXdNZXRob2ROYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IGNvbnN0cnVjdG9yLnByb3RvdHlwZVtuZXdNZXRob2ROYW1lXTtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbb2xkTWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgS29udmEuVXRpbC5lcnJvcihvbGRNZXRob2ROYW1lICsgJyBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIHNvb24uIFVzZSAnICsgbmV3TWV0aG9kTmFtZSArICcgaW5zdGVhZCcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgYWZ0ZXJTZXRGaWx0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBLb252YS5WYWxpZGF0b3JzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgUkdCQ29tcG9uZW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIGlmICh2YWwgPiAyNTUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMjU1O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBhbHBoYUNvbXBvbmVudDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICBpZiAodmFsID4gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hyb21lIGRvZXMgbm90IGhvbm9yIGFscGhhIHZhbHVlcyBvZiAwXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPCAwLjAwMDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC4wMDAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5cbihmdW5jdGlvbihLb252YSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBDT05TVEFOVFNcbiAgICB2YXIgQUJTT0xVVEVfT1BBQ0lUWSA9ICdhYnNvbHV0ZU9wYWNpdHknLFxuICAgICAgICBBQlNPTFVURV9UUkFOU0ZPUk0gPSAnYWJzb2x1dGVUcmFuc2Zvcm0nLFxuICAgICAgICBDSEFOR0UgPSAnQ2hhbmdlJyxcbiAgICAgICAgQ0hJTERSRU4gPSAnY2hpbGRyZW4nLFxuICAgICAgICBET1QgPSAnLicsXG4gICAgICAgIEVNUFRZX1NUUklORyA9ICcnLFxuICAgICAgICBHRVQgPSAnZ2V0JyxcbiAgICAgICAgSUQgPSAnaWQnLFxuICAgICAgICBLT05WQSA9ICdrb252YScsXG4gICAgICAgIExJU1RFTklORyA9ICdsaXN0ZW5pbmcnLFxuICAgICAgICBNT1VTRUVOVEVSID0gJ21vdXNlZW50ZXInLFxuICAgICAgICBNT1VTRUxFQVZFID0gJ21vdXNlbGVhdmUnLFxuICAgICAgICBOQU1FID0gJ25hbWUnLFxuICAgICAgICBTRVQgPSAnc2V0JyxcbiAgICAgICAgU0hBUEUgPSAnU2hhcGUnLFxuICAgICAgICBTUEFDRSA9ICcgJyxcbiAgICAgICAgU1RBR0UgPSAnc3RhZ2UnLFxuICAgICAgICBUUkFOU0ZPUk0gPSAndHJhbnNmb3JtJyxcbiAgICAgICAgVVBQRVJfU1RBR0UgPSAnU3RhZ2UnLFxuICAgICAgICBWSVNJQkxFID0gJ3Zpc2libGUnLFxuICAgICAgICBDTE9ORV9CTEFDS19MSVNUID0gWydpZCddLFxuXG4gICAgICAgIFRSQU5TRk9STV9DSEFOR0VfU1RSID0gW1xuICAgICAgICAgICAgJ3hDaGFuZ2Uua29udmEnLFxuICAgICAgICAgICAgJ3lDaGFuZ2Uua29udmEnLFxuICAgICAgICAgICAgJ3NjYWxlWENoYW5nZS5rb252YScsXG4gICAgICAgICAgICAnc2NhbGVZQ2hhbmdlLmtvbnZhJyxcbiAgICAgICAgICAgICdza2V3WENoYW5nZS5rb252YScsXG4gICAgICAgICAgICAnc2tld1lDaGFuZ2Uua29udmEnLFxuICAgICAgICAgICAgJ3JvdGF0aW9uQ2hhbmdlLmtvbnZhJyxcbiAgICAgICAgICAgICdvZmZzZXRYQ2hhbmdlLmtvbnZhJyxcbiAgICAgICAgICAgICdvZmZzZXRZQ2hhbmdlLmtvbnZhJyxcbiAgICAgICAgICAgICd0cmFuc2Zvcm1zRW5hYmxlZENoYW5nZS5rb252YSdcbiAgICAgICAgXS5qb2luKFNQQUNFKTtcblxuICAgIC8qKlxuICAgICAqIE5vZGUgY29uc3RydWN0b3IuIE5vZGVzIGFyZSBlbnRpdGllcyB0aGF0IGNhbiBiZSB0cmFuc2Zvcm1lZCwgbGF5ZXJlZCxcbiAgICAgKiBhbmQgaGF2ZSBib3VuZCBldmVudHMuIFRoZSBzdGFnZSwgbGF5ZXJzLCBncm91cHMsIGFuZCBzaGFwZXMgYWxsIGV4dGVuZCBOb2RlLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqL1xuICAgIEtvbnZhLk5vZGUgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5VdGlsLmFkZE1ldGhvZHMoS29udmEuTm9kZSwge1xuICAgICAgICBfaW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9pZCA9IEtvbnZhLmlkQ291bnRlcisrO1xuICAgICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5hdHRycyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlclVwVG9EYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJzKGNvbmZpZyk7XG5cbiAgICAgICAgICAgIC8vIGV2ZW50IGJpbmRpbmdzIGZvciBjYWNoZSBoYW5kbGluZ1xuICAgICAgICAgICAgdGhpcy5vbihUUkFOU0ZPUk1fQ0hBTkdFX1NUUiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJDYWNoZShUUkFOU0ZPUk0pO1xuICAgICAgICAgICAgICAgIHRoYXQuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9UUkFOU0ZPUk0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm9uKCd2aXNpYmxlQ2hhbmdlLmtvbnZhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKFZJU0lCTEUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm9uKCdsaXN0ZW5pbmdDaGFuZ2Uua29udmEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoTElTVEVOSU5HKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5vbignb3BhY2l0eUNoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9PUEFDSVRZKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBfY2xlYXJDYWNoZTogZnVuY3Rpb24oYXR0cil7XG4gICAgICAgICAgICBpZiAoYXR0cikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jYWNoZVthdHRyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRDYWNoZTogZnVuY3Rpb24oYXR0ciwgcHJpdmF0ZUdldHRlcil7XG4gICAgICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLl9jYWNoZVthdHRyXTtcblxuICAgICAgICAgICAgLy8gaWYgbm90IGNhY2hlZCwgd2UgbmVlZCB0byBzZXQgaXQgdXNpbmcgdGhlIHByaXZhdGUgZ2V0dGVyIG1ldGhvZC5cbiAgICAgICAgICAgIGlmIChjYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVbYXR0cl0gPSBwcml2YXRlR2V0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZVthdHRyXTtcbiAgICAgICAgfSxcbiAgICAgICAgLypcbiAgICAgICAgICogd2hlbiB0aGUgbG9naWMgZm9yIGEgY2FjaGVkIHJlc3VsdCBkZXBlbmRzIG9uIGFuY2VzdG9yIHByb3BhZ2F0aW9uLCB1c2UgdGhpc1xuICAgICAgICAgKiBtZXRob2QgdG8gY2xlYXIgc2VsZiBhbmQgY2hpbGRyZW4gY2FjaGVcbiAgICAgICAgICovXG4gICAgICAgIF9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGU6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoYXR0cik7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRDaGlsZHJlbigpLmVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoYXR0cik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIGNsZWFyIGNhY2hlZCBjYW52YXNcbiAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgKiBub2RlLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgKi9cbiAgICAgICAgY2xlYXJDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fY2FjaGUuY2FudmFzO1xuICAgICAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiAgY2FjaGUgbm9kZSB0byBpbXByb3ZlIGRyYXdpbmcgcGVyZm9ybWFuY2UsIGFwcGx5IGZpbHRlcnMsIG9yIGNyZWF0ZSBtb3JlIGFjY3VyYXRlXG4gICAgICAgICogIGhpdCByZWdpb25zLiBGb3IgYWxsIGJhc2ljIHNoYXBlcyBzaXplIG9mIGNhY2hlIGNhbnZhcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZGV0ZWN0ZWQuXG4gICAgICAgICogIElmIHlvdSBuZWVkIHRvIGNhY2hlIHlvdXIgY3VzdG9tIGBLb252YS5TaGFwZWAgaW5zdGFuY2UgeW91IGhhdmUgdG8gcGFzcyBzaGFwZSdzIGJvdW5kaW5nIGJveFxuICAgICAgICAqICBwcm9wZXJ0aWVzLiBMb29rIGF0IFtsaW5rIHRvIGRlbW8gcGFnZV0obGluayB0byBkZW1vIHBhZ2UpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ11cbiAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldF0gIGluY3JlYXNlIGNhbnZhcyBzaXplIGJ5IGBvZmZzZXRgIHBpeGVsIGluIGFsbCBkaXJlY3Rpb25zLlxuICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmF3Qm9yZGVyXSB3aGVuIHNldCB0byB0cnVlLCBhIHJlZCBib3JkZXIgd2lsbCBiZSBkcmF3biBhcm91bmQgdGhlIGNhY2hlZFxuICAgICAgICAqICByZWdpb24gZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICogLy8gY2FjaGUgYSBzaGFwZSB3aXRoIHRoZSB4LHkgcG9zaXRpb24gb2YgdGhlIGJvdW5kaW5nIGJveCBhdCB0aGUgY2VudGVyIGFuZFxuICAgICAgICAqIC8vIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBib3VuZGluZyBib3ggZXF1YWwgdG8gdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2ZcbiAgICAgICAgKiAvLyB0aGUgc2hhcGUgb2J0YWluZWQgZnJvbSBzaGFwZS53aWR0aCgpIGFuZCBzaGFwZS5oZWlnaHQoKVxuICAgICAgICAqIGltYWdlLmNhY2hlKCk7XG4gICAgICAgICpcbiAgICAgICAgKiAvLyBjYWNoZSBhIG5vZGUgYW5kIGRlZmluZSB0aGUgYm91bmRpbmcgYm94IHBvc2l0aW9uIGFuZCBzaXplXG4gICAgICAgICogbm9kZS5jYWNoZSh7XG4gICAgICAgICogICB4OiAtMzAsXG4gICAgICAgICogICB5OiAtMzAsXG4gICAgICAgICogICB3aWR0aDogMTAwLFxuICAgICAgICAqICAgaGVpZ2h0OiAyMDBcbiAgICAgICAgKiB9KTtcbiAgICAgICAgKlxuICAgICAgICAqIC8vIGNhY2hlIGEgbm9kZSBhbmQgZHJhdyBhIHJlZCBib3JkZXIgYXJvdW5kIHRoZSBib3VuZGluZyBib3hcbiAgICAgICAgKiAvLyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXG4gICAgICAgICogbm9kZS5jYWNoZSh7XG4gICAgICAgICogICB4OiAtMzAsXG4gICAgICAgICogICB5OiAtMzAsXG4gICAgICAgICogICB3aWR0aDogMTAwLFxuICAgICAgICAqICAgaGVpZ2h0OiAyMDAsXG4gICAgICAgICogICBvZmZzZXQgOiAxMCxcbiAgICAgICAgKiAgIGRyYXdCb3JkZXI6IHRydWVcbiAgICAgICAgKiB9KTtcbiAgICAgICAgKi9cbiAgICAgICAgY2FjaGU6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgdmFyIGNvbmYgPSBjb25maWcgfHwge30sXG4gICAgICAgICAgICAgICAgcmVjdCA9IHRoaXMuZ2V0Q2xpZW50UmVjdCh0cnVlKSxcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGNvbmYud2lkdGggfHwgcmVjdC53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBjb25mLmhlaWdodCB8fCByZWN0LmhlaWdodCxcbiAgICAgICAgICAgICAgICB4ID0gY29uZi54IHx8IHJlY3QueCxcbiAgICAgICAgICAgICAgICB5ID0gY29uZi55IHx8IHJlY3QueSxcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBjb25mLm9mZnNldCB8fCAwLFxuICAgICAgICAgICAgICAgIGRyYXdCb3JkZXIgPSBjb25mLmRyYXdCb3JkZXIgfHwgZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2lkdGggb3IgaGVpZ2h0IG9mIGNhY2hpbmcgY29uZmlndXJhdGlvbiBlcXVhbHMgMC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2lkdGggKz0gb2Zmc2V0ICogMjtcbiAgICAgICAgICAgIGhlaWdodCArPSBvZmZzZXQgKiAyO1xuXG4gICAgICAgICAgICB4IC09IG9mZnNldDtcbiAgICAgICAgICAgIHkgLT0gb2Zmc2V0O1xuXG5cbiAgICAgICAgICAgIHZhciBjYWNoZWRTY2VuZUNhbnZhcyA9IG5ldyBLb252YS5TY2VuZUNhbnZhcyh7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNhY2hlZEZpbHRlckNhbnZhcyA9IG5ldyBLb252YS5TY2VuZUNhbnZhcyh7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNhY2hlZEhpdENhbnZhcyA9IG5ldyBLb252YS5IaXRDYW52YXMoe1xuICAgICAgICAgICAgICAgIHBpeGVsUmF0aW86IDEsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHNjZW5lQ29udGV4dCA9IGNhY2hlZFNjZW5lQ2FudmFzLmdldENvbnRleHQoKSxcbiAgICAgICAgICAgIGhpdENvbnRleHQgPSBjYWNoZWRIaXRDYW52YXMuZ2V0Q29udGV4dCgpO1xuXG4gICAgICAgICAgICBjYWNoZWRIaXRDYW52YXMuaXNDYWNoZSA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuXG4gICAgICAgICAgICBzY2VuZUNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgaGl0Q29udGV4dC5zYXZlKCk7XG5cbiAgICAgICAgICAgIHNjZW5lQ29udGV4dC50cmFuc2xhdGUoLXgsIC15KTtcbiAgICAgICAgICAgIGhpdENvbnRleHQudHJhbnNsYXRlKC14LCAteSk7XG5cbiAgICAgICAgICAgIHRoaXMuZHJhd1NjZW5lKGNhY2hlZFNjZW5lQ2FudmFzLCB0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0hpdChjYWNoZWRIaXRDYW52YXMsIHRoaXMsIHRydWUpO1xuXG4gICAgICAgICAgICBzY2VuZUNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgaGl0Q29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBkcmF3IGEgcmVkIGJvcmRlciBhcm91bmQgdGhlIGNhY2hlZCBib3ggZm9yXG4gICAgICAgICAgICAvLyBkZWJ1Z2dpbmcgcHVycG9zZXNcbiAgICAgICAgICAgIGlmIChkcmF3Qm9yZGVyKSB7XG4gICAgICAgICAgICAgICAgc2NlbmVDb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBzY2VuZUNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgc2NlbmVDb250ZXh0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgc2NlbmVDb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIHNjZW5lQ29udGV4dC5zZXRBdHRyKCdzdHJva2VTdHlsZScsICdyZWQnKTtcbiAgICAgICAgICAgICAgICBzY2VuZUNvbnRleHQuc2V0QXR0cignbGluZVdpZHRoJywgNSk7XG4gICAgICAgICAgICAgICAgc2NlbmVDb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIHNjZW5lQ29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2NhY2hlLmNhbnZhcyA9IHtcbiAgICAgICAgICAgICAgICBzY2VuZTogY2FjaGVkU2NlbmVDYW52YXMsXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBjYWNoZWRGaWx0ZXJDYW52YXMsXG4gICAgICAgICAgICAgICAgaGl0OiBjYWNoZWRIaXRDYW52YXMsXG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiBjbGllbnQgcmVjdGFuZ2xlIHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSBvZiBub2RlLiBUaGlzIHJlY3RhbmdsZSBhbHNvIGluY2x1ZGUgYWxsIHN0eWxpbmcgKHN0cm9rZXMsIHNoYWRvd3MsIGV0YykuXG4gICAgICAgICAqIFRoZSByZWN0YW5nbGUgcG9zaXRpb24gaXMgcmVsYXRpdmUgdG8gcGFyZW50IGNvbnRhaW5lci5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbc2tpcFRyYW5zZm9ybV0gZmxhZyBzaG91bGQgd2Ugc2tpcCB0cmFuc2Zvcm1hdGlvbiB0byByZWN0YW5nbGVcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gcmVjdCB3aXRoIHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSBwcm9wZXJ0aWVzXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIHZhciByZWN0ID0gbmV3IEtvbnZhLlJlY3Qoe1xuICAgICAgICAgKiAgICAgIHdpZHRoIDogMTAwLFxuICAgICAgICAgKiAgICAgIGhlaWdodCA6IDEwMCxcbiAgICAgICAgICogICAgICB4IDogNTAsXG4gICAgICAgICAqICAgICAgeSA6IDUwLFxuICAgICAgICAgKiAgICAgIHN0cm9rZVdpZHRoIDogNCxcbiAgICAgICAgICogICAgICBzdHJva2UgOiAnYmxhY2snLFxuICAgICAgICAgKiAgICAgIG9mZnNldFggOiA1MCxcbiAgICAgICAgICogICAgICBzY2FsZVkgOiAyXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBnZXQgY2xpZW50IHJlY3Qgd2l0aG91dCB0aGluayBvZmYgdHJhbnNmb3JtYXRpb25zIChwb3NpdGlvbiwgcm90YXRpb24sIHNjYWxlLCBvZmZzZXQsIGV0YylcbiAgICAgICAgICogcmVjdC5nZXRDbGllbnRSZWN0KHRydWUpO1xuICAgICAgICAgKiAvLyByZXR1cm5zIHtcbiAgICAgICAgICogLy8gICAgIHggOiAtMiwgICAvLyB0d28gcGl4ZWxzIGZvciBzdHJva2UgLyAyXG4gICAgICAgICAqIC8vICAgICB5IDogLTIsXG4gICAgICAgICAqIC8vICAgICB3aWR0aCA6IDEwNCwgLy8gaW5jcmVhc2VkIGJ5IDQgZm9yIHN0cm9rZVxuICAgICAgICAgKiAvLyAgICAgaGVpZ2h0IDogMTA0XG4gICAgICAgICAqIC8vfVxuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBnZXQgY2xpZW50IHJlY3Qgd2l0aCB0cmFuc2Zvcm1hdGlvbiBhcHBsaWVkXG4gICAgICAgICAqIHJlY3QuZ2V0Q2xpZW50UmVjdCgpO1xuICAgICAgICAgKiAvLyByZXR1cm5zIE9iamVjdCB7eDogLTIsIHk6IDQ2LCB3aWR0aDogMTA0LCBoZWlnaHQ6IDIwOH1cbiAgICAgICAgICovXG4gICAgICAgIGdldENsaWVudFJlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gYWJzdHJhY3QgbWV0aG9kXG4gICAgICAgICAgICAvLyByZWRlZmluZSBpbiBDb250YWluZXIgYW5kIFNoYXBlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fic3RyYWN0IFwiZ2V0Q2xpZW50UmVjdFwiIG1ldGhvZCBjYWxsJyk7XG4gICAgICAgIH0sXG4gICAgICAgIF90cmFuc2Zvcm1lZFJlY3Q6IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXG4gICAgICAgICAgICAgICAge3g6IHJlY3QueCwgeTogcmVjdC55fSxcbiAgICAgICAgICAgICAgICB7eDogcmVjdC54ICsgcmVjdC53aWR0aCwgeTogcmVjdC55fSxcbiAgICAgICAgICAgICAgICB7eDogcmVjdC54ICsgcmVjdC53aWR0aCwgeTogcmVjdC55ICsgcmVjdC5oZWlnaHR9LFxuICAgICAgICAgICAgICAgIHt4OiByZWN0LngsIHk6IHJlY3QueSArIHJlY3QuaGVpZ2h0fVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHZhciBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZO1xuICAgICAgICAgICAgdmFyIHRyYW5zID0gdGhpcy5nZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIHBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkID0gdHJhbnMucG9pbnQocG9pbnQpO1xuICAgICAgICAgICAgICAgIGlmIChtaW5YID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluWCA9IG1heFggPSB0cmFuc2Zvcm1lZC54O1xuICAgICAgICAgICAgICAgICAgICBtaW5ZID0gbWF4WSA9IHRyYW5zZm9ybWVkLnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB0cmFuc2Zvcm1lZC54KTtcbiAgICAgICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgdHJhbnNmb3JtZWQueSk7XG4gICAgICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHRyYW5zZm9ybWVkLngpO1xuICAgICAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB0cmFuc2Zvcm1lZC55KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBNYXRoLnJvdW5kKG1pblgpLFxuICAgICAgICAgICAgICAgIHk6IE1hdGgucm91bmQobWluWSksXG4gICAgICAgICAgICAgICAgd2lkdGg6IE1hdGgucm91bmQobWF4WCAtIG1pblgpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogTWF0aC5yb3VuZChtYXhZIC0gbWluWSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIF9kcmF3Q2FjaGVkU2NlbmVDYW52YXM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgY29udGV4dC5fYXBwbHlPcGFjaXR5KHRoaXMpO1xuICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuY2FudmFzLngsXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuY2FudmFzLnlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciBjYWNoZUNhbnZhcyA9IHRoaXMuX2dldENhY2hlZFNjZW5lQ2FudmFzKCk7XG4gICAgICAgICAgICB2YXIgcmF0aW8gPSBjYWNoZUNhbnZhcy5waXhlbFJhdGlvO1xuXG4gICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShjYWNoZUNhbnZhcy5fY2FudmFzLCAwLCAwLCBjYWNoZUNhbnZhcy53aWR0aCAvIHJhdGlvLCBjYWNoZUNhbnZhcy5oZWlnaHQgLyByYXRpbyk7XG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2RyYXdDYWNoZWRIaXRDYW52YXM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZWRDYW52YXMgPSB0aGlzLl9jYWNoZS5jYW52YXMsXG4gICAgICAgICAgICAgICAgaGl0Q2FudmFzID0gY2FjaGVkQ2FudmFzLmhpdDtcbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuY2FudmFzLngsXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuY2FudmFzLnlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShoaXRDYW52YXMuX2NhbnZhcywgMCwgMCk7XG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldENhY2hlZFNjZW5lQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJzID0gdGhpcy5maWx0ZXJzKCksXG4gICAgICAgICAgICAgICAgY2FjaGVkQ2FudmFzID0gdGhpcy5fY2FjaGUuY2FudmFzLFxuICAgICAgICAgICAgICAgIHNjZW5lQ2FudmFzID0gY2FjaGVkQ2FudmFzLnNjZW5lLFxuICAgICAgICAgICAgICAgIGZpbHRlckNhbnZhcyA9IGNhY2hlZENhbnZhcy5maWx0ZXIsXG4gICAgICAgICAgICAgICAgZmlsdGVyQ29udGV4dCA9IGZpbHRlckNhbnZhcy5nZXRDb250ZXh0KCksXG4gICAgICAgICAgICAgICAgbGVuLCBpbWFnZURhdGEsIG4sIGZpbHRlcjtcblxuICAgICAgICAgICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2ZpbHRlclVwVG9EYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYXRpbyA9IHNjZW5lQ2FudmFzLnBpeGVsUmF0aW87XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IGZpbHRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyQ29udGV4dC5jbGVhcigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGNhY2hlZCBjYW52YXMgb250byBmaWx0ZXIgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyQ29udGV4dC5kcmF3SW1hZ2Uoc2NlbmVDYW52YXMuX2NhbnZhcywgMCwgMCwgc2NlbmVDYW52YXMuZ2V0V2lkdGgoKSAvIHJhdGlvLCBzY2VuZUNhbnZhcy5nZXRIZWlnaHQoKSAvIHJhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YSA9IGZpbHRlckNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGZpbHRlckNhbnZhcy5nZXRXaWR0aCgpLCBmaWx0ZXJDYW52YXMuZ2V0SGVpZ2h0KCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcHBseSBmaWx0ZXJzIHRvIGZpbHRlciBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSBmaWx0ZXJzW25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlci5jYWxsKHRoaXMsIGltYWdlRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyQ29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBLb252YS5VdGlsLndhcm4oJ1VuYWJsZSB0byBhcHBseSBmaWx0ZXIuICcgKyBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJDYW52YXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2NlbmVDYW52YXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBiaW5kIGV2ZW50cyB0byB0aGUgbm9kZS4gS29udmFKUyBzdXBwb3J0cyBtb3VzZW92ZXIsIG1vdXNlbW92ZSxcbiAgICAgICAgICogIG1vdXNlb3V0LCBtb3VzZWVudGVyLCBtb3VzZWxlYXZlLCBtb3VzZWRvd24sIG1vdXNldXAsIG1vdXNld2hlZWwsIGNsaWNrLCBkYmxjbGljaywgdG91Y2hzdGFydCwgdG91Y2htb3ZlLFxuICAgICAgICAgKiAgdG91Y2hlbmQsIHRhcCwgZGJsdGFwLCBkcmFnc3RhcnQsIGRyYWdtb3ZlLCBhbmQgZHJhZ2VuZCBldmVudHMuIFRoZSBLb252YSBTdGFnZSBzdXBwb3J0c1xuICAgICAgICAgKiAgY29udGVudE1vdXNlb3ZlciwgY29udGVudE1vdXNlbW92ZSwgY29udGVudE1vdXNlb3V0LCBjb250ZW50TW91c2Vkb3duLCBjb250ZW50TW91c2V1cCxcbiAgICAgICAgICogIGNvbnRlbnRDbGljaywgY29udGVudERibGNsaWNrLCBjb250ZW50VG91Y2hzdGFydCwgY29udGVudFRvdWNobW92ZSwgY29udGVudFRvdWNoZW5kLCBjb250ZW50VGFwLFxuICAgICAgICAgKiAgYW5kIGNvbnRlbnREYmxUYXAuICBQYXNzIGluIGEgc3RyaW5nIG9mIGV2ZW50cyBkZWxpbW1pdGVkIGJ5IGEgc3BhY2UgdG8gYmluZCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICAgICAgICAgKiAgc3VjaCBhcyAnbW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlJy4gSW5jbHVkZSBhIG5hbWVzcGFjZSB0byBiaW5kIGFuXG4gICAgICAgICAqICBldmVudCBieSBuYW1lIHN1Y2ggYXMgJ2NsaWNrLmZvb2JhcicuXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldnRTdHIgZS5nLiAnY2xpY2snLCAnbW91c2Vkb3duIHRvdWNoc3RhcnQnLCAnbW91c2Vkb3duLmZvbyB0b3VjaHN0YXJ0LmZvbydcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgaGFuZGxlciBmdW5jdGlvbiBpcyBwYXNzZWQgYW4gZXZlbnQgb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBhZGQgY2xpY2sgbGlzdGVuZXJcbiAgICAgICAgICogbm9kZS5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZygneW91IGNsaWNrZWQgbWUhJyk7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBnZXQgdGhlIHRhcmdldCBub2RlXG4gICAgICAgICAqIG5vZGUub24oJ2NsaWNrJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coZXZ0LnRhcmdldCk7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uXG4gICAgICAgICAqIG5vZGUub24oJ2NsaWNrJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAqICAgZXZ0LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBiaW5kIG11bHRpcGxlIGxpc3RlbmVyc1xuICAgICAgICAgKiBub2RlLm9uKCdjbGljayB0b3VjaHN0YXJ0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coJ3lvdSBjbGlja2VkL3RvdWNoZWQgbWUhJyk7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBuYW1lc3BhY2UgbGlzdGVuZXJcbiAgICAgICAgICogbm9kZS5vbignY2xpY2suZm9vJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coJ3lvdSBjbGlja2VkL3RvdWNoZWQgbWUhJyk7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBnZXQgdGhlIGV2ZW50IHR5cGVcbiAgICAgICAgICogbm9kZS5vbignY2xpY2sgdGFwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAqICAgdmFyIGV2ZW50VHlwZSA9IGV2dC50eXBlO1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gZ2V0IG5hdGl2ZSBldmVudCBvYmplY3RcbiAgICAgICAgICogbm9kZS5vbignY2xpY2sgdGFwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAqICAgdmFyIG5hdGl2ZUV2ZW50ID0gZXZ0LmV2dDtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGZvciBjaGFuZ2UgZXZlbnRzLCBnZXQgdGhlIG9sZCBhbmQgbmV3IHZhbFxuICAgICAgICAgKiBub2RlLm9uKCd4Q2hhbmdlJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAqICAgdmFyIG9sZFZhbCA9IGV2dC5vbGRWYWw7XG4gICAgICAgICAqICAgdmFyIG5ld1ZhbCA9IGV2dC5uZXdWYWw7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBnZXQgZXZlbnQgdGFyZ2V0c1xuICAgICAgICAgKiAvLyB3aXRoIGV2ZW50IGRlbGVnYXRpb25zXG4gICAgICAgICAqIGxheWVyLm9uKCdjbGljaycsICdHcm91cCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgKiAgIHZhciBzaGFwZSA9IGV2dC50YXJnZXQ7XG4gICAgICAgICAqICAgdmFyIGdyb3VwID0gZXZ0bi5jdXJyZW50VGFyZ2VyO1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIG9uOiBmdW5jdGlvbihldnRTdHIsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXZlbnRzID0gZXZ0U3RyLnNwbGl0KFNQQUNFKSxcbiAgICAgICAgICAgICAgICBsZW4gPSBldmVudHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG4sIGV2ZW50LCBwYXJ0cywgYmFzZUV2ZW50LCBuYW1lO1xuXG4gICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGxvb3AgdGhyb3VnaCB0eXBlcyBhbmQgYXR0YWNoIGV2ZW50IGxpc3RlbmVycyB0b1xuICAgICAgICAgICAgICogZWFjaCBvbmUuICBlZy4gJ2NsaWNrIG1vdXNlb3Zlci5uYW1lc3BhY2UgbW91c2VvdXQnXG4gICAgICAgICAgICAgKiB3aWxsIGNyZWF0ZSB0aHJlZSBldmVudCBiaW5kaW5nc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmb3IobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gZXZlbnRzW25dO1xuICAgICAgICAgICAgICAgIHBhcnRzID0gZXZlbnQuc3BsaXQoRE9UKTtcbiAgICAgICAgICAgICAgICBiYXNlRXZlbnQgPSBwYXJ0c1swXTtcbiAgICAgICAgICAgICAgICBuYW1lID0gcGFydHNbMV0gfHwgRU1QVFlfU1RSSU5HO1xuXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGV2ZW50cyBhcnJheSBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuZXZlbnRMaXN0ZW5lcnNbYmFzZUV2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzW2Jhc2VFdmVudF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzW2Jhc2VFdmVudF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZW1vdmUgZXZlbnQgYmluZGluZ3MgZnJvbSB0aGUgbm9kZS4gUGFzcyBpbiBhIHN0cmluZyBvZlxuICAgICAgICAgKiAgZXZlbnQgdHlwZXMgZGVsaW1taXRlZCBieSBhIHNwYWNlIHRvIHJlbW92ZSBtdWx0aXBsZSBldmVudFxuICAgICAgICAgKiAgYmluZGluZ3MgYXQgb25jZSBzdWNoIGFzICdtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUnLlxuICAgICAgICAgKiAgaW5jbHVkZSBhIG5hbWVzcGFjZSB0byByZW1vdmUgYW4gZXZlbnQgYmluZGluZyBieSBuYW1lXG4gICAgICAgICAqICBzdWNoIGFzICdjbGljay5mb29iYXInLiBJZiB5b3Ugb25seSBnaXZlIGEgbmFtZSBsaWtlICcuZm9vYmFyJyxcbiAgICAgICAgICogIGFsbCBldmVudHMgaW4gdGhhdCBuYW1lc3BhY2Ugd2lsbCBiZSByZW1vdmVkLlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZ0U3RyIGUuZy4gJ2NsaWNrJywgJ21vdXNlZG93biB0b3VjaHN0YXJ0JywgJy5mb29iYXInXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyByZW1vdmUgbGlzdGVuZXJcbiAgICAgICAgICogbm9kZS5vZmYoJ2NsaWNrJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIHJlbW92ZSBtdWx0aXBsZSBsaXN0ZW5lcnNcbiAgICAgICAgICogbm9kZS5vZmYoJ2NsaWNrIHRvdWNoc3RhcnQnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gcmVtb3ZlIGxpc3RlbmVyIGJ5IG5hbWVcbiAgICAgICAgICogbm9kZS5vZmYoJ2NsaWNrLmZvbycpO1xuICAgICAgICAgKi9cbiAgICAgICAgb2ZmOiBmdW5jdGlvbihldnRTdHIpIHtcbiAgICAgICAgICAgIHZhciBldmVudHMgPSAoZXZ0U3RyIHx8ICcnKS5zcGxpdChTUEFDRSksXG4gICAgICAgICAgICAgICAgbGVuID0gZXZlbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBuLCB0LCBldmVudCwgcGFydHMsIGJhc2VFdmVudCwgbmFtZTtcblxuICAgICAgICAgICAgaWYgKCFldnRTdHIpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgYWxsIGV2ZW50c1xuICAgICAgICAgICAgICAgIGZvcih0IGluIHRoaXMuZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2ZmKHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcihuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBldmVudHNbbl07XG4gICAgICAgICAgICAgICAgcGFydHMgPSBldmVudC5zcGxpdChET1QpO1xuICAgICAgICAgICAgICAgIGJhc2VFdmVudCA9IHBhcnRzWzBdO1xuICAgICAgICAgICAgICAgIG5hbWUgPSBwYXJ0c1sxXTtcblxuICAgICAgICAgICAgICAgIGlmKGJhc2VFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmV2ZW50TGlzdGVuZXJzW2Jhc2VFdmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZihiYXNlRXZlbnQsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IodCBpbiB0aGlzLmV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZmYodCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gc29tZSBldmVudCBhbGlhc2VzIGZvciB0aGlyZCBwYXJ0eSBpbnRlZ3JhdGlvbiBsaWtlIEhhbW1lckpTXG4gICAgICAgIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgdmFyIGUgPSB7XG4gICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICAgICAgdHlwZTogZXZ0LnR5cGUsXG4gICAgICAgICAgICAgIGV2dDogZXZ0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5maXJlKGV2dC50eXBlLCBlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbih0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIHBhc3MgbmF0aXZlIGV2ZW50IHRvIGhhbmRsZXJcbiAgICAgICAgICAgIHRoaXMub24odHlwZSwgZnVuY3Rpb24oZXZ0KXtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgZXZ0LmV2dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICB0aGlzLm9mZih0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBsaWtlIG5vZGUub25cbiAgICAgICAgX2RlbGVnYXRlOiBmdW5jdGlvbihldmVudCwgc2VsZWN0b3IsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHZhciBzdG9wTm9kZSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLm9uKGV2ZW50LCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0cyA9IGV2dC50YXJnZXQuZmluZEFuY2VzdG9ycyhzZWxlY3RvciwgdHJ1ZSwgc3RvcE5vZGUpO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2dCA9IEtvbnZhLlV0aWwuY2xvbmVPYmplY3QoZXZ0KTtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LmN1cnJlbnRUYXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwodGFyZ2V0c1tpXSwgZXZ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50LCBidXQgZG9uJ3QgZGVzdHJveVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcblxuICAgICAgICAgICAgaWYocGFyZW50ICYmIHBhcmVudC5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgcGFyZW50Ll9zZXRDaGlsZHJlbkluZGljZXMoKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGV2ZXJ5IGNhY2hlZCBhdHRyIHRoYXQgaXMgY2FsY3VsYXRlZCB2aWEgbm9kZSB0cmVlXG4gICAgICAgICAgICAvLyB0cmF2ZXJzYWwgbXVzdCBiZSBjbGVhcmVkIHdoZW4gcmVtb3ZpbmcgYSBub2RlXG4gICAgICAgICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoU1RBR0UpO1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKEFCU09MVVRFX1RSQU5TRk9STSk7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoVklTSUJMRSk7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoTElTVEVOSU5HKTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9PUEFDSVRZKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZW1vdmUgYW5kIGRlc3Ryb3kgc2VsZlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBub2RlLmRlc3Ryb3koKTtcbiAgICAgICAgICovXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gaWRzIGFuZCBuYW1lcyBoYXNoZXNcbiAgICAgICAgICAgIEtvbnZhLl9yZW1vdmVJZCh0aGlzLmdldElkKCkpO1xuICAgICAgICAgICAgS29udmEuX3JlbW92ZU5hbWUodGhpcy5nZXROYW1lKCksIHRoaXMuX2lkKTtcblxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGF0dHJcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJcbiAgICAgICAgICogQHJldHVybnMge0ludGVnZXJ8U3RyaW5nfE9iamVjdHxBcnJheX1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogdmFyIHggPSBub2RlLmdldEF0dHIoJ3gnKTtcbiAgICAgICAgICovXG4gICAgICAgIGdldEF0dHI6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBHRVQgKyBLb252YS5VdGlsLl9jYXBpdGFsaXplKGF0dHIpO1xuICAgICAgICAgICAgaWYoS29udmEuVXRpbC5faXNGdW5jdGlvbih0aGlzW21ldGhvZF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbbWV0aG9kXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGdldCBkaXJlY3RseVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cnNbYXR0cl07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIGdldCBhbmNlc3RvcnNcbiAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICogQHJldHVybnMge0tvbnZhLkNvbGxlY3Rpb259XG4gICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgKiBzaGFwZS5nZXRBbmNlc3RvcnMoKS5lYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgKiAgIGNvbnNvbGUubG9nKG5vZGUuZ2V0SWQoKSk7XG4gICAgICAgICogfSlcbiAgICAgICAgKi9cbiAgICAgICAgZ2V0QW5jZXN0b3JzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpLFxuICAgICAgICAgICAgICAgIGFuY2VzdG9ycyA9IG5ldyBLb252YS5Db2xsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBhbmNlc3RvcnMucHVzaChwYXJlbnQpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFuY2VzdG9ycztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBhdHRycyBvYmplY3QgbGl0ZXJhbFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cnMgfHwge307XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgbXVsdGlwbGUgYXR0cnMgYXQgb25jZSB1c2luZyBhbiBvYmplY3QgbGl0ZXJhbFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIG9iamVjdCBjb250YWluaW5nIGtleSB2YWx1ZSBwYWlyc1xuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogbm9kZS5zZXRBdHRycyh7XG4gICAgICAgICAqICAgeDogNSxcbiAgICAgICAgICogICBmaWxsOiAncmVkJ1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHNldEF0dHJzOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIHZhciBrZXksIG1ldGhvZDtcblxuICAgICAgICAgICAgaWYoIWNvbmZpZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yKGtleSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBDSElMRFJFTikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gU0VUICsgS29udmEuVXRpbC5fY2FwaXRhbGl6ZShrZXkpO1xuICAgICAgICAgICAgICAgIC8vIHVzZSBzZXR0ZXIgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgaWYoS29udmEuVXRpbC5faXNGdW5jdGlvbih0aGlzW21ldGhvZF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kXShjb25maWdba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBzZXQgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0QXR0cihrZXksIGNvbmZpZ1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRldGVybWluZSBpZiBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzIGJ5IHRha2luZyBpbnRvIGFjY291bnQgYW5jZXN0b3JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBQYXJlbnQgICAgfCBTZWxmICAgICAgfCBpc0xpc3RlbmluZ1xuICAgICAgICAgKiBsaXN0ZW5pbmcgfCBsaXN0ZW5pbmcgfFxuICAgICAgICAgKiAtLS0tLS0tLS0tKy0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLVxuICAgICAgICAgKiBUICAgICAgICAgfCBUICAgICAgICAgfCBUXG4gICAgICAgICAqIFQgICAgICAgICB8IEYgICAgICAgICB8IEZcbiAgICAgICAgICogRiAgICAgICAgIHwgVCAgICAgICAgIHwgVFxuICAgICAgICAgKiBGICAgICAgICAgfCBGICAgICAgICAgfCBGXG4gICAgICAgICAqIC0tLS0tLS0tLS0rLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tXG4gICAgICAgICAqIFQgICAgICAgICB8IEkgICAgICAgICB8IFRcbiAgICAgICAgICogRiAgICAgICAgIHwgSSAgICAgICAgIHwgRlxuICAgICAgICAgKiBJICAgICAgICAgfCBJICAgICAgICAgfCBUXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaXNMaXN0ZW5pbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKExJU1RFTklORywgdGhpcy5faXNMaXN0ZW5pbmcpO1xuICAgICAgICB9LFxuICAgICAgICBfaXNMaXN0ZW5pbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmluZyA9IHRoaXMuZ2V0TGlzdGVuaW5nKCksXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcblxuICAgICAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBhIHNpbXBsaWZpY2F0aW9uIG9mIHRoZSB0cnV0aCB0YWJsZSBhYm92ZS5cbiAgICAgICAgICAgIC8vIHBsZWFzZSBtb2RpZnkgY2FyZWZ1bGx5XG4gICAgICAgICAgICBpZiAobGlzdGVuaW5nID09PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQuaXNMaXN0ZW5pbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5pbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZXRlcm1pbmUgaWYgbm9kZSBpcyB2aXNpYmxlIGJ5IHRha2luZyBpbnRvIGFjY291bnQgYW5jZXN0b3JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBQYXJlbnQgICAgfCBTZWxmICAgICAgfCBpc1Zpc2libGVcbiAgICAgICAgICogdmlzaWJsZSAgIHwgdmlzaWJsZSAgIHxcbiAgICAgICAgICogLS0tLS0tLS0tLSstLS0tLS0tLS0tLSstLS0tLS0tLS0tLS1cbiAgICAgICAgICogVCAgICAgICAgIHwgVCAgICAgICAgIHwgVFxuICAgICAgICAgKiBUICAgICAgICAgfCBGICAgICAgICAgfCBGXG4gICAgICAgICAqIEYgICAgICAgICB8IFQgICAgICAgICB8IFRcbiAgICAgICAgICogRiAgICAgICAgIHwgRiAgICAgICAgIHwgRlxuICAgICAgICAgKiAtLS0tLS0tLS0tKy0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLVxuICAgICAgICAgKiBUICAgICAgICAgfCBJICAgICAgICAgfCBUXG4gICAgICAgICAqIEYgICAgICAgICB8IEkgICAgICAgICB8IEZcbiAgICAgICAgICogSSAgICAgICAgIHwgSSAgICAgICAgIHwgVFxuXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaXNWaXNpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZShWSVNJQkxFLCB0aGlzLl9pc1Zpc2libGUpO1xuICAgICAgICB9LFxuICAgICAgICBfaXNWaXNpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB2aXNpYmxlID0gdGhpcy5nZXRWaXNpYmxlKCksXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcblxuICAgICAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBhIHNpbXBsaWZpY2F0aW9uIG9mIHRoZSB0cnV0aCB0YWJsZSBhYm92ZS5cbiAgICAgICAgICAgIC8vIHBsZWFzZSBtb2RpZnkgY2FyZWZ1bGx5XG4gICAgICAgICAgICBpZiAodmlzaWJsZSA9PT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50LmlzVmlzaWJsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2libGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZXRlcm1pbmUgaWYgbGlzdGVuaW5nIGlzIGVuYWJsZWQgYnkgdGFraW5nIGludG8gYWNjb3VudCBkZXNjZW5kYW50cy4gIElmIHNlbGYgb3IgYW55IGNoaWxkcmVuXG4gICAgICAgICAqIGhhdmUgX2lzTGlzdGVuaW5nRW5hYmxlZCBzZXQgdG8gdHJ1ZSwgdGhlbiBzZWxmIGFsc28gaGFzIGxpc3RlbmluZyBlbmFibGVkLlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHNob3VsZERyYXdIaXQ6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgICAgICAgICAgcmV0dXJuIChjYW52YXMgJiYgY2FudmFzLmlzQ2FjaGUpIHx8IChsYXllciAmJiBsYXllci5oaXRHcmFwaEVuYWJsZWQoKSlcbiAgICAgICAgICAgICAgICAmJiB0aGlzLmlzTGlzdGVuaW5nKCkgJiYgdGhpcy5pc1Zpc2libGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNob3cgbm9kZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICovXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRWaXNpYmxlKHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBoaWRlIG5vZGUuICBIaWRkZW4gbm9kZXMgYXJlIG5vIGxvbmdlciBkZXRlY3RhYmxlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZpc2libGUoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgekluZGV4IHJlbGF0aXZlIHRvIHRoZSBub2RlJ3Mgc2libGluZ3Mgd2hvIHNoYXJlIHRoZSBzYW1lIHBhcmVudFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFpJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleCB8fCAwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGFic29sdXRlIHotaW5kZXggd2hpY2ggdGFrZXMgaW50byBhY2NvdW50IHNpYmxpbmdcbiAgICAgICAgICogIGFuZCBhbmNlc3RvciBpbmRpY2VzXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QWJzb2x1dGVaSW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGRlcHRoID0gdGhpcy5nZXREZXB0aCgpLFxuICAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICAgICAgICBub2RlcywgbGVuLCBuLCBjaGlsZDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBub2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW25dO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKGNoaWxkLm5vZGVUeXBlICE9PSBTSEFQRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMgPSBub2Rlcy5jb25jYXQoY2hpbGQuZ2V0Q2hpbGRyZW4oKS50b0FycmF5KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoY2hpbGQuX2lkID09PSB0aGF0Ll9pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IGxlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKG5vZGVzLmxlbmd0aCA+IDAgJiYgbm9kZXNbMF0uZ2V0RGVwdGgoKSA8PSBkZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRDaGlsZHJlbihub2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhhdC5ub2RlVHlwZSAhPT0gVVBQRVJfU1RBR0UpIHtcbiAgICAgICAgICAgICAgICBhZGRDaGlsZHJlbih0aGF0LmdldFN0YWdlKCkuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBub2RlIGRlcHRoIGluIG5vZGUgdHJlZS4gIFJldHVybnMgYW4gaW50ZWdlci5cbiAgICAgICAgICogIGUuZy4gU3RhZ2UgZGVwdGggd2lsbCBhbHdheXMgYmUgMC4gIExheWVycyB3aWxsIGFsd2F5cyBiZSAxLiAgR3JvdXBzIGFuZCBTaGFwZXMgd2lsbCBhbHdheXNcbiAgICAgICAgICogIGJlID49IDJcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXREZXB0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZGVwdGggPSAwLFxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG4gICAgICAgICAgICB3aGlsZShwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVwdGg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0WChwb3MueCk7XG4gICAgICAgICAgICB0aGlzLnNldFkocG9zLnkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogdGhpcy5nZXRYKCksXG4gICAgICAgICAgICAgICAgeTogdGhpcy5nZXRZKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgYWJzb2x1dGUgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgc3RhZ2UgY29udGFpbmVyIGRpdlxuICAgICAgICAgKiBvciByZWxhdGl2ZSB0byBwYXNzZWQgbm9kZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdG9wXSBvcHRpb25hbCBwYXJlbnQgbm9kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldEFic29sdXRlUG9zaXRpb246IGZ1bmN0aW9uKHRvcCkge1xuICAgICAgICAgICAgdmFyIGFic29sdXRlTWF0cml4ID0gdGhpcy5nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApLmdldE1hdHJpeCgpLFxuICAgICAgICAgICAgICAgIGFic29sdXRlVHJhbnNmb3JtID0gbmV3IEtvbnZhLlRyYW5zZm9ybSgpLFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cbiAgICAgICAgICAgIC8vIGNsb25lIHRoZSBtYXRyaXggYXJyYXlcbiAgICAgICAgICAgIGFic29sdXRlVHJhbnNmb3JtLm0gPSBhYnNvbHV0ZU1hdHJpeC5zbGljZSgpO1xuICAgICAgICAgICAgYWJzb2x1dGVUcmFuc2Zvcm0udHJhbnNsYXRlKG9mZnNldC54LCBvZmZzZXQueSk7XG5cbiAgICAgICAgICAgIHJldHVybiBhYnNvbHV0ZVRyYW5zZm9ybS5nZXRUcmFuc2xhdGlvbigpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IGFic29sdXRlIHBvc2l0aW9uXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy54XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICovXG4gICAgICAgIHNldEFic29sdXRlUG9zaXRpb246IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICAgICAgdmFyIG9yaWdUcmFucyA9IHRoaXMuX2NsZWFyVHJhbnNmb3JtKCksXG4gICAgICAgICAgICAgICAgaXQ7XG5cbiAgICAgICAgICAgIC8vIGRvbid0IGNsZWFyIHRyYW5zbGF0aW9uXG4gICAgICAgICAgICB0aGlzLmF0dHJzLnggPSBvcmlnVHJhbnMueDtcbiAgICAgICAgICAgIHRoaXMuYXR0cnMueSA9IG9yaWdUcmFucy55O1xuICAgICAgICAgICAgZGVsZXRlIG9yaWdUcmFucy54O1xuICAgICAgICAgICAgZGVsZXRlIG9yaWdUcmFucy55O1xuXG4gICAgICAgICAgICAvLyB1bnJhdmVsIHRyYW5zZm9ybVxuICAgICAgICAgICAgaXQgPSB0aGlzLmdldEFic29sdXRlVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAgIGl0LmludmVydCgpO1xuICAgICAgICAgICAgaXQudHJhbnNsYXRlKHBvcy54LCBwb3MueSk7XG4gICAgICAgICAgICBwb3MgPSB7XG4gICAgICAgICAgICAgICAgeDogdGhpcy5hdHRycy54ICsgaXQuZ2V0VHJhbnNsYXRpb24oKS54LFxuICAgICAgICAgICAgICAgIHk6IHRoaXMuYXR0cnMueSArIGl0LmdldFRyYW5zbGF0aW9uKCkueVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbih7eDogcG9zLngsIHk6IHBvcy55fSk7XG4gICAgICAgICAgICB0aGlzLl9zZXRUcmFuc2Zvcm0ob3JpZ1RyYW5zKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIF9zZXRUcmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zKSB7XG4gICAgICAgICAgICB2YXIga2V5O1xuXG4gICAgICAgICAgICBmb3Ioa2V5IGluIHRyYW5zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyc1trZXldID0gdHJhbnNba2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY2xlYXJDYWNoZShUUkFOU0ZPUk0pO1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKEFCU09MVVRFX1RSQU5TRk9STSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9jbGVhclRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnMgPSB7XG4gICAgICAgICAgICAgICAgeDogdGhpcy5nZXRYKCksXG4gICAgICAgICAgICAgICAgeTogdGhpcy5nZXRZKCksXG4gICAgICAgICAgICAgICAgcm90YXRpb246IHRoaXMuZ2V0Um90YXRpb24oKSxcbiAgICAgICAgICAgICAgICBzY2FsZVg6IHRoaXMuZ2V0U2NhbGVYKCksXG4gICAgICAgICAgICAgICAgc2NhbGVZOiB0aGlzLmdldFNjYWxlWSgpLFxuICAgICAgICAgICAgICAgIG9mZnNldFg6IHRoaXMuZ2V0T2Zmc2V0WCgpLFxuICAgICAgICAgICAgICAgIG9mZnNldFk6IHRoaXMuZ2V0T2Zmc2V0WSgpLFxuICAgICAgICAgICAgICAgIHNrZXdYOiB0aGlzLmdldFNrZXdYKCksXG4gICAgICAgICAgICAgICAgc2tld1k6IHRoaXMuZ2V0U2tld1koKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5hdHRycy54ID0gMDtcbiAgICAgICAgICAgIHRoaXMuYXR0cnMueSA9IDA7XG4gICAgICAgICAgICB0aGlzLmF0dHJzLnJvdGF0aW9uID0gMDtcbiAgICAgICAgICAgIHRoaXMuYXR0cnMuc2NhbGVYID0gMTtcbiAgICAgICAgICAgIHRoaXMuYXR0cnMuc2NhbGVZID0gMTtcbiAgICAgICAgICAgIHRoaXMuYXR0cnMub2Zmc2V0WCA9IDA7XG4gICAgICAgICAgICB0aGlzLmF0dHJzLm9mZnNldFkgPSAwO1xuICAgICAgICAgICAgdGhpcy5hdHRycy5za2V3WCA9IDA7XG4gICAgICAgICAgICB0aGlzLmF0dHJzLnNrZXdZID0gMDtcblxuICAgICAgICAgICAgdGhpcy5fY2xlYXJDYWNoZShUUkFOU0ZPUk0pO1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKEFCU09MVVRFX1RSQU5TRk9STSk7XG5cbiAgICAgICAgICAgIC8vIHJldHVybiBvcmlnaW5hbCB0cmFuc2Zvcm1cbiAgICAgICAgICAgIHJldHVybiB0cmFucztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1vdmUgbm9kZSBieSBhbiBhbW91bnQgcmVsYXRpdmUgdG8gaXRzIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5nZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhbmdlLnhcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5nZS55XG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBtb3ZlIG5vZGUgaW4geCBkaXJlY3Rpb24gYnkgMXB4IGFuZCB5IGRpcmVjdGlvbiBieSAycHhcbiAgICAgICAgICogbm9kZS5tb3ZlKHtcbiAgICAgICAgICogICB4OiAxLFxuICAgICAgICAgKiAgIHk6IDIpXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgbW92ZTogZnVuY3Rpb24oY2hhbmdlKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlWCA9IGNoYW5nZS54LFxuICAgICAgICAgICAgICAgIGNoYW5nZVkgPSBjaGFuZ2UueSxcbiAgICAgICAgICAgICAgICB4ID0gdGhpcy5nZXRYKCksXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuZ2V0WSgpO1xuXG4gICAgICAgICAgICBpZihjaGFuZ2VYICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB4ICs9IGNoYW5nZVg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGNoYW5nZVkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHkgKz0gY2hhbmdlWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbih7eDogeCwgeTogeX0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIF9lYWNoQW5jZXN0b3JSZXZlcnNlOiBmdW5jdGlvbihmdW5jLCB0b3ApIHtcbiAgICAgICAgICAgIHZhciBmYW1pbHkgPSBbXSxcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpLFxuICAgICAgICAgICAgICAgIGxlbiwgbjtcblxuICAgICAgICAgICAgLy8gaWYgdG9wIG5vZGUgaXMgZGVmaW5lZCwgYW5kIHRoaXMgbm9kZSBpcyB0b3Agbm9kZSxcbiAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gbmVlZCB0byBidWlsZCBhIGZhbWlseSB0cmVlLiAganVzdCBleGVjdXRlXG4gICAgICAgICAgICAvLyBmdW5jIHdpdGggdGhpcyBiZWNhdXNlIGl0IHdpbGwgYmUgdGhlIG9ubHkgbm9kZVxuICAgICAgICAgICAgaWYgKHRvcCAmJiB0b3AuX2lkID09PSB0aGlzLl9pZCkge1xuICAgICAgICAgICAgICAgIGZ1bmModGhpcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZhbWlseS51bnNoaWZ0KHRoaXMpO1xuXG4gICAgICAgICAgICB3aGlsZShwYXJlbnQgJiYgKCF0b3AgfHwgcGFyZW50Ll9pZCAhPT0gdG9wLl9pZCkpIHtcbiAgICAgICAgICAgICAgICBmYW1pbHkudW5zaGlmdChwYXJlbnQpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxlbiA9IGZhbWlseS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgIGZ1bmMoZmFtaWx5W25dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJvdGF0ZSBub2RlIGJ5IGFuIGFtb3VudCBpbiBkZWdyZWVzIHJlbGF0aXZlIHRvIGl0cyBjdXJyZW50IHJvdGF0aW9uXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aGV0YVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICovXG4gICAgICAgIHJvdGF0ZTogZnVuY3Rpb24odGhldGEpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Um90YXRpb24odGhpcy5nZXRSb3RhdGlvbigpICsgdGhldGEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtb3ZlIG5vZGUgdG8gdGhlIHRvcCBvZiBpdHMgc2libGluZ3NcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlVG9Ub3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwud2FybignTm9kZSBoYXMgbm8gcGFyZW50LiBtb3ZlVG9Ub3AgZnVuY3Rpb24gaXMgaWdub3JlZC4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5fc2V0Q2hpbGRyZW5JbmRpY2VzKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1vdmUgbm9kZSB1cFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gZmxhZyBpcyBtb3ZlZCBvciBub3RcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVVcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdOb2RlIGhhcyBubyBwYXJlbnQuIG1vdmVVcCBmdW5jdGlvbiBpcyBpZ25vcmVkLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICAgICAgbGVuID0gdGhpcy5wYXJlbnQuZ2V0Q2hpbGRyZW4oKS5sZW5ndGg7XG4gICAgICAgICAgICBpZihpbmRleCA8IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCArIDEsIDAsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Ll9zZXRDaGlsZHJlbkluZGljZXMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1vdmUgbm9kZSBkb3duXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZURvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwud2FybignTm9kZSBoYXMgbm8gcGFyZW50LiBtb3ZlRG93biBmdW5jdGlvbiBpcyBpZ25vcmVkLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICBpZihpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCAtIDEsIDAsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Ll9zZXRDaGlsZHJlbkluZGljZXMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1vdmUgbm9kZSB0byB0aGUgYm90dG9tIG9mIGl0cyBzaWJsaW5nc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIG1vdmVUb0JvdHRvbTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdOb2RlIGhhcyBubyBwYXJlbnQuIG1vdmVUb0JvdHRvbSBmdW5jdGlvbiBpcyBpZ25vcmVkLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICBpZihpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnVuc2hpZnQodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuX3NldENoaWxkcmVuSW5kaWNlcygpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IHpJbmRleCByZWxhdGl2ZSB0byBzaWJsaW5nc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHpJbmRleFxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICovXG4gICAgICAgIHNldFpJbmRleDogZnVuY3Rpb24oekluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdOb2RlIGhhcyBubyBwYXJlbnQuIHpJbmRleCBwYXJhbWV0ZXIgaXMgaWdub3JlZC4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZSh6SW5kZXgsIDAsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuX3NldENoaWxkcmVuSW5kaWNlcygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgYWJzb2x1dGUgb3BhY2l0eVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QWJzb2x1dGVPcGFjaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZShBQlNPTFVURV9PUEFDSVRZLCB0aGlzLl9nZXRBYnNvbHV0ZU9wYWNpdHkpO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0QWJzb2x1dGVPcGFjaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhYnNPcGFjaXR5ID0gdGhpcy5nZXRPcGFjaXR5KCk7XG4gICAgICAgICAgICBpZih0aGlzLmdldFBhcmVudCgpKSB7XG4gICAgICAgICAgICAgICAgYWJzT3BhY2l0eSAqPSB0aGlzLmdldFBhcmVudCgpLmdldEFic29sdXRlT3BhY2l0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFic09wYWNpdHk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtb3ZlIG5vZGUgdG8gYW5vdGhlciBjb250YWluZXJcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtDb250YWluZXJ9IG5ld0NvbnRhaW5lclxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gbW92ZSBub2RlIGZyb20gY3VycmVudCBsYXllciBpbnRvIGxheWVyMlxuICAgICAgICAgKiBub2RlLm1vdmVUbyhsYXllcjIpO1xuICAgICAgICAgKi9cbiAgICAgICAgbW92ZVRvOiBmdW5jdGlvbihuZXdDb250YWluZXIpIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmcgaWYgbmV3IGNvbnRhaW5lciBpcyBhbHJlYWR5IHBhcmVudFxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0UGFyZW50KCkgIT09IG5ld0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgbmV3Q29udGFpbmVyLmFkZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogY29udmVydCBOb2RlIGludG8gYW4gb2JqZWN0IGZvciBzZXJpYWxpemF0aW9uLiAgUmV0dXJucyBhbiBvYmplY3QuXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0ge30sXG4gICAgICAgICAgICAgICAgYXR0cnMgPSB0aGlzLmdldEF0dHJzKCksXG4gICAgICAgICAgICAgICAga2V5LCB2YWwsIGdldHRlciwgZGVmYXVsdFZhbHVlO1xuXG4gICAgICAgICAgICBvYmouYXR0cnMgPSB7fTtcblxuICAgICAgICAgICAgZm9yKGtleSBpbiBhdHRycykge1xuICAgICAgICAgICAgICAgIHZhbCA9IGF0dHJzW2tleV07XG4gICAgICAgICAgICAgICAgLy8gc2VyaWFsaXplIG9ubHkgYXR0cmlidXRlcyB0aGF0IGFyZSBub3QgZnVuY3Rpb24sIGltYWdlLCBET00sIG9yIG9iamVjdHMgd2l0aCBtZXRob2RzXG4gICAgICAgICAgICAgICAgaWYgKEtvbnZhLlV0aWwuX2lzRnVuY3Rpb24odmFsKSB8fCBLb252YS5VdGlsLl9pc0VsZW1lbnQodmFsKSB8fFxuICAgICAgICAgICAgICAgICAgICAoS29udmEuVXRpbC5faXNPYmplY3QodmFsKSB8fCBLb252YS5VdGlsLl9oYXNNZXRob2RzKHZhbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZXR0ZXIgPSB0aGlzW2tleV07XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGF0dHIgdmFsdWUgc28gdGhhdCB3ZSBjYW4gZXh0cmFjdCB0aGUgZGVmYXVsdCB2YWx1ZSBmcm9tIHRoZSBnZXR0ZXJcbiAgICAgICAgICAgICAgICBkZWxldGUgYXR0cnNba2V5XTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbCh0aGlzKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBhdHRyIHZhbHVlXG4gICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLmF0dHJzW2tleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmouY2xhc3NOYW1lID0gdGhpcy5nZXRDbGFzc05hbWUoKTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjb252ZXJ0IE5vZGUgaW50byBhIEpTT04gc3RyaW5nLiAgUmV0dXJucyBhIEpTT04gc3RyaW5nLlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfX1cbiAgICAgICAgICovXG4gICAgICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b09iamVjdCgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBwYXJlbnQgY29udGFpbmVyXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0UGFyZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBhbGwgYW5jZXN0cm9zIChwYXJlbnQgdGhlbiBwYXJlbnQgb2YgdGhlIHBhcmVudCwgZXRjKSBvZiB0aGUgbm9kZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbGVjdG9yXSBzZWxlY3RvciBmb3Igc2VhcmNoXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2luY2x1ZGVTZWxmXSBzaG93IHdlIHRoaW5rIHRoYXQgbm9kZSBpcyBhbmNlc3RybyBpdHNlbGY/XG4gICAgICAgICAqIEBwYXJhbSB7S29udmEuTm9kZX0gW3N0b3BOb2RlXSBvcHRpb25hbCBub2RlIHdoZXJlIHdlIG5lZWQgdG8gc3RvcCBzZWFyY2hpbmcgKG9uZSBvZiBhbmNlc3RvcnMpXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gW2FuY2VzdG9yc11cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gZ2V0IG9uZSBvZiB0aGUgcGFyZW50IGdyb3VwXG4gICAgICAgICAqIHZhciBwYXJlbnRHcm91cHMgPSBub2RlLmZpbmRBbmNlc3RvcnMoJ0dyb3VwJyk7XG4gICAgICAgICAqL1xuICAgICAgICBmaW5kQW5jZXN0b3JzOiBmdW5jdGlvbihzZWxlY3RvciwgaW5jbHVkZVNlbGYsIHN0b3BOb2RlKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gW107XG5cbiAgICAgICAgICAgIGlmIChpbmNsdWRlU2VsZiAmJiB0aGlzLl9pc01hdGNoKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFuY2VzdG9yID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICB3aGlsZShhbmNlc3Rvcikge1xuICAgICAgICAgICAgICAgIGlmIChhbmNlc3RvciA9PT0gc3RvcE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFuY2VzdG9yLl9pc01hdGNoKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChhbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBhbmNlc3RvciAocGFyZW50IG9yIHBhcmVudCBvZiB0aGUgcGFyZW50LCBldGMpIG9mIHRoZSBub2RlIHRoYXQgbWF0Y2ggcGFzc2VkIHNlbGVjdG9yXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0b3JdIHNlbGVjdG9yIGZvciBzZWFyY2hcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbaW5jbHVkZVNlbGZdIHNob3cgd2UgdGhpbmsgdGhhdCBub2RlIGlzIGFuY2VzdHJvIGl0c2VsZj9cbiAgICAgICAgICogQHBhcmFtIHtLb252YS5Ob2RlfSBbc3RvcE5vZGVdIG9wdGlvbmFsIG5vZGUgd2hlcmUgd2UgbmVlZCB0byBzdG9wIHNlYXJjaGluZyAob25lIG9mIGFuY2VzdG9ycylcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9IGFuY2VzdG9yXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIGdldCBvbmUgb2YgdGhlIHBhcmVudCBncm91cFxuICAgICAgICAgKiB2YXIgZ3JvdXAgPSBub2RlLmZpbmRBbmNlc3RvcnMoJy5teWdyb3VwJyk7XG4gICAgICAgICAqL1xuICAgICAgICBmaW5kQW5jZXN0b3I6IGZ1bmN0aW9uKHNlbGVjdG9yLCBpbmNsdWRlU2VsZiwgc3RvcE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRBbmNlc3RvcnMoc2VsZWN0b3IsIGluY2x1ZGVTZWxmLCBzdG9wTm9kZSlbMF07XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGlzIGN1cnJlbnQgbm9kZSBtYXRjaCBwYXNzZWQgc2VsZWN0b3I/XG4gICAgICAgIF9pc01hdGNoOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzZWxlY3RvckFyciA9IHNlbGVjdG9yLnJlcGxhY2UoLyAvZywgJycpLnNwbGl0KCcsJyksXG4gICAgICAgICAgICAgICAgbGVuID0gc2VsZWN0b3JBcnIubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG4sIHNlbDtcblxuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgc2VsID0gc2VsZWN0b3JBcnJbbl07XG4gICAgICAgICAgICAgICAgaWYgKCFLb252YS5VdGlsLmlzVmFsaWRTZWxlY3RvcihzZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwud2FybignU2VsZWN0b3IgXCInICsgc2VsICsgJ1wiIGlzIGludmFsaWQuIEFsbG93ZWQgc2VsZWN0b3JzIGV4YW1wbGVzIGFyZSBcIiNmb29cIiwgXCIuYmFyXCIgb3IgXCJHcm91cFwiLicpO1xuICAgICAgICAgICAgICAgICAgICBLb252YS5VdGlsLndhcm4oJ0lmIHlvdSBoYXZlIGEgY3VzdG9tIHNoYXBlIHdpdGggc3VjaCBjbGFzc05hbWUsIHBsZWFzZSBjaGFuZ2UgaXQgdG8gc3RhcnQgd2l0aCB1cHBlciBsZXR0ZXIgbGlrZSBcIlRyaWFuZ2xlXCIuJyk7XG4gICAgICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwud2FybignS29udmEgaXMgYXdlc29tZSwgcmlnaHQ/Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlkIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgaWYoc2VsLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkKCkgPT09IHNlbC5zbGljZSgxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbmFtZSBzZWxlY3RvclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoc2VsLmNoYXJBdCgwKSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc05hbWUoc2VsLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2dldChzZWwpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgbGF5ZXIgYW5jZXN0b3JcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLkxheWVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGF5ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50ID8gcGFyZW50LmdldExheWVyKCkgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IHN0YWdlIGFuY2VzdG9yXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5TdGFnZX1cbiAgICAgICAgICovXG4gICAgICAgIGdldFN0YWdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZShTVEFHRSwgdGhpcy5fZ2V0U3RhZ2UpO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0U3RhZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgICAgICAgICBpZihwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50LmdldFN0YWdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZmlyZSBldmVudFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIGV2ZW50IHR5cGUuICBjYW4gYmUgYSByZWd1bGFyIGV2ZW50LCBsaWtlIGNsaWNrLCBtb3VzZW92ZXIsIG9yIG1vdXNlb3V0LCBvciBpdCBjYW4gYmUgYSBjdXN0b20gZXZlbnQsIGxpa2UgbXlDdXN0b21FdmVudFxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZXZ0XSBldmVudCBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlXSBzZXR0aW5nIHRoZSB2YWx1ZSB0byBmYWxzZSwgb3IgbGVhdmluZyBpdCB1bmRlZmluZWQsIHdpbGwgcmVzdWx0IGluIHRoZSBldmVudFxuICAgICAgICAgKiAgbm90IGJ1YmJsaW5nLiAgU2V0dGluZyB0aGUgdmFsdWUgdG8gdHJ1ZSB3aWxsIHJlc3VsdCBpbiB0aGUgZXZlbnQgYnViYmxpbmcuXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBtYW51YWxseSBmaXJlIGNsaWNrIGV2ZW50XG4gICAgICAgICAqIG5vZGUuZmlyZSgnY2xpY2snKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gZmlyZSBjdXN0b20gZXZlbnRcbiAgICAgICAgICogbm9kZS5maXJlKCdmb28nKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gZmlyZSBjdXN0b20gZXZlbnQgd2l0aCBjdXN0b20gZXZlbnQgb2JqZWN0XG4gICAgICAgICAqIG5vZGUuZmlyZSgnZm9vJywge1xuICAgICAgICAgKiAgIGJhcjogMTBcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGZpcmUgY2xpY2sgZXZlbnQgdGhhdCBidWJibGVzXG4gICAgICAgICAqIG5vZGUuZmlyZSgnY2xpY2snLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICovXG4gICAgICAgIGZpcmU6IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZXZ0LCBidWJibGUpIHtcbiAgICAgICAgICAgIGV2dCA9IGV2dCB8fCB7fTtcbiAgICAgICAgICAgIGV2dC50YXJnZXQgPSBldnQudGFyZ2V0IHx8IHRoaXM7XG4gICAgICAgICAgICAvLyBidWJibGVcbiAgICAgICAgICAgIGlmIChidWJibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlQW5kQnViYmxlKGV2ZW50VHlwZSwgZXZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vIGJ1YmJsZVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyZShldmVudFR5cGUsIGV2dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBhYnNvbHV0ZSB0cmFuc2Zvcm0gb2YgdGhlIG5vZGUgd2hpY2ggdGFrZXMgaW50b1xuICAgICAgICAgKiAgYWNjb3VudCBpdHMgYW5jZXN0b3IgdHJhbnNmb3Jtc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuVHJhbnNmb3JtfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QWJzb2x1dGVUcmFuc2Zvcm06IGZ1bmN0aW9uKHRvcCkge1xuICAgICAgICAgICAgLy8gaWYgdXNpbmcgYW4gYXJndW1lbnQsIHdlIGNhbid0IGNhY2hlIHRoZSByZXN1bHQuXG4gICAgICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEFic29sdXRlVHJhbnNmb3JtKHRvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBubyBhcmd1bWVudCwgd2UgY2FuIGNhY2hlIHRoZSByZXN1bHRcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZShBQlNPTFVURV9UUkFOU0ZPUk0sIHRoaXMuX2dldEFic29sdXRlVHJhbnNmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2dldEFic29sdXRlVHJhbnNmb3JtOiBmdW5jdGlvbih0b3ApIHtcbiAgICAgICAgICAgIHZhciBhdCA9IG5ldyBLb252YS5UcmFuc2Zvcm0oKSxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1zRW5hYmxlZCwgdHJhbnM7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IHdpdGggc3RhZ2UgYW5kIHRyYXZlcnNlIGRvd253YXJkcyB0byBzZWxmXG4gICAgICAgICAgICB0aGlzLl9lYWNoQW5jZXN0b3JSZXZlcnNlKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1zRW5hYmxlZCA9IG5vZGUudHJhbnNmb3Jtc0VuYWJsZWQoKTtcbiAgICAgICAgICAgICAgICB0cmFucyA9IG5vZGUuZ2V0VHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3Jtc0VuYWJsZWQgPT09ICdhbGwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0Lm11bHRpcGx5KHRyYW5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHJhbnNmb3Jtc0VuYWJsZWQgPT09ICdwb3NpdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgYXQudHJhbnNsYXRlKG5vZGUueCgpLCBub2RlLnkoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdG9wKTtcbiAgICAgICAgICAgIHJldHVybiBhdDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCB0cmFuc2Zvcm0gb2YgdGhlIG5vZGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoVFJBTlNGT1JNLCB0aGlzLl9nZXRUcmFuc2Zvcm0pO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0VHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBtID0gbmV3IEtvbnZhLlRyYW5zZm9ybSgpLFxuICAgICAgICAgICAgICAgIHggPSB0aGlzLmdldFgoKSxcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5nZXRZKCksXG4gICAgICAgICAgICAgICAgcm90YXRpb24gPSBLb252YS5nZXRBbmdsZSh0aGlzLmdldFJvdGF0aW9uKCkpLFxuICAgICAgICAgICAgICAgIHNjYWxlWCA9IHRoaXMuZ2V0U2NhbGVYKCksXG4gICAgICAgICAgICAgICAgc2NhbGVZID0gdGhpcy5nZXRTY2FsZVkoKSxcbiAgICAgICAgICAgICAgICBza2V3WCA9IHRoaXMuZ2V0U2tld1goKSxcbiAgICAgICAgICAgICAgICBza2V3WSA9IHRoaXMuZ2V0U2tld1koKSxcbiAgICAgICAgICAgICAgICBvZmZzZXRYID0gdGhpcy5nZXRPZmZzZXRYKCksXG4gICAgICAgICAgICAgICAgb2Zmc2V0WSA9IHRoaXMuZ2V0T2Zmc2V0WSgpO1xuXG4gICAgICAgICAgICBpZih4ICE9PSAwIHx8IHkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBtLnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgbS5yb3RhdGUocm90YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoc2tld1ggIT09IDAgfHwgc2tld1kgIT09IDApIHtcbiAgICAgICAgICAgICAgICBtLnNrZXcoc2tld1gsIHNrZXdZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHNjYWxlWCAhPT0gMSB8fCBzY2FsZVkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICBtLnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKG9mZnNldFggIT09IDAgfHwgb2Zmc2V0WSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIG0udHJhbnNsYXRlKC0xICogb2Zmc2V0WCwgLTEgKiBvZmZzZXRZKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjbG9uZSBub2RlLiAgUmV0dXJucyBhIG5ldyBOb2RlIGluc3RhbmNlIHdpdGggaWRlbnRpY2FsIGF0dHJpYnV0ZXMuICBZb3UgY2FuIGFsc28gb3ZlcnJpZGVcbiAgICAgICAgICogIHRoZSBub2RlIHByb3BlcnRpZXMgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbCwgZW5hYmxpbmcgeW91IHRvIHVzZSBhbiBleGlzdGluZyBub2RlIGFzIGEgdGVtcGxhdGVcbiAgICAgICAgICogIGZvciBhbm90aGVyIG5vZGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBvdmVycmlkZSBhdHRyc1xuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gc2ltcGxlIGNsb25lXG4gICAgICAgICAqIHZhciBjbG9uZSA9IG5vZGUuY2xvbmUoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gY2xvbmUgYSBub2RlIGFuZCBvdmVycmlkZSB0aGUgeCBwb3NpdGlvblxuICAgICAgICAgKiB2YXIgY2xvbmUgPSByZWN0LmNsb25lKHtcbiAgICAgICAgICogICB4OiA1XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgLy8gaW5zdGFudGlhdGUgbmV3IG5vZGVcbiAgICAgICAgICAgIHZhciBhdHRycyA9IEtvbnZhLlV0aWwuY2xvbmVPYmplY3QodGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAga2V5LCBhbGxMaXN0ZW5lcnMsIGxlbiwgbiwgbGlzdGVuZXI7XG4gICAgICAgICAgICAvLyBmaWx0ZXIgYmxhY2sgYXR0cnNcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gQ0xPTkVfQkxBQ0tfTElTVCkge1xuICAgICAgICAgICAgICAgIHZhciBibG9ja0F0dHIgPSBDTE9ORV9CTEFDS19MSVNUW2ldO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyc1tibG9ja0F0dHJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXBwbHkgYXR0ciBvdmVycmlkZXNcbiAgICAgICAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5vZGUgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihhdHRycyk7XG4gICAgICAgICAgICAvLyBjb3B5IG92ZXIgbGlzdGVuZXJzXG4gICAgICAgICAgICBmb3Ioa2V5IGluIHRoaXMuZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBhbGxMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzW2tleV07XG4gICAgICAgICAgICAgICAgbGVuID0gYWxsTGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGFsbExpc3RlbmVyc1tuXTtcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICogZG9uJ3QgaW5jbHVkZSBrb252YSBuYW1lc3BhY2VkIGxpc3RlbmVycyBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAgICAqICB0aGVzZSBhcmUgZ2VuZXJhdGVkIGJ5IHRoZSBjb25zdHJ1Y3RvcnNcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmKGxpc3RlbmVyLm5hbWUuaW5kZXhPZihLT05WQSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBsaXN0ZW5lcnMgYXJyYXkgZG9lc24ndCBleGlzdCwgdGhlbiBjcmVhdGUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFub2RlLmV2ZW50TGlzdGVuZXJzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmV2ZW50TGlzdGVuZXJzW2tleV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZXZlbnRMaXN0ZW5lcnNba2V5XS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSBkYXRhIFVSTC4gSWYgTUlNRSB0eXBlIGlzIG5vdFxuICAgICAgICAgKiBzcGVjaWZpZWQsIHRoZW4gXCJpbWFnZS9wbmdcIiB3aWxsIHJlc3VsdC4gRm9yIFwiaW1hZ2UvanBlZ1wiLCBzcGVjaWZ5IGEgcXVhbGl0eVxuICAgICAgICAgKiBsZXZlbCBhcyBxdWFsaXR5IChyYW5nZSAwLjAgLSAxLjApXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubWltZVR5cGVdIGNhbiBiZSBcImltYWdlL3BuZ1wiIG9yIFwiaW1hZ2UvanBlZ1wiLlxuICAgICAgICAgKiAgXCJpbWFnZS9wbmdcIiBpcyB0aGUgZGVmYXVsdFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XSB4IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldIHkgcG9zaXRpb24gb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdIHdpZHRoIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF0gaGVpZ2h0IG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnF1YWxpdHldIGpwZWcgcXVhbGl0eS4gIElmIHVzaW5nIGFuIFwiaW1hZ2UvanBlZ1wiIG1pbWVUeXBlLFxuICAgICAgICAgKiAgeW91IGNhbiBzcGVjaWZ5IHRoZSBxdWFsaXR5IGZyb20gMCB0byAxLCB3aGVyZSAwIGlzIHZlcnkgcG9vciBxdWFsaXR5IGFuZCAxXG4gICAgICAgICAqICBpcyB2ZXJ5IGhpZ2ggcXVhbGl0eVxuICAgICAgICAgKiBAcGFyZW10IHtOdW1iZXJ9IFtjb25maWcucGl4ZWxSYXRpb10gcGl4ZWxSYXRpbyBvZiBvdXB1dCBpbWFnZSB1cmwuIERlZmF1bHQgaXMgMVxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdG9EYXRhVVJMOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuICAgICAgICAgICAgdmFyIG1pbWVUeXBlID0gY29uZmlnLm1pbWVUeXBlIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgcXVhbGl0eSA9IGNvbmZpZy5xdWFsaXR5IHx8IG51bGwsXG4gICAgICAgICAgICAgICAgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCksXG4gICAgICAgICAgICAgICAgeCA9IGNvbmZpZy54IHx8IDAsXG4gICAgICAgICAgICAgICAgeSA9IGNvbmZpZy55IHx8IDAsXG4gICAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IGNvbmZpZy5waXhlbFJhdGlvIHx8IDEsXG4gICAgICAgICAgICAgICAgY2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbmZpZy53aWR0aCB8fCB0aGlzLmdldFdpZHRoKCkgfHwgKHN0YWdlID8gc3RhZ2UuZ2V0V2lkdGgoKSA6IDApLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNvbmZpZy5oZWlnaHQgfHwgdGhpcy5nZXRIZWlnaHQoKSB8fCAoc3RhZ2UgPyBzdGFnZS5nZXRIZWlnaHQoKSA6IDApLFxuICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvOiBwaXhlbFJhdGlvXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCk7XG5cbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuXG4gICAgICAgICAgICBpZih4IHx8IHkpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtMSAqIHgsIC0xICogeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZHJhd1NjZW5lKGNhbnZhcyk7XG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwobWltZVR5cGUsIHF1YWxpdHkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogY29udmVydHMgbm9kZSBpbnRvIGFuIGltYWdlLiAgU2luY2UgdGhlIHRvSW1hZ2VcbiAgICAgICAgICogIG1ldGhvZCBpcyBhc3luY2hyb25vdXMsIGEgY2FsbGJhY2sgaXMgcmVxdWlyZWQuICB0b0ltYWdlIGlzIG1vc3QgY29tbW9ubHkgdXNlZFxuICAgICAgICAgKiAgdG8gY2FjaGUgY29tcGxleCBkcmF3aW5ncyBhcyBhbiBpbWFnZSBzbyB0aGF0IHRoZXkgZG9uJ3QgaGF2ZSB0byBjb25zdGFudGx5IGJlIHJlZHJhd25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25maWcuY2FsbGJhY2sgZnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiB0aGUgY29tcG9zaXRlIGhhcyBjb21wbGV0ZWRcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubWltZVR5cGVdIGNhbiBiZSBcImltYWdlL3BuZ1wiIG9yIFwiaW1hZ2UvanBlZ1wiLlxuICAgICAgICAgKiAgXCJpbWFnZS9wbmdcIiBpcyB0aGUgZGVmYXVsdFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XSB4IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldIHkgcG9zaXRpb24gb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdIHdpZHRoIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF0gaGVpZ2h0IG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnF1YWxpdHldIGpwZWcgcXVhbGl0eS4gIElmIHVzaW5nIGFuIFwiaW1hZ2UvanBlZ1wiIG1pbWVUeXBlLFxuICAgICAgICAgKiAgeW91IGNhbiBzcGVjaWZ5IHRoZSBxdWFsaXR5IGZyb20gMCB0byAxLCB3aGVyZSAwIGlzIHZlcnkgcG9vciBxdWFsaXR5IGFuZCAxXG4gICAgICAgICAqICBpcyB2ZXJ5IGhpZ2ggcXVhbGl0eVxuICAgICAgICAgKiBAcGFyZW10IHtOdW1iZXJ9IFtjb25maWcucGl4ZWxSYXRpb10gcGl4ZWxSYXRpbyBvZiBvdXB1dCBpbWFnZS4gIERlZmF1bHQgaXMgMS5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogdmFyIGltYWdlID0gbm9kZS50b0ltYWdlKHtcbiAgICAgICAgICogICBjYWxsYmFjazogZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgICAqICAgICAvLyBkbyBzdHVmZiB3aXRoIGltZ1xuICAgICAgICAgKiAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB0b0ltYWdlOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIGlmICghY29uZmlnIHx8ICFjb25maWcuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnY2FsbGJhY2sgcmVxdWlyZWQgZm9yIHRvSW1hZ2UgbWV0aG9kIGNvbmZpZyBhcmd1bWVudCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBLb252YS5VdGlsLl9nZXRJbWFnZSh0aGlzLnRvRGF0YVVSTChjb25maWcpLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuY2FsbGJhY2soaW1nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXRTaXplOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgICAgICB0aGlzLnNldFdpZHRoKHNpemUud2lkdGgpO1xuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQoc2l6ZS5oZWlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5nZXRIZWlnaHQoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cnMud2lkdGggfHwgMDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJzLmhlaWdodCB8fCAwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGNsYXNzIG5hbWUsIHdoaWNoIG1heSByZXR1cm4gU3RhZ2UsIExheWVyLCBHcm91cCwgb3Igc2hhcGUgY2xhc3MgbmFtZXMgbGlrZSBSZWN0LCBDaXJjbGUsIFRleHQsIGV0Yy5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldENsYXNzTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGFzc05hbWUgfHwgdGhpcy5ub2RlVHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCB0aGUgbm9kZSB0eXBlLCB3aGljaCBtYXkgcmV0dXJuIFN0YWdlLCBMYXllciwgR3JvdXAsIG9yIE5vZGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldFR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZVR5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldERyYWdEaXN0YW5jZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBjb21wYXJlIHdpdGggdW5kZWZpbmVkIGJlY2F1c2Ugd2UgbmVlZCB0byB0cmFjayAwIHZhbHVlXG4gICAgICAgICAgICBpZiAodGhpcy5hdHRycy5kcmFnRGlzdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJzLmRyYWdEaXN0YW5jZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0RHJhZ0Rpc3RhbmNlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBLb252YS5kcmFnRGlzdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXQ6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGFzc05hbWUgPT09IHNlbGVjdG9yIHx8IHRoaXMubm9kZVR5cGUgPT09IHNlbGVjdG9yID8gW3RoaXNdIDogW107XG4gICAgICAgIH0sXG4gICAgICAgIF9vZmY6IGZ1bmN0aW9uKHR5cGUsIG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBldnRMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzW3R5cGVdLFxuICAgICAgICAgICAgICAgIGksIGV2dE5hbWU7XG5cbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IGV2dExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGV2dE5hbWUgPSBldnRMaXN0ZW5lcnNbaV0ubmFtZTtcbiAgICAgICAgICAgICAgICAvLyB0aGUgZm9sbG93aW5nIHR3byBjb25kaXRpb25zIG11c3QgYmUgdHJ1ZSBpbiBvcmRlciB0byByZW1vdmUgYSBoYW5kbGVyOlxuICAgICAgICAgICAgICAgIC8vIDEpIHRoZSBjdXJyZW50IGV2ZW50IG5hbWUgY2Fubm90IGJlIGtvbnZhIHVubGVzcyB0aGUgZXZlbnQgbmFtZSBpcyBrb252YVxuICAgICAgICAgICAgICAgIC8vICAgIHRoaXMgZW5hYmxlcyBkZXZlbG9wZXJzIHRvIGZvcmNlIHJlbW92ZSBhIGtvbnZhIHNwZWNpZmljIGxpc3RlbmVyIGZvciB3aGF0ZXZlciByZWFzb25cbiAgICAgICAgICAgICAgICAvLyAyKSBhbiBldmVudCBuYW1lIGlzIG5vdCBzcGVjaWZpZWQsIG9yIGlmIG9uZSBpcyBzcGVjaWZpZWQsIGl0IG1hdGNoZXMgdGhlIGN1cnJlbnQgZXZlbnQgbmFtZVxuICAgICAgICAgICAgICAgIGlmKChldnROYW1lICE9PSAna29udmEnIHx8IG5hbWUgPT09ICdrb252YScpICYmICghbmFtZSB8fCBldnROYW1lID09PSBuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBldnRMaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZihldnRMaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5ldmVudExpc3RlbmVyc1t0eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9maXJlQ2hhbmdlRXZlbnQ6IGZ1bmN0aW9uKGF0dHIsIG9sZFZhbCwgbmV3VmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9maXJlKGF0dHIgKyBDSEFOR0UsIHtcbiAgICAgICAgICAgICAgICBvbGRWYWw6IG9sZFZhbCxcbiAgICAgICAgICAgICAgICBuZXdWYWw6IG5ld1ZhbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldElkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgdmFyIG9sZElkID0gdGhpcy5nZXRJZCgpO1xuXG4gICAgICAgICAgICBLb252YS5fcmVtb3ZlSWQob2xkSWQpO1xuICAgICAgICAgICAgS29udmEuX2FkZElkKHRoaXMsIGlkKTtcbiAgICAgICAgICAgIHRoaXMuX3NldEF0dHIoSUQsIGlkKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBzZXROYW1lOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICB2YXIgb2xkTmFtZXMgPSAodGhpcy5nZXROYW1lKCkgfHwgJycpLnNwbGl0KC9cXHMvZyk7XG4gICAgICAgICAgICB2YXIgbmV3TmFtZXMgPSAobmFtZSB8fCAnJykuc3BsaXQoL1xccy9nKTtcbiAgICAgICAgICAgIHZhciBzdWJuYW1lLCBpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBzdWJuYW1lc1xuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgb2xkTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdWJuYW1lID0gb2xkTmFtZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKChuZXdOYW1lcy5pbmRleE9mKHN1Ym5hbWUpKSA9PT0gLTEgJiYgc3VibmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBLb252YS5fcmVtb3ZlTmFtZShzdWJuYW1lLCB0aGlzLl9pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhZGQgbmV3IG5hbWVzXG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBuZXdOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHN1Ym5hbWUgPSBuZXdOYW1lc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoKG9sZE5hbWVzLmluZGV4T2Yoc3VibmFtZSkgPT09IC0xKSAmJiBzdWJuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIEtvbnZhLl9hZGROYW1lKHRoaXMsIHN1Ym5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fc2V0QXR0cihOQU1FLCBuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBuYW1pbmcgbWV0aG9kc1xuICAgICAgICAvKipcbiAgICAgICAgICogYWRkIG5hbWUgdG8gbm9kZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogbm9kZS5uYW1lKCdyZWQnKTtcbiAgICAgICAgICogbm9kZS5hZGROYW1lKCdzZWxlY3RlZCcpO1xuICAgICAgICAgKiBub2RlLm5hbWUoKTsgLy8gcmV0dXJuICdyZWQgc2VsZWN0ZWQnXG4gICAgICAgICAqL1xuICAgICAgICBhZGROYW1lOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzTmFtZShuYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciBvbGROYW1lID0gdGhpcy5uYW1lKCk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld05hbWUgPSBvbGROYW1lID8gKG9sZE5hbWUgKyAnICcgKyBuYW1lKSA6IG5hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXROYW1lKG5ld05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGVjayBpcyBub2RlIGhhcyBuYW1lXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBub2RlLm5hbWUoJ3JlZCcpO1xuICAgICAgICAgKiBub2RlLmhhc05hbWUoJ3JlZCcpOyAgIC8vIHJldHVybiB0cnVlXG4gICAgICAgICAqIG5vZGUuaGFzTmFtZSgnc2VsZWN0ZWQnKTsgLy8gcmV0dXJuIGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBoYXNOYW1lOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICB2YXIgbmFtZXMgPSAodGhpcy5uYW1lKCkgfHwgJycpLnNwbGl0KC9cXHMvZyk7XG4gICAgICAgICAgICByZXR1cm4gbmFtZXMuaW5kZXhPZihuYW1lKSAhPT0gLTE7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZW1vdmUgbmFtZSBmcm9tIG5vZGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIG5vZGUubmFtZSgncmVkIHNlbGVjdGVkJyk7XG4gICAgICAgICAqIG5vZGUucmVtb3ZlTmFtZSgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICogbm9kZS5oYXNOYW1lKCdzZWxlY3RlZCcpOyAvLyByZXR1cm4gZmFsc2VcbiAgICAgICAgICogbm9kZS5uYW1lKCk7IC8vIHJldHVybiAncmVkJ1xuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlTmFtZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgdmFyIG5hbWVzID0gKHRoaXMubmFtZSgpIHx8ICcnKS5zcGxpdCgvXFxzL2cpO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBuYW1lcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TmFtZShuYW1lcy5qb2luKCcgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgYXR0clxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0clxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbFxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogbm9kZS5zZXRBdHRyKCd4JywgNSk7XG4gICAgICAgICAqL1xuICAgICAgICBzZXRBdHRyOiBmdW5jdGlvbihhdHRyLCB2YWwpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBTRVQgKyBLb252YS5VdGlsLl9jYXBpdGFsaXplKGF0dHIpLFxuICAgICAgICAgICAgICAgIGZ1bmMgPSB0aGlzW21ldGhvZF07XG5cbiAgICAgICAgICAgIGlmKEtvbnZhLlV0aWwuX2lzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgICAgICAgICBmdW5jLmNhbGwodGhpcywgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBzZXQgZGlyZWN0bHlcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEF0dHIoYXR0ciwgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBfc2V0QXR0cjogZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgICAgIHZhciBvbGRWYWw7XG4gICAgICAgICAgICBpZih2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9sZFZhbCA9IHRoaXMuYXR0cnNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAob2xkVmFsID09PSB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJzW2tleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyZUNoYW5nZUV2ZW50KGtleSwgb2xkVmFsLCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfc2V0Q29tcG9uZW50QXR0cjogZnVuY3Rpb24oa2V5LCBjb21wb25lbnQsIHZhbCkge1xuICAgICAgICAgICAgdmFyIG9sZFZhbDtcbiAgICAgICAgICAgIGlmKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb2xkVmFsID0gdGhpcy5hdHRyc1trZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFvbGRWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHZhbHVlIHRvIGRlZmF1bHQgdmFsdWUgdXNpbmcgZ2V0QXR0clxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzW2tleV0gPSB0aGlzLmdldEF0dHIoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJzW2tleV1bY29tcG9uZW50XSA9IHZhbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlQ2hhbmdlRXZlbnQoa2V5LCBvbGRWYWwsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9maXJlQW5kQnViYmxlOiBmdW5jdGlvbihldmVudFR5cGUsIGV2dCwgY29tcGFyZVNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgb2theVRvUnVuID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYoZXZ0ICYmIHRoaXMubm9kZVR5cGUgPT09IFNIQVBFKSB7XG4gICAgICAgICAgICAgICAgZXZ0LnRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGV2ZW50VHlwZSA9PT0gTU9VU0VFTlRFUiAmJiBjb21wYXJlU2hhcGUgJiYgKHRoaXMuX2lkID09PSBjb21wYXJlU2hhcGUuX2lkIHx8ICh0aGlzLmlzQW5jZXN0b3JPZiAmJiB0aGlzLmlzQW5jZXN0b3JPZihjb21wYXJlU2hhcGUpKSkpIHtcbiAgICAgICAgICAgICAgICBva2F5VG9SdW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoZXZlbnRUeXBlID09PSBNT1VTRUxFQVZFICYmIGNvbXBhcmVTaGFwZSAmJiAodGhpcy5faWQgPT09IGNvbXBhcmVTaGFwZS5faWQgfHwgKHRoaXMuaXNBbmNlc3Rvck9mICYmIHRoaXMuaXNBbmNlc3Rvck9mKGNvbXBhcmVTaGFwZSkpKSkge1xuICAgICAgICAgICAgICAgIG9rYXlUb1J1biA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYob2theVRvUnVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyZShldmVudFR5cGUsIGV2dCk7XG5cbiAgICAgICAgICAgICAgICAvLyBzaW11bGF0ZSBldmVudCBidWJibGluZ1xuICAgICAgICAgICAgICAgIHZhciBzdG9wQnViYmxlID0gKGV2ZW50VHlwZSA9PT0gTU9VU0VFTlRFUiB8fCBldmVudFR5cGUgPT09IE1PVVNFTEVBVkUpICYmICgoY29tcGFyZVNoYXBlICYmIGNvbXBhcmVTaGFwZS5pc0FuY2VzdG9yT2YgJiYgY29tcGFyZVNoYXBlLmlzQW5jZXN0b3JPZih0aGlzKSkgfHwgISEoY29tcGFyZVNoYXBlICYmIGNvbXBhcmVTaGFwZS5pc0FuY2VzdG9yT2YpKTtcbiAgICAgICAgICAgICAgICBpZigoZXZ0ICYmICFldnQuY2FuY2VsQnViYmxlIHx8ICFldnQpICYmIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmlzTGlzdGVuaW5nKCkgJiYgKCFzdG9wQnViYmxlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZihjb21wYXJlU2hhcGUgJiYgY29tcGFyZVNoYXBlLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlyZUFuZEJ1YmJsZS5jYWxsKHRoaXMucGFyZW50LCBldmVudFR5cGUsIGV2dCwgY29tcGFyZVNoYXBlLnBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9maXJlQW5kQnViYmxlLmNhbGwodGhpcy5wYXJlbnQsIGV2ZW50VHlwZSwgZXZ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2ZpcmU6IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZXZ0KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5ldmVudExpc3RlbmVyc1tldmVudFR5cGVdLFxuICAgICAgICAgICAgICAgIGk7XG5cbiAgICAgICAgICAgIGV2dCA9IEtvbnZhLlV0aWwuY2xvbmVPYmplY3QoZXZ0IHx8IHt9KTtcbiAgICAgICAgICAgIGV2dC5jdXJyZW50VGFyZ2V0ID0gdGhpcztcbiAgICAgICAgICAgIGV2dC50eXBlID0gZXZlbnRUeXBlO1xuXG4gICAgICAgICAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50c1tpXS5oYW5kbGVyLmNhbGwodGhpcywgZXZ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkcmF3IGJvdGggc2NlbmUgYW5kIGhpdCBncmFwaHMuICBJZiB0aGUgbm9kZSBiZWluZyBkcmF3biBpcyB0aGUgc3RhZ2UsIGFsbCBvZiB0aGUgbGF5ZXJzIHdpbGwgYmUgY2xlYXJlZCBhbmQgcmVkcmF3blxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICovXG4gICAgICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3U2NlbmUoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0hpdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBub2RlIHdpdGggSlNPTiBzdHJpbmcgb3IgYW4gT2JqZWN0LiAgRGUtc2VyaWFsaXp0aW9uIGRvZXMgbm90IGdlbmVyYXRlIGN1c3RvbVxuICAgICAqICBzaGFwZSBkcmF3aW5nIGZ1bmN0aW9ucywgaW1hZ2VzLCBvciBldmVudCBoYW5kbGVycyAodGhpcyB3b3VsZCBtYWtlIHRoZVxuICAgICAqICBzZXJpYWxpemVkIG9iamVjdCBodWdlKS4gIElmIHlvdXIgYXBwIHVzZXMgY3VzdG9tIHNoYXBlcywgaW1hZ2VzLCBhbmRcbiAgICAgKiAgZXZlbnQgaGFuZGxlcnMgKGl0IHByb2JhYmx5IGRvZXMpLCB0aGVuIHlvdSBuZWVkIHRvIHNlbGVjdCB0aGUgYXBwcm9wcmlhdGVcbiAgICAgKiAgc2hhcGVzIGFmdGVyIGxvYWRpbmcgdGhlIHN0YWdlIGFuZCBzZXQgdGhlc2UgcHJvcGVydGllcyB2aWEgb24oKSwgc2V0RHJhd0Z1bmMoKSxcbiAgICAgKiAgYW5kIHNldEltYWdlKCkgbWV0aG9kc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ganNvbiBzdHJpbmcgb3Igb2JqZWN0XG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBbY29udGFpbmVyXSBvcHRpb25hbCBjb250YWluZXIgZG9tIGVsZW1lbnQgdXNlZCBvbmx5IGlmIHlvdSdyZVxuICAgICAqICBjcmVhdGluZyBhIHN0YWdlIG5vZGVcbiAgICAgKi9cbiAgICBLb252YS5Ob2RlLmNyZWF0ZSA9IGZ1bmN0aW9uKGRhdGEsIGNvbnRhaW5lcikge1xuICAgICAgICBpZiAoS29udmEuVXRpbC5faXNTdHJpbmcoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVOb2RlKGRhdGEsIGNvbnRhaW5lcik7XG4gICAgfTtcbiAgICBLb252YS5Ob2RlLl9jcmVhdGVOb2RlID0gZnVuY3Rpb24ob2JqLCBjb250YWluZXIpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IEtvbnZhLk5vZGUucHJvdG90eXBlLmdldENsYXNzTmFtZS5jYWxsKG9iaiksXG4gICAgICAgICAgICBjaGlsZHJlbiA9IG9iai5jaGlsZHJlbixcbiAgICAgICAgICAgIG5vLCBsZW4sIG47XG5cbiAgICAgICAgLy8gaWYgY29udGFpbmVyIHdhcyBwYXNzZWQgaW4sIGFkZCBpdCB0byBhdHRyc1xuICAgICAgICBpZihjb250YWluZXIpIHtcbiAgICAgICAgICAgIG9iai5hdHRycy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIH1cblxuICAgICAgICBubyA9IG5ldyBLb252YVtjbGFzc05hbWVdKG9iai5hdHRycyk7XG4gICAgICAgIGlmKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBmb3IobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgIG5vLmFkZCh0aGlzLl9jcmVhdGVOb2RlKGNoaWxkcmVuW25dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm87XG4gICAgfTtcblxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09IGFkZCBnZXR0ZXJzIHNldHRlcnMgPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3Bvc2l0aW9uJyk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBub2RlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHBhcmVudFxuICAgICAqIEBuYW1lIHBvc2l0aW9uXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zLnhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zLnlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHBvc2l0aW9uXG4gICAgICogdmFyIHBvc2l0aW9uID0gbm9kZS5wb3NpdGlvbigpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHBvc2l0aW9uXG4gICAgICogbm9kZS5wb3NpdGlvbih7XG4gICAgICogICB4OiA1XG4gICAgICogICB5OiAxMFxuICAgICAqIH0pO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3gnLCAwKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgeCBwb3NpdGlvblxuICAgICAqIEBuYW1lIHhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHhcbiAgICAgKiB2YXIgeCA9IG5vZGUueCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHhcbiAgICAgKiBub2RlLngoNSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAneScsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCB5IHBvc2l0aW9uXG4gICAgICogQG5hbWUgeVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHlcbiAgICAgKiB2YXIgeSA9IG5vZGUueSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHlcbiAgICAgKiBub2RlLnkoNSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnb3BhY2l0eScsIDEpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBvcGFjaXR5LiAgT3BhY2l0eSB2YWx1ZXMgcmFuZ2UgZnJvbSAwIHRvIDEuXG4gICAgICogIEEgbm9kZSB3aXRoIGFuIG9wYWNpdHkgb2YgMCBpcyBmdWxseSB0cmFuc3BhcmVudCwgYW5kIGEgbm9kZVxuICAgICAqICB3aXRoIGFuIG9wYWNpdHkgb2YgMSBpcyBmdWxseSBvcGFxdWVcbiAgICAgKiBAbmFtZSBvcGFjaXR5XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcGFjaXR5XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBvcGFjaXR5XG4gICAgICogdmFyIG9wYWNpdHkgPSBub2RlLm9wYWNpdHkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBvcGFjaXR5XG4gICAgICogbm9kZS5vcGFjaXR5KDAuNSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlcihLb252YS5Ob2RlLCAnbmFtZScpO1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnbmFtZScpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBuYW1lXG4gICAgICogQG5hbWUgbmFtZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgbmFtZVxuICAgICAqIHZhciBuYW1lID0gbm9kZS5uYW1lKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgbmFtZVxuICAgICAqIG5vZGUubmFtZSgnZm9vJyk7XG4gICAgICpcbiAgICAgKiAvLyBhbHNvIG5vZGUgbWF5IGhhdmUgbXVsdGlwbGUgbmFtZXMgKGFzIGNzcyBjbGFzc2VzKVxuICAgICAqIG5vZGUubmFtZSgnZm9vIGJhcicpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXIoS29udmEuTm9kZSwgJ2lkJyk7XG4gICAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdpZCcpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBpZC4gSWQgaXMgZ2xvYmFsIGZvciB3aG9sZSBwYWdlLlxuICAgICAqIEBuYW1lIGlkXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgaWRcbiAgICAgKiB2YXIgbmFtZSA9IG5vZGUuaWQoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBpZFxuICAgICAqIG5vZGUuaWQoJ2ZvbycpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3JvdGF0aW9uJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAbmFtZSByb3RhdGlvblxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcm90YXRpb25cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiB2YXIgcm90YXRpb24gPSBub2RlLnJvdGF0aW9uKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIG5vZGUucm90YXRpb24oNDUpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdzY2FsZScsIFsneCcsICd5J10pO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBzY2FsZVxuICAgICAqIEBuYW1lIHNjYWxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlLnhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUueVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHNjYWxlXG4gICAgICogdmFyIHNjYWxlID0gbm9kZS5zY2FsZSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNjYWxlXG4gICAgICogc2hhcGUuc2NhbGUoe1xuICAgICAqICAgeDogMlxuICAgICAqICAgeTogM1xuICAgICAqIH0pO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3NjYWxlWCcsIDEpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBzY2FsZSB4XG4gICAgICogQG5hbWUgc2NhbGVYXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzY2FsZSB4XG4gICAgICogdmFyIHNjYWxlWCA9IG5vZGUuc2NhbGVYKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc2NhbGUgeFxuICAgICAqIG5vZGUuc2NhbGVYKDIpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3NjYWxlWScsIDEpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBzY2FsZSB5XG4gICAgICogQG5hbWUgc2NhbGVZXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzY2FsZSB5XG4gICAgICogdmFyIHNjYWxlWSA9IG5vZGUuc2NhbGVZKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc2NhbGUgeVxuICAgICAqIG5vZGUuc2NhbGVZKDIpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdza2V3JywgWyd4JywgJ3knXSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHNrZXdcbiAgICAgKiBAbmFtZSBza2V3XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNrZXdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2tldy54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNrZXcueVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHNrZXdcbiAgICAgKiB2YXIgc2tldyA9IG5vZGUuc2tldygpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNrZXdcbiAgICAgKiBub2RlLnNrZXcoe1xuICAgICAqICAgeDogMjBcbiAgICAgKiAgIHk6IDEwXG4gICAgICogfSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnc2tld1gnLCAwKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgc2tldyB4XG4gICAgICogQG5hbWUgc2tld1hcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHNrZXcgeFxuICAgICAqIHZhciBza2V3WCA9IG5vZGUuc2tld1goKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBza2V3IHhcbiAgICAgKiBub2RlLnNrZXdYKDMpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3NrZXdZJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHNrZXcgeVxuICAgICAqIEBuYW1lIHNrZXdZXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBza2V3IHlcbiAgICAgKiB2YXIgc2tld1kgPSBub2RlLnNrZXdZKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc2tldyB5XG4gICAgICogbm9kZS5za2V3WSgzKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5Ob2RlLCAnb2Zmc2V0JywgWyd4JywgJ3knXSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IG9mZnNldC4gIE9mZnNldHMgdGhlIGRlZmF1bHQgcG9zaXRpb24gYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0LnhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0LnlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IG9mZnNldFxuICAgICAqIHZhciBvZmZzZXQgPSBub2RlLm9mZnNldCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IG9mZnNldFxuICAgICAqIG5vZGUub2Zmc2V0KHtcbiAgICAgKiAgIHg6IDIwXG4gICAgICogICB5OiAxMFxuICAgICAqIH0pO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ29mZnNldFgnLCAwKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgb2Zmc2V0IHhcbiAgICAgKiBAbmFtZSBvZmZzZXRYXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBvZmZzZXQgeFxuICAgICAqIHZhciBvZmZzZXRYID0gbm9kZS5vZmZzZXRYKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgb2Zmc2V0IHhcbiAgICAgKiBub2RlLm9mZnNldFgoMyk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnb2Zmc2V0WScsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBvZmZzZXQgeVxuICAgICAqIEBuYW1lIG9mZnNldFlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IG9mZnNldCB5XG4gICAgICogdmFyIG9mZnNldFkgPSBub2RlLm9mZnNldFkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBvZmZzZXQgeVxuICAgICAqIG5vZGUub2Zmc2V0WSgzKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkU2V0dGVyKEtvbnZhLk5vZGUsICdkcmFnRGlzdGFuY2UnKTtcbiAgICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2RyYWdEaXN0YW5jZScpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBkcmFnIGRpc3RhbmNlXG4gICAgICogQG5hbWUgZHJhZ0Rpc3RhbmNlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkaXN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZHJhZyBkaXN0YW5jZVxuICAgICAqIHZhciBkcmFnRGlzdGFuY2UgPSBub2RlLmRyYWdEaXN0YW5jZSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGRpc3RhbmNlXG4gICAgICogLy8gbm9kZSBzdGFydHMgZHJhZ2dpbmcgb25seSBpZiBwb2ludGVyIG1vdmVkIG1vcmUgdGhlbiAzIHBpeGVsc1xuICAgICAqIG5vZGUuZHJhZ0Rpc3RhbmNlKDMpO1xuICAgICAqIC8vIG9yIHNldCBnbG9iYWxseVxuICAgICAqIEtvbnZhLmRyYWdEaXN0YW5jZSA9IDM7XG4gICAgICovXG5cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkU2V0dGVyKEtvbnZhLk5vZGUsICd3aWR0aCcsIDApO1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnd2lkdGgnKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHdpZHRoXG4gICAgICogQG5hbWUgd2lkdGhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCB3aWR0aFxuICAgICAqIHZhciB3aWR0aCA9IG5vZGUud2lkdGgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCB3aWR0aFxuICAgICAqIG5vZGUud2lkdGgoMTAwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkU2V0dGVyKEtvbnZhLk5vZGUsICdoZWlnaHQnLCAwKTtcbiAgICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2hlaWdodCcpO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgaGVpZ2h0XG4gICAgICogQG5hbWUgaGVpZ2h0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGhlaWdodFxuICAgICAqIHZhciBoZWlnaHQgPSBub2RlLmhlaWdodCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGhlaWdodFxuICAgICAqIG5vZGUuaGVpZ2h0KDEwMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnbGlzdGVuaW5nJywgJ2luaGVyaXQnKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGxpc3RlbmlnIGF0dHIuICBJZiB5b3UgbmVlZCB0byBkZXRlcm1pbmUgaWYgYSBub2RlIGlzIGxpc3RlbmluZyBvciBub3RcbiAgICAgKiAgIGJ5IHRha2luZyBpbnRvIGFjY291bnQgaXRzIHBhcmVudHMsIHVzZSB0aGUgaXNMaXN0ZW5pbmcoKSBtZXRob2RcbiAgICAgKiBAbmFtZSBsaXN0ZW5pbmdcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gbGlzdGVuaW5nIENhbiBiZSBcImluaGVyaXRcIiwgdHJ1ZSwgb3IgZmFsc2UuICBUaGUgZGVmYXVsdCBpcyBcImluaGVyaXRcIi5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgbGlzdGVuaW5nIGF0dHJcbiAgICAgKiB2YXIgbGlzdGVuaW5nID0gbm9kZS5saXN0ZW5pbmcoKTtcbiAgICAgKlxuICAgICAqIC8vIHN0b3AgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBub2RlLmxpc3RlbmluZyhmYWxzZSk7XG4gICAgICpcbiAgICAgKiAvLyBsaXN0ZW4gZm9yIGV2ZW50c1xuICAgICAqIG5vZGUubGlzdGVuaW5nKHRydWUpO1xuICAgICAqXG4gICAgICogLy8gbGlzdGVuIHRvIGV2ZW50cyBhY2NvcmRpbmcgdG8gdGhlIHBhcmVudFxuICAgICAqIG5vZGUubGlzdGVuaW5nKCdpbmhlcml0Jyk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZmlsdGVycycsIHVuZGVmaW5lZCwgZnVuY3Rpb24odmFsKSB7dGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTsgcmV0dXJuIHZhbDsgfSk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWx0ZXJzLiAgRmlsdGVycyBhcmUgYXBwbGllZCB0byBjYWNoZWQgY2FudmFzZXNcbiAgICAgKiBAbmFtZSBmaWx0ZXJzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnMgYXJyYXkgb2YgZmlsdGVyc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWx0ZXJzXG4gICAgICogdmFyIGZpbHRlcnMgPSBub2RlLmZpbHRlcnMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBhIHNpbmdsZSBmaWx0ZXJcbiAgICAgKiBub2RlLmNhY2hlKCk7XG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkJsdXJdKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBtdWx0aXBsZSBmaWx0ZXJzXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbXG4gICAgICogICBLb252YS5GaWx0ZXJzLkJsdXIsXG4gICAgICogICBLb252YS5GaWx0ZXJzLlNlcGlhLFxuICAgICAqICAgS29udmEuRmlsdGVycy5JbnZlcnRcbiAgICAgKiBdKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICd2aXNpYmxlJywgJ2luaGVyaXQnKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHZpc2libGUgYXR0ci4gIENhbiBiZSBcImluaGVyaXRcIiwgdHJ1ZSwgb3IgZmFsc2UuICBUaGUgZGVmYXVsdCBpcyBcImluaGVyaXRcIi5cbiAgICAgKiAgIElmIHlvdSBuZWVkIHRvIGRldGVybWluZSBpZiBhIG5vZGUgaXMgdmlzaWJsZSBvciBub3RcbiAgICAgKiAgIGJ5IHRha2luZyBpbnRvIGFjY291bnQgaXRzIHBhcmVudHMsIHVzZSB0aGUgaXNWaXNpYmxlKCkgbWV0aG9kXG4gICAgICogQG5hbWUgdmlzaWJsZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSB2aXNpYmxlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW58U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHZpc2libGUgYXR0clxuICAgICAqIHZhciB2aXNpYmxlID0gbm9kZS52aXNpYmxlKCk7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGludmlzaWJsZVxuICAgICAqIG5vZGUudmlzaWJsZShmYWxzZSk7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIHZpc2libGVcbiAgICAgKiBub2RlLnZpc2libGUodHJ1ZSk7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIHZpc2libGUgYWNjb3JkaW5nIHRvIHRoZSBwYXJlbnRcbiAgICAgKiBub2RlLnZpc2libGUoJ2luaGVyaXQnKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICd0cmFuc2Zvcm1zRW5hYmxlZCcsICdhbGwnKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgdHJhbnNmb3JtcyB0aGF0IGFyZSBlbmFibGVkLiAgQ2FuIGJlIFwiYWxsXCIsIFwibm9uZVwiLCBvciBcInBvc2l0aW9uXCIuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBcImFsbFwiXG4gICAgICogQG5hbWUgdHJhbnNmb3Jtc0VuYWJsZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGVuYWJsZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZW5hYmxlIHBvc2l0aW9uIHRyYW5zZm9ybSBvbmx5IHRvIGltcHJvdmUgZHJhdyBwZXJmb3JtYW5jZVxuICAgICAqIG5vZGUudHJhbnNmb3Jtc0VuYWJsZWQoJ3Bvc2l0aW9uJyk7XG4gICAgICpcbiAgICAgKiAvLyBlbmFibGUgYWxsIHRyYW5zZm9ybXNcbiAgICAgKiBub2RlLnRyYW5zZm9ybXNFbmFibGVkKCdhbGwnKTtcbiAgICAgKi9cblxuXG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IG5vZGUgc2l6ZVxuICAgICAqIEBuYW1lIHNpemVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNpemVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZS53aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplLmhlaWdodFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgbm9kZSBzaXplXG4gICAgICogdmFyIHNpemUgPSBub2RlLnNpemUoKTtcbiAgICAgKiB2YXIgeCA9IHNpemUueDtcbiAgICAgKiB2YXIgeSA9IHNpemUueTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzaXplXG4gICAgICogbm9kZS5zaXplKHtcbiAgICAgKiAgIHdpZHRoOiAxMDAsXG4gICAgICogICBoZWlnaHQ6IDIwMFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnc2l6ZScpO1xuXG4gICAgS29udmEuRmFjdG9yeS5iYWNrQ29tcGF0KEtvbnZhLk5vZGUsIHtcbiAgICAgICAgcm90YXRlRGVnOiAncm90YXRlJyxcbiAgICAgICAgc2V0Um90YXRpb25EZWc6ICdzZXRSb3RhdGlvbicsXG4gICAgICAgIGdldFJvdGF0aW9uRGVnOiAnZ2V0Um90YXRpb24nXG4gICAgfSk7XG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuTm9kZSk7XG59KShLb252YSk7XG5cbihmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8qKlxyXG4gICAgKiBHcmF5c2NhbGUgRmlsdGVyXHJcbiAgICAqIEBmdW5jdGlvblxyXG4gICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqIG5vZGUuY2FjaGUoKTtcclxuICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkdyYXlzY2FsZV0pO1xyXG4gICAgKi9cclxuICAgIEtvbnZhLkZpbHRlcnMuR3JheXNjYWxlID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcclxuICAgICAgICAgICAgbGVuID0gZGF0YS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGksIGJyaWdodG5lc3M7XHJcblxyXG4gICAgICAgIGZvcihpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgIGJyaWdodG5lc3MgPSAwLjM0ICogZGF0YVtpXSArIDAuNSAqIGRhdGFbaSArIDFdICsgMC4xNiAqIGRhdGFbaSArIDJdO1xyXG4gICAgICAgICAgICAvLyByZWRcclxuICAgICAgICAgICAgZGF0YVtpXSA9IGJyaWdodG5lc3M7XHJcbiAgICAgICAgICAgIC8vIGdyZWVuXHJcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gYnJpZ2h0bmVzcztcclxuICAgICAgICAgICAgLy8gYmx1ZVxyXG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IGJyaWdodG5lc3M7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSkoKTtcclxuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qKlxuICAgICAqIEJyaWdodGVuIEZpbHRlci5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuQnJpZ2h0ZW5dKTtcbiAgICAgKiBub2RlLmJyaWdodG5lc3MoMC44KTtcbiAgICAgKi9cbiAgICBLb252YS5GaWx0ZXJzLkJyaWdodGVuID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgICAgIHZhciBicmlnaHRuZXNzID0gdGhpcy5icmlnaHRuZXNzKCkgKiAyNTUsXG4gICAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgICAgIC8vIHJlZFxuICAgICAgICAgICAgZGF0YVtpXSArPSBicmlnaHRuZXNzO1xuICAgICAgICAgICAgLy8gZ3JlZW5cbiAgICAgICAgICAgIGRhdGFbaSArIDFdICs9IGJyaWdodG5lc3M7XG4gICAgICAgICAgICAvLyBibHVlXG4gICAgICAgICAgICBkYXRhW2kgKyAyXSArPSBicmlnaHRuZXNzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdicmlnaHRuZXNzJywgMCwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGZpbHRlciBicmlnaHRuZXNzLiAgVGhlIGJyaWdodG5lc3MgaXMgYSBudW1iZXIgYmV0d2VlbiAtMSBhbmQgMS4mbmJzcDsgUG9zaXRpdmUgdmFsdWVzXG4gICAgKiAgYnJpZ2h0ZW4gdGhlIHBpeGVscyBhbmQgbmVnYXRpdmUgdmFsdWVzIGRhcmtlbiB0aGVtLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5CcmlnaHRlbn0gZmlsdGVyLlxuICAgICogQG5hbWUgYnJpZ2h0bmVzc1xuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge051bWJlcn0gYnJpZ2h0bmVzcyB2YWx1ZSBiZXR3ZWVuIC0xIGFuZCAxXG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICovXG5cbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8qKlxyXG4gICAgKiBJbnZlcnQgRmlsdGVyXHJcbiAgICAqIEBmdW5jdGlvblxyXG4gICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqIG5vZGUuY2FjaGUoKTtcclxuICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkludmVydF0pO1xyXG4gICAgKi9cclxuICAgIEtvbnZhLkZpbHRlcnMuSW52ZXJ0ID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcclxuICAgICAgICAgICAgbGVuID0gZGF0YS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGk7XHJcblxyXG4gICAgICAgIGZvcihpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgIC8vIHJlZFxyXG4gICAgICAgICAgICBkYXRhW2ldID0gMjU1IC0gZGF0YVtpXTtcclxuICAgICAgICAgICAgLy8gZ3JlZW5cclxuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSAyNTUgLSBkYXRhW2kgKyAxXTtcclxuICAgICAgICAgICAgLy8gYmx1ZVxyXG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IDI1NSAtIGRhdGFbaSArIDJdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0pKCk7XHJcblxuLypcbiB0aGUgR2F1c3MgZmlsdGVyXG4gbWFzdGVyIHJlcG86IGh0dHBzOi8vZ2l0aHViLmNvbS9wYXZlbHBvd2VyL2tpbmV0aWNqc0dhdXNzRmlsdGVyXG4qL1xuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKlxuXG4gICAgIFN0YWNrQmx1ciAtIGEgZmFzdCBhbG1vc3QgR2F1c3NpYW4gQmx1ciBGb3IgQ2FudmFzXG5cbiAgICAgVmVyc2lvbjogICAwLjVcbiAgICAgQXV0aG9yOiAgICBNYXJpbyBLbGluZ2VtYW5uXG4gICAgIENvbnRhY3Q6ICAgbWFyaW9AcXVhc2ltb25kby5jb21cbiAgICAgV2Vic2l0ZTogICBodHRwOi8vd3d3LnF1YXNpbW9uZG8uY29tL1N0YWNrQmx1ckZvckNhbnZhc1xuICAgICBUd2l0dGVyOiAgIEBxdWFzaW1vbmRvXG5cbiAgICAgSW4gY2FzZSB5b3UgZmluZCB0aGlzIGNsYXNzIHVzZWZ1bCAtIGVzcGVjaWFsbHkgaW4gY29tbWVyY2lhbCBwcm9qZWN0cyAtXG4gICAgIEkgYW0gbm90IHRvdGFsbHkgdW5oYXBweSBmb3IgYSBzbWFsbCBkb25hdGlvbiB0byBteSBQYXlQYWwgYWNjb3VudFxuICAgICBtYXJpb0BxdWFzaW1vbmRvLmRlXG5cbiAgICAgT3Igc3VwcG9ydCBtZSBvbiBmbGF0dHI6XG4gICAgIGh0dHBzOi8vZmxhdHRyLmNvbS90aGluZy83Mjc5MS9TdGFja0JsdXItYS1mYXN0LWFsbW9zdC1HYXVzc2lhbi1CbHVyLUVmZmVjdC1mb3ItQ2FudmFzSmF2YXNjcmlwdFxuXG4gICAgIENvcHlyaWdodCAoYykgMjAxMCBNYXJpbyBLbGluZ2VtYW5uXG5cbiAgICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAgICAgZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gICAgIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICAgICBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAgICAgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAgICAgY29uZGl0aW9uczpcblxuICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICAgICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAgICAgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAgICAgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gICAgIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICAgICBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gICAgIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEJsdXJTdGFjaygpIHtcbiAgICAgICAgdGhpcy5yID0gMDtcbiAgICAgICAgdGhpcy5nID0gMDtcbiAgICAgICAgdGhpcy5iID0gMDtcbiAgICAgICAgdGhpcy5hID0gMDtcbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbXVsX3RhYmxlID0gW1xuICAgICAgICA1MTIsIDUxMiwgNDU2LCA1MTIsIDMyOCwgNDU2LCAzMzUsIDUxMiwgNDA1LCAzMjgsIDI3MSwgNDU2LCAzODgsIDMzNSwgMjkyLCA1MTIsXG4gICAgICAgIDQ1NCwgNDA1LCAzNjQsIDMyOCwgMjk4LCAyNzEsIDQ5NiwgNDU2LCA0MjAsIDM4OCwgMzYwLCAzMzUsIDMxMiwgMjkyLCAyNzMsIDUxMixcbiAgICAgICAgNDgyLCA0NTQsIDQyOCwgNDA1LCAzODMsIDM2NCwgMzQ1LCAzMjgsIDMxMiwgMjk4LCAyODQsIDI3MSwgMjU5LCA0OTYsIDQ3NSwgNDU2LFxuICAgICAgICA0MzcsIDQyMCwgNDA0LCAzODgsIDM3NCwgMzYwLCAzNDcsIDMzNSwgMzIzLCAzMTIsIDMwMiwgMjkyLCAyODIsIDI3MywgMjY1LCA1MTIsXG4gICAgICAgIDQ5NywgNDgyLCA0NjgsIDQ1NCwgNDQxLCA0MjgsIDQxNywgNDA1LCAzOTQsIDM4MywgMzczLCAzNjQsIDM1NCwgMzQ1LCAzMzcsIDMyOCxcbiAgICAgICAgMzIwLCAzMTIsIDMwNSwgMjk4LCAyOTEsIDI4NCwgMjc4LCAyNzEsIDI2NSwgMjU5LCA1MDcsIDQ5NiwgNDg1LCA0NzUsIDQ2NSwgNDU2LFxuICAgICAgICA0NDYsIDQzNywgNDI4LCA0MjAsIDQxMiwgNDA0LCAzOTYsIDM4OCwgMzgxLCAzNzQsIDM2NywgMzYwLCAzNTQsIDM0NywgMzQxLCAzMzUsXG4gICAgICAgIDMyOSwgMzIzLCAzMTgsIDMxMiwgMzA3LCAzMDIsIDI5NywgMjkyLCAyODcsIDI4MiwgMjc4LCAyNzMsIDI2OSwgMjY1LCAyNjEsIDUxMixcbiAgICAgICAgNTA1LCA0OTcsIDQ4OSwgNDgyLCA0NzUsIDQ2OCwgNDYxLCA0NTQsIDQ0NywgNDQxLCA0MzUsIDQyOCwgNDIyLCA0MTcsIDQxMSwgNDA1LFxuICAgICAgICAzOTksIDM5NCwgMzg5LCAzODMsIDM3OCwgMzczLCAzNjgsIDM2NCwgMzU5LCAzNTQsIDM1MCwgMzQ1LCAzNDEsIDMzNywgMzMyLCAzMjgsXG4gICAgICAgIDMyNCwgMzIwLCAzMTYsIDMxMiwgMzA5LCAzMDUsIDMwMSwgMjk4LCAyOTQsIDI5MSwgMjg3LCAyODQsIDI4MSwgMjc4LCAyNzQsIDI3MSxcbiAgICAgICAgMjY4LCAyNjUsIDI2MiwgMjU5LCAyNTcsIDUwNywgNTAxLCA0OTYsIDQ5MSwgNDg1LCA0ODAsIDQ3NSwgNDcwLCA0NjUsIDQ2MCwgNDU2LFxuICAgICAgICA0NTEsIDQ0NiwgNDQyLCA0MzcsIDQzMywgNDI4LCA0MjQsIDQyMCwgNDE2LCA0MTIsIDQwOCwgNDA0LCA0MDAsIDM5NiwgMzkyLCAzODgsXG4gICAgICAgIDM4NSwgMzgxLCAzNzcsIDM3NCwgMzcwLCAzNjcsIDM2MywgMzYwLCAzNTcsIDM1NCwgMzUwLCAzNDcsIDM0NCwgMzQxLCAzMzgsIDMzNSxcbiAgICAgICAgMzMyLCAzMjksIDMyNiwgMzIzLCAzMjAsIDMxOCwgMzE1LCAzMTIsIDMxMCwgMzA3LCAzMDQsIDMwMiwgMjk5LCAyOTcsIDI5NCwgMjkyLFxuICAgICAgICAyODksIDI4NywgMjg1LCAyODIsIDI4MCwgMjc4LCAyNzUsIDI3MywgMjcxLCAyNjksIDI2NywgMjY1LCAyNjMsIDI2MSwgMjU5XG4gICAgXTtcblxuICAgIHZhciBzaGdfdGFibGUgPSBbXG4gICAgICAgIDksIDExLCAxMiwgMTMsIDEzLCAxNCwgMTQsIDE1LCAxNSwgMTUsIDE1LCAxNiwgMTYsIDE2LCAxNiwgMTcsXG4gICAgICAgIDE3LCAxNywgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE5LFxuICAgICAgICAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCxcbiAgICAgICAgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjEsXG4gICAgICAgIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLFxuICAgICAgICAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMixcbiAgICAgICAgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsXG4gICAgICAgIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIzLFxuICAgICAgICAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMyxcbiAgICAgICAgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsXG4gICAgICAgIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLFxuICAgICAgICAyMywgMjMsIDIzLCAyMywgMjMsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcbiAgICAgICAgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsXG4gICAgICAgIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxuICAgICAgICAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcbiAgICAgICAgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNFxuICAgIF07XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJHYXVzc0JsdXJSR0JBKCBpbWFnZURhdGEsIHJhZGl1cykge1xuXG4gICAgICAgIHZhciBwaXhlbHMgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICAgIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodDtcblxuICAgICAgICB2YXIgeCwgeSwgaSwgcCwgeXAsIHlpLCB5dywgcl9zdW0sIGdfc3VtLCBiX3N1bSwgYV9zdW0sXG4gICAgICAgICAgICByX291dF9zdW0sIGdfb3V0X3N1bSwgYl9vdXRfc3VtLCBhX291dF9zdW0sXG4gICAgICAgICAgICByX2luX3N1bSwgZ19pbl9zdW0sIGJfaW5fc3VtLCBhX2luX3N1bSxcbiAgICAgICAgICAgIHByLCBwZywgcGIsIHBhLCByYnM7XG5cbiAgICAgICAgdmFyIGRpdiA9IHJhZGl1cyArIHJhZGl1cyArIDEsXG4gICAgICAgICAgICB3aWR0aE1pbnVzMSA9IHdpZHRoIC0gMSxcbiAgICAgICAgICAgIGhlaWdodE1pbnVzMSA9IGhlaWdodCAtIDEsXG4gICAgICAgICAgICByYWRpdXNQbHVzMSA9IHJhZGl1cyArIDEsXG4gICAgICAgICAgICBzdW1GYWN0b3IgPSByYWRpdXNQbHVzMSAqICggcmFkaXVzUGx1czEgKyAxICkgLyAyLFxuICAgICAgICAgICAgc3RhY2tTdGFydCA9IG5ldyBCbHVyU3RhY2soKSxcbiAgICAgICAgICAgIHN0YWNrRW5kID0gbnVsbCxcbiAgICAgICAgICAgIHN0YWNrID0gc3RhY2tTdGFydCxcbiAgICAgICAgICAgIHN0YWNrSW4gPSBudWxsLFxuICAgICAgICAgICAgc3RhY2tPdXQgPSBudWxsLFxuICAgICAgICAgICAgbXVsX3N1bSA9IG11bF90YWJsZVtyYWRpdXNdLFxuICAgICAgICAgICAgc2hnX3N1bSA9IHNoZ190YWJsZVtyYWRpdXNdO1xuXG4gICAgICAgIGZvciAoIGkgPSAxOyBpIDwgZGl2OyBpKysgKSB7XG4gICAgICAgICAgICBzdGFjayA9IHN0YWNrLm5leHQgPSBuZXcgQmx1clN0YWNrKCk7XG4gICAgICAgICAgICBpZiAoIGkgPT09IHJhZGl1c1BsdXMxICl7XG4gICAgICAgICAgICAgICAgc3RhY2tFbmQgPSBzdGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YWNrLm5leHQgPSBzdGFja1N0YXJ0O1xuXG4gICAgICAgIHl3ID0geWkgPSAwO1xuXG4gICAgICAgIGZvciAoIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KysgKVxuICAgICAgICB7XG4gICAgICAgICAgICByX2luX3N1bSA9IGdfaW5fc3VtID0gYl9pbl9zdW0gPSBhX2luX3N1bSA9IHJfc3VtID0gZ19zdW0gPSBiX3N1bSA9IGFfc3VtID0gMDtcblxuICAgICAgICAgICAgcl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHByID0gcGl4ZWxzW3lpXSApO1xuICAgICAgICAgICAgZ19vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHBnID0gcGl4ZWxzW3lpICsgMV0gKTtcbiAgICAgICAgICAgIGJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwYiA9IHBpeGVsc1t5aSArIDJdICk7XG4gICAgICAgICAgICBhX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGEgPSBwaXhlbHNbeWkgKyAzXSApO1xuXG4gICAgICAgICAgICByX3N1bSArPSBzdW1GYWN0b3IgKiBwcjtcbiAgICAgICAgICAgIGdfc3VtICs9IHN1bUZhY3RvciAqIHBnO1xuICAgICAgICAgICAgYl9zdW0gKz0gc3VtRmFjdG9yICogcGI7XG4gICAgICAgICAgICBhX3N1bSArPSBzdW1GYWN0b3IgKiBwYTtcblxuICAgICAgICAgICAgc3RhY2sgPSBzdGFja1N0YXJ0O1xuXG4gICAgICAgICAgICBmb3IoIGkgPSAwOyBpIDwgcmFkaXVzUGx1czE7IGkrKyApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhY2suciA9IHByO1xuICAgICAgICAgICAgICAgIHN0YWNrLmcgPSBwZztcbiAgICAgICAgICAgICAgICBzdGFjay5iID0gcGI7XG4gICAgICAgICAgICAgICAgc3RhY2suYSA9IHBhO1xuICAgICAgICAgICAgICAgIHN0YWNrID0gc3RhY2submV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yKCBpID0gMTsgaSA8IHJhZGl1c1BsdXMxOyBpKysgKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHAgPSB5aSArICgoIHdpZHRoTWludXMxIDwgaSA/IHdpZHRoTWludXMxIDogaSApIDw8IDIgKTtcbiAgICAgICAgICAgICAgICByX3N1bSArPSAoIHN0YWNrLnIgPSAoIHByID0gcGl4ZWxzW3BdKSkgKiAoIHJicyA9IHJhZGl1c1BsdXMxIC0gaSApO1xuICAgICAgICAgICAgICAgIGdfc3VtICs9ICggc3RhY2suZyA9ICggcGcgPSBwaXhlbHNbcCArIDFdKSkgKiByYnM7XG4gICAgICAgICAgICAgICAgYl9zdW0gKz0gKCBzdGFjay5iID0gKCBwYiA9IHBpeGVsc1twICsgMl0pKSAqIHJicztcbiAgICAgICAgICAgICAgICBhX3N1bSArPSAoIHN0YWNrLmEgPSAoIHBhID0gcGl4ZWxzW3AgKyAzXSkpICogcmJzO1xuXG4gICAgICAgICAgICAgICAgcl9pbl9zdW0gKz0gcHI7XG4gICAgICAgICAgICAgICAgZ19pbl9zdW0gKz0gcGc7XG4gICAgICAgICAgICAgICAgYl9pbl9zdW0gKz0gcGI7XG4gICAgICAgICAgICAgICAgYV9pbl9zdW0gKz0gcGE7XG5cbiAgICAgICAgICAgICAgICBzdGFjayA9IHN0YWNrLm5leHQ7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgc3RhY2tJbiA9IHN0YWNrU3RhcnQ7XG4gICAgICAgICAgICBzdGFja091dCA9IHN0YWNrRW5kO1xuICAgICAgICAgICAgZm9yICggeCA9IDA7IHggPCB3aWR0aDsgeCsrIClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwaXhlbHNbeWkgKyAzXSA9IHBhID0gKGFfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bTtcbiAgICAgICAgICAgICAgICBpZiAoIHBhICE9PSAwIClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBhID0gMjU1IC8gcGE7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsc1t5aV0gPSAoKHJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSkgKiBwYTtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW3lpICsgMV0gPSAoKGdfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSkgKiBwYTtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW3lpICsgMl0gPSAoKGJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSkgKiBwYTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwaXhlbHNbeWldID0gcGl4ZWxzW3lpICsgMV0gPSBwaXhlbHNbeWkgKyAyXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcl9zdW0gLT0gcl9vdXRfc3VtO1xuICAgICAgICAgICAgICAgIGdfc3VtIC09IGdfb3V0X3N1bTtcbiAgICAgICAgICAgICAgICBiX3N1bSAtPSBiX291dF9zdW07XG4gICAgICAgICAgICAgICAgYV9zdW0gLT0gYV9vdXRfc3VtO1xuXG4gICAgICAgICAgICAgICAgcl9vdXRfc3VtIC09IHN0YWNrSW4ucjtcbiAgICAgICAgICAgICAgICBnX291dF9zdW0gLT0gc3RhY2tJbi5nO1xuICAgICAgICAgICAgICAgIGJfb3V0X3N1bSAtPSBzdGFja0luLmI7XG4gICAgICAgICAgICAgICAgYV9vdXRfc3VtIC09IHN0YWNrSW4uYTtcblxuICAgICAgICAgICAgICAgIHAgPSAoeXcgKyAoICggcCA9IHggKyByYWRpdXMgKyAxICkgPCB3aWR0aE1pbnVzMSA/IHAgOiB3aWR0aE1pbnVzMSApICkgPDwgMjtcblxuICAgICAgICAgICAgICAgIHJfaW5fc3VtICs9ICggc3RhY2tJbi5yID0gcGl4ZWxzW3BdKTtcbiAgICAgICAgICAgICAgICBnX2luX3N1bSArPSAoIHN0YWNrSW4uZyA9IHBpeGVsc1twICsgMV0pO1xuICAgICAgICAgICAgICAgIGJfaW5fc3VtICs9ICggc3RhY2tJbi5iID0gcGl4ZWxzW3AgKyAyXSk7XG4gICAgICAgICAgICAgICAgYV9pbl9zdW0gKz0gKCBzdGFja0luLmEgPSBwaXhlbHNbcCArIDNdKTtcblxuICAgICAgICAgICAgICAgIHJfc3VtICs9IHJfaW5fc3VtO1xuICAgICAgICAgICAgICAgIGdfc3VtICs9IGdfaW5fc3VtO1xuICAgICAgICAgICAgICAgIGJfc3VtICs9IGJfaW5fc3VtO1xuICAgICAgICAgICAgICAgIGFfc3VtICs9IGFfaW5fc3VtO1xuXG4gICAgICAgICAgICAgICAgc3RhY2tJbiA9IHN0YWNrSW4ubmV4dDtcblxuICAgICAgICAgICAgICAgIHJfb3V0X3N1bSArPSAoIHByID0gc3RhY2tPdXQuciApO1xuICAgICAgICAgICAgICAgIGdfb3V0X3N1bSArPSAoIHBnID0gc3RhY2tPdXQuZyApO1xuICAgICAgICAgICAgICAgIGJfb3V0X3N1bSArPSAoIHBiID0gc3RhY2tPdXQuYiApO1xuICAgICAgICAgICAgICAgIGFfb3V0X3N1bSArPSAoIHBhID0gc3RhY2tPdXQuYSApO1xuXG4gICAgICAgICAgICAgICAgcl9pbl9zdW0gLT0gcHI7XG4gICAgICAgICAgICAgICAgZ19pbl9zdW0gLT0gcGc7XG4gICAgICAgICAgICAgICAgYl9pbl9zdW0gLT0gcGI7XG4gICAgICAgICAgICAgICAgYV9pbl9zdW0gLT0gcGE7XG5cbiAgICAgICAgICAgICAgICBzdGFja091dCA9IHN0YWNrT3V0Lm5leHQ7XG5cbiAgICAgICAgICAgICAgICB5aSArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeXcgKz0gd2lkdGg7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGZvciAoIHggPSAwOyB4IDwgd2lkdGg7IHgrKyApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdfaW5fc3VtID0gYl9pbl9zdW0gPSBhX2luX3N1bSA9IHJfaW5fc3VtID0gZ19zdW0gPSBiX3N1bSA9IGFfc3VtID0gcl9zdW0gPSAwO1xuXG4gICAgICAgICAgICB5aSA9IHggPDwgMjtcbiAgICAgICAgICAgIHJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwciA9IHBpeGVsc1t5aV0pO1xuICAgICAgICAgICAgZ19vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHBnID0gcGl4ZWxzW3lpICsgMV0pO1xuICAgICAgICAgICAgYl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHBiID0gcGl4ZWxzW3lpICsgMl0pO1xuICAgICAgICAgICAgYV9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHBhID0gcGl4ZWxzW3lpICsgM10pO1xuXG4gICAgICAgICAgICByX3N1bSArPSBzdW1GYWN0b3IgKiBwcjtcbiAgICAgICAgICAgIGdfc3VtICs9IHN1bUZhY3RvciAqIHBnO1xuICAgICAgICAgICAgYl9zdW0gKz0gc3VtRmFjdG9yICogcGI7XG4gICAgICAgICAgICBhX3N1bSArPSBzdW1GYWN0b3IgKiBwYTtcblxuICAgICAgICAgICAgc3RhY2sgPSBzdGFja1N0YXJ0O1xuXG4gICAgICAgICAgICBmb3IoIGkgPSAwOyBpIDwgcmFkaXVzUGx1czE7IGkrKyApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhY2suciA9IHByO1xuICAgICAgICAgICAgICAgIHN0YWNrLmcgPSBwZztcbiAgICAgICAgICAgICAgICBzdGFjay5iID0gcGI7XG4gICAgICAgICAgICAgICAgc3RhY2suYSA9IHBhO1xuICAgICAgICAgICAgICAgIHN0YWNrID0gc3RhY2submV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeXAgPSB3aWR0aDtcblxuICAgICAgICAgICAgZm9yKCBpID0gMTsgaSA8PSByYWRpdXM7IGkrKyApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgeWkgPSAoIHlwICsgeCApIDw8IDI7XG5cbiAgICAgICAgICAgICAgICByX3N1bSArPSAoIHN0YWNrLnIgPSAoIHByID0gcGl4ZWxzW3lpXSkpICogKCByYnMgPSByYWRpdXNQbHVzMSAtIGkgKTtcbiAgICAgICAgICAgICAgICBnX3N1bSArPSAoIHN0YWNrLmcgPSAoIHBnID0gcGl4ZWxzW3lpICsgMV0pKSAqIHJicztcbiAgICAgICAgICAgICAgICBiX3N1bSArPSAoIHN0YWNrLmIgPSAoIHBiID0gcGl4ZWxzW3lpICsgMl0pKSAqIHJicztcbiAgICAgICAgICAgICAgICBhX3N1bSArPSAoIHN0YWNrLmEgPSAoIHBhID0gcGl4ZWxzW3lpICsgM10pKSAqIHJicztcblxuICAgICAgICAgICAgICAgIHJfaW5fc3VtICs9IHByO1xuICAgICAgICAgICAgICAgIGdfaW5fc3VtICs9IHBnO1xuICAgICAgICAgICAgICAgIGJfaW5fc3VtICs9IHBiO1xuICAgICAgICAgICAgICAgIGFfaW5fc3VtICs9IHBhO1xuXG4gICAgICAgICAgICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuXG4gICAgICAgICAgICAgICAgaWYoIGkgPCBoZWlnaHRNaW51czEgKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgeXAgKz0gd2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB5aSA9IHg7XG4gICAgICAgICAgICBzdGFja0luID0gc3RhY2tTdGFydDtcbiAgICAgICAgICAgIHN0YWNrT3V0ID0gc3RhY2tFbmQ7XG4gICAgICAgICAgICBmb3IgKCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrIClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwID0geWkgPDwgMjtcbiAgICAgICAgICAgICAgICBwaXhlbHNbcCArIDNdID0gcGEgPSAoYV9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtO1xuICAgICAgICAgICAgICAgIGlmICggcGEgPiAwIClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBhID0gMjU1IC8gcGE7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsc1twXSA9ICgocl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtICkgKiBwYTtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW3AgKyAxXSA9ICgoZ19zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtICkgKiBwYTtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW3AgKyAyXSA9ICgoYl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtICkgKiBwYTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwaXhlbHNbcF0gPSBwaXhlbHNbcCArIDFdID0gcGl4ZWxzW3AgKyAyXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcl9zdW0gLT0gcl9vdXRfc3VtO1xuICAgICAgICAgICAgICAgIGdfc3VtIC09IGdfb3V0X3N1bTtcbiAgICAgICAgICAgICAgICBiX3N1bSAtPSBiX291dF9zdW07XG4gICAgICAgICAgICAgICAgYV9zdW0gLT0gYV9vdXRfc3VtO1xuXG4gICAgICAgICAgICAgICAgcl9vdXRfc3VtIC09IHN0YWNrSW4ucjtcbiAgICAgICAgICAgICAgICBnX291dF9zdW0gLT0gc3RhY2tJbi5nO1xuICAgICAgICAgICAgICAgIGJfb3V0X3N1bSAtPSBzdGFja0luLmI7XG4gICAgICAgICAgICAgICAgYV9vdXRfc3VtIC09IHN0YWNrSW4uYTtcblxuICAgICAgICAgICAgICAgIHAgPSAoIHggKyAoKCAoIHAgPSB5ICsgcmFkaXVzUGx1czEpIDwgaGVpZ2h0TWludXMxID8gcCA6IGhlaWdodE1pbnVzMSApICogd2lkdGggKSkgPDwgMjtcblxuICAgICAgICAgICAgICAgIHJfc3VtICs9ICggcl9pbl9zdW0gKz0gKCBzdGFja0luLnIgPSBwaXhlbHNbcF0pKTtcbiAgICAgICAgICAgICAgICBnX3N1bSArPSAoIGdfaW5fc3VtICs9ICggc3RhY2tJbi5nID0gcGl4ZWxzW3AgKyAxXSkpO1xuICAgICAgICAgICAgICAgIGJfc3VtICs9ICggYl9pbl9zdW0gKz0gKCBzdGFja0luLmIgPSBwaXhlbHNbcCArIDJdKSk7XG4gICAgICAgICAgICAgICAgYV9zdW0gKz0gKCBhX2luX3N1bSArPSAoIHN0YWNrSW4uYSA9IHBpeGVsc1twICsgM10pKTtcblxuICAgICAgICAgICAgICAgIHN0YWNrSW4gPSBzdGFja0luLm5leHQ7XG5cbiAgICAgICAgICAgICAgICByX291dF9zdW0gKz0gKCBwciA9IHN0YWNrT3V0LnIgKTtcbiAgICAgICAgICAgICAgICBnX291dF9zdW0gKz0gKCBwZyA9IHN0YWNrT3V0LmcgKTtcbiAgICAgICAgICAgICAgICBiX291dF9zdW0gKz0gKCBwYiA9IHN0YWNrT3V0LmIgKTtcbiAgICAgICAgICAgICAgICBhX291dF9zdW0gKz0gKCBwYSA9IHN0YWNrT3V0LmEgKTtcblxuICAgICAgICAgICAgICAgIHJfaW5fc3VtIC09IHByO1xuICAgICAgICAgICAgICAgIGdfaW5fc3VtIC09IHBnO1xuICAgICAgICAgICAgICAgIGJfaW5fc3VtIC09IHBiO1xuICAgICAgICAgICAgICAgIGFfaW5fc3VtIC09IHBhO1xuXG4gICAgICAgICAgICAgICAgc3RhY2tPdXQgPSBzdGFja091dC5uZXh0O1xuXG4gICAgICAgICAgICAgICAgeWkgKz0gd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCbHVyIEZpbHRlclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIEJsdXJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuQmx1cl0pO1xuICAgICAqIG5vZGUuYmx1clJhZGl1cygxMCk7XG4gICAgICovXG4gICAgS29udmEuRmlsdGVycy5CbHVyID0gZnVuY3Rpb24gQmx1cihpbWFnZURhdGEpIHtcbiAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGgucm91bmQodGhpcy5ibHVyUmFkaXVzKCkpO1xuXG4gICAgICAgIGlmIChyYWRpdXMgPiAwKSB7XG4gICAgICAgICAgICBmaWx0ZXJHYXVzc0JsdXJSR0JBKGltYWdlRGF0YSwgcmFkaXVzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnYmx1clJhZGl1cycsIDAsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuXG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGJsdXIgcmFkaXVzLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5CbHVyfSBmaWx0ZXJcbiAgICAqIEBuYW1lIGJsdXJSYWRpdXNcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSByYWRpdXNcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICovXG59KSgpO1xuXG4vKmVzbGludC1kaXNhYmxlICBtYXgtZGVwdGggKi9cbihmdW5jdGlvbigpIHtcblx0J3VzZSBzdHJpY3QnO1xuXHRmdW5jdGlvbiBwaXhlbEF0KGlkYXRhLCB4LCB5KSB7XG5cdFx0dmFyIGlkeCA9ICh5ICogaWRhdGEud2lkdGggKyB4KSAqIDQ7XG5cdFx0dmFyIGQgPSBbXTtcblx0XHRkLnB1c2goaWRhdGEuZGF0YVtpZHgrK10sIGlkYXRhLmRhdGFbaWR4KytdLCBpZGF0YS5kYXRhW2lkeCsrXSwgaWRhdGEuZGF0YVtpZHgrK10pO1xuXHRcdHJldHVybiBkO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmdiRGlzdGFuY2UocDEsIHAyKSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwMVswXSAtIHAyWzBdLCAyKSArIE1hdGgucG93KHAxWzFdIC0gcDJbMV0sIDIpICsgTWF0aC5wb3cocDFbMl0gLSBwMlsyXSwgMikpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmdiTWVhbihwVGFiKSB7XG5cdFx0dmFyIG0gPSBbMCwgMCwgMF07XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBUYWIubGVuZ3RoOyBpKyspIHtcblx0XHRcdG1bMF0gKz0gcFRhYltpXVswXTtcblx0XHRcdG1bMV0gKz0gcFRhYltpXVsxXTtcblx0XHRcdG1bMl0gKz0gcFRhYltpXVsyXTtcblx0XHR9XG5cblx0XHRtWzBdIC89IHBUYWIubGVuZ3RoO1xuXHRcdG1bMV0gLz0gcFRhYi5sZW5ndGg7XG5cdFx0bVsyXSAvPSBwVGFiLmxlbmd0aDtcblxuXHRcdHJldHVybiBtO1xuXHR9XG5cblx0ZnVuY3Rpb24gYmFja2dyb3VuZE1hc2soaWRhdGEsIHRocmVzaG9sZCkge1xuXHRcdHZhciByZ2J2X25vID0gcGl4ZWxBdChpZGF0YSwgMCwgMCk7XG5cdFx0dmFyIHJnYnZfbmUgPSBwaXhlbEF0KGlkYXRhLCBpZGF0YS53aWR0aCAtIDEsIDApO1xuXHRcdHZhciByZ2J2X3NvID0gcGl4ZWxBdChpZGF0YSwgMCwgaWRhdGEuaGVpZ2h0IC0gMSk7XG5cdFx0dmFyIHJnYnZfc2UgPSBwaXhlbEF0KGlkYXRhLCBpZGF0YS53aWR0aCAtIDEsIGlkYXRhLmhlaWdodCAtIDEpO1xuXG5cblx0XHR2YXIgdGhyZXMgPSB0aHJlc2hvbGQgfHwgMTA7XG5cdFx0aWYgKHJnYkRpc3RhbmNlKHJnYnZfbm8sIHJnYnZfbmUpIDwgdGhyZXMgJiYgcmdiRGlzdGFuY2Uocmdidl9uZSwgcmdidl9zZSkgPCB0aHJlcyAmJiByZ2JEaXN0YW5jZShyZ2J2X3NlLCByZ2J2X3NvKSA8IHRocmVzICYmIHJnYkRpc3RhbmNlKHJnYnZfc28sIHJnYnZfbm8pIDwgdGhyZXMpIHtcblxuXHRcdFx0Ly8gTWVhbiBjb2xvclxuXHRcdFx0dmFyIG1lYW4gPSByZ2JNZWFuKFtyZ2J2X25lLCByZ2J2X25vLCByZ2J2X3NlLCByZ2J2X3NvXSk7XG5cblx0XHRcdC8vIE1hc2sgYmFzZWQgb24gY29sb3IgZGlzdGFuY2Vcblx0XHRcdHZhciBtYXNrID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGlkYXRhLndpZHRoICogaWRhdGEuaGVpZ2h0OyBpKyspIHtcblx0XHRcdFx0dmFyIGQgPSByZ2JEaXN0YW5jZShtZWFuLCBbaWRhdGEuZGF0YVtpICogNF0sIGlkYXRhLmRhdGFbaSAqIDQgKyAxXSwgaWRhdGEuZGF0YVtpICogNCArIDJdXSk7XG5cdFx0XHRcdG1hc2tbaV0gPSAoZCA8IHRocmVzKSA/IDAgOiAyNTU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXNrO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGFwcGx5TWFzayhpZGF0YSwgbWFzaykge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaWRhdGEud2lkdGggKiBpZGF0YS5oZWlnaHQ7IGkrKykge1xuXHRcdFx0aWRhdGEuZGF0YVs0ICogaSArIDNdID0gbWFza1tpXTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBlcm9kZU1hc2sobWFzaywgc3csIHNoKSB7XG5cblx0XHR2YXIgd2VpZ2h0cyA9IFsxLCAxLCAxLCAxLCAwLCAxLCAxLCAxLCAxXTtcblx0XHR2YXIgc2lkZSA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KHdlaWdodHMubGVuZ3RoKSk7XG5cdFx0dmFyIGhhbGZTaWRlID0gTWF0aC5mbG9vcihzaWRlIC8gMik7XG5cblx0XHR2YXIgbWFza1Jlc3VsdCA9IFtdO1xuXHRcdGZvciAodmFyIHkgPSAwOyB5IDwgc2g7IHkrKykge1xuXHRcdFx0Zm9yICh2YXIgeCA9IDA7IHggPCBzdzsgeCsrKSB7XG5cblx0XHRcdFx0dmFyIHNvID0geSAqIHN3ICsgeDtcblx0XHRcdFx0dmFyIGEgPSAwO1xuXHRcdFx0XHRmb3IgKHZhciBjeSA9IDA7IGN5IDwgc2lkZTsgY3krKykge1xuXHRcdFx0XHRcdGZvciAodmFyIGN4ID0gMDsgY3ggPCBzaWRlOyBjeCsrKSB7XG5cdFx0XHRcdFx0XHR2YXIgc2N5ID0geSArIGN5IC0gaGFsZlNpZGU7XG5cdFx0XHRcdFx0XHR2YXIgc2N4ID0geCArIGN4IC0gaGFsZlNpZGU7XG5cblx0XHRcdFx0XHRcdGlmIChzY3kgPj0gMCAmJiBzY3kgPCBzaCAmJiBzY3ggPj0gMCAmJiBzY3ggPCBzdykge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBzcmNPZmYgPSBzY3kgKiBzdyArIHNjeDtcblx0XHRcdFx0XHRcdFx0dmFyIHd0ID0gd2VpZ2h0c1tjeSAqIHNpZGUgKyBjeF07XG5cblx0XHRcdFx0XHRcdFx0YSArPSBtYXNrW3NyY09mZl0gKiB3dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtYXNrUmVzdWx0W3NvXSA9IChhID09PSAyNTUgKiA4KSA/IDI1NSA6IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc2tSZXN1bHQ7XG5cdH1cblxuXHRmdW5jdGlvbiBkaWxhdGVNYXNrKG1hc2ssIHN3LCBzaCkge1xuXG5cdFx0dmFyIHdlaWdodHMgPSBbMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMV07XG5cdFx0dmFyIHNpZGUgPSBNYXRoLnJvdW5kKE1hdGguc3FydCh3ZWlnaHRzLmxlbmd0aCkpO1xuXHRcdHZhciBoYWxmU2lkZSA9IE1hdGguZmxvb3Ioc2lkZSAvIDIpO1xuXG5cdFx0dmFyIG1hc2tSZXN1bHQgPSBbXTtcblx0XHRmb3IgKHZhciB5ID0gMDsgeSA8IHNoOyB5KyspIHtcblx0XHRcdGZvciAodmFyIHggPSAwOyB4IDwgc3c7IHgrKykge1xuXG5cdFx0XHRcdHZhciBzbyA9IHkgKiBzdyArIHg7XG5cdFx0XHRcdHZhciBhID0gMDtcblx0XHRcdFx0Zm9yICh2YXIgY3kgPSAwOyBjeSA8IHNpZGU7IGN5KyspIHtcblx0XHRcdFx0XHRmb3IgKHZhciBjeCA9IDA7IGN4IDwgc2lkZTsgY3grKykge1xuXHRcdFx0XHRcdFx0dmFyIHNjeSA9IHkgKyBjeSAtIGhhbGZTaWRlO1xuXHRcdFx0XHRcdFx0dmFyIHNjeCA9IHggKyBjeCAtIGhhbGZTaWRlO1xuXG5cdFx0XHRcdFx0XHRpZiAoc2N5ID49IDAgJiYgc2N5IDwgc2ggJiYgc2N4ID49IDAgJiYgc2N4IDwgc3cpIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgc3JjT2ZmID0gc2N5ICogc3cgKyBzY3g7XG5cdFx0XHRcdFx0XHRcdHZhciB3dCA9IHdlaWdodHNbY3kgKiBzaWRlICsgY3hdO1xuXG5cdFx0XHRcdFx0XHRcdGEgKz0gbWFza1tzcmNPZmZdICogd3Q7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWFza1Jlc3VsdFtzb10gPSAoYSA+PSAyNTUgKiA0KSA/IDI1NSA6IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc2tSZXN1bHQ7XG5cdH1cblxuXHRmdW5jdGlvbiBzbW9vdGhFZGdlTWFzayhtYXNrLCBzdywgc2gpIHtcblxuXHRcdHZhciB3ZWlnaHRzID0gWzEgLyA5LCAxIC8gOSwgMSAvIDksIDEgLyA5LCAxIC8gOSwgMSAvIDksIDEgLyA5LCAxIC8gOSwgMSAvIDldO1xuXHRcdHZhciBzaWRlID0gTWF0aC5yb3VuZChNYXRoLnNxcnQod2VpZ2h0cy5sZW5ndGgpKTtcblx0XHR2YXIgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUgLyAyKTtcblxuXHRcdHZhciBtYXNrUmVzdWx0ID0gW107XG5cdFx0Zm9yICh2YXIgeSA9IDA7IHkgPCBzaDsgeSsrKSB7XG5cdFx0XHRmb3IgKHZhciB4ID0gMDsgeCA8IHN3OyB4KyspIHtcblxuXHRcdFx0XHR2YXIgc28gPSB5ICogc3cgKyB4O1xuXHRcdFx0XHR2YXIgYSA9IDA7XG5cdFx0XHRcdGZvciAodmFyIGN5ID0gMDsgY3kgPCBzaWRlOyBjeSsrKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgY3ggPSAwOyBjeCA8IHNpZGU7IGN4KyspIHtcblx0XHRcdFx0XHRcdHZhciBzY3kgPSB5ICsgY3kgLSBoYWxmU2lkZTtcblx0XHRcdFx0XHRcdHZhciBzY3ggPSB4ICsgY3ggLSBoYWxmU2lkZTtcblxuXHRcdFx0XHRcdFx0aWYgKHNjeSA+PSAwICYmIHNjeSA8IHNoICYmIHNjeCA+PSAwICYmIHNjeCA8IHN3KSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHNyY09mZiA9IHNjeSAqIHN3ICsgc2N4O1xuXHRcdFx0XHRcdFx0XHR2YXIgd3QgPSB3ZWlnaHRzW2N5ICogc2lkZSArIGN4XTtcblxuXHRcdFx0XHRcdFx0XHRhICs9IG1hc2tbc3JjT2ZmXSAqIHd0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1hc2tSZXN1bHRbc29dID0gYTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWFza1Jlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBNYXNrIEZpbHRlclxuXHQgKiBAZnVuY3Rpb25cblx0ICogQG5hbWUgTWFza1xuXHQgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXG5cdCAqIEBleGFtcGxlXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5NYXNrXSk7XG4gICAgICogbm9kZS50aHJlc2hvbGQoMjAwKTtcblx0ICovXG5cdEtvbnZhLkZpbHRlcnMuTWFzayA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuXHRcdC8vIERldGVjdCBwaXhlbHMgY2xvc2UgdG8gdGhlIGJhY2tncm91bmQgY29sb3Jcblx0XHR2YXIgdGhyZXNob2xkID0gdGhpcy50aHJlc2hvbGQoKSxcbiAgICAgICAgbWFzayA9IGJhY2tncm91bmRNYXNrKGltYWdlRGF0YSwgdGhyZXNob2xkKTtcblx0XHRpZiAobWFzaykge1xuXHRcdFx0Ly8gRXJvZGVcblx0XHRcdG1hc2sgPSBlcm9kZU1hc2sobWFzaywgaW1hZ2VEYXRhLndpZHRoLCBpbWFnZURhdGEuaGVpZ2h0KTtcblxuXHRcdFx0Ly8gRGlsYXRlXG5cdFx0XHRtYXNrID0gZGlsYXRlTWFzayhtYXNrLCBpbWFnZURhdGEud2lkdGgsIGltYWdlRGF0YS5oZWlnaHQpO1xuXG5cdFx0XHQvLyBHcmFkaWVudFxuXHRcdFx0bWFzayA9IHNtb290aEVkZ2VNYXNrKG1hc2ssIGltYWdlRGF0YS53aWR0aCwgaW1hZ2VEYXRhLmhlaWdodCk7XG5cblx0XHRcdC8vIEFwcGx5IG1hc2tcblx0XHRcdGFwcGx5TWFzayhpbWFnZURhdGEsIG1hc2spO1xuXG5cdFx0XHQvLyB0b2RvIDogVXBkYXRlIGhpdCByZWdpb24gZnVuY3Rpb24gYWNjb3JkaW5nIHRvIG1hc2tcblx0XHR9XG5cblx0XHRyZXR1cm4gaW1hZ2VEYXRhO1xuXHR9O1xuXG5cdEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICd0aHJlc2hvbGQnLCAwLCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcbn0pKCk7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qKlxuICAgICAqIFJHQiBGaWx0ZXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBSR0JcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuUkdCXSk7XG4gICAgICogbm9kZS5ibHVlKDEyMCk7XG4gICAgICogbm9kZS5ncmVlbigyMDApO1xuICAgICAqL1xuICAgIEtvbnZhLkZpbHRlcnMuUkdCID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xuICAgICAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgICAgblBpeGVscyA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgcmVkID0gdGhpcy5yZWQoKSxcbiAgICAgICAgICAgIGdyZWVuID0gdGhpcy5ncmVlbigpLFxuICAgICAgICAgICAgYmx1ZSA9IHRoaXMuYmx1ZSgpLFxuICAgICAgICAgICAgaSwgYnJpZ2h0bmVzcztcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgblBpeGVsczsgaSArPSA0KSB7XG4gICAgICAgICAgICBicmlnaHRuZXNzID0gKDAuMzQgKiBkYXRhW2ldICsgMC41ICogZGF0YVtpICsgMV0gKyAwLjE2ICogZGF0YVtpICsgMl0pIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpXSA9IGJyaWdodG5lc3MgKiByZWQ7IC8vIHJcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gYnJpZ2h0bmVzcyAqIGdyZWVuOyAvLyBnXG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IGJyaWdodG5lc3MgKiBibHVlOyAvLyBiXG4gICAgICAgICAgICBkYXRhW2kgKyAzXSA9IGRhdGFbaSArIDNdOyAvLyBhbHBoYVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdyZWQnLCAwLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhbCA+IDI1NSkge1xuICAgICAgICAgICAgcmV0dXJuIDI1NTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAqIGdldC9zZXQgZmlsdGVyIHJlZCB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUkdCfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSByZWRcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSByZWQgdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTVcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZ3JlZW4nLCAwLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhbCA+IDI1NSkge1xuICAgICAgICAgICAgcmV0dXJuIDI1NTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAqIGdldC9zZXQgZmlsdGVyIGdyZWVuIHZhbHVlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5SR0J9IGZpbHRlci5cbiAgICAqIEBuYW1lIGdyZWVuXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7SW50ZWdlcn0gZ3JlZW4gdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTVcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnYmx1ZScsIDAsIEtvbnZhLlZhbGlkYXRvcnMuUkdCQ29tcG9uZW50LCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcbiAgICAvKipcbiAgICAqIGdldC9zZXQgZmlsdGVyIGJsdWUgdmFsdWUuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLlJHQn0gZmlsdGVyLlxuICAgICogQG5hbWUgYmx1ZVxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge0ludGVnZXJ9IGJsdWUgdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTVcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICovXG59KSgpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBSR0JBIEZpbHRlclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIFJHQkFcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAgKiBAYXV0aG9yIGNvZGVmb1xuICAgICAqIEBleGFtcGxlXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5SR0JBXSk7XG4gICAgICogbm9kZS5ibHVlKDEyMCk7XG4gICAgICogbm9kZS5ncmVlbigyMDApO1xuICAgICAqIG5vZGUuYWxwaGEoMC4zKTtcbiAgICAgKi9cbiAgICBLb252YS5GaWx0ZXJzLlJHQkEgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG4gICAgICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgICBuUGl4ZWxzID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICByZWQgPSB0aGlzLnJlZCgpLFxuICAgICAgICAgICAgZ3JlZW4gPSB0aGlzLmdyZWVuKCksXG4gICAgICAgICAgICBibHVlID0gdGhpcy5ibHVlKCksXG4gICAgICAgICAgICBhbHBoYSA9IHRoaXMuYWxwaGEoKSxcbiAgICAgICAgICAgIGksIGlhO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuUGl4ZWxzOyBpICs9IDQpIHtcbiAgICAgICAgICAgIGlhID0gMSAtIGFscGhhO1xuXG4gICAgICAgICAgICBkYXRhW2ldID0gcmVkICogYWxwaGEgKyBkYXRhW2ldICogaWE7IC8vIHJcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZ3JlZW4gKiBhbHBoYSArIGRhdGFbaSArIDFdICogaWE7IC8vIGdcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gYmx1ZSAqIGFscGhhICsgZGF0YVtpICsgMl0gKiBpYTsgLy8gYlxuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdyZWQnLCAwLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhbCA+IDI1NSkge1xuICAgICAgICAgICAgcmV0dXJuIDI1NTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAqIGdldC9zZXQgZmlsdGVyIHJlZCB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUkdCQX0gZmlsdGVyLlxuICAgICogQG5hbWUgcmVkXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7SW50ZWdlcn0gcmVkIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1XG4gICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2dyZWVuJywgMCwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlclVwVG9EYXRlID0gZmFsc2U7XG4gICAgICAgIGlmICh2YWwgPiAyNTUpIHtcbiAgICAgICAgICAgIHJldHVybiAyNTU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWwpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGZpbHRlciBncmVlbiB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUkdCQX0gZmlsdGVyLlxuICAgICogQG5hbWUgZ3JlZW5cbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSBncmVlbiB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NVxuICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdibHVlJywgMCwgS29udmEuVmFsaWRhdG9ycy5SR0JDb21wb25lbnQsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuICAgIC8qKlxuICAgICogZ2V0L3NldCBmaWx0ZXIgYmx1ZSB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUkdCQX0gZmlsdGVyLlxuICAgICogQG5hbWUgYmx1ZVxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge0ludGVnZXJ9IGJsdWUgdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTVcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnYWxwaGEnLCAxLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhbCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsdGVyIGFscGhhIHZhbHVlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5SR0JBfSBmaWx0ZXIuXG4gICAgICogQG5hbWUgYWxwaGFcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtGbG9hdH0gYWxwaGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHJldHVybnMge0Zsb2F0fVxuICAgICAqL1xufSkoKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgKiBIU1YgRmlsdGVyLiBBZGp1c3RzIHRoZSBodWUsIHNhdHVyYXRpb24gYW5kIHZhbHVlXG4gICAgKiBAZnVuY3Rpb25cbiAgICAqIEBuYW1lIEhTVlxuICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAqIEBhdXRob3IgaXBwbzYxNVxuICAgICogQGV4YW1wbGVcbiAgICAqIGltYWdlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuSFNWXSk7XG4gICAgKiBpbWFnZS52YWx1ZSgyMDApO1xuICAgICovXG5cbiAgICBLb252YS5GaWx0ZXJzLkhTViA9IGZ1bmN0aW9uIChpbWFnZURhdGEpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICAgIG5QaXhlbHMgPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIHYgPSBNYXRoLnBvdygyLCB0aGlzLnZhbHVlKCkpLFxuICAgICAgICAgICAgcyA9IE1hdGgucG93KDIsIHRoaXMuc2F0dXJhdGlvbigpKSxcbiAgICAgICAgICAgIGggPSBNYXRoLmFicygodGhpcy5odWUoKSkgKyAzNjApICUgMzYwLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICAvLyBCYXNpcyBmb3IgdGhlIHRlY2huaXF1ZSB1c2VkOlxuICAgICAgICAvLyBodHRwOi8vYmVlc2J1enouYml6L2NvZGUvaHN2X2NvbG9yX3RyYW5zZm9ybXMucGhwXG4gICAgICAgIC8vIFYgaXMgdGhlIHZhbHVlIG11bHRpcGxpZXIgKDEgZm9yIG5vbmUsIDIgZm9yIGRvdWJsZSwgMC41IGZvciBoYWxmKVxuICAgICAgICAvLyBTIGlzIHRoZSBzYXR1cmF0aW9uIG11bHRpcGxpZXIgKDEgZm9yIG5vbmUsIDIgZm9yIGRvdWJsZSwgMC41IGZvciBoYWxmKVxuICAgICAgICAvLyBIIGlzIHRoZSBodWUgc2hpZnQgaW4gZGVncmVlcyAoMCB0byAzNjApXG4gICAgICAgIC8vIHZzdSA9IFYqUypjb3MoSCpQSS8xODApO1xuICAgICAgICAvLyB2c3cgPSBWKlMqc2luKEgqUEkvMTgwKTtcbiAgICAgICAgLy9bIC4yOTlWKy43MDF2c3UrLjE2OHZzdyAgICAuNTg3Vi0uNTg3dnN1Ky4zMzB2c3cgICAgLjExNFYtLjExNHZzdS0uNDk3dnN3IF0gW1JdXG4gICAgICAgIC8vWyAuMjk5Vi0uMjk5dnN1LS4zMjh2c3cgICAgLjU4N1YrLjQxM3ZzdSsuMDM1dnN3ICAgIC4xMTRWLS4xMTR2c3UrLjI5MnZzdyBdKltHXVxuICAgICAgICAvL1sgLjI5OVYtLjMwMHZzdSsxLjI1dnN3ICAgIC41ODdWLS41ODh2c3UtMS4wNXZzdyAgICAuMTE0VisuODg2dnN1LS4yMDN2c3cgXSBbQl1cblxuICAgICAgICAvLyBQcmVjb21wdXRlIHRoZSB2YWx1ZXMgaW4gdGhlIG1hdHJpeDpcbiAgICAgICAgdmFyIHZzdSA9IHYgKiBzICogTWF0aC5jb3MoaCAqIE1hdGguUEkgLyAxODApLFxuICAgICAgICAgICAgdnN3ID0gdiAqIHMgKiBNYXRoLnNpbihoICogTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgIC8vIChyZXN1bHQgc3BvdCkoc291cmNlIHNwb3QpXG4gICAgICAgIHZhciByciA9IDAuMjk5ICogdiArIDAuNzAxICogdnN1ICsgMC4xNjcgKiB2c3csXG4gICAgICAgICAgICByZyA9IDAuNTg3ICogdiAtIDAuNTg3ICogdnN1ICsgMC4zMzAgKiB2c3csXG4gICAgICAgICAgICByYiA9IDAuMTE0ICogdiAtIDAuMTE0ICogdnN1IC0gMC40OTcgKiB2c3c7XG4gICAgICAgIHZhciBnciA9IDAuMjk5ICogdiAtIDAuMjk5ICogdnN1IC0gMC4zMjggKiB2c3csXG4gICAgICAgICAgICBnZyA9IDAuNTg3ICogdiArIDAuNDEzICogdnN1ICsgMC4wMzUgKiB2c3csXG4gICAgICAgICAgICBnYiA9IDAuMTE0ICogdiAtIDAuMTE0ICogdnN1ICsgMC4yOTMgKiB2c3c7XG4gICAgICAgIHZhciBiciA9IDAuMjk5ICogdiAtIDAuMzAwICogdnN1ICsgMS4yNTAgKiB2c3csXG4gICAgICAgICAgICBiZyA9IDAuNTg3ICogdiAtIDAuNTg2ICogdnN1IC0gMS4wNTAgKiB2c3csXG4gICAgICAgICAgICBiYiA9IDAuMTE0ICogdiArIDAuODg2ICogdnN1IC0gMC4yMDAgKiB2c3c7XG5cbiAgICAgICAgdmFyIHIsIGcsIGIsIGE7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5QaXhlbHM7IGkgKz0gNCkge1xuICAgICAgICAgICAgciA9IGRhdGFbaSArIDBdO1xuICAgICAgICAgICAgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgICAgICAgYiA9IGRhdGFbaSArIDJdO1xuICAgICAgICAgICAgYSA9IGRhdGFbaSArIDNdO1xuXG4gICAgICAgICAgICBkYXRhW2kgKyAwXSA9IHJyICogciArIHJnICogZyArIHJiICogYjtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZ3IgKiByICsgZ2cgKiBnICsgZ2IgKiBiO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiciAqIHIgKyBiZyAqIGcgKyBiYiAqIGI7XG4gICAgICAgICAgICBkYXRhW2kgKyAzXSA9IGE7IC8vIGFscGhhXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnaHVlJywgMCwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGhzdiBodWUgaW4gZGVncmVlcy4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuSFNWfSBvciB7QGxpbmsgS29udmEuRmlsdGVycy5IU0x9IGZpbHRlci5cbiAgICAqIEBuYW1lIGh1ZVxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge051bWJlcn0gaHVlIHZhbHVlIGJldHdlZW4gMCBhbmQgMzU5XG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnc2F0dXJhdGlvbicsIDAsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuICAgIC8qKlxuICAgICogZ2V0L3NldCBoc3Ygc2F0dXJhdGlvbi4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuSFNWfSBvciB7QGxpbmsgS29udmEuRmlsdGVycy5IU0x9IGZpbHRlci5cbiAgICAqIEBuYW1lIHNhdHVyYXRpb25cbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHNhdHVyYXRpb24gMCBpcyBubyBjaGFuZ2UsIC0xLjAgaGFsdmVzIHRoZSBzYXR1cmF0aW9uLCAxLjAgZG91YmxlcywgZXRjLi5cbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICd2YWx1ZScsIDAsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuICAgIC8qKlxuICAgICogZ2V0L3NldCBoc3YgdmFsdWUuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkhTVn0gZmlsdGVyLlxuICAgICogQG5hbWUgdmFsdWVcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIDAgaXMgbm8gY2hhbmdlLCAtMS4wIGhhbHZlcyB0aGUgdmFsdWUsIDEuMCBkb3VibGVzLCBldGMuLlxuICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAqL1xuXG59KSgpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdodWUnLCAwLCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcbiAgICAvKipcbiAgICAqIGdldC9zZXQgaHN2IGh1ZSBpbiBkZWdyZWVzLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5IU1Z9IG9yIHtAbGluayBLb252YS5GaWx0ZXJzLkhTTH0gZmlsdGVyLlxuICAgICogQG5hbWUgaHVlXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBodWUgdmFsdWUgYmV0d2VlbiAwIGFuZCAzNTlcbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdzYXR1cmF0aW9uJywgMCwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGhzdiBzYXR1cmF0aW9uLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5IU1Z9IG9yIHtAbGluayBLb252YS5GaWx0ZXJzLkhTTH0gZmlsdGVyLlxuICAgICogQG5hbWUgc2F0dXJhdGlvblxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvbiAwIGlzIG5vIGNoYW5nZSwgLTEuMCBoYWx2ZXMgdGhlIHNhdHVyYXRpb24sIDEuMCBkb3VibGVzLCBldGMuLlxuICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2x1bWluYW5jZScsIDAsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuICAgIC8qKlxuICAgICogZ2V0L3NldCBoc2wgbHVtaW5hbmNlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5IU0x9IGZpbHRlci5cbiAgICAqIEBuYW1lIHZhbHVlXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAwIGlzIG5vIGNoYW5nZSwgLTEuMCBoYWx2ZXMgdGhlIHZhbHVlLCAxLjAgZG91YmxlcywgZXRjLi5cbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogSFNMIEZpbHRlci4gQWRqdXN0cyB0aGUgaHVlLCBzYXR1cmF0aW9uIGFuZCBsdW1pbmFuY2UgKG9yIGxpZ2h0bmVzcylcbiAgICAqIEBmdW5jdGlvblxuICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAqIEBhdXRob3IgaXBwbzYxNVxuICAgICogQGV4YW1wbGVcbiAgICAqIGltYWdlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuSFNMXSk7XG4gICAgKiBpbWFnZS5sdW1pbmFuY2UoMjAwKTtcbiAgICAqL1xuXG4gICAgS29udmEuRmlsdGVycy5IU0wgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG4gICAgICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgICBuUGl4ZWxzID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICB2ID0gMSxcbiAgICAgICAgICAgIHMgPSBNYXRoLnBvdygyLCB0aGlzLnNhdHVyYXRpb24oKSksXG4gICAgICAgICAgICBoID0gTWF0aC5hYnMoKHRoaXMuaHVlKCkpICsgMzYwKSAlIDM2MCxcbiAgICAgICAgICAgIGwgPSB0aGlzLmx1bWluYW5jZSgpICogMTI3LFxuICAgICAgICAgICAgaTtcblxuICAgICAgICAvLyBCYXNpcyBmb3IgdGhlIHRlY2huaXF1ZSB1c2VkOlxuICAgICAgICAvLyBodHRwOi8vYmVlc2J1enouYml6L2NvZGUvaHN2X2NvbG9yX3RyYW5zZm9ybXMucGhwXG4gICAgICAgIC8vIFYgaXMgdGhlIHZhbHVlIG11bHRpcGxpZXIgKDEgZm9yIG5vbmUsIDIgZm9yIGRvdWJsZSwgMC41IGZvciBoYWxmKVxuICAgICAgICAvLyBTIGlzIHRoZSBzYXR1cmF0aW9uIG11bHRpcGxpZXIgKDEgZm9yIG5vbmUsIDIgZm9yIGRvdWJsZSwgMC41IGZvciBoYWxmKVxuICAgICAgICAvLyBIIGlzIHRoZSBodWUgc2hpZnQgaW4gZGVncmVlcyAoMCB0byAzNjApXG4gICAgICAgIC8vIHZzdSA9IFYqUypjb3MoSCpQSS8xODApO1xuICAgICAgICAvLyB2c3cgPSBWKlMqc2luKEgqUEkvMTgwKTtcbiAgICAgICAgLy9bIC4yOTlWKy43MDF2c3UrLjE2OHZzdyAgICAuNTg3Vi0uNTg3dnN1Ky4zMzB2c3cgICAgLjExNFYtLjExNHZzdS0uNDk3dnN3IF0gW1JdXG4gICAgICAgIC8vWyAuMjk5Vi0uMjk5dnN1LS4zMjh2c3cgICAgLjU4N1YrLjQxM3ZzdSsuMDM1dnN3ICAgIC4xMTRWLS4xMTR2c3UrLjI5MnZzdyBdKltHXVxuICAgICAgICAvL1sgLjI5OVYtLjMwMHZzdSsxLjI1dnN3ICAgIC41ODdWLS41ODh2c3UtMS4wNXZzdyAgICAuMTE0VisuODg2dnN1LS4yMDN2c3cgXSBbQl1cblxuICAgICAgICAvLyBQcmVjb21wdXRlIHRoZSB2YWx1ZXMgaW4gdGhlIG1hdHJpeDpcbiAgICAgICAgdmFyIHZzdSA9IHYgKiBzICogTWF0aC5jb3MoaCAqIE1hdGguUEkgLyAxODApLFxuICAgICAgICAgICAgdnN3ID0gdiAqIHMgKiBNYXRoLnNpbihoICogTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgIC8vIChyZXN1bHQgc3BvdCkoc291cmNlIHNwb3QpXG4gICAgICAgIHZhciByciA9IDAuMjk5ICogdiArIDAuNzAxICogdnN1ICsgMC4xNjcgKiB2c3csXG4gICAgICAgICAgICByZyA9IDAuNTg3ICogdiAtIDAuNTg3ICogdnN1ICsgMC4zMzAgKiB2c3csXG4gICAgICAgICAgICByYiA9IDAuMTE0ICogdiAtIDAuMTE0ICogdnN1IC0gMC40OTcgKiB2c3c7XG4gICAgICAgIHZhciBnciA9IDAuMjk5ICogdiAtIDAuMjk5ICogdnN1IC0gMC4zMjggKiB2c3csXG4gICAgICAgICAgICBnZyA9IDAuNTg3ICogdiArIDAuNDEzICogdnN1ICsgMC4wMzUgKiB2c3csXG4gICAgICAgICAgICBnYiA9IDAuMTE0ICogdiAtIDAuMTE0ICogdnN1ICsgMC4yOTMgKiB2c3c7XG4gICAgICAgIHZhciBiciA9IDAuMjk5ICogdiAtIDAuMzAwICogdnN1ICsgMS4yNTAgKiB2c3csXG4gICAgICAgICAgICBiZyA9IDAuNTg3ICogdiAtIDAuNTg2ICogdnN1IC0gMS4wNTAgKiB2c3csXG4gICAgICAgICAgICBiYiA9IDAuMTE0ICogdiArIDAuODg2ICogdnN1IC0gMC4yMDAgKiB2c3c7XG5cbiAgICAgICAgdmFyIHIsIGcsIGIsIGE7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5QaXhlbHM7IGkgKz0gNCkge1xuICAgICAgICAgICAgciA9IGRhdGFbaSArIDBdO1xuICAgICAgICAgICAgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgICAgICAgYiA9IGRhdGFbaSArIDJdO1xuICAgICAgICAgICAgYSA9IGRhdGFbaSArIDNdO1xuXG4gICAgICAgICAgICBkYXRhW2kgKyAwXSA9IHJyICogciArIHJnICogZyArIHJiICogYiArIGw7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IGdyICogciArIGdnICogZyArIGdiICogYiArIGw7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IGJyICogciArIGJnICogZyArIGJiICogYiArIGw7XG4gICAgICAgICAgICBkYXRhW2kgKyAzXSA9IGE7IC8vIGFscGhhXG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogRW1ib3NzIEZpbHRlci5cbiAgICAgKiBQaXhhc3RpYyBMaWIgLSBFbWJvc3MgZmlsdGVyIC0gdjAuMS4wXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDA4IEphY29iIFNlaWRlbGluLCBqc2VpZGVsaW5AbmloaWxvZ2ljLmRrLCBodHRwOi8vYmxvZy5uaWhpbG9naWMuZGsvXG4gICAgICogTGljZW5zZTogW2h0dHA6Ly93d3cucGl4YXN0aWMuY29tL2xpYi9saWNlbnNlLnR4dF1cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuRW1ib3NzXSk7XG4gICAgICogbm9kZS5lbWJvc3NTdHJlbmd0aCgwLjgpO1xuICAgICAqIG5vZGUuZW1ib3NzV2hpdGVMZXZlbCgwLjMpO1xuICAgICAqIG5vZGUuZW1ib3NzRGlyZWN0aW9uKCdyaWdodCcpO1xuICAgICAqIG5vZGUuZW1ib3NzQmxlbmQodHJ1ZSk7XG4gICAgICovXG4gICAgS29udmEuRmlsdGVycy5FbWJvc3MgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG5cbiAgICAgICAgLy8gcGl4YXN0aWMgc3RyZW5ndGggaXMgYmV0d2VlbiAwIGFuZCAxMC4gIEkgd2FudCBpdCBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgICAgLy8gcGl4YXN0aWMgZ3JleUxldmVsIGlzIGJldHdlZW4gMCBhbmQgMjU1LiAgSSB3YW50IGl0IGJldHdlZW4gMCBhbmQgMS4gIEFsc28sXG4gICAgICAgIC8vIGEgbWF4IHZhbHVlIG9mIGdyZXlMZXZlbCB5aWVsZHMgYSB3aGl0ZSBlbWJvc3MsIGFuZCB0aGUgbWluIHZhbHVlIHlpZWxkcyBhIGJsYWNrXG4gICAgICAgIC8vIGVtYm9zcy4gIFRoZXJlZm9yZSwgSSBjaGFuZ2VkIGdyZXlMZXZlbCB0byB3aGl0ZUxldmVsXG4gICAgICAgIHZhciBzdHJlbmd0aCA9IHRoaXMuZW1ib3NzU3RyZW5ndGgoKSAqIDEwLFxuICAgICAgICAgICAgZ3JleUxldmVsID0gdGhpcy5lbWJvc3NXaGl0ZUxldmVsKCkgKiAyNTUsXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSB0aGlzLmVtYm9zc0RpcmVjdGlvbigpLFxuICAgICAgICAgICAgYmxlbmQgPSB0aGlzLmVtYm9zc0JsZW5kKCksXG4gICAgICAgICAgICBkaXJZID0gMCxcbiAgICAgICAgICAgIGRpclggPSAwLFxuICAgICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgICAgdyA9IGltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgICAgIGggPSBpbWFnZURhdGEuaGVpZ2h0LFxuICAgICAgICAgICAgdzQgPSB3ICogNCxcbiAgICAgICAgICAgIHkgPSBoO1xuXG4gICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICd0b3AtbGVmdCc6XG4gICAgICAgICAgICAgICAgZGlyWSA9IC0xO1xuICAgICAgICAgICAgICAgIGRpclggPSAtMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgZGlyWSA9IC0xO1xuICAgICAgICAgICAgICAgIGRpclggPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndG9wLXJpZ2h0JzpcbiAgICAgICAgICAgICAgICBkaXJZID0gLTE7XG4gICAgICAgICAgICAgICAgZGlyWCA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgZGlyWSA9IDA7XG4gICAgICAgICAgICAgICAgZGlyWCA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdib3R0b20tcmlnaHQnOlxuICAgICAgICAgICAgICAgIGRpclkgPSAxO1xuICAgICAgICAgICAgICAgIGRpclggPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICBkaXJZID0gMTtcbiAgICAgICAgICAgICAgICBkaXJYID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbS1sZWZ0JzpcbiAgICAgICAgICAgICAgICBkaXJZID0gMTtcbiAgICAgICAgICAgICAgICBkaXJYID0gLTE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBkaXJZID0gMDtcbiAgICAgICAgICAgICAgICBkaXJYID0gLTE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0WSA9ICh5IC0gMSkgKiB3NDtcblxuICAgICAgICAgICAgdmFyIG90aGVyWSA9IGRpclk7XG4gICAgICAgICAgICBpZiAoeSArIG90aGVyWSA8IDEpe1xuICAgICAgICAgICAgICAgIG90aGVyWSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeSArIG90aGVyWSA+IGgpIHtcbiAgICAgICAgICAgICAgICBvdGhlclkgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb2Zmc2V0WU90aGVyID0gKHkgLSAxICsgb3RoZXJZKSAqIHcgKiA0O1xuXG4gICAgICAgICAgICB2YXIgeCA9IHc7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldFkgKyAoeCAtIDEpICogNDtcblxuICAgICAgICAgICAgICAgIHZhciBvdGhlclggPSBkaXJYO1xuICAgICAgICAgICAgICAgIGlmICh4ICsgb3RoZXJYIDwgMSl7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyWCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh4ICsgb3RoZXJYID4gdykge1xuICAgICAgICAgICAgICAgICAgICBvdGhlclggPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRPdGhlciA9IG9mZnNldFlPdGhlciArICh4IC0gMSArIG90aGVyWCkgKiA0O1xuXG4gICAgICAgICAgICAgICAgdmFyIGRSID0gZGF0YVtvZmZzZXRdIC0gZGF0YVtvZmZzZXRPdGhlcl07XG4gICAgICAgICAgICAgICAgdmFyIGRHID0gZGF0YVtvZmZzZXQgKyAxXSAtIGRhdGFbb2Zmc2V0T3RoZXIgKyAxXTtcbiAgICAgICAgICAgICAgICB2YXIgZEIgPSBkYXRhW29mZnNldCArIDJdIC0gZGF0YVtvZmZzZXRPdGhlciArIDJdO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRpZiA9IGRSO1xuICAgICAgICAgICAgICAgIHZhciBhYnNEaWYgPSBkaWYgPiAwID8gZGlmIDogLWRpZjtcblxuICAgICAgICAgICAgICAgIHZhciBhYnNHID0gZEcgPiAwID8gZEcgOiAtZEc7XG4gICAgICAgICAgICAgICAgdmFyIGFic0IgPSBkQiA+IDAgPyBkQiA6IC1kQjtcblxuICAgICAgICAgICAgICAgIGlmIChhYnNHID4gYWJzRGlmKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZiA9IGRHO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWJzQiA+IGFic0RpZikge1xuICAgICAgICAgICAgICAgICAgICBkaWYgPSBkQjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkaWYgKj0gc3RyZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmxlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBkYXRhW29mZnNldF0gKyBkaWY7XG4gICAgICAgICAgICAgICAgICAgIHZhciBnID0gZGF0YVtvZmZzZXQgKyAxXSArIGRpZjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBkYXRhW29mZnNldCArIDJdICsgZGlmO1xuXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IChyID4gMjU1KSA/IDI1NSA6IChyIDwgMCA/IDAgOiByKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAxXSA9IChnID4gMjU1KSA/IDI1NSA6IChnIDwgMCA/IDAgOiBnKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAyXSA9IChiID4gMjU1KSA/IDI1NSA6IChiIDwgMCA/IDAgOiBiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JleSA9IGdyZXlMZXZlbCAtIGRpZjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyZXkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmV5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChncmV5ID4gMjU1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmV5ID0gMjU1O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gZGF0YVtvZmZzZXQgKyAxXSA9IGRhdGFbb2Zmc2V0ICsgMl0gPSBncmV5O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSB3aGlsZSAoLS14KTtcbiAgICAgICAgfSB3aGlsZSAoLS15KTtcbiAgICB9O1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2VtYm9zc1N0cmVuZ3RoJywgMC41LCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcbiAgICAvKipcbiAgICAqIGdldC9zZXQgZW1ib3NzIHN0cmVuZ3RoLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5FbWJvc3N9IGZpbHRlci5cbiAgICAqIEBuYW1lIGVtYm9zc1N0cmVuZ3RoXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBiZXR3ZWVuIDAgYW5kIDEuICBEZWZhdWx0IGlzIDAuNVxuICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2VtYm9zc1doaXRlTGV2ZWwnLCAwLjUsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuICAgIC8qKlxuICAgICogZ2V0L3NldCBlbWJvc3Mgd2hpdGUgbGV2ZWwuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkVtYm9zc30gZmlsdGVyLlxuICAgICogQG5hbWUgZW1ib3NzV2hpdGVMZXZlbFxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge051bWJlcn0gZW1ib3NzV2hpdGVMZXZlbCBiZXR3ZWVuIDAgYW5kIDEuICBEZWZhdWx0IGlzIDAuNVxuICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2VtYm9zc0RpcmVjdGlvbicsICd0b3AtbGVmdCcsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuICAgIC8qKlxuICAgICogZ2V0L3NldCBlbWJvc3MgZGlyZWN0aW9uLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5FbWJvc3N9IGZpbHRlci5cbiAgICAqIEBuYW1lIGVtYm9zc0RpcmVjdGlvblxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gZW1ib3NzRGlyZWN0aW9uIGNhbiBiZSB0b3AtbGVmdCwgdG9wLCB0b3AtcmlnaHQsIHJpZ2h0LCBib3R0b20tcmlnaHQsIGJvdHRvbSwgYm90dG9tLWxlZnQgb3IgbGVmdFxuICAgICogICBUaGUgZGVmYXVsdCBpcyB0b3AtbGVmdFxuICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2VtYm9zc0JsZW5kJywgZmFsc2UsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuICAgIC8qKlxuICAgICogZ2V0L3NldCBlbWJvc3MgYmxlbmQuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkVtYm9zc30gZmlsdGVyLlxuICAgICogQG5hbWUgZW1ib3NzQmxlbmRcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtCb29sZWFufSBlbWJvc3NCbGVuZFxuICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgKi9cbn0pKCk7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGZ1bmN0aW9uIHJlbWFwKGZyb21WYWx1ZSwgZnJvbU1pbiwgZnJvbU1heCwgdG9NaW4sIHRvTWF4KSB7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHJhbmdlIG9mIHRoZSBkYXRhXG4gICAgICAgIHZhciBmcm9tUmFuZ2UgPSBmcm9tTWF4IC0gZnJvbU1pbixcbiAgICAgICAgICB0b1JhbmdlID0gdG9NYXggLSB0b01pbixcbiAgICAgICAgICB0b1ZhbHVlO1xuXG4gICAgICAgIC8vIElmIGVpdGhlciByYW5nZSBpcyAwLCB0aGVuIHRoZSB2YWx1ZSBjYW4gb25seSBiZSBtYXBwZWQgdG8gMSB2YWx1ZVxuICAgICAgICBpZiAoZnJvbVJhbmdlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9NaW4gKyB0b1JhbmdlIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9SYW5nZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRvTWluO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gKDEpIHVudHJhbnNsYXRlLCAoMikgdW5zY2FsZSwgKDMpIHJlc2NhbGUsICg0KSByZXRyYW5zbGF0ZVxuICAgICAgICB0b1ZhbHVlID0gKGZyb21WYWx1ZSAtIGZyb21NaW4pIC8gZnJvbVJhbmdlO1xuICAgICAgICB0b1ZhbHVlID0gKHRvUmFuZ2UgKiB0b1ZhbHVlKSArIHRvTWluO1xuXG4gICAgICAgIHJldHVybiB0b1ZhbHVlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgKiBFbmhhbmNlIEZpbHRlci4gQWRqdXN0cyB0aGUgY29sb3JzIHNvIHRoYXQgdGhleSBzcGFuIHRoZSB3aWRlc3RcbiAgICAqICBwb3NzaWJsZSByYW5nZSAoaWUgMC0yNTUpLiBQZXJmb3JtcyB3KmggcGl4ZWwgcmVhZHMgYW5kIHcqaCBwaXhlbFxuICAgICogIHdyaXRlcy5cbiAgICAqIEBmdW5jdGlvblxuICAgICogQG5hbWUgRW5oYW5jZVxuICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAqIEBhdXRob3IgaXBwbzYxNVxuICAgICogQGV4YW1wbGVcbiAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5FbmhhbmNlXSk7XG4gICAgKiBub2RlLmVuaGFuY2UoMC40KTtcbiAgICAqL1xuICAgIEtvbnZhLkZpbHRlcnMuRW5oYW5jZSA9IGZ1bmN0aW9uIChpbWFnZURhdGEpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICAgIG5TdWJQaXhlbHMgPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIHJNaW4gPSBkYXRhWzBdLCByTWF4ID0gck1pbiwgcixcbiAgICAgICAgICAgIGdNaW4gPSBkYXRhWzFdLCBnTWF4ID0gZ01pbiwgZyxcbiAgICAgICAgICAgIGJNaW4gPSBkYXRhWzJdLCBiTWF4ID0gYk1pbiwgYixcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgLy8gSWYgd2UgYXJlIG5vdCBlbmhhbmNpbmcgYW55dGhpbmcgLSBkb24ndCBkbyBhbnkgY29tcHV0YXRpb25cbiAgICAgICAgdmFyIGVuaGFuY2VBbW91bnQgPSB0aGlzLmVuaGFuY2UoKTtcbiAgICAgICAgaWYoIGVuaGFuY2VBbW91bnQgPT09IDAgKXsgcmV0dXJuOyB9XG5cbiAgICAgICAgLy8gMXN0IFBhc3MgLSBmaW5kIHRoZSBtaW4gYW5kIG1heCBmb3IgZWFjaCBjaGFubmVsOlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgblN1YlBpeGVsczsgaSArPSA0KSB7XG4gICAgICAgICAgICByID0gZGF0YVtpICsgMF07XG4gICAgICAgICAgICBpZiAociA8IHJNaW4pIHsgck1pbiA9IHI7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHIgPiByTWF4KSB7IHJNYXggPSByOyB9XG4gICAgICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgICAgICBpZiAoZyA8IGdNaW4pIHsgZ01pbiA9IGc7IH0gZWxzZVxuICAgICAgICAgICAgaWYgKGcgPiBnTWF4KSB7IGdNYXggPSBnOyB9XG4gICAgICAgICAgICBiID0gZGF0YVtpICsgMl07XG4gICAgICAgICAgICBpZiAoYiA8IGJNaW4pIHsgYk1pbiA9IGI7IH0gZWxzZVxuICAgICAgICAgICAgaWYgKGIgPiBiTWF4KSB7IGJNYXggPSBiOyB9XG4gICAgICAgICAgICAvL2EgPSBkYXRhW2kgKyAzXTtcbiAgICAgICAgICAgIC8vaWYgKGEgPCBhTWluKSB7IGFNaW4gPSBhOyB9IGVsc2VcbiAgICAgICAgICAgIC8vaWYgKGEgPiBhTWF4KSB7IGFNYXggPSBhOyB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBvbmx5IDEgbGV2ZWwgLSBkb24ndCByZW1hcFxuICAgICAgICBpZiggck1heCA9PT0gck1pbiApeyByTWF4ID0gMjU1OyByTWluID0gMDsgfVxuICAgICAgICBpZiggZ01heCA9PT0gZ01pbiApeyBnTWF4ID0gMjU1OyBnTWluID0gMDsgfVxuICAgICAgICBpZiggYk1heCA9PT0gYk1pbiApeyBiTWF4ID0gMjU1OyBiTWluID0gMDsgfVxuXG4gICAgICAgIHZhciByTWlkLCByR29hbE1heCwgckdvYWxNaW4sXG4gICAgICAgICAgICBnTWlkLCBnR29hbE1heCwgZ0dvYWxNaW4sXG4gICAgICAgICAgICBiTWlkLCBiR29hbE1heCwgYkdvYWxNaW47XG5cbiAgICAgICAgLy8gSWYgdGhlIGVuaGFuY2VtZW50IGlzIHBvc2l0aXZlIC0gc3RyZXRjaCB0aGUgaGlzdG9ncmFtXG4gICAgICAgIGlmICggZW5oYW5jZUFtb3VudCA+IDAgKXtcbiAgICAgICAgICAgIHJHb2FsTWF4ID0gck1heCArIGVuaGFuY2VBbW91bnQgKiAoMjU1IC0gck1heCk7XG4gICAgICAgICAgICByR29hbE1pbiA9IHJNaW4gLSBlbmhhbmNlQW1vdW50ICogKHJNaW4gLSAwKTtcbiAgICAgICAgICAgIGdHb2FsTWF4ID0gZ01heCArIGVuaGFuY2VBbW91bnQgKiAoMjU1IC0gZ01heCk7XG4gICAgICAgICAgICBnR29hbE1pbiA9IGdNaW4gLSBlbmhhbmNlQW1vdW50ICogKGdNaW4gLSAwKTtcbiAgICAgICAgICAgIGJHb2FsTWF4ID0gYk1heCArIGVuaGFuY2VBbW91bnQgKiAoMjU1IC0gYk1heCk7XG4gICAgICAgICAgICBiR29hbE1pbiA9IGJNaW4gLSBlbmhhbmNlQW1vdW50ICogKGJNaW4gLSAwKTtcbiAgICAgICAgLy8gSWYgdGhlIGVuaGFuY2VtZW50IGlzIG5lZ2F0aXZlIC0gICBjb21wcmVzcyB0aGUgaGlzdG9ncmFtXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByTWlkID0gKHJNYXggKyByTWluKSAqIDAuNTtcbiAgICAgICAgICAgIHJHb2FsTWF4ID0gck1heCArIGVuaGFuY2VBbW91bnQgKiAock1heCAtIHJNaWQpO1xuICAgICAgICAgICAgckdvYWxNaW4gPSByTWluICsgZW5oYW5jZUFtb3VudCAqIChyTWluIC0gck1pZCk7XG4gICAgICAgICAgICBnTWlkID0gKGdNYXggKyBnTWluKSAqIDAuNTtcbiAgICAgICAgICAgIGdHb2FsTWF4ID0gZ01heCArIGVuaGFuY2VBbW91bnQgKiAoZ01heCAtIGdNaWQpO1xuICAgICAgICAgICAgZ0dvYWxNaW4gPSBnTWluICsgZW5oYW5jZUFtb3VudCAqIChnTWluIC0gZ01pZCk7XG4gICAgICAgICAgICBiTWlkID0gKGJNYXggKyBiTWluKSAqIDAuNTtcbiAgICAgICAgICAgIGJHb2FsTWF4ID0gYk1heCArIGVuaGFuY2VBbW91bnQgKiAoYk1heCAtIGJNaWQpO1xuICAgICAgICAgICAgYkdvYWxNaW4gPSBiTWluICsgZW5oYW5jZUFtb3VudCAqIChiTWluIC0gYk1pZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQYXNzIDIgLSByZW1hcCBldmVyeXRoaW5nLCBleGNlcHQgdGhlIGFscGhhXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuU3ViUGl4ZWxzOyBpICs9IDQpIHtcbiAgICAgICAgICAgIGRhdGFbaSArIDBdID0gcmVtYXAoZGF0YVtpICsgMF0sIHJNaW4sIHJNYXgsIHJHb2FsTWluLCByR29hbE1heCk7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IHJlbWFwKGRhdGFbaSArIDFdLCBnTWluLCBnTWF4LCBnR29hbE1pbiwgZ0dvYWxNYXgpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSByZW1hcChkYXRhW2kgKyAyXSwgYk1pbiwgYk1heCwgYkdvYWxNaW4sIGJHb2FsTWF4KTtcbiAgICAgICAgICAgIC8vZGF0YVtpICsgM10gPSByZW1hcChkYXRhW2kgKyAzXSwgYU1pbiwgYU1heCwgYUdvYWxNaW4sIGFHb2FsTWF4KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZW5oYW5jZScsIDAsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuXG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGVuaGFuY2UuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkVuaGFuY2V9IGZpbHRlci5cbiAgICAqIEBuYW1lIGVuaGFuY2VcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtGbG9hdH0gYW1vdW50XG4gICAgKiBAcmV0dXJucyB7RmxvYXR9XG4gICAgKi9cbn0pKCk7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qKlxuICAgICAqIFBvc3Rlcml6ZSBGaWx0ZXIuIEFkanVzdHMgdGhlIGNoYW5uZWxzIHNvIHRoYXQgdGhlcmUgYXJlIG5vIG1vcmVcbiAgICAgKiAgdGhhbiBuIGRpZmZlcmVudCB2YWx1ZXMgZm9yIHRoYXQgY2hhbm5lbC4gVGhpcyBpcyBhbHNvIGFwcGxpZWRcbiAgICAgKiAgdG8gdGhlIGFscGhhIGNoYW5uZWwuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgUG9zdGVyaXplXG4gICAgICogQGF1dGhvciBpcHBvNjE1XG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBub2RlLmNhY2hlKCk7XG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLlBvc3Rlcml6ZV0pO1xuICAgICAqIG5vZGUubGV2ZWxzKDAuOCk7XG4gICAgICovXG5cbiAgICBLb252YS5GaWx0ZXJzLlBvc3Rlcml6ZSA9IGZ1bmN0aW9uIChpbWFnZURhdGEpIHtcbiAgICAgICAgLy8gbGV2ZWwgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDI1NVxuICAgICAgICB2YXIgbGV2ZWxzID0gTWF0aC5yb3VuZCh0aGlzLmxldmVscygpICogMjU0KSArIDEsXG4gICAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIHNjYWxlID0gKDI1NSAvIGxldmVscyksXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgZGF0YVtpXSA9IE1hdGguZmxvb3IoZGF0YVtpXSAvIHNjYWxlKSAqIHNjYWxlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdsZXZlbHMnLCAwLjUsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuXG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGxldmVscy4gIE11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLiAgVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUG9zdGVyaXplfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSBsZXZlbHNcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIGJldHdlZW4gMCBhbmQgMVxuICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAqL1xufSkoKTtcblxuKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vaXNlIEZpbHRlci4gUmFuZG9tbHkgYWRkcyBvciBzdWJzdHJhY3RzIHRvIHRoZSBjb2xvciBjaGFubmVsc1xyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAbmFtZSBOb2lzZVxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcclxuICAgICAqIEBhdXRob3IgaXBwbzYxNVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIG5vZGUuY2FjaGUoKTtcclxuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5Ob2lzZV0pO1xyXG4gICAgICogbm9kZS5ub2lzZSgwLjgpO1xyXG4gICAgICovXHJcbiAgICBLb252YS5GaWx0ZXJzLk5vaXNlID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xyXG4gICAgICAgIHZhciBhbW91bnQgPSB0aGlzLm5vaXNlKCkgKiAyNTUsXHJcbiAgICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcclxuICAgICAgICAgICAgblBpeGVscyA9IGRhdGEubGVuZ3RoLFxyXG4gICAgICAgICAgICBoYWxmID0gYW1vdW50IC8gMixcclxuICAgICAgICAgICAgaTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5QaXhlbHM7IGkgKz0gNCkge1xyXG4gICAgICAgICAgICBkYXRhW2kgKyAwXSArPSBoYWxmIC0gMiAqIGhhbGYgKiBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgICAgICBkYXRhW2kgKyAxXSArPSBoYWxmIC0gMiAqIGhhbGYgKiBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgICAgICBkYXRhW2kgKyAyXSArPSBoYWxmIC0gMiAqIGhhbGYgKiBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ25vaXNlJywgMC4yLCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcclxuXHJcbiAgICAvKipcclxuICAgICogZ2V0L3NldCBub2lzZSBhbW91bnQuICBNdXN0IGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5Ob2lzZX0gZmlsdGVyLlxyXG4gICAgKiBAbmFtZSBub2lzZVxyXG4gICAgKiBAbWV0aG9kXHJcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgKiBAcGFyYW0ge051bWJlcn0gbm9pc2VcclxuICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICovXHJcbn0pKCk7XHJcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtZGVwdGggKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8qKlxyXG4gICAgICogUGl4ZWxhdGUgRmlsdGVyLiBBdmVyYWdlcyBncm91cHMgb2YgcGl4ZWxzIGFuZCByZWRyYXdzXHJcbiAgICAgKiAgdGhlbSBhcyBsYXJnZXIgcGl4ZWxzXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBuYW1lIFBpeGVsYXRlXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxyXG4gICAgICogQGF1dGhvciBpcHBvNjE1XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogbm9kZS5jYWNoZSgpO1xyXG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLlBpeGVsYXRlXSk7XHJcbiAgICAgKiBub2RlLnBpeGVsU2l6ZSgxMCk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GaWx0ZXJzLlBpeGVsYXRlID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xyXG5cclxuICAgICAgICB2YXIgcGl4ZWxTaXplID0gTWF0aC5jZWlsKHRoaXMucGl4ZWxTaXplKCkpLFxyXG4gICAgICAgICAgICB3aWR0aCA9IGltYWdlRGF0YS53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodCxcclxuICAgICAgICAgICAgeCwgeSwgaSxcclxuICAgICAgICAgICAgLy9waXhlbHNQZXJCaW4gPSBwaXhlbFNpemUgKiBwaXhlbFNpemUsXHJcbiAgICAgICAgICAgIHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhLFxyXG4gICAgICAgICAgICBuQmluc1ggPSBNYXRoLmNlaWwod2lkdGggLyBwaXhlbFNpemUpLFxyXG4gICAgICAgICAgICBuQmluc1kgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gcGl4ZWxTaXplKSxcclxuICAgICAgICAgICAgeEJpblN0YXJ0LCB4QmluRW5kLCB5QmluU3RhcnQsIHlCaW5FbmQsXHJcbiAgICAgICAgICAgIHhCaW4sIHlCaW4sIHBpeGVsc0luQmluO1xyXG4gICAgICAgIGltYWdlRGF0YSA9IGltYWdlRGF0YS5kYXRhO1xyXG5cclxuICAgICAgICBmb3IgKHhCaW4gPSAwOyB4QmluIDwgbkJpbnNYOyB4QmluICs9IDEpIHtcclxuICAgICAgICAgICAgZm9yICh5QmluID0gMDsgeUJpbiA8IG5CaW5zWTsgeUJpbiArPSAxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgY29sb3IgYWNjdW1sYXRvcnMgdG8gMFxyXG4gICAgICAgICAgICAgICAgcmVkID0gMDtcclxuICAgICAgICAgICAgICAgIGdyZWVuID0gMDtcclxuICAgICAgICAgICAgICAgIGJsdWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgYWxwaGEgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB3aGljaCBwaXhlbHMgYXJlIGluY2x1ZGVkIGluIHRoaXMgYmluXHJcbiAgICAgICAgICAgICAgICB4QmluU3RhcnQgPSB4QmluICogcGl4ZWxTaXplO1xyXG4gICAgICAgICAgICAgICAgeEJpbkVuZCA9IHhCaW5TdGFydCArIHBpeGVsU2l6ZTtcclxuICAgICAgICAgICAgICAgIHlCaW5TdGFydCA9IHlCaW4gKiBwaXhlbFNpemU7XHJcbiAgICAgICAgICAgICAgICB5QmluRW5kID0geUJpblN0YXJ0ICsgcGl4ZWxTaXplO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCBhbGwgb2YgdGhlIHBpeGVscyB0byB0aGlzIGJpbiFcclxuICAgICAgICAgICAgICAgIHBpeGVsc0luQmluID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoeCA9IHhCaW5TdGFydDsgeCA8IHhCaW5FbmQ7IHggKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCB4ID49IHdpZHRoICl7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh5ID0geUJpblN0YXJ0OyB5IDwgeUJpbkVuZDsgeSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCB5ID49IGhlaWdodCApeyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gKHdpZHRoICogeSArIHgpICogNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVkICs9IGltYWdlRGF0YVtpICsgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyZWVuICs9IGltYWdlRGF0YVtpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsdWUgKz0gaW1hZ2VEYXRhW2kgKyAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEgKz0gaW1hZ2VEYXRhW2kgKyAzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxzSW5CaW4gKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBjaGFubmVscyBhcmUgYmV0d2VlbiAwLTI1NVxyXG4gICAgICAgICAgICAgICAgcmVkID0gcmVkIC8gcGl4ZWxzSW5CaW47XHJcbiAgICAgICAgICAgICAgICBncmVlbiA9IGdyZWVuIC8gcGl4ZWxzSW5CaW47XHJcbiAgICAgICAgICAgICAgICBibHVlID0gYmx1ZSAvIHBpeGVsc0luQmluO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERyYXcgdGhpcyBiaW5cclxuICAgICAgICAgICAgICAgIGZvciAoeCA9IHhCaW5TdGFydDsgeCA8IHhCaW5FbmQ7IHggKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCB4ID49IHdpZHRoICl7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh5ID0geUJpblN0YXJ0OyB5IDwgeUJpbkVuZDsgeSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCB5ID49IGhlaWdodCApeyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gKHdpZHRoICogeSArIHgpICogNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhW2kgKyAwXSA9IHJlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhW2kgKyAxXSA9IGdyZWVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGFbaSArIDJdID0gYmx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhW2kgKyAzXSA9IGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdwaXhlbFNpemUnLCA4LCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcclxuXHJcbiAgICAvKipcclxuICAgICogZ2V0L3NldCBwaXhlbCBzaXplLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5QaXhlbGF0ZX0gZmlsdGVyLlxyXG4gICAgKiBAbmFtZSBwaXhlbFNpemVcclxuICAgICogQG1ldGhvZFxyXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSBwaXhlbFNpemVcclxuICAgICogQHJldHVybnMge0ludGVnZXJ9XHJcbiAgICAqL1xyXG59KSgpO1xyXG5cbihmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICAvKipcclxuICAgICAqIFRocmVzaG9sZCBGaWx0ZXIuIFB1c2hlcyBhbnkgdmFsdWUgYWJvdmUgdGhlIG1pZCBwb2ludCB0b1xyXG4gICAgICogIHRoZSBtYXggYW5kIGFueSB2YWx1ZSBiZWxvdyB0aGUgbWlkIHBvaW50IHRvIHRoZSBtaW4uXHJcbiAgICAgKiAgVGhpcyBhZmZlY3RzIHRoZSBhbHBoYSBjaGFubmVsLlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAbmFtZSBUaHJlc2hvbGRcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXHJcbiAgICAgKiBAYXV0aG9yIGlwcG82MTVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBub2RlLmNhY2hlKCk7XHJcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuVGhyZXNob2xkXSk7XHJcbiAgICAgKiBub2RlLnRocmVzaG9sZCgwLjEpO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmlsdGVycy5UaHJlc2hvbGQgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy50aHJlc2hvbGQoKSAqIDI1NSxcclxuICAgICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxyXG4gICAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aCxcclxuICAgICAgICAgICAgaTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGRhdGFbaV0gPSBkYXRhW2ldIDwgbGV2ZWwgPyAwIDogMjU1O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3RocmVzaG9sZCcsIDAuNSwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIGdldC9zZXQgdGhyZXNob2xkLiAgTXVzdCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuVGhyZXNob2xkfSBvciB7QGxpbmsgS29udmEuRmlsdGVycy5NYXNrfSBmaWx0ZXIuXHJcbiAgICAqIEBuYW1lIHRocmVzaG9sZFxyXG4gICAgKiBAbWV0aG9kXHJcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgKiBAcGFyYW0ge051bWJlcn0gdGhyZXNob2xkXHJcbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAqL1xyXG59KSgpO1xyXG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogU2VwaWEgRmlsdGVyXG4gICAgICogQmFzZWQgb246IFBpeGFzdGljIExpYiAtIFNlcGlhIGZpbHRlciAtIHYwLjEuMFxuICAgICAqIENvcHlyaWdodCAoYykgMjAwOCBKYWNvYiBTZWlkZWxpbiwganNlaWRlbGluQG5paGlsb2dpYy5kaywgaHR0cDovL2Jsb2cubmloaWxvZ2ljLmRrL1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIFNlcGlhXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXG4gICAgICogQGF1dGhvciBKYWNvYiBTZWlkZWxpbiA8anNlaWRlbGluQG5paGlsb2dpYy5kaz5cbiAgICAgKiBAbGljZW5zZSBNUEwgdjEuMSBbaHR0cDovL3d3dy5waXhhc3RpYy5jb20vbGliL2xpY2Vuc2UudHh0XVxuICAgICAqIEBleGFtcGxlXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5TZXBpYV0pO1xuICAgICAqL1xuICAgIEtvbnZhLkZpbHRlcnMuU2VwaWEgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG4gICAgICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgICB3ID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgICAgeSA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgICB3NCA9IHcgKiA0LFxuICAgICAgICAgICAgb2Zmc2V0WSwgeCwgb2Zmc2V0LCBvciwgb2csIG9iLCByLCBnLCBiO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIG9mZnNldFkgPSAoeSAtIDEpICogdzQ7XG4gICAgICAgICAgICB4ID0gdztcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXRZICsgKHggLSAxKSAqIDQ7XG5cbiAgICAgICAgICAgICAgICBvciA9IGRhdGFbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICBvZyA9IGRhdGFbb2Zmc2V0ICsgMV07XG4gICAgICAgICAgICAgICAgb2IgPSBkYXRhW29mZnNldCArIDJdO1xuXG4gICAgICAgICAgICAgICAgciA9IG9yICogMC4zOTMgKyBvZyAqIDAuNzY5ICsgb2IgKiAwLjE4OTtcbiAgICAgICAgICAgICAgICBnID0gb3IgKiAwLjM0OSArIG9nICogMC42ODYgKyBvYiAqIDAuMTY4O1xuICAgICAgICAgICAgICAgIGIgPSBvciAqIDAuMjcyICsgb2cgKiAwLjUzNCArIG9iICogMC4xMzE7XG5cbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldF0gPSByID4gMjU1ID8gMjU1IDogcjtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIDFdID0gZyA+IDI1NSA/IDI1NSA6IGc7XG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAyXSA9IGIgPiAyNTUgPyAyNTUgOiBiO1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgM10gPSBkYXRhW29mZnNldCArIDNdO1xuICAgICAgICAgICAgfSB3aGlsZSAoLS14KTtcbiAgICAgICAgfSB3aGlsZSAoLS15KTtcbiAgICB9O1xufSkoKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogU29sYXJpemUgRmlsdGVyXG4gICAgICogUGl4YXN0aWMgTGliIC0gU29sYXJpemUgZmlsdGVyIC0gdjAuMS4wXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDA4IEphY29iIFNlaWRlbGluLCBqc2VpZGVsaW5AbmloaWxvZ2ljLmRrLCBodHRwOi8vYmxvZy5uaWhpbG9naWMuZGsvXG4gICAgICogTGljZW5zZTogW2h0dHA6Ly93d3cucGl4YXN0aWMuY29tL2xpYi9saWNlbnNlLnR4dF1cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBTb2xhcml6ZVxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgICAqIEBleGFtcGxlXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5Tb2xhcml6ZV0pO1xuICAgICAqL1xuICAgIEtvbnZhLkZpbHRlcnMuU29sYXJpemUgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG4gICAgICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgICB3ID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgICAgaCA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgICB3NCA9IHcgKiA0LFxuICAgICAgICAgICAgeSA9IGg7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIG9mZnNldFkgPSAoeSAtIDEpICogdzQ7XG4gICAgICAgICAgICB2YXIgeCA9IHc7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldFkgKyAoeCAtIDEpICogNDtcbiAgICAgICAgICAgICAgICB2YXIgciA9IGRhdGFbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICB2YXIgZyA9IGRhdGFbb2Zmc2V0ICsgMV07XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBkYXRhW29mZnNldCArIDJdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHIgPiAxMjcpIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IDI1NSAtIHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnID4gMTI3KSB7XG4gICAgICAgICAgICAgICAgICAgIGcgPSAyNTUgLSBnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYiA+IDEyNykge1xuICAgICAgICAgICAgICAgICAgICBiID0gMjU1IC0gYjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldF0gPSByO1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgMV0gPSBnO1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgMl0gPSBiO1xuICAgICAgICAgICAgfSB3aGlsZSAoLS14KTtcbiAgICAgICAgfSB3aGlsZSAoLS15KTtcbiAgICB9O1xufSkoKTtcblxuXG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qXG4gICAqIFRvUG9sYXIgRmlsdGVyLiBDb252ZXJ0cyBpbWFnZSBkYXRhIHRvIHBvbGFyIGNvb3JkaW5hdGVzLiBQZXJmb3Jtc1xuICAgKiAgdypoKjQgcGl4ZWwgcmVhZHMgYW5kIHcqaCBwaXhlbCB3cml0ZXMuIFRoZSByIGF4aXMgaXMgcGxhY2VkIGFsb25nXG4gICAqICB3aGF0IHdvdWxkIGJlIHRoZSB5IGF4aXMgYW5kIHRoZSB0aGV0YSBheGlzIGFsb25nIHRoZSB4IGF4aXMuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICogQHBhcmFtIHtJbWFnZURhdGF9IHNyYywgdGhlIHNvdXJjZSBpbWFnZSBkYXRhICh3aGF0IHdpbGwgYmUgdHJhbnNmb3JtZWQpXG4gICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBkc3QsIHRoZSBkZXN0aW5hdGlvbiBpbWFnZSBkYXRhICh3aGVyZSBpdCB3aWxsIGJlIHNhdmVkKVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0LnBvbGFyQ2VudGVyWF0gaG9yaXpvbnRhbCBsb2NhdGlvbiBmb3IgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlLFxuICAgKiAgZGVmYXVsdCBpcyBpbiB0aGUgbWlkZGxlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0LnBvbGFyQ2VudGVyWV0gdmVydGljYWwgbG9jYXRpb24gZm9yIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSxcbiAgICogIGRlZmF1bHQgaXMgaW4gdGhlIG1pZGRsZVxuICAgKi9cblxuICAgIHZhciBUb1BvbGFyID0gZnVuY3Rpb24oc3JjLCBkc3QsIG9wdCl7XG5cbiAgICAgICAgdmFyIHNyY1BpeGVscyA9IHNyYy5kYXRhLFxuICAgICAgICAgICAgZHN0UGl4ZWxzID0gZHN0LmRhdGEsXG4gICAgICAgICAgICB4U2l6ZSA9IHNyYy53aWR0aCxcbiAgICAgICAgICAgIHlTaXplID0gc3JjLmhlaWdodCxcbiAgICAgICAgICAgIHhNaWQgPSBvcHQucG9sYXJDZW50ZXJYIHx8IHhTaXplIC8gMixcbiAgICAgICAgICAgIHlNaWQgPSBvcHQucG9sYXJDZW50ZXJZIHx8IHlTaXplIC8gMixcbiAgICAgICAgICAgIGksIHgsIHksIHIgPSAwLCBnID0gMCwgYiA9IDAsIGEgPSAwO1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIGxhcmdlc3QgcmFkaXVzXG4gICAgICAgIHZhciByYWQsIHJNYXggPSBNYXRoLnNxcnQoIHhNaWQgKiB4TWlkICsgeU1pZCAqIHlNaWQgKTtcbiAgICAgICAgeCA9IHhTaXplIC0geE1pZDtcbiAgICAgICAgeSA9IHlTaXplIC0geU1pZDtcbiAgICAgICAgcmFkID0gTWF0aC5zcXJ0KCB4ICogeCArIHkgKiB5ICk7XG4gICAgICAgIHJNYXggPSAocmFkID4gck1heCkgPyByYWQgOiByTWF4O1xuXG4gICAgICAgIC8vIFdlJ2xsIGJlIHVpc25nIHkgYXMgdGhlIHJhZGl1cywgYW5kIHggYXMgdGhlIGFuZ2xlICh0aGV0YT10KVxuICAgICAgICB2YXIgclNpemUgPSB5U2l6ZSxcbiAgICAgICAgICAgIHRTaXplID0geFNpemUsXG4gICAgICAgICAgICByYWRpdXMsIHRoZXRhO1xuXG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY292ZXIgYWxsIGFuZ2xlcyAoMC0zNjApIGFuZCB3ZSBuZWVkIHRvIGNvbnZlcnQgdG9cbiAgICAgICAgLy8gcmFkaWFucyAoKlBJLzE4MClcbiAgICAgICAgdmFyIGNvbnZlcnNpb24gPSAzNjAgLyB0U2l6ZSAqIE1hdGguUEkgLyAxODAsIHNpbiwgY29zO1xuXG4gICAgICAgIC8vIHZhciB4MSwgeDIsIHgxaSwgeDJpLCB5MSwgeTIsIHkxaSwgeTJpLCBzY2FsZTtcblxuICAgICAgICBmb3IoIHRoZXRhID0gMDsgdGhldGEgPCB0U2l6ZTsgdGhldGEgKz0gMSApe1xuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4odGhldGEgKiBjb252ZXJzaW9uKTtcbiAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKHRoZXRhICogY29udmVyc2lvbik7XG4gICAgICAgICAgICBmb3IoIHJhZGl1cyA9IDA7IHJhZGl1cyA8IHJTaXplOyByYWRpdXMgKz0gMSApe1xuICAgICAgICAgICAgICAgIHggPSBNYXRoLmZsb29yKHhNaWQgKyByTWF4ICogcmFkaXVzIC8gclNpemUgKiBjb3MpO1xuICAgICAgICAgICAgICAgIHkgPSBNYXRoLmZsb29yKHlNaWQgKyByTWF4ICogcmFkaXVzIC8gclNpemUgKiBzaW4pO1xuICAgICAgICAgICAgICAgIGkgPSAoeSAqIHhTaXplICsgeCkgKiA0O1xuICAgICAgICAgICAgICAgIHIgPSBzcmNQaXhlbHNbaSArIDBdO1xuICAgICAgICAgICAgICAgIGcgPSBzcmNQaXhlbHNbaSArIDFdO1xuICAgICAgICAgICAgICAgIGIgPSBzcmNQaXhlbHNbaSArIDJdO1xuICAgICAgICAgICAgICAgIGEgPSBzcmNQaXhlbHNbaSArIDNdO1xuXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgaXRcbiAgICAgICAgICAgICAgICAvL2kgPSAodGhldGEgKiB4U2l6ZSAgKyAgcmFkaXVzKSAqIDQ7XG4gICAgICAgICAgICAgICAgaSA9ICh0aGV0YSArIHJhZGl1cyAqIHhTaXplKSAqIDQ7XG4gICAgICAgICAgICAgICAgZHN0UGl4ZWxzW2kgKyAwXSA9IHI7XG4gICAgICAgICAgICAgICAgZHN0UGl4ZWxzW2kgKyAxXSA9IGc7XG4gICAgICAgICAgICAgICAgZHN0UGl4ZWxzW2kgKyAyXSA9IGI7XG4gICAgICAgICAgICAgICAgZHN0UGl4ZWxzW2kgKyAzXSA9IGE7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgICAqIEZyb21Qb2xhciBGaWx0ZXIuIENvbnZlcnRzIGltYWdlIGRhdGEgZnJvbSBwb2xhciBjb29yZGluYXRlcyBiYWNrIHRvIHJlY3Rhbmd1bGFyLlxuICAgICAqICBQZXJmb3JtcyB3KmgqNCBwaXhlbCByZWFkcyBhbmQgdypoIHBpeGVsIHdyaXRlcy5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBzcmMsIHRoZSBzb3VyY2UgaW1hZ2UgZGF0YSAod2hhdCB3aWxsIGJlIHRyYW5zZm9ybWVkKVxuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBkc3QsIHRoZSBkZXN0aW5hdGlvbiBpbWFnZSBkYXRhICh3aGVyZSBpdCB3aWxsIGJlIHNhdmVkKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdC5wb2xhckNlbnRlclhdIGhvcml6b250YWwgbG9jYXRpb24gZm9yIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSxcbiAgICAgKiAgZGVmYXVsdCBpcyBpbiB0aGUgbWlkZGxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHQucG9sYXJDZW50ZXJZXSB2ZXJ0aWNhbCBsb2NhdGlvbiBmb3IgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlLFxuICAgICAqICBkZWZhdWx0IGlzIGluIHRoZSBtaWRkbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdC5wb2xhclJvdGF0aW9uXSBhbW91bnQgdG8gcm90YXRlIHRoZSBpbWFnZSBjb3VudGVyY2xvY2t3aXMsXG4gICAgICogIDAgaXMgbm8gcm90YXRpb24sIDM2MCBkZWdyZWVzIGlzIGEgZnVsbCByb3RhdGlvblxuICAgICAqL1xuXG4gICAgdmFyIEZyb21Qb2xhciA9IGZ1bmN0aW9uKHNyYywgZHN0LCBvcHQpe1xuXG4gICAgICAgIHZhciBzcmNQaXhlbHMgPSBzcmMuZGF0YSxcbiAgICAgICAgICAgIGRzdFBpeGVscyA9IGRzdC5kYXRhLFxuICAgICAgICAgICAgeFNpemUgPSBzcmMud2lkdGgsXG4gICAgICAgICAgICB5U2l6ZSA9IHNyYy5oZWlnaHQsXG4gICAgICAgICAgICB4TWlkID0gb3B0LnBvbGFyQ2VudGVyWCB8fCB4U2l6ZSAvIDIsXG4gICAgICAgICAgICB5TWlkID0gb3B0LnBvbGFyQ2VudGVyWSB8fCB5U2l6ZSAvIDIsXG4gICAgICAgICAgICBpLCB4LCB5LCBkeCwgZHksIHIgPSAwLCBnID0gMCwgYiA9IDAsIGEgPSAwO1xuXG5cbiAgICAgICAgLy8gRmluZCB0aGUgbGFyZ2VzdCByYWRpdXNcbiAgICAgICAgdmFyIHJhZCwgck1heCA9IE1hdGguc3FydCggeE1pZCAqIHhNaWQgKyB5TWlkICogeU1pZCApO1xuICAgICAgICB4ID0geFNpemUgLSB4TWlkO1xuICAgICAgICB5ID0geVNpemUgLSB5TWlkO1xuICAgICAgICByYWQgPSBNYXRoLnNxcnQoIHggKiB4ICsgeSAqIHkgKTtcbiAgICAgICAgck1heCA9IChyYWQgPiByTWF4KSA/IHJhZCA6IHJNYXg7XG5cbiAgICAgICAgLy8gV2UnbGwgYmUgdWlzbmcgeCBhcyB0aGUgcmFkaXVzLCBhbmQgeSBhcyB0aGUgYW5nbGUgKHRoZXRhPXQpXG4gICAgICAgIHZhciByU2l6ZSA9IHlTaXplLFxuICAgICAgICB0U2l6ZSA9IHhTaXplLFxuICAgICAgICByYWRpdXMsIHRoZXRhLFxuICAgICAgICBwaGFzZVNoaWZ0ID0gb3B0LnBvbGFyUm90YXRpb24gfHwgMDtcblxuICAgICAgICAvLyBXZSBuZWVkIHRvIGNvbnZlcnQgdG8gZGVncmVlcyBhbmQgd2UgbmVlZCB0byBtYWtlIHN1cmVcbiAgICAgICAgLy8gaXQncyBiZXR3ZWVuICgwLTM2MClcbiAgICAgICAgLy8gdmFyIGNvbnZlcnNpb24gPSB0U2l6ZS8zNjAqMTgwL01hdGguUEk7XG4gICAgICAgIC8vdmFyIGNvbnZlcnNpb24gPSB0U2l6ZS8zNjAqMTgwL01hdGguUEk7XG5cbiAgICAgICAgdmFyIHgxLCB5MTtcblxuICAgICAgICBmb3IoIHggPSAwOyB4IDwgeFNpemU7IHggKz0gMSApe1xuICAgICAgICAgICAgZm9yKCB5ID0gMDsgeSA8IHlTaXplOyB5ICs9IDEgKXtcbiAgICAgICAgICAgICAgICBkeCA9IHggLSB4TWlkO1xuICAgICAgICAgICAgICAgIGR5ID0geSAtIHlNaWQ7XG4gICAgICAgICAgICAgICAgcmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSAqIHJTaXplIC8gck1heDtcbiAgICAgICAgICAgICAgICB0aGV0YSA9IChNYXRoLmF0YW4yKGR5LCBkeCkgKiAxODAgLyBNYXRoLlBJICsgMzYwICsgcGhhc2VTaGlmdCkgJSAzNjA7XG4gICAgICAgICAgICAgICAgdGhldGEgPSB0aGV0YSAqIHRTaXplIC8gMzYwO1xuICAgICAgICAgICAgICAgIHgxID0gTWF0aC5mbG9vcih0aGV0YSk7XG4gICAgICAgICAgICAgICAgeTEgPSBNYXRoLmZsb29yKHJhZGl1cyk7XG4gICAgICAgICAgICAgICAgaSA9ICh5MSAqIHhTaXplICsgeDEpICogNDtcbiAgICAgICAgICAgICAgICByID0gc3JjUGl4ZWxzW2kgKyAwXTtcbiAgICAgICAgICAgICAgICBnID0gc3JjUGl4ZWxzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBiID0gc3JjUGl4ZWxzW2kgKyAyXTtcbiAgICAgICAgICAgICAgICBhID0gc3JjUGl4ZWxzW2kgKyAzXTtcblxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIGl0XG4gICAgICAgICAgICAgICAgaSA9ICh5ICogeFNpemUgKyB4KSAqIDQ7XG4gICAgICAgICAgICAgICAgZHN0UGl4ZWxzW2kgKyAwXSA9IHI7XG4gICAgICAgICAgICAgICAgZHN0UGl4ZWxzW2kgKyAxXSA9IGc7XG4gICAgICAgICAgICAgICAgZHN0UGl4ZWxzW2kgKyAyXSA9IGI7XG4gICAgICAgICAgICAgICAgZHN0UGl4ZWxzW2kgKyAzXSA9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvL0tvbnZhLkZpbHRlcnMuVG9Qb2xhciA9IEtvbnZhLlV0aWwuX0ZpbHRlcldyYXBEb3VibGVCdWZmZXIoVG9Qb2xhcik7XG4gICAgLy9Lb252YS5GaWx0ZXJzLkZyb21Qb2xhciA9IEtvbnZhLlV0aWwuX0ZpbHRlcldyYXBEb3VibGVCdWZmZXIoRnJvbVBvbGFyKTtcblxuICAgIC8vIGNyZWF0ZSBhIHRlbXBvcmFyeSBjYW52YXMgZm9yIHdvcmtpbmcgLSBzaGFyZWQgYmV0d2VlbiBtdWx0aXBsZSBjYWxsc1xuICAgIHZhciB0ZW1wQ2FudmFzID0gS29udmEuVXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG5cbiAgICAvKlxuICAgICAqIEthbGVpZG9zY29wZSBGaWx0ZXIuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgS2FsZWlkb3Njb3BlXG4gICAgICogQGF1dGhvciBpcHBvNjE1XG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuS2FsZWlkb3Njb3BlXSk7XG4gICAgICogbm9kZS5rYWxlaWRvc2NvcGVQb3dlcigzKTtcbiAgICAgKiBub2RlLmthbGVpZG9zY29wZUFuZ2xlKDQ1KTtcbiAgICAgKi9cbiAgICBLb252YS5GaWx0ZXJzLkthbGVpZG9zY29wZSA9IGZ1bmN0aW9uKGltYWdlRGF0YSl7XG4gICAgICAgIHZhciB4U2l6ZSA9IGltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgICAgIHlTaXplID0gaW1hZ2VEYXRhLmhlaWdodDtcblxuICAgICAgICB2YXIgeCwgeSwgeG9mZiwgaSwgciwgZywgYiwgYSwgc3JjUG9zLCBkc3RQb3M7XG4gICAgICAgIHZhciBwb3dlciA9IE1hdGgucm91bmQoIHRoaXMua2FsZWlkb3Njb3BlUG93ZXIoKSApO1xuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLnJvdW5kKCB0aGlzLmthbGVpZG9zY29wZUFuZ2xlKCkgKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IE1hdGguZmxvb3IoeFNpemUgKiAoYW5nbGUgJSAzNjApIC8gMzYwKTtcblxuICAgICAgICBpZiggcG93ZXIgPCAxICl7cmV0dXJuOyB9XG5cbiAgICAgICAgLy8gV29yayB3aXRoIG91ciBzaGFyZWQgYnVmZmVyIGNhbnZhc1xuICAgICAgICB0ZW1wQ2FudmFzLndpZHRoID0geFNpemU7XG4gICAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0geVNpemU7XG4gICAgICAgIHZhciBzY3JhdGNoRGF0YSA9IHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5nZXRJbWFnZURhdGEoMCwgMCwgeFNpemUsIHlTaXplKTtcblxuICAgICAgICAvLyBDb252ZXJ0IHRoaGUgb3JpZ2luYWwgdG8gcG9sYXIgY29vcmRpbmF0ZXNcbiAgICAgICAgVG9Qb2xhciggaW1hZ2VEYXRhLCBzY3JhdGNoRGF0YSwge1xuICAgICAgICAgICAgcG9sYXJDZW50ZXJYOiB4U2l6ZSAvIDIsXG4gICAgICAgICAgICBwb2xhckNlbnRlclk6IHlTaXplIC8gMlxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgaG93IGJpZyBlYWNoIHNlY3Rpb24gd2lsbCBiZSwgaWYgaXQncyB0b28gc21hbGxcbiAgICAgICAgLy8gbWFrZSBpdCBiaWdnZXJcbiAgICAgICAgdmFyIG1pblNlY3Rpb25TaXplID0geFNpemUgLyBNYXRoLnBvdygyLCBwb3dlcik7XG4gICAgICAgIHdoaWxlKCBtaW5TZWN0aW9uU2l6ZSA8PSA4KXtcbiAgICAgICAgICAgIG1pblNlY3Rpb25TaXplID0gbWluU2VjdGlvblNpemUgKiAyO1xuICAgICAgICAgICAgcG93ZXIgLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBtaW5TZWN0aW9uU2l6ZSA9IE1hdGguY2VpbChtaW5TZWN0aW9uU2l6ZSk7XG4gICAgICAgIHZhciBzZWN0aW9uU2l6ZSA9IG1pblNlY3Rpb25TaXplO1xuXG4gICAgICAgIC8vIENvcHkgdGhlIG9mZnNldCByZWdpb24gdG8gMFxuICAgICAgICAvLyBEZXBlbmRpbmcgb24gdGhlIHNpemUgb2YgZmlsdGVyIGFuZCBsb2NhdGlvbiBvZiB0aGUgb2Zmc2V0IHdlIG1heSBuZWVkXG4gICAgICAgIC8vIHRvIGNvcHkgdGhlIHNlY3Rpb24gYmFja3dhcmRzIHRvIHByZXZlbnQgaXQgZnJvbSByZXdyaXRpbmcgaXRzZWxmXG4gICAgICAgIHZhciB4U3RhcnQgPSAwLFxuICAgICAgICAgIHhFbmQgPSBzZWN0aW9uU2l6ZSxcbiAgICAgICAgICB4RGVsdGEgPSAxO1xuICAgICAgICBpZiggb2Zmc2V0ICsgbWluU2VjdGlvblNpemUgPiB4U2l6ZSApe1xuICAgICAgICAgICAgeFN0YXJ0ID0gc2VjdGlvblNpemU7XG4gICAgICAgICAgICB4RW5kID0gMDtcbiAgICAgICAgICAgIHhEZWx0YSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGZvciggeSA9IDA7IHkgPCB5U2l6ZTsgeSArPSAxICl7XG4gICAgICAgICAgICBmb3IoIHggPSB4U3RhcnQ7IHggIT09IHhFbmQ7IHggKz0geERlbHRhICl7XG4gICAgICAgICAgICAgICAgeG9mZiA9IE1hdGgucm91bmQoeCArIG9mZnNldCkgJSB4U2l6ZTtcbiAgICAgICAgICAgICAgICBzcmNQb3MgPSAoeFNpemUgKiB5ICsgeG9mZikgKiA0O1xuICAgICAgICAgICAgICAgIHIgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDBdO1xuICAgICAgICAgICAgICAgIGcgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDFdO1xuICAgICAgICAgICAgICAgIGIgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDJdO1xuICAgICAgICAgICAgICAgIGEgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDNdO1xuICAgICAgICAgICAgICAgIGRzdFBvcyA9ICh4U2l6ZSAqIHkgKyB4KSAqIDQ7XG4gICAgICAgICAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAwXSA9IHI7XG4gICAgICAgICAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAxXSA9IGc7XG4gICAgICAgICAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAyXSA9IGI7XG4gICAgICAgICAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAzXSA9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQZXJmb3JtIHRoZSBhY3R1YWwgZWZmZWN0XG4gICAgICAgIGZvciggeSA9IDA7IHkgPCB5U2l6ZTsgeSArPSAxICl7XG4gICAgICAgICAgICBzZWN0aW9uU2l6ZSA9IE1hdGguZmxvb3IoIG1pblNlY3Rpb25TaXplICk7XG4gICAgICAgICAgICBmb3IoIGkgPSAwOyBpIDwgcG93ZXI7IGkgKz0gMSApe1xuICAgICAgICAgICAgICAgIGZvciggeCA9IDA7IHggPCBzZWN0aW9uU2l6ZSArIDE7IHggKz0gMSApe1xuICAgICAgICAgICAgICAgICAgICBzcmNQb3MgPSAoeFNpemUgKiB5ICsgeCkgKiA0O1xuICAgICAgICAgICAgICAgICAgICByID0gc2NyYXRjaERhdGEuZGF0YVtzcmNQb3MgKyAwXTtcbiAgICAgICAgICAgICAgICAgICAgZyA9IHNjcmF0Y2hEYXRhLmRhdGFbc3JjUG9zICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGIgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDJdO1xuICAgICAgICAgICAgICAgICAgICBhID0gc2NyYXRjaERhdGEuZGF0YVtzcmNQb3MgKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgZHN0UG9zID0gKHhTaXplICogeSArIHNlY3Rpb25TaXplICogMiAtIHggLSAxKSAqIDQ7XG4gICAgICAgICAgICAgICAgICAgIHNjcmF0Y2hEYXRhLmRhdGFbZHN0UG9zICsgMF0gPSByO1xuICAgICAgICAgICAgICAgICAgICBzY3JhdGNoRGF0YS5kYXRhW2RzdFBvcyArIDFdID0gZztcbiAgICAgICAgICAgICAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAyXSA9IGI7XG4gICAgICAgICAgICAgICAgICAgIHNjcmF0Y2hEYXRhLmRhdGFbZHN0UG9zICsgM10gPSBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWN0aW9uU2l6ZSAqPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udmVydCBiYWNrIGZyb20gcG9sYXIgY29vcmRpbmF0ZXNcbiAgICAgICAgRnJvbVBvbGFyKHNjcmF0Y2hEYXRhLCBpbWFnZURhdGEsIHtwb2xhclJvdGF0aW9uOiAwfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICogZ2V0L3NldCBrYWxlaWRvc2NvcGUgcG93ZXIuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkthbGVpZG9zY29wZX0gZmlsdGVyLlxuICAgICogQG5hbWUga2FsZWlkb3Njb3BlUG93ZXJcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSBwb3dlciBvZiBrYWxlaWRvc2NvcGVcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICovXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2thbGVpZG9zY29wZVBvd2VyJywgMiwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG5cbiAgICAvKipcbiAgICAqIGdldC9zZXQga2FsZWlkb3Njb3BlIGFuZ2xlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5LYWxlaWRvc2NvcGV9IGZpbHRlci5cbiAgICAqIEBuYW1lIGthbGVpZG9zY29wZUFuZ2xlXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7SW50ZWdlcn0gZGVncmVlc1xuICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgKi9cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAna2FsZWlkb3Njb3BlQW5nbGUnLCAwLCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcblxufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBDb250YWluZXIgY29uc3RydWN0b3IuJm5ic3A7IENvbnRhaW5lcnMgYXJlIHVzZWQgdG8gY29udGFpbiBub2RlcyBvciBvdGhlciBjb250YWluZXJzXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLk5vZGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmNsaXBdIHNldCBjbGlwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFhdIHNldCBjbGlwIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWV0gc2V0IGNsaXAgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBXaWR0aF0gc2V0IGNsaXAgd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwSGVpZ2h0XSBzZXQgY2xpcCBoZWlnaHRcblxuICAgICAqL1xuICAgIEtvbnZhLkNvbnRhaW5lciA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5VdGlsLmFkZE1ldGhvZHMoS29udmEuQ29udGFpbmVyLCB7XG4gICAgICAgIF9faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IEtvbnZhLkNvbGxlY3Rpb24oKTtcbiAgICAgICAgICAgIEtvbnZhLk5vZGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJucyBhIHtAbGluayBLb252YS5Db2xsZWN0aW9ufSBvZiBkaXJlY3QgZGVzY2VuZGFudCBub2Rlc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtmaWx0ZXJGdW5jXSBmaWx0ZXIgZnVuY3Rpb25cbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLkNvbGxlY3Rpb259XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIGdldCBhbGwgY2hpbGRyZW5cbiAgICAgICAgICogdmFyIGNoaWxkcmVuID0gbGF5ZXIuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gZ2V0IG9ubHkgY2lyY2xlc1xuICAgICAgICAgKiB2YXIgY2lyY2xlcyA9IGxheWVyLmdldENoaWxkcmVuKGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgKiAgICByZXR1cm4gbm9kZS5nZXRDbGFzc05hbWUoKSA9PT0gJ0NpcmNsZSc7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q2hpbGRyZW46IGZ1bmN0aW9uKGZpbHRlckZ1bmMpIHtcbiAgICAgICAgICAgIGlmICghZmlsdGVyRnVuYykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IG5ldyBLb252YS5Db2xsZWN0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmVhY2goZnVuY3Rpb24oY2hpbGQpe1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJGdW5jKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZXRlcm1pbmUgaWYgbm9kZSBoYXMgY2hpbGRyZW5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGhhc0NoaWxkcmVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENoaWxkcmVuKCkubGVuZ3RoID4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlbW92ZSBhbGwgY2hpbGRyZW5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gS29udmEuQ29sbGVjdGlvbi50b0NvbGxlY3Rpb24odGhpcy5jaGlsZHJlbik7XG4gICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAvLyByZXNldCBwYXJlbnQgdG8gcHJldmVudCBtYW55IF9zZXRDaGlsZHJlbkluZGljZXMgY2FsbHNcbiAgICAgICAgICAgICAgICBkZWxldGUgY2hpbGQucGFyZW50O1xuICAgICAgICAgICAgICAgIGNoaWxkLmluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaGFzQ2hpbGRyZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5yZW1vdmVDaGlsZHJlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGlsZC5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgS29udmEuQ29sbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZXN0cm95IGFsbCBjaGlsZHJlblxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95Q2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBLb252YS5Db2xsZWN0aW9uLnRvQ29sbGVjdGlvbih0aGlzLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIC8vIHJlc2V0IHBhcmVudCB0byBwcmV2ZW50IG1hbnkgX3NldENoaWxkcmVuSW5kaWNlcyBjYWxsc1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjaGlsZC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgY2hpbGQuaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGNoaWxkLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgS29udmEuQ29sbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgbm9kZSBvciBub2RlcyB0byBjb250YWluZXIuXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHsuLi5Lb252YS5Ob2RlfSBjaGlsZFxuICAgICAgICAgKiBAcmV0dXJucyB7Q29udGFpbmVyfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBsYXllci5hZGQoc2hhcGUxLCBzaGFwZTIsIHNoYXBlMyk7XG4gICAgICAgICAqL1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChhcmd1bWVudHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGlsZC5nZXRQYXJlbnQoKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLm1vdmVUbyh0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0ZUFkZChjaGlsZCk7XG4gICAgICAgICAgICBjaGlsZC5pbmRleCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoJ2FkZCcsIHtcbiAgICAgICAgICAgICAgICBjaGlsZDogY2hpbGRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBpZiBub2RlIHVuZGVyIGRyYWcgd2UgbmVlZCB0byB1cGRhdGUgZHJhZyBhbmltYXRpb25cbiAgICAgICAgICAgIGlmIChLb252YS5ERCAmJiBjaGlsZC5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBLb252YS5ERC5hbmltLnNldExheWVycyhjaGlsZC5nZXRMYXllcigpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hhaW5hYmxlXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBkZXN0cm95IGNoaWxkcmVuXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95Q2hpbGRyZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoZW4gZGVzdHJveSBzZWxmXG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJldHVybiBhIHtAbGluayBLb252YS5Db2xsZWN0aW9ufSBvZiBub2RlcyB0aGF0IG1hdGNoIHRoZSBzZWxlY3Rvci4gIFVzZSAnIycgZm9yIGlkIHNlbGVjdGlvbnNcbiAgICAgICAgICogYW5kICcuJyBmb3IgbmFtZSBzZWxlY3Rpb25zLiAgWW91IGNhbiBhbHNvIHNlbGVjdCBieSB0eXBlIG9yIGNsYXNzIG5hbWUuIFBhc3MgbXVsdGlwbGUgc2VsZWN0b3JzXG4gICAgICAgICAqIHNlcGFyYXRlZCBieSBhIHNwYWNlLlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICAgICAgICAgKiBAcmV0dXJucyB7Q29sbGVjdGlvbn1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gc2VsZWN0IG5vZGUgd2l0aCBpZCBmb29cbiAgICAgICAgICogdmFyIG5vZGUgPSBzdGFnZS5maW5kKCcjZm9vJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIHNlbGVjdCBub2RlcyB3aXRoIG5hbWUgYmFyIGluc2lkZSBsYXllclxuICAgICAgICAgKiB2YXIgbm9kZXMgPSBsYXllci5maW5kKCcuYmFyJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIHNlbGVjdCBhbGwgZ3JvdXBzIGluc2lkZSBsYXllclxuICAgICAgICAgKiB2YXIgbm9kZXMgPSBsYXllci5maW5kKCdHcm91cCcpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBzZWxlY3QgYWxsIHJlY3RhbmdsZXMgaW5zaWRlIGxheWVyXG4gICAgICAgICAqIHZhciBub2RlcyA9IGxheWVyLmZpbmQoJ1JlY3QnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gc2VsZWN0IG5vZGUgd2l0aCBhbiBpZCBvZiBmb28gb3IgYSBuYW1lIG9mIGJhciBpbnNpZGUgbGF5ZXJcbiAgICAgICAgICogdmFyIG5vZGVzID0gbGF5ZXIuZmluZCgnI2ZvbywgLmJhcicpO1xuICAgICAgICAgKi9cbiAgICAgICAgZmluZDogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHZhciByZXRBcnIgPSBbXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvckFyciA9IHNlbGVjdG9yLnJlcGxhY2UoLyAvZywgJycpLnNwbGl0KCcsJyksXG4gICAgICAgICAgICAgICAgbGVuID0gc2VsZWN0b3JBcnIubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG4sIGksIHNlbCwgYXJyLCBub2RlLCBjaGlsZHJlbiwgY2xlbjtcblxuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgc2VsID0gc2VsZWN0b3JBcnJbbl07XG4gICAgICAgICAgICAgICAgaWYgKCFLb252YS5VdGlsLmlzVmFsaWRTZWxlY3RvcihzZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwud2FybignU2VsZWN0b3IgXCInICsgc2VsICsgJ1wiIGlzIGludmFsaWQuIEFsbG93ZWQgc2VsZWN0b3JzIGV4YW1wbGVzIGFyZSBcIiNmb29cIiwgXCIuYmFyXCIgb3IgXCJHcm91cFwiLicpO1xuICAgICAgICAgICAgICAgICAgICBLb252YS5VdGlsLndhcm4oJ0lmIHlvdSBoYXZlIGEgY3VzdG9tIHNoYXBlIHdpdGggc3VjaCBjbGFzc05hbWUsIHBsZWFzZSBjaGFuZ2UgaXQgdG8gc3RhcnQgd2l0aCB1cHBlciBsZXR0ZXIgbGlrZSBcIlRyaWFuZ2xlXCIuJyk7XG4gICAgICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwud2FybignS29udmEgaXMgYXdlc29tZSwgcmlnaHQ/Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlkIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgaWYoc2VsLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLl9nZXROb2RlQnlJZChzZWwuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRBcnIucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBuYW1lIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgZWxzZSBpZihzZWwuY2hhckF0KDApID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyID0gdGhpcy5fZ2V0Tm9kZXNCeU5hbWUoc2VsLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0QXJyID0gcmV0QXJyLmNvbmNhdChhcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1bnJlY29nbml6ZWQgc2VsZWN0b3IsIHBhc3MgdG8gY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgICAgICAgICAgICAgICAgIGNsZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IGNsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0QXJyID0gcmV0QXJyLmNvbmNhdChjaGlsZHJlbltpXS5fZ2V0KHNlbCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gS29udmEuQ29sbGVjdGlvbi50b0NvbGxlY3Rpb24ocmV0QXJyKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJldHVybiBhIGZpcnN0IG5vZGUgZnJvbSBgZmluZGAgbWV0aG9kXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBzZWxlY3Qgbm9kZSB3aXRoIGlkIGZvb1xuICAgICAgICAgKiB2YXIgbm9kZSA9IHN0YWdlLmZpbmRPbmUoJyNmb28nKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gc2VsZWN0IG5vZGUgd2l0aCBuYW1lIGJhciBpbnNpZGUgbGF5ZXJcbiAgICAgICAgICogdmFyIG5vZGVzID0gbGF5ZXIuZmluZE9uZSgnLmJhcicpO1xuICAgICAgICAgKi9cbiAgICAgICAgZmluZE9uZTogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmQoc2VsZWN0b3IpWzBdO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0Tm9kZUJ5SWQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBLb252YS5pZHNba2V5XTtcblxuICAgICAgICAgICAgaWYobm9kZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuaXNBbmNlc3Rvck9mKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldE5vZGVzQnlOYW1lOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHZhciBhcnIgPSBLb252YS5uYW1lc1trZXldIHx8IFtdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldERlc2NlbmRhbnRzKGFycik7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXQ6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgcmV0QXJyID0gS29udmEuTm9kZS5wcm90b3R5cGUuX2dldC5jYWxsKHRoaXMsIHNlbGVjdG9yKTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBmb3IodmFyIG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICByZXRBcnIgPSByZXRBcnIuY29uY2F0KGNoaWxkcmVuW25dLl9nZXQoc2VsZWN0b3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGV4dGVuZGVyc1xuICAgICAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gS29udmEuTm9kZS5wcm90b3R5cGUudG9PYmplY3QuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgb2JqLmNoaWxkcmVuID0gW107XG5cbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBmb3IodmFyIG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltuXTtcbiAgICAgICAgICAgICAgICBvYmouY2hpbGRyZW4ucHVzaChjaGlsZC50b09iamVjdCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldERlc2NlbmRhbnRzOiBmdW5jdGlvbihhcnIpIHtcbiAgICAgICAgICAgIHZhciByZXRBcnIgPSBbXTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICAgICAgZm9yKHZhciBuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBhcnJbbl07XG4gICAgICAgICAgICAgICAgaWYodGhpcy5pc0FuY2VzdG9yT2Yobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0QXJyLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZGV0ZXJtaW5lIGlmIG5vZGUgaXMgYW4gYW5jZXN0b3JcbiAgICAgICAgICogb2YgZGVzY2VuZGFudFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7S29udmEuTm9kZX0gbm9kZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNBbmNlc3Rvck9mOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgICAgICAgIHdoaWxlKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmKHBhcmVudC5faWQgPT09IHRoaXMuX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBtZXRob2RcbiAgICAgICAgICAgIHZhciBub2RlID0gS29udmEuTm9kZS5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLCBvYmopO1xuXG4gICAgICAgICAgICB0aGlzLmdldENoaWxkcmVuKCkuZWFjaChmdW5jdGlvbihubykge1xuICAgICAgICAgICAgICAgIG5vZGUuYWRkKG5vLmNsb25lKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBhbGwgc2hhcGVzIHRoYXQgaW50ZXJzZWN0IGEgcG9pbnQuICBOb3RlOiBiZWNhdXNlIHRoaXMgbWV0aG9kIG11c3QgY2xlYXIgYSB0ZW1wb3JhcnlcbiAgICAgICAgICogY2FudmFzIGFuZCByZWRyYXcgZXZlcnkgc2hhcGUgaW5zaWRlIHRoZSBjb250YWluZXIsIGl0IHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHNwZWNpYWwgc2l0YXRpb25zXG4gICAgICAgICAqIGJlY2F1c2UgaXQgcGVyZm9ybXMgdmVyeSBwb29ybHkuICBQbGVhc2UgdXNlIHRoZSB7QGxpbmsgS29udmEuU3RhZ2UjZ2V0SW50ZXJzZWN0aW9ufSBtZXRob2QgaWYgYXQgYWxsIHBvc3NpYmxlXG4gICAgICAgICAqIGJlY2F1c2UgaXQgcGVyZm9ybXMgbXVjaCBiZXR0ZXJcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9zXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zLnlcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fSBhcnJheSBvZiBzaGFwZXNcbiAgICAgICAgICovXG4gICAgICAgIGdldEFsbEludGVyc2VjdGlvbnM6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICAgICAgdmFyIGFyciA9IFtdO1xuXG4gICAgICAgICAgICB0aGlzLmZpbmQoJ1NoYXBlJykuZWFjaChmdW5jdGlvbihzaGFwZSkge1xuICAgICAgICAgICAgICAgIGlmKHNoYXBlLmlzVmlzaWJsZSgpICYmIHNoYXBlLmludGVyc2VjdHMocG9zKSkge1xuICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChzaGFwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH0sXG4gICAgICAgIF9zZXRDaGlsZHJlbkluZGljZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5lYWNoKGZ1bmN0aW9uKGNoaWxkLCBuKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuaW5kZXggPSBuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYXdTY2VuZTogZnVuY3Rpb24oY2FuLCB0b3AsIGNhY2hpbmcpIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKSxcbiAgICAgICAgICAgICAgICBjYW52YXMgPSBjYW4gfHwgKGxheWVyICYmIGxheWVyLmdldENhbnZhcygpKSxcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gY2FudmFzICYmIGNhbnZhcy5nZXRDb250ZXh0KCksXG4gICAgICAgICAgICAgICAgY2FjaGVkQ2FudmFzID0gdGhpcy5fY2FjaGUuY2FudmFzLFxuICAgICAgICAgICAgICAgIGNhY2hlZFNjZW5lQ2FudmFzID0gY2FjaGVkQ2FudmFzICYmIGNhY2hlZENhbnZhcy5zY2VuZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hpbmcgJiYgY2FjaGVkU2NlbmVDYW52YXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9hcHBseVRyYW5zZm9ybSh0aGlzLCBjb250ZXh0LCB0b3ApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmF3Q2FjaGVkU2NlbmVDYW52YXMoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhd0NoaWxkcmVuKGNhbnZhcywgJ2RyYXdTY2VuZScsIHRvcCwgZmFsc2UsIGNhY2hpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBkcmF3SGl0OiBmdW5jdGlvbihjYW4sIHRvcCwgY2FjaGluZykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLFxuICAgICAgICAgICAgICAgIGNhbnZhcyA9IGNhbiB8fCAobGF5ZXIgJiYgbGF5ZXIuaGl0Q2FudmFzKSxcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gY2FudmFzICYmIGNhbnZhcy5nZXRDb250ZXh0KCksXG4gICAgICAgICAgICAgICAgY2FjaGVkQ2FudmFzID0gdGhpcy5fY2FjaGUuY2FudmFzLFxuICAgICAgICAgICAgICAgIGNhY2hlZEhpdENhbnZhcyA9IGNhY2hlZENhbnZhcyAmJiBjYWNoZWRDYW52YXMuaGl0O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zaG91bGREcmF3SGl0KGNhbnZhcykpIHtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuY2xlYXJIaXRDYWNoZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hpbmcgJiYgY2FjaGVkSGl0Q2FudmFzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBsYXllci5fYXBwbHlUcmFuc2Zvcm0odGhpcywgY29udGV4dCwgdG9wKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhd0NhY2hlZEhpdENhbnZhcyhjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmF3Q2hpbGRyZW4oY2FudmFzLCAnZHJhd0hpdCcsIHRvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIF9kcmF3Q2hpbGRyZW46IGZ1bmN0aW9uKGNhbnZhcywgZHJhd01ldGhvZCwgdG9wLCBjYWNoaW5nLCBza2lwQnVmZmVyKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCgpLFxuICAgICAgICAgICAgICAgIGNsaXBXaWR0aCA9IHRoaXMuZ2V0Q2xpcFdpZHRoKCksXG4gICAgICAgICAgICAgICAgY2xpcEhlaWdodCA9IHRoaXMuZ2V0Q2xpcEhlaWdodCgpLFxuICAgICAgICAgICAgICAgIGhhc0NsaXAgPSBjbGlwV2lkdGggJiYgY2xpcEhlaWdodCxcbiAgICAgICAgICAgICAgICBjbGlwWCwgY2xpcFk7XG5cbiAgICAgICAgICAgIGlmIChoYXNDbGlwICYmIGxheWVyKSB7XG4gICAgICAgICAgICAgICAgY2xpcFggPSB0aGlzLmdldENsaXBYKCk7XG4gICAgICAgICAgICAgICAgY2xpcFkgPSB0aGlzLmdldENsaXBZKCk7XG5cbiAgICAgICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBsYXllci5fYXBwbHlUcmFuc2Zvcm0odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlY3QoY2xpcFgsIGNsaXBZLCBjbGlwV2lkdGgsIGNsaXBIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY2xpcCgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVzZXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5lYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRbZHJhd01ldGhvZF0oY2FudmFzLCB0b3AsIGNhY2hpbmcsIHNraXBCdWZmZXIpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChoYXNDbGlwKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNob3VsZERyYXdIaXQ6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgICAgICAgICAgdmFyIGRkID0gS29udmEuREQ7XG4gICAgICAgICAgICB2YXIgbGF5ZXJVbmRlckRyYWcgPSBkZCAmJiBLb252YS5pc0RyYWdnaW5nKCkgJiYgKEtvbnZhLkRELmFuaW0uZ2V0TGF5ZXJzKCkuaW5kZXhPZihsYXllcikgIT09IC0xKTtcbiAgICAgICAgICAgIHJldHVybiAoY2FudmFzICYmIGNhbnZhcy5pc0NhY2hlKSB8fCAobGF5ZXIgJiYgbGF5ZXIuaGl0R3JhcGhFbmFibGVkKCkpXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5pc1Zpc2libGUoKSAmJiAhbGF5ZXJVbmRlckRyYWc7XG4gICAgICAgIH0sXG4gICAgICAgIGdldENsaWVudFJlY3Q6IGZ1bmN0aW9uKHNraXBUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHZhciBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZO1xuICAgICAgICAgICAgdmFyIHNlbGZSZWN0ID0ge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGNoaWxkLmdldENsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgICAgIC8vIHNraXAgaW52aXNpYmxlIGNoaWxkcmVuIChsaWtlIGVtcHR5IGdyb3VwcylcbiAgICAgICAgICAgICAgICAvLyBvciBkb24ndCBza2lwLi4uIGhtbW0uLi5cbiAgICAgICAgICAgICAgICAvLyBpZiAocmVjdC53aWR0aCA9PT0gMCAmJiByZWN0LmhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1pblggPT09IHVuZGVmaW5lZCkgeyAvLyBpbml0aWFsIHZhbHVlIGZvciBmaXJzdCBjaGlsZFxuICAgICAgICAgICAgICAgICAgICBtaW5YID0gcmVjdC54O1xuICAgICAgICAgICAgICAgICAgICBtaW5ZID0gcmVjdC55O1xuICAgICAgICAgICAgICAgICAgICBtYXhYID0gcmVjdC54ICsgcmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgbWF4WSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCByZWN0LngpO1xuICAgICAgICAgICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgcmVjdC55KTtcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHJlY3QueCArIHJlY3Qud2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHNlbGZSZWN0ID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBtaW5YLFxuICAgICAgICAgICAgICAgICAgICB5OiBtaW5ZLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogbWF4WCAtIG1pblgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogbWF4WSAtIG1pbllcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXNraXBUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtZWRSZWN0KHNlbGZSZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWxmUmVjdDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuQ29udGFpbmVyLCBLb252YS5Ob2RlKTtcbiAgICAvLyBkZXByZWNhdGVkIG1ldGhvZHNcbiAgICBLb252YS5Db250YWluZXIucHJvdG90eXBlLmdldCA9IEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuZmluZDtcblxuICAgIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuQ29udGFpbmVyLCAnY2xpcCcsIFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCddKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGNsaXBcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG5hbWUgY2xpcFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNsaXBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2xpcC54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNsaXAueVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjbGlwLndpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNsaXAuaGVpZ2h0XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjbGlwXG4gICAgICogdmFyIGNsaXAgPSBjb250YWluZXIuY2xpcCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGNsaXBcbiAgICAgKiBjb250YWluZXIuc2V0Q2xpcCh7XG4gICAgICogICB4OiAyMCxcbiAgICAgKiAgIHk6IDIwLFxuICAgICAqICAgd2lkdGg6IDIwLFxuICAgICAqICAgaGVpZ2h0OiAyMFxuICAgICAqIH0pO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQ29udGFpbmVyLCAnY2xpcFgnKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGNsaXAgeFxuICAgICAqIEBuYW1lIGNsaXBYXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNsaXAgeFxuICAgICAqIHZhciBjbGlwWCA9IGNvbnRhaW5lci5jbGlwWCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGNsaXAgeFxuICAgICAqIGNvbnRhaW5lci5jbGlwWCgxMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Db250YWluZXIsICdjbGlwWScpO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgY2xpcCB5XG4gICAgICogQG5hbWUgY2xpcFlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY2xpcCB5XG4gICAgICogdmFyIGNsaXBZID0gY29udGFpbmVyLmNsaXBZKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgY2xpcCB5XG4gICAgICogY29udGFpbmVyLmNsaXBZKDEwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkNvbnRhaW5lciwgJ2NsaXBXaWR0aCcpO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgY2xpcCB3aWR0aFxuICAgICAqIEBuYW1lIGNsaXBXaWR0aFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY2xpcCB3aWR0aFxuICAgICAqIHZhciBjbGlwV2lkdGggPSBjb250YWluZXIuY2xpcFdpZHRoKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgY2xpcCB3aWR0aFxuICAgICAqIGNvbnRhaW5lci5jbGlwV2lkdGgoMTAwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkNvbnRhaW5lciwgJ2NsaXBIZWlnaHQnKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGNsaXAgaGVpZ2h0XG4gICAgICogQG5hbWUgY2xpcEhlaWdodFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNsaXAgaGVpZ2h0XG4gICAgICogdmFyIGNsaXBIZWlnaHQgPSBjb250YWluZXIuY2xpcEhlaWdodCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGNsaXAgaGVpZ2h0XG4gICAgICogY29udGFpbmVyLmNsaXBIZWlnaHQoMTAwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5Db250YWluZXIpO1xufSkoKTtcblxuKGZ1bmN0aW9uKEtvbnZhKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBIQVNfU0hBRE9XID0gJ2hhc1NoYWRvdyc7XG4gICAgdmFyIFNIQURPV19SR0JBID0gJ3NoYWRvd1JHQkEnO1xuXG4gICAgZnVuY3Rpb24gX2ZpbGxGdW5jKGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9zdHJva2VGdW5jKGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2ZpbGxGdW5jSGl0KGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9zdHJva2VGdW5jSGl0KGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY2xlYXJIYXNTaGFkb3dDYWNoZSgpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJDYWNoZShIQVNfU0hBRE9XKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY2xlYXJHZXRTaGFkb3dSR0JBQ2FjaGUoKSB7XG4gICAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoU0hBRE9XX1JHQkEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNoYXBlIGNvbnN0cnVjdG9yLiAgU2hhcGVzIGFyZSBwcmltaXRpdmUgb2JqZWN0cyBzdWNoIGFzIHJlY3RhbmdsZXMsXG4gICAgICogIGNpcmNsZXMsIHRleHQsIGxpbmVzLCBldGMuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLk5vZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBjdXN0b21TaGFwZSA9IG5ldyBLb252YS5TaGFwZSh7XG4gICAgICAgICAqICAgeDogNSxcbiAgICAgICAgICogICB5OiAxMCxcbiAgICAgICAgICogICBmaWxsOiAncmVkJyxcbiAgICAgICAgICogICAvLyBhIEtvbnZhLkNhbnZhcyByZW5kZXJlciBpcyBwYXNzZWQgaW50byB0aGUgZHJhd0Z1bmMgZnVuY3Rpb25cbiAgICAgICAgICogICBkcmF3RnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgKiAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICogICAgIGNvbnRleHQubW92ZVRvKDIwMCwgNTApO1xuICAgICAgICAgKiAgICAgY29udGV4dC5saW5lVG8oNDIwLCA4MCk7XG4gICAgICAgICAqICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oMzAwLCAxMDAsIDI2MCwgMTcwKTtcbiAgICAgICAgICogICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAqICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgICogICB9XG4gICAgICAgICAqfSk7XG4gICAgICovXG4gICAgS29udmEuU2hhcGUgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX2luaXQoY29uZmlnKTtcbiAgICB9O1xuXG4gICAgS29udmEuVXRpbC5hZGRNZXRob2RzKEtvbnZhLlNoYXBlLCB7XG4gICAgICAgIF9faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVUeXBlID0gJ1NoYXBlJztcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxGdW5jID0gX2ZpbGxGdW5jO1xuICAgICAgICAgICAgdGhpcy5fc3Ryb2tlRnVuYyA9IF9zdHJva2VGdW5jO1xuICAgICAgICAgICAgdGhpcy5fZmlsbEZ1bmNIaXQgPSBfZmlsbEZ1bmNIaXQ7XG4gICAgICAgICAgICB0aGlzLl9zdHJva2VGdW5jSGl0ID0gX3N0cm9rZUZ1bmNIaXQ7XG5cbiAgICAgICAgICAgIC8vIHNldCBjb2xvcktleVxuICAgICAgICAgICAgdmFyIHNoYXBlcyA9IEtvbnZhLnNoYXBlcztcbiAgICAgICAgICAgIHZhciBrZXk7XG5cbiAgICAgICAgICAgIHdoaWxlKHRydWUpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBLb252YS5VdGlsLmdldFJhbmRvbUNvbG9yKCk7XG4gICAgICAgICAgICAgICAgaWYoa2V5ICYmICEoIGtleSBpbiBzaGFwZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jb2xvcktleSA9IGtleTtcbiAgICAgICAgICAgIHNoYXBlc1trZXldID0gdGhpcztcblxuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgS29udmEuTm9kZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG5cbiAgICAgICAgICAgIHRoaXMub24oJ3NoYWRvd0NvbG9yQ2hhbmdlLmtvbnZhIHNoYWRvd0JsdXJDaGFuZ2Uua29udmEgc2hhZG93T2Zmc2V0Q2hhbmdlLmtvbnZhIHNoYWRvd09wYWNpdHlDaGFuZ2Uua29udmEgc2hhZG93RW5hYmxlZENoYW5nZS5rb252YScsIF9jbGVhckhhc1NoYWRvd0NhY2hlKTtcblxuICAgICAgICAgICAgdGhpcy5vbignc2hhZG93Q29sb3JDaGFuZ2Uua29udmEgc2hhZG93T3BhY2l0eUNoYW5nZS5rb252YSBzaGFkb3dFbmFibGVkQ2hhbmdlLmtvbnZhJywgX2NsZWFyR2V0U2hhZG93UkdCQUNhY2hlKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBnZXRDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgY2FudmFzIGNvbnRleHQgdGllZCB0byB0aGUgbGF5ZXJcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Db250ZXh0fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29udGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXllcigpLmdldENvbnRleHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBjYW52YXMgcmVuZGVyZXIgdGllZCB0byB0aGUgbGF5ZXIuICBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIGEgY2FudmFzIHJlbmRlcmVyLCBub3QgYSBjYW52YXMgZWxlbWVudFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLkNhbnZhc31cbiAgICAgICAgICovXG4gICAgICAgIGdldENhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXllcigpLmdldENhbnZhcygpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhIHNoYWRvdyB3aWxsIGJlIHJlbmRlcmVkXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGhhc1NoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoSEFTX1NIQURPVywgdGhpcy5faGFzU2hhZG93KTtcbiAgICAgICAgfSxcbiAgICAgICAgX2hhc1NoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTaGFkb3dFbmFibGVkKCkgJiYgKHRoaXMuZ2V0U2hhZG93T3BhY2l0eSgpICE9PSAwICYmICEhKHRoaXMuZ2V0U2hhZG93Q29sb3IoKSB8fCB0aGlzLmdldFNoYWRvd0JsdXIoKSB8fCB0aGlzLmdldFNoYWRvd09mZnNldFgoKSB8fCB0aGlzLmdldFNoYWRvd09mZnNldFkoKSkpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRTaGFkb3dSR0JBOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZShTSEFET1dfUkdCQSwgdGhpcy5fZ2V0U2hhZG93UkdCQSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRTaGFkb3dSR0JBOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1NoYWRvdygpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJnYmEgPSBLb252YS5VdGlsLmNvbG9yVG9SR0JBKHRoaXMuc2hhZG93Q29sb3IoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdyZ2JhKCcgKyByZ2JhLnIgKyAnLCcgKyByZ2JhLmcgKyAnLCcgKyByZ2JhLmIgKyAnLCcgKyAocmdiYS5hICogKHRoaXMuZ2V0U2hhZG93T3BhY2l0eSgpIHx8IDEpKSArICcpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHNoYXBlIHdpbGwgYmUgZmlsbGVkXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGhhc0ZpbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhKHRoaXMuZ2V0RmlsbCgpIHx8IHRoaXMuZ2V0RmlsbFBhdHRlcm5JbWFnZSgpIHx8IHRoaXMuZ2V0RmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wcygpIHx8IHRoaXMuZ2V0RmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wcygpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHNoYXBlIHdpbGwgYmUgc3Ryb2tlZFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBoYXNTdHJva2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhKHRoaXMuc3Ryb2tlKCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZGV0ZXJtaW5lcyBpZiBwb2ludCBpcyBpbiB0aGUgc2hhcGUsIHJlZ2FyZGxlc3MgaWYgb3RoZXIgc2hhcGVzIGFyZSBvbiB0b3Agb2YgaXQuICBOb3RlOiBiZWNhdXNlXG4gICAgICAgICAqICB0aGlzIG1ldGhvZCBjbGVhcnMgYSB0ZW1wb3JhcnkgY2FudmFzIGFuZCB0aGVuIHJlZHJhd3MgdGhlIHNoYXBlLCBpdCBwZXJmb3JtcyB2ZXJ5IHBvb3JseSBpZiBleGVjdXRlZCBtYW55IHRpbWVzXG4gICAgICAgICAqICBjb25zZWN1dGl2ZWx5LiAgUGxlYXNlIHVzZSB0aGUge0BsaW5rIEtvbnZhLlN0YWdlI2dldEludGVyc2VjdGlvbn0gbWV0aG9kIGlmIGF0IGFsbCBwb3NzaWJsZVxuICAgICAgICAgKiAgYmVjYXVzZSBpdCBwZXJmb3JtcyBtdWNoIGJldHRlclxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludC54XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludC55XG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaW50ZXJzZWN0czogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKSxcbiAgICAgICAgICAgICAgICBidWZmZXJIaXRDYW52YXMgPSBzdGFnZS5idWZmZXJIaXRDYW52YXMsXG4gICAgICAgICAgICAgICAgcDtcblxuICAgICAgICAgICAgYnVmZmVySGl0Q2FudmFzLmdldENvbnRleHQoKS5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5kcmF3U2NlbmUoYnVmZmVySGl0Q2FudmFzKTtcbiAgICAgICAgICAgIHAgPSBidWZmZXJIaXRDYW52YXMuY29udGV4dC5nZXRJbWFnZURhdGEoTWF0aC5yb3VuZChwb2ludC54KSwgTWF0aC5yb3VuZChwb2ludC55KSwgMSwgMSkuZGF0YTtcbiAgICAgICAgICAgIHJldHVybiBwWzNdID4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZXh0ZW5kcyBOb2RlLnByb3RvdHlwZS5kZXN0cm95XG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgZGVsZXRlIEtvbnZhLnNoYXBlc1t0aGlzLmNvbG9yS2V5XTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBfdXNlQnVmZmVyQ2FudmFzOiBmdW5jdGlvbihjYWNoaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gIWNhY2hpbmcgJiYgKHRoaXMucGVyZmVjdERyYXdFbmFibGVkKCkgJiYgKHRoaXMuZ2V0QWJzb2x1dGVPcGFjaXR5KCkgIT09IDEpICYmIHRoaXMuaGFzRmlsbCgpICYmIHRoaXMuaGFzU3Ryb2tlKCkgJiYgdGhpcy5nZXRTdGFnZSgpKSB8fFxuICAgICAgICAgICAgICAgICAgICh0aGlzLnBlcmZlY3REcmF3RW5hYmxlZCgpICYmIHRoaXMuaGFzU2hhZG93KCkgJiYgKHRoaXMuZ2V0QWJzb2x1dGVPcGFjaXR5KCkgIT09IDEpICYmIHRoaXMuaGFzRmlsbCgpICYmIHRoaXMuaGFzU3Ryb2tlKCkgJiYgdGhpcy5nZXRTdGFnZSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJldHVybiBzZWxmIHJlY3RhbmdsZSAoeCwgeSwgd2lkdGgsIGhlaWdodCkgb2Ygc2hhcGUuXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGFyZSBub3QgdGFrZW4gaW50byBhY2NvdW50IHRyYW5zZm9ybWF0aW9uIGFuZCBzdHlsZXMuXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJlY3Qgd2l0aCB7eCwgeSwgd2lkdGgsIGhlaWdodH0gcHJvcGVydGllc1xuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiByZWN0LmdldFNlbGZSZWN0KCk7ICAvLyByZXR1cm4ge3g6MCwgeTowLCB3aWR0aDpyZWN0LndpZHRoKCksIGhlaWdodDpyZWN0LmhlaWdodCgpfVxuICAgICAgICAgKiBjaXJjbGUuZ2V0U2VsZlJlY3QoKTsgIC8vIHJldHVybiB7eDogLSBjaXJjbGUud2lkdGgoKSAvIDIsIHk6IC0gY2lyY2xlLmhlaWdodCgpIC8gMiwgd2lkdGg6Y2lyY2xlLndpZHRoKCksIGhlaWdodDpjaXJjbGUuaGVpZ2h0KCl9XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTZWxmUmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLl9jZW50cm9pZCA/IE1hdGgucm91bmQoLXNpemUud2lkdGggLyAyKSA6IDAsXG4gICAgICAgICAgICAgICAgeTogdGhpcy5fY2VudHJvaWQgPyBNYXRoLnJvdW5kKC1zaXplLmhlaWdodCAvIDIpIDogMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogc2l6ZS53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBnZXRDbGllbnRSZWN0OiBmdW5jdGlvbihza2lwVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB2YXIgZmlsbFJlY3QgPSB0aGlzLmdldFNlbGZSZWN0KCk7XG5cbiAgICAgICAgICAgIHZhciBzdHJva2VXaWR0aCA9ICh0aGlzLmhhc1N0cm9rZSgpICYmIHRoaXMuc3Ryb2tlV2lkdGgoKSkgfHwgMDtcbiAgICAgICAgICAgIHZhciBmaWxsQW5kU3Ryb2tlV2lkdGggPSBmaWxsUmVjdC53aWR0aCArIHN0cm9rZVdpZHRoO1xuICAgICAgICAgICAgdmFyIGZpbGxBbmRTdHJva2VIZWlnaHQgPSBmaWxsUmVjdC5oZWlnaHQgKyBzdHJva2VXaWR0aDtcblxuICAgICAgICAgICAgdmFyIHNoYWRvd09mZnNldFggPSB0aGlzLnNoYWRvd09mZnNldFgoKTtcbiAgICAgICAgICAgIHZhciBzaGFkb3dPZmZzZXRZID0gdGhpcy5zaGFkb3dPZmZzZXRZKCk7XG5cbiAgICAgICAgICAgIHZhciBwcmVXaWR0aCA9IGZpbGxBbmRTdHJva2VXaWR0aCArIE1hdGguYWJzKHNoYWRvd09mZnNldFgpO1xuICAgICAgICAgICAgdmFyIHByZUhlaWdodCA9IGZpbGxBbmRTdHJva2VIZWlnaHQgKyBNYXRoLmFicyhzaGFkb3dPZmZzZXRZKTtcblxuICAgICAgICAgICAgdmFyIGJsdXJSYWRpdXMgPSAodGhpcy5oYXNTaGFkb3coKSAmJiB0aGlzLnNoYWRvd0JsdXIoKSB8fCAwKTtcblxuICAgICAgICAgICAgdmFyIHdpZHRoID0gcHJlV2lkdGggKyBibHVyUmFkaXVzICogMjtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBwcmVIZWlnaHQgKyBibHVyUmFkaXVzICogMjtcblxuICAgICAgICAgICAgLy8gaWYgc3Ryb2tlLCBmb3IgZXhhbXBsZSA9IDNcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gc2V0IHggdG8gMS41LCBidXQgYWZ0ZXIgTWF0aC5yb3VuZCBpdCB3aWxsIGJlIDJcbiAgICAgICAgICAgIC8vIGFzIHdlIGhhdmUgYWRkaXRpb25hbCBvZmZzZXQgd2UgbmVlZCB0byBpbmNyZWFzZSB3aWR0aCBhbmQgaGVpZ2h0IGJ5IDEgcGl4ZWxcbiAgICAgICAgICAgIHZhciByb3VuZGluZ09mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAoTWF0aC5yb3VuZChzdHJva2VXaWR0aCAvIDIpICE9PSBzdHJva2VXaWR0aCAvIDIpIHtcbiAgICAgICAgICAgICAgICByb3VuZGluZ09mZnNldCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGggKyByb3VuZGluZ09mZnNldCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCArIHJvdW5kaW5nT2Zmc2V0LFxuICAgICAgICAgICAgICAgIHg6IC1NYXRoLnJvdW5kKHN0cm9rZVdpZHRoIC8gMiArIGJsdXJSYWRpdXMpICsgTWF0aC5taW4oc2hhZG93T2Zmc2V0WCwgMCkgKyBmaWxsUmVjdC54LFxuICAgICAgICAgICAgICAgIHk6IC1NYXRoLnJvdW5kKHN0cm9rZVdpZHRoIC8gMiArIGJsdXJSYWRpdXMpICsgTWF0aC5taW4oc2hhZG93T2Zmc2V0WSwgMCkgKyBmaWxsUmVjdC55XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFza2lwVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybWVkUmVjdChyZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICB9LFxuICAgICAgICBkcmF3U2NlbmU6IGZ1bmN0aW9uKGNhbiwgdG9wLCBjYWNoaW5nLCBza2lwQnVmZmVyKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksXG4gICAgICAgICAgICAgICAgY2FudmFzID0gY2FuIHx8IGxheWVyLmdldENhbnZhcygpLFxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgpLFxuICAgICAgICAgICAgICAgIGNhY2hlZENhbnZhcyA9IHRoaXMuX2NhY2hlLmNhbnZhcyxcbiAgICAgICAgICAgICAgICBkcmF3RnVuYyA9IHRoaXMuc2NlbmVGdW5jKCksXG4gICAgICAgICAgICAgICAgaGFzU2hhZG93ID0gdGhpcy5oYXNTaGFkb3coKSxcbiAgICAgICAgICAgICAgICBoYXNTdHJva2UgPSB0aGlzLmhhc1N0cm9rZSgpLFxuICAgICAgICAgICAgICAgIHN0YWdlLCBidWZmZXJDYW52YXMsIGJ1ZmZlckNvbnRleHQ7XG5cbiAgICAgICAgICAgIGlmKCF0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FjaGVkQ2FudmFzKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgbGF5ZXIuX2FwcGx5VHJhbnNmb3JtKHRoaXMsIGNvbnRleHQsIHRvcCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhd0NhY2hlZFNjZW5lQ2FudmFzKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkcmF3RnVuYykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICAvLyBpZiBidWZmZXIgY2FudmFzIGlzIG5lZWRlZFxuICAgICAgICAgICAgaWYgKHRoaXMuX3VzZUJ1ZmZlckNhbnZhcyhjYWNoaW5nKSAmJiAhc2tpcEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlckNhbnZhcyA9IHN0YWdlLmJ1ZmZlckNhbnZhcztcbiAgICAgICAgICAgICAgICBidWZmZXJDb250ZXh0ID0gYnVmZmVyQ2FudmFzLmdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICBidWZmZXJDb250ZXh0LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgYnVmZmVyQ29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgYnVmZmVyQ29udGV4dC5fYXBwbHlMaW5lSm9pbih0aGlzKTtcbiAgICAgICAgICAgICAgICAvLyBsYXllciBtaWdodCBiZSB1bmRlZmluZWQgaWYgd2UgYXJlIHVzaW5nIGNhY2hlIGJlZm9yZSBhZGRpbmcgdG8gbGF5ZXJcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllci5fYXBwbHlUcmFuc2Zvcm0odGhpcywgYnVmZmVyQ29udGV4dCwgdG9wKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gdGhpcy5nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApLmdldE1hdHJpeCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC50cmFuc2Zvcm0obVswXSwgbVsxXSwgbVsyXSwgbVszXSwgbVs0XSwgbVs1XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkcmF3RnVuYy5jYWxsKHRoaXMsIGJ1ZmZlckNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlckNvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhc1NoYWRvdyAmJiAhY2FudmFzLmhpdENhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Ll9hcHBseVNoYWRvdyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5T3BhY2l0eSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGJ1ZmZlckNhbnZhcy5fY2FudmFzLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5T3BhY2l0eSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoYnVmZmVyQ2FudmFzLl9jYW52YXMsIDAsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGJ1ZmZlciBjYW52YXMgaXMgbm90IG5lZWRlZFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5fYXBwbHlMaW5lSm9pbih0aGlzKTtcbiAgICAgICAgICAgICAgICAvLyBsYXllciBtaWdodCBiZSB1bmRlZmluZWQgaWYgd2UgYXJlIHVzaW5nIGNhY2hlIGJlZm9yZSBhZGRpbmcgdG8gbGF5ZXJcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllci5fYXBwbHlUcmFuc2Zvcm0odGhpcywgY29udGV4dCwgdG9wKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gdGhpcy5nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApLmdldE1hdHJpeCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC50cmFuc2Zvcm0ob1swXSwgb1sxXSwgb1syXSwgb1szXSwgb1s0XSwgb1s1XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzU2hhZG93ICYmIGhhc1N0cm9rZSAmJiAhY2FudmFzLmhpdENhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwbHkgc2hhZG93XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FjaGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5fYXBwbHlPcGFjaXR5KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5U2hhZG93KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBkcmF3RnVuYy5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgc2hhcGUgaGFzIHN0cm9rZSB3ZSBuZWVkIHRvIHJlZHJhdyBzaGFwZVxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCBzZWUgYSBzaGFkb3cgdW5kZXIgc3Ryb2tlIChhbmQgb3ZlciBmaWxsKVxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgSSB0aGluayB0aGlzIGlzIHVuZXhwZWN0ZWQgYmVoYXZpb3JcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzRmlsbCgpICYmIHRoaXMuZ2V0U2hhZG93Rm9yU3Ryb2tlRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3RnVuYy5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNTaGFkb3cgJiYgIWNhbnZhcy5oaXRDYW52YXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FjaGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5fYXBwbHlPcGFjaXR5KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5U2hhZG93KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBkcmF3RnVuYy5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhY2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5T3BhY2l0eSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkcmF3RnVuYy5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYXdIaXQ6IGZ1bmN0aW9uKGNhbiwgdG9wLCBjYWNoaW5nKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksXG4gICAgICAgICAgICAgICAgY2FudmFzID0gY2FuIHx8IGxheWVyLmhpdENhbnZhcyxcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoKSxcbiAgICAgICAgICAgICAgICBkcmF3RnVuYyA9IHRoaXMuaGl0RnVuYygpIHx8IHRoaXMuc2NlbmVGdW5jKCksXG4gICAgICAgICAgICAgICAgY2FjaGVkQ2FudmFzID0gdGhpcy5fY2FjaGUuY2FudmFzLFxuICAgICAgICAgICAgICAgIGNhY2hlZEhpdENhbnZhcyA9IGNhY2hlZENhbnZhcyAmJiBjYWNoZWRDYW52YXMuaGl0O1xuXG4gICAgICAgICAgICBpZighdGhpcy5zaG91bGREcmF3SGl0KGNhbnZhcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgICAgICAgIGxheWVyLmNsZWFySGl0Q2FjaGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWNoZWRIaXRDYW52YXMpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBsYXllci5fYXBwbHlUcmFuc2Zvcm0odGhpcywgY29udGV4dCwgdG9wKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmF3Q2FjaGVkSGl0Q2FudmFzKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkcmF3RnVuYykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICBjb250ZXh0Ll9hcHBseUxpbmVKb2luKHRoaXMpO1xuICAgICAgICAgICAgaWYgKCFjYWNoaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9hcHBseVRyYW5zZm9ybSh0aGlzLCBjb250ZXh0LCB0b3ApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvID0gdGhpcy5nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApLmdldE1hdHJpeCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zZm9ybShvWzBdLCBvWzFdLCBvWzJdLCBvWzNdLCBvWzRdLCBvWzVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkcmF3RnVuYy5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogZHJhdyBoaXQgZ3JhcGggdXNpbmcgdGhlIGNhY2hlZCBzY2VuZSBjYW52YXNcbiAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gYWxwaGFUaHJlc2hvbGQgYWxwaGEgY2hhbm5lbCB0aHJlc2hvbGQgdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90XG4gICAgICAgICogIGEgcGl4ZWwgc2hvdWxkIGJlIGRyYXduIG9udG8gdGhlIGhpdCBncmFwaC4gIE11c3QgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NS5cbiAgICAgICAgKiAgVGhlIGRlZmF1bHQgaXMgMFxuICAgICAgICAqIEByZXR1cm5zIHtLb252YS5TaGFwZX1cbiAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAqIHNoYXBlLmNhY2hlKCk7XG4gICAgICAgICogc2hhcGUuZHJhd0hpdEZyb21DYWNoZSgpO1xuICAgICAgICAqL1xuICAgICAgICBkcmF3SGl0RnJvbUNhY2hlOiBmdW5jdGlvbihhbHBoYVRocmVzaG9sZCkge1xuICAgICAgICAgICAgdmFyIHRocmVzaG9sZCA9IGFscGhhVGhyZXNob2xkIHx8IDAsXG4gICAgICAgICAgICAgICAgY2FjaGVkQ2FudmFzID0gdGhpcy5fY2FjaGUuY2FudmFzLFxuICAgICAgICAgICAgICAgIHNjZW5lQ2FudmFzID0gdGhpcy5fZ2V0Q2FjaGVkU2NlbmVDYW52YXMoKSxcbiAgICAgICAgICAgICAgICBoaXRDYW52YXMgPSBjYWNoZWRDYW52YXMuaGl0LFxuICAgICAgICAgICAgICAgIGhpdENvbnRleHQgPSBoaXRDYW52YXMuZ2V0Q29udGV4dCgpLFxuICAgICAgICAgICAgICAgIGhpdFdpZHRoID0gaGl0Q2FudmFzLmdldFdpZHRoKCksXG4gICAgICAgICAgICAgICAgaGl0SGVpZ2h0ID0gaGl0Q2FudmFzLmdldEhlaWdodCgpLFxuICAgICAgICAgICAgICAgIGhpdEltYWdlRGF0YSwgaGl0RGF0YSwgbGVuLCByZ2JDb2xvcktleSwgaSwgYWxwaGE7XG5cbiAgICAgICAgICAgIGhpdENvbnRleHQuY2xlYXIoKTtcbiAgICAgICAgICAgIGhpdENvbnRleHQuZHJhd0ltYWdlKHNjZW5lQ2FudmFzLl9jYW52YXMsIDAsIDAsIGhpdFdpZHRoLCBoaXRIZWlnaHQpO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGhpdEltYWdlRGF0YSA9IGhpdENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGhpdFdpZHRoLCBoaXRIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGhpdERhdGEgPSBoaXRJbWFnZURhdGEuZGF0YTtcbiAgICAgICAgICAgICAgICBsZW4gPSBoaXREYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZ2JDb2xvcktleSA9IEtvbnZhLlV0aWwuX2hleFRvUmdiKHRoaXMuY29sb3JLZXkpO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBub24gdHJhbnNwYXJlbnQgcGl4ZWxzIHdpdGggY29sb3Iga2V5XG4gICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBoaXREYXRhW2kgKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXREYXRhW2ldID0gcmdiQ29sb3JLZXkucjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdERhdGFbaSArIDFdID0gcmdiQ29sb3JLZXkuZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdERhdGFbaSArIDJdID0gcmdiQ29sb3JLZXkuYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdERhdGFbaSArIDNdID0gMjU1O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGl0RGF0YVtpICsgM10gPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhpdENvbnRleHQucHV0SW1hZ2VEYXRhKGhpdEltYWdlRGF0YSwgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC5lcnJvcignVW5hYmxlIHRvIGRyYXcgaGl0IGdyYXBoIGZyb20gY2FjaGVkIHNjZW5lIGNhbnZhcy4gJyArIGUubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuU2hhcGUsIEtvbnZhLk5vZGUpO1xuXG4gICAgLy8gYWRkIGdldHRlcnMgYW5kIHNldHRlcnNcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3N0cm9rZScpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBzdHJva2UgY29sb3JcbiAgICAgKiBAbmFtZSBzdHJva2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc3Ryb2tlIGNvbG9yXG4gICAgICogdmFyIHN0cm9rZSA9IHNoYXBlLnN0cm9rZSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHN0cm9rZSBjb2xvciB3aXRoIGNvbG9yIHN0cmluZ1xuICAgICAqIHNoYXBlLnN0cm9rZSgnZ3JlZW4nKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzdHJva2UgY29sb3Igd2l0aCBoZXhcbiAgICAgKiBzaGFwZS5zdHJva2UoJyMwMGZmMDAnKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzdHJva2UgY29sb3Igd2l0aCByZ2JcbiAgICAgKiBzaGFwZS5zdHJva2UoJ3JnYigwLDI1NSwwKScpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHN0cm9rZSBjb2xvciB3aXRoIHJnYmEgYW5kIG1ha2UgaXQgNTAlIG9wYXF1ZVxuICAgICAqIHNoYXBlLnN0cm9rZSgncmdiYSgwLDI1NSwwLDAuNScpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc3Ryb2tlUmVkJywgMCwgS29udmEuVmFsaWRhdG9ycy5SR0JDb21wb25lbnQpO1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkRGVwcmVjYXRlZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3N0cm9rZUdyZWVuJywgMCwgS29udmEuVmFsaWRhdG9ycy5SR0JDb21wb25lbnQpO1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkRGVwcmVjYXRlZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3N0cm9rZUJsdWUnLCAwLCBLb252YS5WYWxpZGF0b3JzLlJHQkNvbXBvbmVudCk7XG4gICAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc3Ryb2tlQWxwaGEnLCAxLCBLb252YS5WYWxpZGF0b3JzLmFscGhhQ29tcG9uZW50KTtcblxuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzdHJva2VXaWR0aCcsIDIpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBzdHJva2Ugd2lkdGhcbiAgICAgKiBAbmFtZSBzdHJva2VXaWR0aFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0cm9rZVdpZHRoXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzdHJva2Ugd2lkdGhcbiAgICAgKiB2YXIgc3Ryb2tlV2lkdGggPSBzaGFwZS5zdHJva2VXaWR0aCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHN0cm9rZSB3aWR0aFxuICAgICAqIHNoYXBlLnN0cm9rZVdpZHRoKCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3N0cm9rZUhpdEVuYWJsZWQnLCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgc3Ryb2tlSGl0RW5hYmxlZCBwcm9wZXJ0eS4gVXNlZnVsIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gICAgICogWW91IG1heSBzZXQgYHNoYXBlLnN0cm9rZUhpdEVuYWJsZWQoZmFsc2UpYC4gSW4gdGhpcyBjYXNlIHN0cm9rZSB3aWxsIGJlIG5vIGRyYXcgb24gaGl0IGNhbnZhcywgc28gaGl0IGFyZWFcbiAgICAgKiBvZiBzaGFwZSB3aWxsIGJlIGRlY3JlYXNlZCAoYnkgbGluZVdpZHRoIC8gMikuIFJlbWVtYmVyIHRoYXQgbm9uIGNsb3NlZCBsaW5lIHdpdGggYHN0cm9rZUhpdEVuYWJsZWQgPSBmYWxzZWBcbiAgICAgKiB3aWxsIGJlIG5vdCBkcmF3biBvbiBoaXQgY2FudmFzLCB0aGF0IGlzIG1lYW4gbGluZSB3aWxsIG5vIHRyaWdnZXIgcG9pbnRlciBldmVudHMgKGxpa2UgbW91c2VvdmVyKVxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBuYW1lIHN0cm9rZUhpdEVuYWJsZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3Ryb2tlSGl0RW5hYmxlZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHN0cm9rZUhpdEVuYWJsZWRcbiAgICAgKiB2YXIgc3Ryb2tlSGl0RW5hYmxlZCA9IHNoYXBlLnN0cm9rZUhpdEVuYWJsZWQoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzdHJva2VIaXRFbmFibGVkXG4gICAgICogc2hhcGUuc3Ryb2tlSGl0RW5hYmxlZCgpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdwZXJmZWN0RHJhd0VuYWJsZWQnLCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgcGVyZmVjdERyYXdFbmFibGVkLiBJZiBhIHNoYXBlIGhhcyBmaWxsLCBzdHJva2UgYW5kIG9wYWNpdHkgeW91IG1heSBzZXQgYHBlcmZlY3REcmF3RW5hYmxlZGAgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAgICAgKiBTZWUgaHR0cDovL2tvbnZhanMuZ2l0aHViLmlvL2RvY3MvcGVyZm9ybWFuY2UvRGlzYWJsZV9QZXJmZWN0X0RyYXcuaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAbmFtZSBwZXJmZWN0RHJhd0VuYWJsZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGVyZmVjdERyYXdFbmFibGVkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgcGVyZmVjdERyYXdFbmFibGVkXG4gICAgICogdmFyIHBlcmZlY3REcmF3RW5hYmxlZCA9IHNoYXBlLnBlcmZlY3REcmF3RW5hYmxlZCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHBlcmZlY3REcmF3RW5hYmxlZFxuICAgICAqIHNoYXBlLnBlcmZlY3REcmF3RW5hYmxlZCgpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dGb3JTdHJva2VFbmFibGVkJywgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHNoYWRvd0ZvclN0cm9rZUVuYWJsZWQuIFVzZWZ1bCBmb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLlxuICAgICAqIFlvdSBtYXkgc2V0IGBzaGFwZS5zaGFkb3dGb3JTdHJva2VFbmFibGVkKGZhbHNlKWAuIEluIHRoaXMgY2FzZSBzdHJva2Ugd2lsbCBiZSBubyBkcmF3IHNoYWRvdyBmb3Igc3Ryb2tlLlxuICAgICAqIFJlbWVtYmVyIGlmIHlvdSBzZXQgYHNoYWRvd0ZvclN0cm9rZUVuYWJsZWQgPSBmYWxzZWAgZm9yIG5vbiBjbG9zZWQgbGluZSAtIHRoYXQgbGluZSB3aXRoIGhhdmUgbm8gc2hhZG93IS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAbmFtZSBzaGFkb3dGb3JTdHJva2VFbmFibGVkXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNoYWRvd0ZvclN0cm9rZUVuYWJsZWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzaGFkb3dGb3JTdHJva2VFbmFibGVkXG4gICAgICogdmFyIHNoYWRvd0ZvclN0cm9rZUVuYWJsZWQgPSBzaGFwZS5zaGFkb3dGb3JTdHJva2VFbmFibGVkKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZFxuICAgICAqIHNoYXBlLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWQoKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnbGluZUpvaW4nKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgbGluZSBqb2luLiAgQ2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGVcbiAgICAgKiAgZGVmYXVsdCBpcyBtaXRlclxuICAgICAqIEBuYW1lIGxpbmVKb2luXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZUpvaW5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGxpbmUgam9pblxuICAgICAqIHZhciBsaW5lSm9pbiA9IHNoYXBlLmxpbmVKb2luKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgbGluZSBqb2luXG4gICAgICogc2hhcGUubGluZUpvaW4oJ3JvdW5kJyk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2xpbmVDYXAnKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgbGluZSBjYXAuICBDYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxdWFyZVxuICAgICAqIEBuYW1lIGxpbmVDYXBcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lQ2FwXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBsaW5lIGNhcFxuICAgICAqIHZhciBsaW5lQ2FwID0gc2hhcGUubGluZUNhcCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGxpbmUgY2FwXG4gICAgICogc2hhcGUubGluZUNhcCgncm91bmQnKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2NlbmVGdW5jJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHNjZW5lIGRyYXcgZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBzY2VuZUZ1bmNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYXdGdW5jIGRyYXdpbmcgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc2NlbmUgZHJhdyBmdW5jdGlvblxuICAgICAqIHZhciBzY2VuZUZ1bmMgPSBzaGFwZS5zY2VuZUZ1bmMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzY2VuZSBkcmF3IGZ1bmN0aW9uXG4gICAgICogc2hhcGUuc2NlbmVGdW5jKGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgKiAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICogICBjb250ZXh0LnJlY3QoMCwgMCwgdGhpcy53aWR0aCgpLCB0aGlzLmhlaWdodCgpKTtcbiAgICAgKiAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICogICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnaGl0RnVuYycpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBoaXQgZHJhdyBmdW5jdGlvblxuICAgICAqIEBuYW1lIGhpdEZ1bmNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYXdGdW5jIGRyYXdpbmcgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgaGl0IGRyYXcgZnVuY3Rpb25cbiAgICAgKiB2YXIgaGl0RnVuYyA9IHNoYXBlLmhpdEZ1bmMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBoaXQgZHJhdyBmdW5jdGlvblxuICAgICAqIHNoYXBlLmhpdEZ1bmMoZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAqICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgKiAgIGNvbnRleHQucmVjdCgwLCAwLCB0aGlzLndpZHRoKCksIHRoaXMuaGVpZ2h0KCkpO1xuICAgICAqICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgKiAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAqIH0pO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdkYXNoJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGRhc2ggYXJyYXkgZm9yIHN0cm9rZS5cbiAgICAgKiBAbmFtZSBkYXNoXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXNoXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogIC8vIGFwcGx5IGRhc2hlZCBzdHJva2UgdGhhdCBpcyAxMHB4IGxvbmcgYW5kIDUgcGl4ZWxzIGFwYXJ0XG4gICAgICogIGxpbmUuZGFzaChbMTAsIDVdKTtcbiAgICAgKiAgLy8gYXBwbHkgZGFzaGVkIHN0cm9rZSB0aGF0IGlzIG1hZGUgdXAgb2YgYWx0ZXJuYXRpbmcgZGFzaGVkXG4gICAgICogIC8vIGxpbmVzIHRoYXQgYXJlIDEwcHggbG9uZyBhbmQgMjBweCBhcGFydCwgYW5kIGRvdHMgdGhhdCBoYXZlXG4gICAgICogIC8vIGEgcmFkaXVzIG9mIDVweCBhbmQgYXJlIDIwcHggYXBhcnRcbiAgICAgKiAgbGluZS5kYXNoKFsxMCwgMjAsIDAuMDAxLCAyMF0pO1xuICAgICAqL1xuXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3NoYWRvd0NvbG9yJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHNoYWRvdyBjb2xvclxuICAgICAqIEBuYW1lIHNoYWRvd0NvbG9yXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3JcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHNoYWRvdyBjb2xvclxuICAgICAqIHZhciBzaGFkb3cgPSBzaGFwZS5zaGFkb3dDb2xvcigpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNoYWRvdyBjb2xvciB3aXRoIGNvbG9yIHN0cmluZ1xuICAgICAqIHNoYXBlLnNoYWRvd0NvbG9yKCdncmVlbicpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNoYWRvdyBjb2xvciB3aXRoIGhleFxuICAgICAqIHNoYXBlLnNoYWRvd0NvbG9yKCcjMDBmZjAwJyk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc2hhZG93IGNvbG9yIHdpdGggcmdiXG4gICAgICogc2hhcGUuc2hhZG93Q29sb3IoJ3JnYigwLDI1NSwwKScpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNoYWRvdyBjb2xvciB3aXRoIHJnYmEgYW5kIG1ha2UgaXQgNTAlIG9wYXF1ZVxuICAgICAqIHNoYXBlLnNoYWRvd0NvbG9yKCdyZ2JhKDAsMjU1LDAsMC41Jyk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZERlcHJlY2F0ZWRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dSZWQnLCAwLCBLb252YS5WYWxpZGF0b3JzLlJHQkNvbXBvbmVudCk7XG4gICAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93R3JlZW4nLCAwLCBLb252YS5WYWxpZGF0b3JzLlJHQkNvbXBvbmVudCk7XG4gICAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93Qmx1ZScsIDAsIEtvbnZhLlZhbGlkYXRvcnMuUkdCQ29tcG9uZW50KTtcbiAgICBLb252YS5GYWN0b3J5LmFkZERlcHJlY2F0ZWRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dBbHBoYScsIDEsIEtvbnZhLlZhbGlkYXRvcnMuYWxwaGFDb21wb25lbnQpO1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dCbHVyJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHNoYWRvdyBibHVyXG4gICAgICogQG5hbWUgc2hhZG93Qmx1clxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGJsdXJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHNoYWRvdyBibHVyXG4gICAgICogdmFyIHNoYWRvd0JsdXIgPSBzaGFwZS5zaGFkb3dCbHVyKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc2hhZG93IGJsdXJcbiAgICAgKiBzaGFwZS5zaGFkb3dCbHVyKDEwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93T3BhY2l0eScpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBzaGFkb3cgb3BhY2l0eS4gIG11c3QgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAbmFtZSBzaGFkb3dPcGFjaXR5XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3BhY2l0eVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc2hhZG93IG9wYWNpdHlcbiAgICAgKiB2YXIgc2hhZG93T3BhY2l0eSA9IHNoYXBlLnNoYWRvd09wYWNpdHkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzaGFkb3cgb3BhY2l0eVxuICAgICAqIHNoYXBlLnNoYWRvd09wYWNpdHkoMC41KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3NoYWRvd09mZnNldCcsIFsneCcsICd5J10pO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBzaGFkb3cgb2Zmc2V0XG4gICAgICogQG5hbWUgc2hhZG93T2Zmc2V0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2Zmc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldC54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldC55XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzaGFkb3cgb2Zmc2V0XG4gICAgICogdmFyIHNoYWRvd09mZnNldCA9IHNoYXBlLnNoYWRvd09mZnNldCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNoYWRvdyBvZmZzZXRcbiAgICAgKiBzaGFwZS5zaGFkb3dPZmZzZXQoe1xuICAgICAqICAgeDogMjBcbiAgICAgKiAgIHk6IDEwXG4gICAgICogfSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3NoYWRvd09mZnNldFgnLCAwKTtcblxuICAgICAvKipcbiAgICAgKiBnZXQvc2V0IHNoYWRvdyBvZmZzZXQgeFxuICAgICAqIEBuYW1lIHNoYWRvd09mZnNldFhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzaGFkb3cgb2Zmc2V0IHhcbiAgICAgKiB2YXIgc2hhZG93T2Zmc2V0WCA9IHNoYXBlLnNoYWRvd09mZnNldFgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzaGFkb3cgb2Zmc2V0IHhcbiAgICAgKiBzaGFwZS5zaGFkb3dPZmZzZXRYKDUpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dPZmZzZXRZJywgMCk7XG5cbiAgICAgLyoqXG4gICAgICogZ2V0L3NldCBzaGFkb3cgb2Zmc2V0IHlcbiAgICAgKiBAbmFtZSBzaGFkb3dPZmZzZXRZXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc2hhZG93IG9mZnNldCB5XG4gICAgICogdmFyIHNoYWRvd09mZnNldFkgPSBzaGFwZS5zaGFkb3dPZmZzZXRZKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc2hhZG93IG9mZnNldCB5XG4gICAgICogc2hhcGUuc2hhZG93T2Zmc2V0WSg1KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5JbWFnZScpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAbmFtZSBmaWxsUGF0dGVybkltYWdlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2V9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogdmFyIGZpbGxQYXR0ZXJuSW1hZ2UgPSBzaGFwZS5maWxsUGF0dGVybkltYWdlKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogdmFyIGltYWdlT2JqID0gbmV3IEltYWdlKCk7XG4gICAgICogaW1hZ2VPYmoub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICogICBzaGFwZS5maWxsUGF0dGVybkltYWdlKGltYWdlT2JqKTtcbiAgICAgKiB9O1xuICAgICAqIGltYWdlT2JqLnNyYyA9ICdwYXRoL3RvL2ltYWdlL2pwZyc7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGwnKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCBjb2xvclxuICAgICAqIEBuYW1lIGZpbGxcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBjb2xvclxuICAgICAqIHZhciBmaWxsID0gc2hhcGUuZmlsbCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgY29sb3Igd2l0aCBjb2xvciBzdHJpbmdcbiAgICAgKiBzaGFwZS5maWxsKCdncmVlbicpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgY29sb3Igd2l0aCBoZXhcbiAgICAgKiBzaGFwZS5maWxsKCcjMDBmZjAwJyk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBjb2xvciB3aXRoIHJnYlxuICAgICAqIHNoYXBlLmZpbGwoJ3JnYigwLDI1NSwwKScpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgY29sb3Igd2l0aCByZ2JhIGFuZCBtYWtlIGl0IDUwJSBvcGFxdWVcbiAgICAgKiBzaGFwZS5maWxsKCdyZ2JhKDAsMjU1LDAsMC41Jyk7XG4gICAgICpcbiAgICAgKiAvLyBzaGFwZSB3aXRob3V0IGZpbGxcbiAgICAgKiBzaGFwZS5maWxsKG51bGwpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFJlZCcsIDAsIEtvbnZhLlZhbGlkYXRvcnMuUkdCQ29tcG9uZW50KTtcbiAgICBLb252YS5GYWN0b3J5LmFkZERlcHJlY2F0ZWRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsR3JlZW4nLCAwLCBLb252YS5WYWxpZGF0b3JzLlJHQkNvbXBvbmVudCk7XG4gICAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbEJsdWUnLCAwLCBLb252YS5WYWxpZGF0b3JzLlJHQkNvbXBvbmVudCk7XG4gICAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbEFscGhhJywgMSwgS29udmEuVmFsaWRhdG9ycy5hbHBoYUNvbXBvbmVudCk7XG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQYXR0ZXJuWCcsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4geFxuICAgICAqIEBuYW1lIGZpbGxQYXR0ZXJuWFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiB4XG4gICAgICogdmFyIGZpbGxQYXR0ZXJuWCA9IHNoYXBlLmZpbGxQYXR0ZXJuWCgpO1xuICAgICAqIC8vIHNldCBmaWxsIHBhdHRlcm4geFxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuWCgyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQYXR0ZXJuWScsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4geVxuICAgICAqIEBuYW1lIGZpbGxQYXR0ZXJuWVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiB5XG4gICAgICogdmFyIGZpbGxQYXR0ZXJuWSA9IHNoYXBlLmZpbGxQYXR0ZXJuWSgpO1xuICAgICAqIC8vIHNldCBmaWxsIHBhdHRlcm4geVxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuWSgyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMnKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgY29sb3Igc3RvcHNcbiAgICAgKiBAbmFtZSBmaWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb2xvclN0b3BzXG4gICAgICogQHJldHVybnMge0FycmF5fSBjb2xvclN0b3BzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgY29sb3Igc3RvcHNcbiAgICAgKiB2YXIgY29sb3JTdG9wcyA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMoKTtcbiAgICAgKlxuICAgICAqIC8vIGNyZWF0ZSBhIGxpbmVhciBncmFkaWVudCB0aGF0IHN0YXJ0cyB3aXRoIHJlZCwgY2hhbmdlcyB0byBibHVlXG4gICAgICogLy8gaGFsZndheSB0aHJvdWdoLCBhbmQgdGhlbiBjaGFuZ2VzIHRvIGdyZWVuXG4gICAgICogc2hhcGUuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wcygwLCAncmVkJywgMC41LCAnYmx1ZScsIDEsICdncmVlbicpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1cycsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCByYWRpdXNcbiAgICAgKiBAbmFtZSBmaWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHJhZGl1c1xuICAgICAqIHZhciBzdGFydFJhZGl1cyA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHJhZGl1c1xuICAgICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzKDApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXMnLCAwKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgZW5kIHJhZGl1c1xuICAgICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgcmFkaWFsIGdyYWRpZW50IGVuZCByYWRpdXNcbiAgICAgKiB2YXIgZW5kUmFkaXVzID0gc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgcmFkaWFsIGdyYWRpZW50IGVuZCByYWRpdXNcbiAgICAgKiBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXMoMTAwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wcycpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBjb2xvciBzdG9wc1xuICAgICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb2xvclN0b3BzXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGNvbG9yIHN0b3BzXG4gICAgICogdmFyIGNvbG9yU3RvcHMgPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzKCk7XG4gICAgICpcbiAgICAgKiAvLyBjcmVhdGUgYSByYWRpYWwgZ3JhZGllbnQgdGhhdCBzdGFydHMgd2l0aCByZWQsIGNoYW5nZXMgdG8gYmx1ZVxuICAgICAqIC8vIGhhbGZ3YXkgdGhyb3VnaCwgYW5kIHRoZW4gY2hhbmdlcyB0byBncmVlblxuICAgICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMoMCwgJ3JlZCcsIDAuNSwgJ2JsdWUnLCAxLCAnZ3JlZW4nKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5SZXBlYXQnLCAncmVwZWF0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiByZXBlYXQuICBDYW4gYmUgJ3JlcGVhdCcsICdyZXBlYXQteCcsICdyZXBlYXQteScsIG9yICduby1yZXBlYXQnLiAgVGhlIGRlZmF1bHQgaXMgJ3JlcGVhdCdcbiAgICAgKiBAbmFtZSBmaWxsUGF0dGVyblJlcGVhdFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcGVhdFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIHJlcGVhdFxuICAgICAqIHZhciByZXBlYXQgPSBzaGFwZS5maWxsUGF0dGVyblJlcGVhdCgpO1xuICAgICAqXG4gICAgICogLy8gcmVwZWF0IHBhdHRlcm4gaW4geCBkaXJlY3Rpb24gb25seVxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuUmVwZWF0KCdyZXBlYXQteCcpO1xuICAgICAqXG4gICAgICogLy8gZG8gbm90IHJlcGVhdCB0aGUgcGF0dGVyblxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuUmVwZWF0KCdubyByZXBlYXQnKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbEVuYWJsZWQnLCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCBlbmFibGVkIGZsYWdcbiAgICAgKiBAbmFtZSBmaWxsRW5hYmxlZFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBlbmFibGVkIGZsYWdcbiAgICAgKiB2YXIgZmlsbEVuYWJsZWQgPSBzaGFwZS5maWxsRW5hYmxlZCgpO1xuICAgICAqXG4gICAgICogLy8gZGlzYWJsZSBmaWxsXG4gICAgICogc2hhcGUuZmlsbEVuYWJsZWQoZmFsc2UpO1xuICAgICAqXG4gICAgICogLy8gZW5hYmxlIGZpbGxcbiAgICAgKiBzaGFwZS5maWxsRW5hYmxlZCh0cnVlKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc3Ryb2tlRW5hYmxlZCcsIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBzdHJva2UgZW5hYmxlZCBmbGFnXG4gICAgICogQG5hbWUgc3Ryb2tlRW5hYmxlZFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc3Ryb2tlIGVuYWJsZWQgZmxhZ1xuICAgICAqIHZhciBzdHJva2VFbmFibGVkID0gc2hhcGUuc3Ryb2tlRW5hYmxlZCgpO1xuICAgICAqXG4gICAgICogLy8gZGlzYWJsZSBzdHJva2VcbiAgICAgKiBzaGFwZS5zdHJva2VFbmFibGVkKGZhbHNlKTtcbiAgICAgKlxuICAgICAqIC8vIGVuYWJsZSBzdHJva2VcbiAgICAgKiBzaGFwZS5zdHJva2VFbmFibGVkKHRydWUpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dFbmFibGVkJywgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHNoYWRvdyBlbmFibGVkIGZsYWdcbiAgICAgKiBAbmFtZSBzaGFkb3dFbmFibGVkXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzaGFkb3cgZW5hYmxlZCBmbGFnXG4gICAgICogdmFyIHNoYWRvd0VuYWJsZWQgPSBzaGFwZS5zaGFkb3dFbmFibGVkKCk7XG4gICAgICpcbiAgICAgKiAvLyBkaXNhYmxlIHNoYWRvd1xuICAgICAqIHNoYXBlLnNoYWRvd0VuYWJsZWQoZmFsc2UpO1xuICAgICAqXG4gICAgICogLy8gZW5hYmxlIHNoYWRvd1xuICAgICAqIHNoYXBlLnNoYWRvd0VuYWJsZWQodHJ1ZSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2Rhc2hFbmFibGVkJywgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGRhc2ggZW5hYmxlZCBmbGFnXG4gICAgICogQG5hbWUgZGFzaEVuYWJsZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGRhc2ggZW5hYmxlZCBmbGFnXG4gICAgICogdmFyIGRhc2hFbmFibGVkID0gc2hhcGUuZGFzaEVuYWJsZWQoKTtcbiAgICAgKlxuICAgICAqIC8vIGRpc2FibGUgZGFzaFxuICAgICAqIHNoYXBlLmRhc2hFbmFibGVkKGZhbHNlKTtcbiAgICAgKlxuICAgICAqIC8vIGVuYWJsZSBkYXNoXG4gICAgICogc2hhcGUuZGFzaEVuYWJsZWQodHJ1ZSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3N0cm9rZVNjYWxlRW5hYmxlZCcsIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBzdHJva2VTY2FsZSBlbmFibGVkIGZsYWdcbiAgICAgKiBAbmFtZSBzdHJva2VTY2FsZUVuYWJsZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHN0cm9rZSBzY2FsZSBlbmFibGVkIGZsYWdcbiAgICAgKiB2YXIgc3Ryb2tlU2NhbGVFbmFibGVkID0gc2hhcGUuc3Ryb2tlU2NhbGVFbmFibGVkKCk7XG4gICAgICpcbiAgICAgKiAvLyBkaXNhYmxlIHN0cm9rZSBzY2FsZVxuICAgICAqIHNoYXBlLnN0cm9rZVNjYWxlRW5hYmxlZChmYWxzZSk7XG4gICAgICpcbiAgICAgKiAvLyBlbmFibGUgc3Ryb2tlIHNjYWxlXG4gICAgICogc2hhcGUuc3Ryb2tlU2NhbGVFbmFibGVkKHRydWUpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUHJpb3JpdHknLCAnY29sb3InKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCBwcmlvcml0eS4gIGNhbiBiZSBjb2xvciwgcGF0dGVybiwgbGluZWFyLWdyYWRpZW50LCBvciByYWRpYWwtZ3JhZGllbnQuICBUaGUgZGVmYXVsdCBpcyBjb2xvci5cbiAgICAgKiAgIFRoaXMgaXMgaGFuZHkgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuXG4gICAgICogQG5hbWUgZmlsbFByaW9yaXR5XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJpb3JpdHlcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcHJpb3JpdHlcbiAgICAgKiB2YXIgZmlsbFByaW9yaXR5ID0gc2hhcGUuZmlsbFByaW9yaXR5KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBwcmlvcml0eVxuICAgICAqIHNoYXBlLmZpbGxQcmlvcml0eSgnbGluZWFyLWdyYWRpZW50Jyk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUGF0dGVybk9mZnNldCcsIFsneCcsICd5J10pO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gb2Zmc2V0XG4gICAgICogQG5hbWUgZmlsbFBhdHRlcm5PZmZzZXRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0LnhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0LnlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiBvZmZzZXRcbiAgICAgKiB2YXIgcGF0dGVybk9mZnNldCA9IHNoYXBlLmZpbGxQYXR0ZXJuT2Zmc2V0KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBwYXR0ZXJuIG9mZnNldFxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuT2Zmc2V0KHtcbiAgICAgKiAgIHg6IDIwXG4gICAgICogICB5OiAxMFxuICAgICAqIH0pO1xuICAgICAqL1xuXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQYXR0ZXJuT2Zmc2V0WCcsIDApO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCBwYXR0ZXJuIG9mZnNldCB4XG4gICAgICogQG5hbWUgZmlsbFBhdHRlcm5PZmZzZXRYXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIG9mZnNldCB4XG4gICAgICogdmFyIHBhdHRlcm5PZmZzZXRYID0gc2hhcGUuZmlsbFBhdHRlcm5PZmZzZXRYKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBwYXR0ZXJuIG9mZnNldCB4XG4gICAgICogc2hhcGUuZmlsbFBhdHRlcm5PZmZzZXRYKDIwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5PZmZzZXRZJywgMCk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gb2Zmc2V0IHlcbiAgICAgKiBAbmFtZSBmaWxsUGF0dGVybk9mZnNldFlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gb2Zmc2V0IHlcbiAgICAgKiB2YXIgcGF0dGVybk9mZnNldFkgPSBzaGFwZS5maWxsUGF0dGVybk9mZnNldFkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHBhdHRlcm4gb2Zmc2V0IHlcbiAgICAgKiBzaGFwZS5maWxsUGF0dGVybk9mZnNldFkoMTApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5TY2FsZScsIFsneCcsICd5J10pO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gc2NhbGVcbiAgICAgKiBAbmFtZSBmaWxsUGF0dGVyblNjYWxlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUueFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZS55XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gc2NhbGVcbiAgICAgKiB2YXIgcGF0dGVyblNjYWxlID0gc2hhcGUuZmlsbFBhdHRlcm5TY2FsZSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgcGF0dGVybiBzY2FsZVxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuU2NhbGUoe1xuICAgICAqICAgeDogMlxuICAgICAqICAgeTogMlxuICAgICAqIH0pO1xuICAgICAqL1xuXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQYXR0ZXJuU2NhbGVYJywgMSk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gc2NhbGUgeFxuICAgICAqIEBuYW1lIGZpbGxQYXR0ZXJuU2NhbGVYXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIHNjYWxlIHhcbiAgICAgKiB2YXIgcGF0dGVyblNjYWxlWCA9IHNoYXBlLmZpbGxQYXR0ZXJuU2NhbGVYKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBwYXR0ZXJuIHNjYWxlIHhcbiAgICAgKiBzaGFwZS5maWxsUGF0dGVyblNjYWxlWCgyKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5TY2FsZVknLCAxKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiBzY2FsZSB5XG4gICAgICogQG5hbWUgZmlsbFBhdHRlcm5TY2FsZVlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gc2NhbGUgeVxuICAgICAqIHZhciBwYXR0ZXJuU2NhbGVZID0gc2hhcGUuZmlsbFBhdHRlcm5TY2FsZVkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHBhdHRlcm4gc2NhbGUgeVxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuU2NhbGVZKDIpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludCcsIFsneCcsICd5J10pO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIGxpbmVhciBncmFkaWVudCBzdGFydCBwb2ludFxuICAgICAqIEBuYW1lIGZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFydFBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0UG9pbnQueFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFBvaW50LnlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50XG4gICAgICogdmFyIHN0YXJ0UG9pbnQgPSBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnRcbiAgICAgKiBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50KHtcbiAgICAgKiAgIHg6IDIwXG4gICAgICogICB5OiAxMFxuICAgICAqIH0pO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WCcsIDApO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgICAqIEBuYW1lIGZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgICAqIHZhciBzdGFydFBvaW50WCA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgICAqIHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYKDIwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFknLCAwKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50IHlcbiAgICAgKiBAbmFtZSBmaWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50IHlcbiAgICAgKiB2YXIgc3RhcnRQb2ludFkgPSBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50IHlcbiAgICAgKiBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WSgyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsTGluZWFyR3JhZGllbnRFbmRQb2ludCcsIFsneCcsICd5J10pO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnRcbiAgICAgKiBAbmFtZSBmaWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVuZFBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZFBvaW50LnhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kUG9pbnQueVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgZW5kIHBvaW50XG4gICAgICogdmFyIGVuZFBvaW50ID0gc2hhcGUuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnQoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnRcbiAgICAgKiBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludCh7XG4gICAgICogICB4OiAyMFxuICAgICAqICAgeTogMTBcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYJywgMCk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnQgeFxuICAgICAqIEBuYW1lIGZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludCB4XG4gICAgICogdmFyIGVuZFBvaW50WCA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludCB4XG4gICAgICogc2hhcGUuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYKDIwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZJywgMCk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnQgeVxuICAgICAqIEBuYW1lIGZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludCB5XG4gICAgICogdmFyIGVuZFBvaW50WSA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludCB5XG4gICAgICogc2hhcGUuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZKDIwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnQnLCBbJ3gnLCAneSddKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnRcbiAgICAgKiBAbmFtZSBmaWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhcnRQb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFBvaW50LnhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRQb2ludC55XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludFxuICAgICAqIHZhciBzdGFydFBvaW50ID0gc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHBvaW50XG4gICAgICogc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludCh7XG4gICAgICogICB4OiAyMFxuICAgICAqICAgeTogMTBcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFgnLCAwKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHBvaW50IHhcbiAgICAgKiBAbmFtZSBmaWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHBvaW50IHhcbiAgICAgKiB2YXIgc3RhcnRQb2ludFggPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHBvaW50IHhcbiAgICAgKiBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WCgyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZJywgMCk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludCB5XG4gICAgICogQG5hbWUgZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludCB5XG4gICAgICogdmFyIHN0YXJ0UG9pbnRZID0gc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludCB5XG4gICAgICogc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFkoMjApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnQnLCBbJ3gnLCAneSddKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgZW5kIHBvaW50XG4gICAgICogQG5hbWUgZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbmRQb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRQb2ludC54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZFBvaW50LnlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludFxuICAgICAqIHZhciBlbmRQb2ludCA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgZW5kIHBvaW50XG4gICAgICogc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnQoe1xuICAgICAqICAgeDogMjBcbiAgICAgKiAgIHk6IDEwXG4gICAgICogfSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WCcsIDApO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgZW5kIHBvaW50IHhcbiAgICAgKiBAbmFtZSBmaWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnQgeFxuICAgICAqIHZhciBlbmRQb2ludFggPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnQgeFxuICAgICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WCgyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WScsIDApO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgZW5kIHBvaW50IHlcbiAgICAgKiBAbmFtZSBmaWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnQgeVxuICAgICAqIHZhciBlbmRQb2ludFkgPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnQgeVxuICAgICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WSgyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQYXR0ZXJuUm90YXRpb24nLCAwKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCBwYXR0ZXJuIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAbmFtZSBmaWxsUGF0dGVyblJvdGF0aW9uXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcm90YXRpb25cbiAgICAgKiBAcmV0dXJucyB7S29udmEuU2hhcGV9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIHJvdGF0aW9uXG4gICAgICogdmFyIHBhdHRlcm5Sb3RhdGlvbiA9IHNoYXBlLmZpbGxQYXR0ZXJuUm90YXRpb24oKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHBhdHRlcm4gcm90YXRpb25cbiAgICAgKiBzaGFwZS5maWxsUGF0dGVyblJvdGF0aW9uKDIwKTtcbiAgICAgKi9cblxuXG4gICAgS29udmEuRmFjdG9yeS5iYWNrQ29tcGF0KEtvbnZhLlNoYXBlLCB7XG4gICAgICAgIGRhc2hBcnJheTogJ2Rhc2gnLFxuICAgICAgICBnZXREYXNoQXJyYXk6ICdnZXREYXNoJyxcbiAgICAgICAgc2V0RGFzaEFycmF5OiAnZ2V0RGFzaCcsXG5cbiAgICAgICAgZHJhd0Z1bmM6ICdzY2VuZUZ1bmMnLFxuICAgICAgICBnZXREcmF3RnVuYzogJ2dldFNjZW5lRnVuYycsXG4gICAgICAgIHNldERyYXdGdW5jOiAnc2V0U2NlbmVGdW5jJyxcblxuICAgICAgICBkcmF3SGl0RnVuYzogJ2hpdEZ1bmMnLFxuICAgICAgICBnZXREcmF3SGl0RnVuYzogJ2dldEhpdEZ1bmMnLFxuICAgICAgICBzZXREcmF3SGl0RnVuYzogJ3NldEhpdEZ1bmMnXG4gICAgfSk7XG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuU2hhcGUpO1xufSkoS29udmEpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIENPTlNUQU5UU1xuICAgIHZhciBTVEFHRSA9ICdTdGFnZScsXG4gICAgICAgIFNUUklORyA9ICdzdHJpbmcnLFxuICAgICAgICBQWCA9ICdweCcsXG5cbiAgICAgICAgTU9VU0VPVVQgPSAnbW91c2VvdXQnLFxuICAgICAgICBNT1VTRUxFQVZFID0gJ21vdXNlbGVhdmUnLFxuICAgICAgICBNT1VTRU9WRVIgPSAnbW91c2VvdmVyJyxcbiAgICAgICAgTU9VU0VFTlRFUiA9ICdtb3VzZWVudGVyJyxcbiAgICAgICAgTU9VU0VNT1ZFID0gJ21vdXNlbW92ZScsXG4gICAgICAgIE1PVVNFRE9XTiA9ICdtb3VzZWRvd24nLFxuICAgICAgICBNT1VTRVVQID0gJ21vdXNldXAnLFxuICAgICAgICBDTElDSyA9ICdjbGljaycsXG4gICAgICAgIERCTF9DTElDSyA9ICdkYmxjbGljaycsXG4gICAgICAgIFRPVUNIU1RBUlQgPSAndG91Y2hzdGFydCcsXG4gICAgICAgIFRPVUNIRU5EID0gJ3RvdWNoZW5kJyxcbiAgICAgICAgVEFQID0gJ3RhcCcsXG4gICAgICAgIERCTF9UQVAgPSAnZGJsdGFwJyxcbiAgICAgICAgVE9VQ0hNT1ZFID0gJ3RvdWNobW92ZScsXG4gICAgICAgIERPTU1PVVNFU0NST0xMID0gJ0RPTU1vdXNlU2Nyb2xsJyxcbiAgICAgICAgTU9VU0VXSEVFTCA9ICdtb3VzZXdoZWVsJyxcbiAgICAgICAgV0hFRUwgPSAnd2hlZWwnLFxuXG4gICAgICAgIENPTlRFTlRfTU9VU0VPVVQgPSAnY29udGVudE1vdXNlb3V0JyxcbiAgICAgICAgQ09OVEVOVF9NT1VTRU9WRVIgPSAnY29udGVudE1vdXNlb3ZlcicsXG4gICAgICAgIENPTlRFTlRfTU9VU0VNT1ZFID0gJ2NvbnRlbnRNb3VzZW1vdmUnLFxuICAgICAgICBDT05URU5UX01PVVNFRE9XTiA9ICdjb250ZW50TW91c2Vkb3duJyxcbiAgICAgICAgQ09OVEVOVF9NT1VTRVVQID0gJ2NvbnRlbnRNb3VzZXVwJyxcbiAgICAgICAgQ09OVEVOVF9DTElDSyA9ICdjb250ZW50Q2xpY2snLFxuICAgICAgICBDT05URU5UX0RCTF9DTElDSyA9ICdjb250ZW50RGJsY2xpY2snLFxuICAgICAgICBDT05URU5UX1RPVUNIU1RBUlQgPSAnY29udGVudFRvdWNoc3RhcnQnLFxuICAgICAgICBDT05URU5UX1RPVUNIRU5EID0gJ2NvbnRlbnRUb3VjaGVuZCcsXG4gICAgICAgIENPTlRFTlRfREJMX1RBUCA9ICdjb250ZW50RGJsdGFwJyxcbiAgICAgICAgQ09OVEVOVF9UQVAgPSAnY29udGVudFRhcCcsXG4gICAgICAgIENPTlRFTlRfVE9VQ0hNT1ZFID0gJ2NvbnRlbnRUb3VjaG1vdmUnLFxuXG4gICAgICAgIERJViA9ICdkaXYnLFxuICAgICAgICBSRUxBVElWRSA9ICdyZWxhdGl2ZScsXG4gICAgICAgIEtPTlZBX0NPTlRFTlQgPSAna29udmFqcy1jb250ZW50JyxcbiAgICAgICAgU1BBQ0UgPSAnICcsXG4gICAgICAgIFVOREVSU0NPUkUgPSAnXycsXG4gICAgICAgIENPTlRBSU5FUiA9ICdjb250YWluZXInLFxuICAgICAgICBFTVBUWV9TVFJJTkcgPSAnJyxcbiAgICAgICAgRVZFTlRTID0gW01PVVNFRE9XTiwgTU9VU0VNT1ZFLCBNT1VTRVVQLCBNT1VTRU9VVCwgVE9VQ0hTVEFSVCwgVE9VQ0hNT1ZFLCBUT1VDSEVORCwgTU9VU0VPVkVSLCBET01NT1VTRVNDUk9MTCwgTU9VU0VXSEVFTCwgV0hFRUxdLFxuXG4gICAgICAgIC8vIGNhY2hlZCB2YXJpYWJsZXNcbiAgICAgICAgZXZlbnRzTGVuZ3RoID0gRVZFTlRTLmxlbmd0aDtcblxuICAgIGZ1bmN0aW9uIGFkZEV2ZW50KGN0eCwgZXZlbnROYW1lKSB7XG4gICAgICAgIGN0eC5jb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIGN0eFtVTkRFUlNDT1JFICsgZXZlbnROYW1lXShldnQpO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhZ2UgY29uc3RydWN0b3IuICBBIHN0YWdlIGlzIHVzZWQgdG8gY29udGFpbiBtdWx0aXBsZSBsYXllcnNcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYXVnbWVudHMgS29udmEuQ29udGFpbmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR9IGNvbmZpZy5jb250YWluZXIgQ29udGFpbmVyIGlkIG9yIERPTSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBzdGFnZSA9IG5ldyBLb252YS5TdGFnZSh7XG4gICAgICAgICAqICAgd2lkdGg6IDUwMCxcbiAgICAgICAgICogICBoZWlnaHQ6IDgwMCxcbiAgICAgICAgICogICBjb250YWluZXI6ICdjb250YWluZXJJZCdcbiAgICAgICAgICogfSk7XG4gICAgICovXG4gICAgS29udmEuU3RhZ2UgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLlV0aWwuYWRkTWV0aG9kcyhLb252YS5TdGFnZSwge1xuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZVR5cGUgPSBTVEFHRTtcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLkNvbnRhaW5lci5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLl9pZCA9IEtvbnZhLmlkQ291bnRlcisrO1xuICAgICAgICAgICAgdGhpcy5fYnVpbGRET00oKTtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRDb250ZW50RXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLl9lbmFibGVOZXN0ZWRUcmFuc2Zvcm1zID0gZmFsc2U7XG4gICAgICAgICAgICBLb252YS5zdGFnZXMucHVzaCh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3ZhbGlkYXRlQWRkOiBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLmdldFR5cGUoKSAhPT0gJ0xheWVyJykge1xuICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwudGhyb3coJ1lvdSBtYXkgb25seSBhZGQgbGF5ZXJzIHRvIHRoZSBzdGFnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCBjb250YWluZXIgZG9tIGVsZW1lbnQgd2hpY2ggY29udGFpbnMgdGhlIHN0YWdlIHdyYXBwZXIgZGl2IGVsZW1lbnRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7RG9tRWxlbWVudH0gY29udGFpbmVyIGNhbiBwYXNzIGluIGEgZG9tIGVsZW1lbnQgb3IgaWQgc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzZXRDb250YWluZXI6IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgaWYoIHR5cGVvZiBjb250YWluZXIgPT09IFNUUklORykge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IGNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBLb252YS5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdDYW4gbm90IGZpbmQgY29udGFpbmVyIGluIGRvY3VtZW50IHdpdGggaWQgJyArIGlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldEF0dHIoQ09OVEFJTkVSLCBjb250YWluZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNob3VsZERyYXdIaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuZHJhdy5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkcmF3IGxheWVyIHNjZW5lIGdyYXBoc1xuICAgICAgICAgKiBAbmFtZSBkcmF3XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogZHJhdyBsYXllciBoaXQgZ3JhcGhzXG4gICAgICAgICAqIEBuYW1lIGRyYXdIaXRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgaGVpZ2h0XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICAgICAqL1xuICAgICAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0LmNhbGwodGhpcywgaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZURPTSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgd2lkdGhcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRXaWR0aC5jYWxsKHRoaXMsIHdpZHRoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZURPTSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjbGVhciBhbGwgbGF5ZXJzXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgbGVuID0gbGF5ZXJzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBuO1xuXG4gICAgICAgICAgICBmb3IobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgIGxheWVyc1tuXS5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIGlmICghb2JqKSB7XG4gICAgICAgICAgICAgICAgb2JqID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmouY29udGFpbmVyID0gS29udmEuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChESVYpO1xuICAgICAgICAgICAgcmV0dXJuIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLCBvYmopO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZGVzdHJveSBzdGFnZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQ7XG4gICAgICAgICAgICBLb252YS5Db250YWluZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgaWYoY29udGVudCAmJiBLb252YS5VdGlsLl9pc0luRG9jdW1lbnQoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldENvbnRhaW5lcigpLnJlbW92ZUNoaWxkKGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGluZGV4ID0gS29udmEuc3RhZ2VzLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIEtvbnZhLnN0YWdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgcG9pbnRlciBwb3NpdGlvbiB3aGljaCBjYW4gYmUgYSB0b3VjaCBwb3NpdGlvbiBvciBtb3VzZSBwb3NpdGlvblxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldFBvaW50ZXJQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb2ludGVyUG9zO1xuICAgICAgICB9LFxuICAgICAgICBnZXRTdGFnZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBzdGFnZSBjb250ZW50IGRpdiBlbGVtZW50IHdoaWNoIGhhcyB0aGVcbiAgICAgICAgICogIHRoZSBjbGFzcyBuYW1lIFwia29udmFqcy1jb250ZW50XCJcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRDb250ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgY29tcG9zaXRlIGRhdGEgVVJMXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuY2FsbGJhY2tdIGZ1bmN0aW9uIGV4ZWN1dGVkIHdoZW4gdGhlIGNvbXBvc2l0ZSBoYXMgY29tcGxldGVkLiBEZXByZWNhdGVkIGFzIG1ldGhvZCBpcyBzeW5jIG5vdy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubWltZVR5cGVdIGNhbiBiZSBcImltYWdlL3BuZ1wiIG9yIFwiaW1hZ2UvanBlZ1wiLlxuICAgICAgICAgKiAgXCJpbWFnZS9wbmdcIiBpcyB0aGUgZGVmYXVsdFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XSB4IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldIHkgcG9zaXRpb24gb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdIHdpZHRoIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF0gaGVpZ2h0IG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnF1YWxpdHldIGpwZWcgcXVhbGl0eS4gIElmIHVzaW5nIGFuIFwiaW1hZ2UvanBlZ1wiIG1pbWVUeXBlLFxuICAgICAgICAgKiAgeW91IGNhbiBzcGVjaWZ5IHRoZSBxdWFsaXR5IGZyb20gMCB0byAxLCB3aGVyZSAwIGlzIHZlcnkgcG9vciBxdWFsaXR5IGFuZCAxXG4gICAgICAgICAqICBpcyB2ZXJ5IGhpZ2ggcXVhbGl0eVxuICAgICAgICAgKi9cbiAgICAgICAgdG9EYXRhVVJMOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuICAgICAgICAgICAgdmFyIG1pbWVUeXBlID0gY29uZmlnLm1pbWVUeXBlIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgcXVhbGl0eSA9IGNvbmZpZy5xdWFsaXR5IHx8IG51bGwsXG4gICAgICAgICAgICAgICAgeCA9IGNvbmZpZy54IHx8IDAsXG4gICAgICAgICAgICAgICAgeSA9IGNvbmZpZy55IHx8IDAsXG4gICAgICAgICAgICAgICAgY2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbmZpZy53aWR0aCB8fCB0aGlzLmdldFdpZHRoKCksXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogY29uZmlnLmhlaWdodCB8fCB0aGlzLmdldEhlaWdodCgpLFxuICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvOiBjb25maWcucGl4ZWxSYXRpb1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIF9jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoKS5fY29udGV4dCxcbiAgICAgICAgICAgICAgICBsYXllcnMgPSB0aGlzLmNoaWxkcmVuO1xuXG4gICAgICAgICAgICBpZih4IHx8IHkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC50cmFuc2xhdGUoLTEgKiB4LCAtMSAqIHkpO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGxheWVycy5lYWNoKGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gbGF5ZXIuZ2V0Q2FudmFzKCkuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gbGF5ZXIuZ2V0Q2FudmFzKCkuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHJhdGlvID0gbGF5ZXIuZ2V0Q2FudmFzKCkuZ2V0UGl4ZWxSYXRpbygpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LmRyYXdJbWFnZShsYXllci5nZXRDYW52YXMoKS5fY2FudmFzLCAwLCAwLCB3aWR0aCAvIHJhdGlvLCBoZWlnaHQgLyByYXRpbyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBzcmMgPSBjYW52YXMudG9EYXRhVVJMKG1pbWVUeXBlLCBxdWFsaXR5KTtcblxuICAgICAgICAgICAgaWYgKGNvbmZpZy5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFjayhzcmMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc3JjO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogY29udmVydHMgc3RhZ2UgaW50byBhbiBpbWFnZS5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZmlnLmNhbGxiYWNrIGZ1bmN0aW9uIGV4ZWN1dGVkIHdoZW4gdGhlIGNvbXBvc2l0ZSBoYXMgY29tcGxldGVkXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm1pbWVUeXBlXSBjYW4gYmUgXCJpbWFnZS9wbmdcIiBvciBcImltYWdlL2pwZWdcIi5cbiAgICAgICAgICogIFwiaW1hZ2UvcG5nXCIgaXMgdGhlIGRlZmF1bHRcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF0geCBwb3NpdGlvbiBvZiBjYW52YXMgc2VjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XSB5IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXSB3aWR0aCBvZiBjYW52YXMgc2VjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdIGhlaWdodCBvZiBjYW52YXMgc2VjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5xdWFsaXR5XSBqcGVnIHF1YWxpdHkuICBJZiB1c2luZyBhbiBcImltYWdlL2pwZWdcIiBtaW1lVHlwZSxcbiAgICAgICAgICogIHlvdSBjYW4gc3BlY2lmeSB0aGUgcXVhbGl0eSBmcm9tIDAgdG8gMSwgd2hlcmUgMCBpcyB2ZXJ5IHBvb3IgcXVhbGl0eSBhbmQgMVxuICAgICAgICAgKiAgaXMgdmVyeSBoaWdoIHF1YWxpdHlcbiAgICAgICAgICovXG4gICAgICAgIHRvSW1hZ2U6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgdmFyIGNiID0gY29uZmlnLmNhbGxiYWNrO1xuXG4gICAgICAgICAgICBjb25maWcuY2FsbGJhY2sgPSBmdW5jdGlvbihkYXRhVXJsKSB7XG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC5fZ2V0SW1hZ2UoZGF0YVVybCwgZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKGltZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy50b0RhdGFVUkwoY29uZmlnKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCB2aXNpYmxlIGludGVyc2VjdGlvbiBzaGFwZS4gVGhpcyBpcyB0aGUgcHJlZmVycmVkXG4gICAgICAgICAqICBtZXRob2QgZm9yIGRldGVybWluaW5nIGlmIGEgcG9pbnQgaW50ZXJzZWN0cyBhIHNoYXBlIG9yIG5vdFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBvc1xuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zLnhcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy55XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0b3JdXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiB2YXIgc2hhcGUgPSBzdGFnZS5nZXRJbnRlcnNlY3Rpb24oe3g6IDUwLCB5OiA1MH0pO1xuICAgICAgICAgKiAvLyBvciBpZiB5b3UgaW50ZXJlc3RlZCBpbiBzaGFwZSBwYXJlbnQ6XG4gICAgICAgICAqIHZhciBncm91cCA9IHN0YWdlLmdldEludGVyc2VjdGlvbih7eDogNTAsIHk6IDUwfSwgJ0dyb3VwJyk7XG4gICAgICAgICAqL1xuICAgICAgICBnZXRJbnRlcnNlY3Rpb246IGZ1bmN0aW9uKHBvcywgc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHZhciBsYXllcnMgPSB0aGlzLmdldENoaWxkcmVuKCksXG4gICAgICAgICAgICAgICAgbGVuID0gbGF5ZXJzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBlbmQgPSBsZW4gLSAxLFxuICAgICAgICAgICAgICAgIG4sIHNoYXBlO1xuXG4gICAgICAgICAgICBmb3IobiA9IGVuZDsgbiA+PSAwOyBuLS0pIHtcbiAgICAgICAgICAgICAgICBzaGFwZSA9IGxheWVyc1tuXS5nZXRJbnRlcnNlY3Rpb24ocG9zLCBzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBfcmVzaXplRE9NOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuY29udGVudCkge1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKSxcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJzID0gdGhpcy5nZXRDaGlsZHJlbigpLFxuICAgICAgICAgICAgICAgICAgICBsZW4gPSBsYXllcnMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBuLCBsYXllcjtcblxuICAgICAgICAgICAgICAgIC8vIHNldCBjb250ZW50IGRpbWVuc2lvbnNcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQuc3R5bGUud2lkdGggPSB3aWR0aCArIFBYO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBQWDtcblxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyQ2FudmFzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXJIaXRDYW52YXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAgICAgICAgIC8vIHNldCBsYXllciBkaW1lbnNpb25zXG4gICAgICAgICAgICAgICAgZm9yKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIgPSBsYXllcnNbbl07XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLmRyYXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhZGQgbGF5ZXIgb3IgbGF5ZXJzIHRvIHN0YWdlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0gey4uLktvbnZhLkxheWVyfSBsYXllclxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBzdGFnZS5hZGQobGF5ZXIxLCBsYXllcjIsIGxheWVyMyk7XG4gICAgICAgICAqL1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChhcmd1bWVudHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgbGF5ZXIpO1xuICAgICAgICAgICAgbGF5ZXIuX3NldENhbnZhc1NpemUodGhpcy53aWR0aCgpLCB0aGlzLmhlaWdodCgpKTtcblxuICAgICAgICAgICAgLy8gZHJhdyBsYXllciBhbmQgYXBwZW5kIGNhbnZhcyB0byBjb250YWluZXJcbiAgICAgICAgICAgIGxheWVyLmRyYXcoKTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5hcHBlbmRDaGlsZChsYXllci5jYW52YXMuX2NhbnZhcyk7XG5cbiAgICAgICAgICAgIC8vIGNoYWluYWJsZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFBhcmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TGF5ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXR1cm5zIGEge0BsaW5rIEtvbnZhLkNvbGxlY3Rpb259IG9mIGxheWVyc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGdldExheWVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgICAgICB9LFxuICAgICAgICBfYmluZENvbnRlbnRFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBldmVudHNMZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgICAgIGFkZEV2ZW50KHRoaXMsIEVWRU5UU1tuXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9tb3VzZW92ZXI6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgaWYgKCFLb252YS5VQS5tb2JpbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfTU9VU0VPVkVSLCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX21vdXNlb3V0OiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIGlmICghS29udmEuVUEubW9iaWxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldFNoYXBlID0gdGhpcy50YXJnZXRTaGFwZTtcblxuICAgICAgICAgICAgICAgIGlmKHRhcmdldFNoYXBlICYmICFLb252YS5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VPVVQsIHtldnQ6IGV2dH0pO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRTaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRUxFQVZFLCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXRTaGFwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlclBvcyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9NT1VTRU9VVCwge2V2dDogZXZ0fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9tb3VzZW1vdmU6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgbW9iaWxlIElFIHRvIGZvcmNlIHRvdWNoIGV2ZW50IHdoZW4gdW5oYW5kbGVkIHBvaW50ZXIgZXZlbnQgZWxldmF0ZXMgaW50byBhIG1vdXNlIGV2ZW50XG4gICAgICAgICAgICBpZiAoS29udmEuVUEuaWVNb2JpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdG91Y2htb3ZlKGV2dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3b3JrYXJvdW5kIGZha2UgbW91c2Vtb3ZlIGV2ZW50IGluIGNocm9tZSBicm93c2VyIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xNjE0NjRcbiAgICAgICAgICAgIGlmICgodHlwZW9mIGV2dC5tb3ZlbWVudFggIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBldnQubW92ZW1lbnRZICE9PSAndW5kZWZpbmVkJykgJiYgZXZ0Lm1vdmVtZW50WSA9PT0gMCAmJiBldnQubW92ZW1lbnRYID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoS29udmEuVUEubW9iaWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgICAgICAgIHZhciBzaGFwZTtcblxuICAgICAgICAgICAgaWYgKCFLb252YS5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBzaGFwZSA9IHRoaXMuZ2V0SW50ZXJzZWN0aW9uKHRoaXMuZ2V0UG9pbnRlclBvc2l0aW9uKCkpO1xuICAgICAgICAgICAgICAgIGlmKHNoYXBlICYmIHNoYXBlLmlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoIUtvbnZhLmlzRHJhZ2dpbmcoKSAmJiAoIXRoaXMudGFyZ2V0U2hhcGUgfHwgdGhpcy50YXJnZXRTaGFwZS5faWQgIT09IHNoYXBlLl9pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMudGFyZ2V0U2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFNoYXBlLl9maXJlQW5kQnViYmxlKE1PVVNFT1VULCB7ZXZ0OiBldnR9LCBzaGFwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXRTaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRUxFQVZFLCB7ZXZ0OiBldnR9LCBzaGFwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRU9WRVIsIHtldnQ6IGV2dH0sIHRoaXMudGFyZ2V0U2hhcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VFTlRFUiwge2V2dDogZXZ0fSwgdGhpcy50YXJnZXRTaGFwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFNoYXBlID0gc2hhcGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRU1PVkUsIHtldnQ6IGV2dH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogaWYgbm8gc2hhcGUgd2FzIGRldGVjdGVkLCBjbGVhciB0YXJnZXQgc2hhcGUgYW5kIHRyeVxuICAgICAgICAgICAgICAgICAqIHRvIHJ1biBtb3VzZW91dCBmcm9tIHByZXZpb3VzIHRhcmdldCBzaGFwZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLnRhcmdldFNoYXBlICYmICFLb252YS5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0U2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VPVVQsIHtldnQ6IGV2dH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXRTaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRUxFQVZFLCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0U2hhcGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjb250ZW50IGV2ZW50XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX01PVVNFTU9WRSwge2V2dDogZXZ0fSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFsd2F5cyBjYWxsIHByZXZlbnREZWZhdWx0IGZvciBkZXNrdG9wIGV2ZW50cyBiZWNhdXNlIHNvbWUgYnJvd3NlcnNcbiAgICAgICAgICAgIC8vIHRyeSB0byBkcmFnIGFuZCBkcm9wIHRoZSBjYW52YXMgZWxlbWVudFxuICAgICAgICAgICAgaWYgKGV2dC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfbW91c2Vkb3duOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIC8vIHdvcmthcm91bmQgZm9yIG1vYmlsZSBJRSB0byBmb3JjZSB0b3VjaCBldmVudCB3aGVuIHVuaGFuZGxlZCBwb2ludGVyIGV2ZW50IGVsZXZhdGVzIGludG8gYSBtb3VzZSBldmVudFxuICAgICAgICAgICAgaWYgKEtvbnZhLlVBLmllTW9iaWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvdWNoc3RhcnQoZXZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghS29udmEuVUEubW9iaWxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5nZXRJbnRlcnNlY3Rpb24odGhpcy5nZXRQb2ludGVyUG9zaXRpb24oKSk7XG5cbiAgICAgICAgICAgICAgICBLb252YS5saXN0ZW5DbGlja1RhcCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUgJiYgc2hhcGUuaXNMaXN0ZW5pbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaWNrU3RhcnRTaGFwZSA9IHNoYXBlO1xuICAgICAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRURPV04sIHtldnQ6IGV2dH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNvbnRlbnQgZXZlbnRcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfTU9VU0VET1dOLCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWx3YXlzIGNhbGwgcHJldmVudERlZmF1bHQgZm9yIGRlc2t0b3AgZXZlbnRzIGJlY2F1c2Ugc29tZSBicm93c2Vyc1xuICAgICAgICAgICAgLy8gdHJ5IHRvIGRyYWcgYW5kIGRyb3AgdGhlIGNhbnZhcyBlbGVtZW50XG4gICAgICAgICAgICBpZiAoZXZ0LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9tb3VzZXVwOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgbW9iaWxlIElFIHRvIGZvcmNlIHRvdWNoIGV2ZW50IHdoZW4gdW5oYW5kbGVkIHBvaW50ZXIgZXZlbnQgZWxldmF0ZXMgaW50byBhIG1vdXNlIGV2ZW50XG4gICAgICAgICAgICBpZiAoS29udmEuVUEuaWVNb2JpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdG91Y2hlbmQoZXZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghS29udmEuVUEubW9iaWxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5nZXRJbnRlcnNlY3Rpb24odGhpcy5nZXRQb2ludGVyUG9zaXRpb24oKSksXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrU3RhcnRTaGFwZSA9IHRoaXMuY2xpY2tTdGFydFNoYXBlLFxuICAgICAgICAgICAgICAgICAgICBmaXJlRGJsQ2xpY2sgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGQgPSBLb252YS5ERDtcblxuICAgICAgICAgICAgICAgIGlmKEtvbnZhLmluRGJsQ2xpY2tXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyZURibENsaWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgS29udmEuaW5EYmxDbGlja1dpbmRvdyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkb24ndCBzZXQgaW5EYmxDbGlja1dpbmRvdyBhZnRlciBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFkZCB8fCAhZGQuanVzdERyYWdnZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgS29udmEuaW5EYmxDbGlja1dpbmRvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZCkge1xuICAgICAgICAgICAgICAgICAgICBkZC5qdXN0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIEtvbnZhLmluRGJsQ2xpY2tXaW5kb3cgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LCBLb252YS5kYmxDbGlja1dpbmRvdyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUgJiYgc2hhcGUuaXNMaXN0ZW5pbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRVVQLCB7ZXZ0OiBldnR9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBkZXRlY3QgaWYgY2xpY2sgb3IgZG91YmxlIGNsaWNrIG9jY3VycmVkXG4gICAgICAgICAgICAgICAgICAgIGlmKEtvbnZhLmxpc3RlbkNsaWNrVGFwICYmIGNsaWNrU3RhcnRTaGFwZSAmJiBjbGlja1N0YXJ0U2hhcGUuX2lkID09PSBzaGFwZS5faWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKENMSUNLLCB7ZXZ0OiBldnR9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZmlyZURibENsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoREJMX0NMSUNLLCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjb250ZW50IGV2ZW50c1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9NT1VTRVVQLCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgICAgICAgICBpZiAoS29udmEubGlzdGVuQ2xpY2tUYXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX0NMSUNLLCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYoZmlyZURibENsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfREJMX0NMSUNLLCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIEtvbnZhLmxpc3RlbkNsaWNrVGFwID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFsd2F5cyBjYWxsIHByZXZlbnREZWZhdWx0IGZvciBkZXNrdG9wIGV2ZW50cyBiZWNhdXNlIHNvbWUgYnJvd3NlcnNcbiAgICAgICAgICAgIC8vIHRyeSB0byBkcmFnIGFuZCBkcm9wIHRoZSBjYW52YXMgZWxlbWVudFxuICAgICAgICAgICAgaWYgKGV2dC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfdG91Y2hzdGFydDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuZ2V0SW50ZXJzZWN0aW9uKHRoaXMuZ2V0UG9pbnRlclBvc2l0aW9uKCkpO1xuXG4gICAgICAgICAgICBLb252YS5saXN0ZW5DbGlja1RhcCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5pc0xpc3RlbmluZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YXBTdGFydFNoYXBlID0gc2hhcGU7XG4gICAgICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoVE9VQ0hTVEFSVCwge2V2dDogZXZ0fSk7XG5cbiAgICAgICAgICAgICAgICAvLyBvbmx5IGNhbGwgcHJldmVudERlZmF1bHQgaWYgdGhlIHNoYXBlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlLmlzTGlzdGVuaW5nKCkgJiYgZXZ0LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnRlbnQgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9UT1VDSFNUQVJULCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgfSxcbiAgICAgICAgX3RvdWNoZW5kOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFBvaW50ZXJQb3NpdGlvbihldnQpO1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5nZXRJbnRlcnNlY3Rpb24odGhpcy5nZXRQb2ludGVyUG9zaXRpb24oKSksXG4gICAgICAgICAgICAgICAgZmlyZURibENsaWNrID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmKEtvbnZhLmluRGJsQ2xpY2tXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICBmaXJlRGJsQ2xpY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIEtvbnZhLmluRGJsQ2xpY2tXaW5kb3cgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIEtvbnZhLmluRGJsQ2xpY2tXaW5kb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIEtvbnZhLmluRGJsQ2xpY2tXaW5kb3cgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIEtvbnZhLmRibENsaWNrV2luZG93KTtcblxuICAgICAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLmlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShUT1VDSEVORCwge2V2dDogZXZ0fSk7XG5cbiAgICAgICAgICAgICAgICAvLyBkZXRlY3QgaWYgdGFwIG9yIGRvdWJsZSB0YXAgb2NjdXJyZWRcbiAgICAgICAgICAgICAgICBpZihLb252YS5saXN0ZW5DbGlja1RhcCAmJiBzaGFwZS5faWQgPT09IHRoaXMudGFwU3RhcnRTaGFwZS5faWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoVEFQLCB7ZXZ0OiBldnR9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZihmaXJlRGJsQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKERCTF9UQVAsIHtldnQ6IGV2dH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG9ubHkgY2FsbCBwcmV2ZW50RGVmYXVsdCBpZiB0aGUgc2hhcGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUuaXNMaXN0ZW5pbmcoKSAmJiBldnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29udGVudCBldmVudHNcbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9UT1VDSEVORCwge2V2dDogZXZ0fSk7XG4gICAgICAgICAgICBpZiAoS29udmEubGlzdGVuQ2xpY2tUYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfVEFQLCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgICAgICAgICBpZihmaXJlRGJsQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX0RCTF9UQVAsIHtldnQ6IGV2dH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgS29udmEubGlzdGVuQ2xpY2tUYXAgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgX3RvdWNobW92ZTogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgICAgICAgIHZhciBkZCA9IEtvbnZhLkRELFxuICAgICAgICAgICAgICAgIHNoYXBlO1xuICAgICAgICAgICAgaWYgKCFLb252YS5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBzaGFwZSA9IHRoaXMuZ2V0SW50ZXJzZWN0aW9uKHRoaXMuZ2V0UG9pbnRlclBvc2l0aW9uKCkpO1xuICAgICAgICAgICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5pc0xpc3RlbmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKFRPVUNITU9WRSwge2V2dDogZXZ0fSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgY2FsbCBwcmV2ZW50RGVmYXVsdCBpZiB0aGUgc2hhcGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlLmlzTGlzdGVuaW5nKCkgJiYgZXZ0LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfVE9VQ0hNT1ZFLCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGRkKSB7XG4gICAgICAgICAgICAgICAgaWYgKEtvbnZhLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9ET01Nb3VzZVNjcm9sbDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICB0aGlzLl9tb3VzZXdoZWVsKGV2dCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9tb3VzZXdoZWVsOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFBvaW50ZXJQb3NpdGlvbihldnQpO1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5nZXRJbnRlcnNlY3Rpb24odGhpcy5nZXRQb2ludGVyUG9zaXRpb24oKSk7XG5cbiAgICAgICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5pc0xpc3RlbmluZygpKSB7XG4gICAgICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VXSEVFTCwge2V2dDogZXZ0fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF93aGVlbDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICB0aGlzLl9tb3VzZXdoZWVsKGV2dCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zZXRQb2ludGVyUG9zaXRpb246IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnRQb3NpdGlvbiA9IHRoaXMuX2dldENvbnRlbnRQb3NpdGlvbigpLFxuICAgICAgICAgICAgICAgIHggPSBudWxsLFxuICAgICAgICAgICAgICAgIHkgPSBudWxsO1xuICAgICAgICAgICAgZXZ0ID0gZXZ0ID8gZXZ0IDogd2luZG93LmV2ZW50O1xuXG4gICAgICAgICAgICAvLyB0b3VjaCBldmVudHNcbiAgICAgICAgICAgIGlmKGV2dC50b3VjaGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50bHksIG9ubHkgaGFuZGxlIG9uZSBmaW5nZXJcbiAgICAgICAgICAgICAgICBpZiAoZXZ0LnRvdWNoZXMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3VjaCA9IGV2dC50b3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGluZm9ybWF0aW9uIGZvciBmaW5nZXIgIzFcbiAgICAgICAgICAgICAgICAgICAgeCA9IHRvdWNoLmNsaWVudFggLSBjb250ZW50UG9zaXRpb24ubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHRvdWNoLmNsaWVudFkgLSBjb250ZW50UG9zaXRpb24udG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1vdXNlIGV2ZW50c1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeCA9IGV2dC5jbGllbnRYIC0gY29udGVudFBvc2l0aW9uLmxlZnQ7XG4gICAgICAgICAgICAgICAgeSA9IGV2dC5jbGllbnRZIC0gY29udGVudFBvc2l0aW9uLnRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ICE9PSBudWxsICYmIHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXJQb3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfZ2V0Q29udGVudFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5jb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA/IHRoaXMuY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvcDogcmVjdC50b3AsXG4gICAgICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBfYnVpbGRET006IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZ2V0Q29udGFpbmVyKCk7XG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIGlmIChLb252YS5VdGlsLmlzQnJvd3NlcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdTdGFnZSBoYXMgbm8gY29udGFpbmVyLiBBIGNvbnRhaW5lciBpcyByZXF1aXJlZC4nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgY3JlYXRlIGVsZW1lbnQgZm9yIGpzZG9tIGluIG5vZGVqcyBlbnZcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0gS29udmEuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChESVYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNsZWFyIGNvbnRlbnQgaW5zaWRlIGNvbnRhaW5lclxuICAgICAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IEVNUFRZX1NUUklORztcblxuICAgICAgICAgICAgLy8gY29udGVudFxuICAgICAgICAgICAgdGhpcy5jb250ZW50ID0gS29udmEuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChESVYpO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LnN0eWxlLnBvc2l0aW9uID0gUkVMQVRJVkU7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuY2xhc3NOYW1lID0gS09OVkFfQ09OVEVOVDtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50KTtcblxuICAgICAgICAgICAgLy8gdGhlIGJ1ZmZlciBjYW52YXMgcGl4ZWwgcmF0aW8gbXVzdCBiZSAxIGJlY2F1c2UgaXQgaXMgdXNlZCBhcyBhblxuICAgICAgICAgICAgLy8gaW50ZXJtZWRpYXRlIGNhbnZhcyBiZWZvcmUgY29weWluZyB0aGUgcmVzdWx0IG9udG8gYSBzY2VuZSBjYW52YXMuXG4gICAgICAgICAgICAvLyBub3Qgc2V0dGluZyBpdCB0byAxIHdpbGwgcmVzdWx0IGluIGFuIG92ZXIgY29tcGVuc2F0aW9uXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlckNhbnZhcyA9IG5ldyBLb252YS5TY2VuZUNhbnZhcyh7XG4gICAgICAgICAgICAgICAgcGl4ZWxSYXRpbzogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlckhpdENhbnZhcyA9IG5ldyBLb252YS5IaXRDYW52YXMoKTtcblxuICAgICAgICAgICAgdGhpcy5fcmVzaXplRE9NKCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9vbkNvbnRlbnQ6IGZ1bmN0aW9uKHR5cGVzU3RyLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB2YXIgdHlwZXMgPSB0eXBlc1N0ci5zcGxpdChTUEFDRSksXG4gICAgICAgICAgICAgICAgbGVuID0gdHlwZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG4sIGJhc2VFdmVudDtcblxuICAgICAgICAgICAgZm9yKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICBiYXNlRXZlbnQgPSB0eXBlc1tuXTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcihiYXNlRXZlbnQsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gY3VycmVudGx5IGNhY2hlIGZ1bmN0aW9uIGlzIG5vdyB3b3JraW5nIGZvciBzdGFnZSwgYmVjYXVzZSBzdGFnZSBoYXMgbm8gaXRzIG93biBjYW52YXMgZWxlbWVudFxuICAgICAgICAvLyBUT0RPOiBtYXkgYmUgaXQgaXMgYmV0dGVyIHRvIGNhY2hlIGFsbCBjaGlsZHJlbiBsYXllcnM/XG4gICAgICAgIGNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEtvbnZhLlV0aWwud2FybignQ2FjaGUgZnVuY3Rpb24gaXMgbm90IGFsbG93ZWQgZm9yIHN0YWdlLiBZb3UgbWF5IHVzZSBjYWNoZSBvbmx5IGZvciBsYXllcnMsIGdyb3VwcyBhbmQgc2hhcGVzLicpO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhckNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlN0YWdlLCBLb252YS5Db250YWluZXIpO1xuXG4gICAgLy8gYWRkIGdldHRlcnMgYW5kIHNldHRlcnNcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlcihLb252YS5TdGFnZSwgJ2NvbnRhaW5lcicpO1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5TdGFnZSwgJ2NvbnRhaW5lcicpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0IGNvbnRhaW5lciBET00gZWxlbWVudFxuICAgICAqIEBuYW1lIGNvbnRhaW5lclxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0RvbUVsZW1lbnR9IGNvbnRhaW5lclxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNvbnRhaW5lclxuICAgICAqIHZhciBjb250YWluZXIgPSBzdGFnZS5jb250YWluZXIoKTtcbiAgICAgKiAvLyBzZXQgY29udGFpbmVyXG4gICAgICogdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAqIGJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgKiBzdGFnZS5jb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgKi9cblxufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBCYXNlTGF5ZXIgY29uc3RydWN0b3IuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLkNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuY2xlYXJCZWZvcmVEcmF3XSBzZXQgdGhpcyBwcm9wZXJ0eSB0byBmYWxzZSBpZiB5b3UgZG9uJ3Qgd2FudFxuICAgICAqIHRvIGNsZWFyIHRoZSBjYW52YXMgYmVmb3JlIGVhY2ggbGF5ZXIgZHJhdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmNsaXBdIHNldCBjbGlwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFhdIHNldCBjbGlwIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWV0gc2V0IGNsaXAgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBXaWR0aF0gc2V0IGNsaXAgd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwSGVpZ2h0XSBzZXQgY2xpcCBoZWlnaHRcblxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGxheWVyID0gbmV3IEtvbnZhLkxheWVyKCk7XG4gICAgICovXG4gICAgS29udmEuQmFzZUxheWVyID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5VdGlsLmFkZE1ldGhvZHMoS29udmEuQmFzZUxheWVyLCB7XG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5ub2RlVHlwZSA9ICdMYXllcic7XG4gICAgICAgICAgICBLb252YS5Db250YWluZXIuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVQTkdTdHJlYW06IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLl9jYW52YXMuY3JlYXRlUE5HU3RyZWFtKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgbGF5ZXIgY2FudmFzXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGdldENhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYW52YXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgbGF5ZXIgaGl0IGNhbnZhc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRIaXRDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGl0Q2FudmFzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGxheWVyIGNhbnZhcyBjb250ZXh0XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FudmFzKCkuZ2V0Q29udGV4dCgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogY2xlYXIgc2NlbmUgYW5kIGhpdCBjYW52YXMgY29udGV4dHMgdGllZCB0byB0aGUgbGF5ZXJcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2JvdW5kc11cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMueF1cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMueV1cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMud2lkdGhdXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbYm91bmRzLmhlaWdodF1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogbGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgICogbGF5ZXIuY2xlYXIoe1xuICAgICAgICAgKiAgIHggOiAwLFxuICAgICAgICAgKiAgIHkgOiAwLFxuICAgICAgICAgKiAgIHdpZHRoIDogMTAwLFxuICAgICAgICAgKiAgIGhlaWdodCA6IDEwMFxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbihib3VuZHMpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0Q29udGV4dCgpLmNsZWFyKGJvdW5kcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJIaXRDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9oaXRJbWFnZURhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGV4dGVuZCBOb2RlLnByb3RvdHlwZS5zZXRaSW5kZXhcbiAgICAgICAgc2V0WkluZGV4OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0WkluZGV4LmNhbGwodGhpcywgaW5kZXgpO1xuICAgICAgICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpO1xuICAgICAgICAgICAgaWYoc3RhZ2UpIHtcbiAgICAgICAgICAgICAgICBzdGFnZS5jb250ZW50LnJlbW92ZUNoaWxkKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XG5cbiAgICAgICAgICAgICAgICBpZihpbmRleCA8IHN0YWdlLmdldENoaWxkcmVuKCkubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFnZS5jb250ZW50Lmluc2VydEJlZm9yZSh0aGlzLmdldENhbnZhcygpLl9jYW52YXMsIHN0YWdlLmdldENoaWxkcmVuKClbaW5kZXggKyAxXS5nZXRDYW52YXMoKS5fY2FudmFzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWdlLmNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZXh0ZW5kIE5vZGUucHJvdG90eXBlLm1vdmVUb1RvcFxuICAgICAgICBtb3ZlVG9Ub3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUubW92ZVRvVG9wLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB2YXIgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XG4gICAgICAgICAgICBpZihzdGFnZSkge1xuICAgICAgICAgICAgICAgIHN0YWdlLmNvbnRlbnQucmVtb3ZlQ2hpbGQodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzKTtcbiAgICAgICAgICAgICAgICBzdGFnZS5jb250ZW50LmFwcGVuZENoaWxkKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZXh0ZW5kIE5vZGUucHJvdG90eXBlLm1vdmVVcFxuICAgICAgICBtb3ZlVXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG1vdmVkID0gS29udmEuTm9kZS5wcm90b3R5cGUubW92ZVVwLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpZiAoIW1vdmVkKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcbiAgICAgICAgICAgIGlmKCFzdGFnZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhZ2UuY29udGVudC5yZW1vdmVDaGlsZCh0aGlzLmdldENhbnZhcygpLl9jYW52YXMpO1xuXG4gICAgICAgICAgICBpZih0aGlzLmluZGV4IDwgc3RhZ2UuZ2V0Q2hpbGRyZW4oKS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgc3RhZ2UuY29udGVudC5pbnNlcnRCZWZvcmUodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzLCBzdGFnZS5nZXRDaGlsZHJlbigpW3RoaXMuaW5kZXggKyAxXS5nZXRDYW52YXMoKS5fY2FudmFzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhZ2UuY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmdldENhbnZhcygpLl9jYW52YXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGV4dGVuZCBOb2RlLnByb3RvdHlwZS5tb3ZlRG93blxuICAgICAgICBtb3ZlRG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZihLb252YS5Ob2RlLnByb3RvdHlwZS5tb3ZlRG93bi5jYWxsKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpO1xuICAgICAgICAgICAgICAgIGlmKHN0YWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHN0YWdlLmdldENoaWxkcmVuKCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YWdlLmNvbnRlbnQucmVtb3ZlQ2hpbGQodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhZ2UuY29udGVudC5pbnNlcnRCZWZvcmUodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzLCBjaGlsZHJlblt0aGlzLmluZGV4ICsgMV0uZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGV4dGVuZCBOb2RlLnByb3RvdHlwZS5tb3ZlVG9Cb3R0b21cbiAgICAgICAgbW92ZVRvQm90dG9tOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKEtvbnZhLk5vZGUucHJvdG90eXBlLm1vdmVUb0JvdHRvbS5jYWxsKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpO1xuICAgICAgICAgICAgICAgIGlmKHN0YWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHN0YWdlLmdldENoaWxkcmVuKCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YWdlLmNvbnRlbnQucmVtb3ZlQ2hpbGQodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhZ2UuY29udGVudC5pbnNlcnRCZWZvcmUodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzLCBjaGlsZHJlblsxXS5nZXRDYW52YXMoKS5fY2FudmFzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TGF5ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgX2NhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcztcblxuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIGlmKF9jYW52YXMgJiYgX2NhbnZhcy5wYXJlbnROb2RlICYmIEtvbnZhLlV0aWwuX2lzSW5Eb2N1bWVudChfY2FudmFzKSkge1xuICAgICAgICAgICAgICAgIF9jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfY2FudmFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBnZXRTdGFnZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldC9zZXQgd2lkdGggb2YgbGF5ZXIuZ2V0dGVyIHJldHVybiB3aWR0aCBvZiBzdGFnZS4gc2V0dGVyIGRvaW5nIG5vdGhpbmcuXG4gICAgICAgICAqIGlmIHlvdSB3YW50IGNoYW5nZSB3aWR0aCB1c2UgYHN0YWdlLndpZHRoKHZhbHVlKTtgXG4gICAgICAgICAqIEBuYW1lIHdpZHRoXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogdmFyIHdpZHRoID0gbGF5ZXIud2lkdGgoKTtcbiAgICAgICAgICovXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBLb252YS5VdGlsLndhcm4oJ0NhbiBub3QgY2hhbmdlIHdpZHRoIG9mIGxheWVyLiBVc2UgXCJzdGFnZS53aWR0aCh2YWx1ZSlcIiBmdW5jdGlvbiBpbnN0ZWFkLicpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0L3NldCBoZWlnaHQgb2YgbGF5ZXIuZ2V0dGVyIHJldHVybiBoZWlnaHQgb2Ygc3RhZ2UuIHNldHRlciBkb2luZyBub3RoaW5nLlxuICAgICAgICAgKiBpZiB5b3Ugd2FudCBjaGFuZ2UgaGVpZ2h0IHVzZSBgc3RhZ2UuaGVpZ2h0KHZhbHVlKTtgXG4gICAgICAgICAqIEBuYW1lIGhlaWdodFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIHZhciBoZWlnaHQgPSBsYXllci5oZWlnaHQoKTtcbiAgICAgICAgICovXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBLb252YS5VdGlsLndhcm4oJ0NhbiBub3QgY2hhbmdlIGhlaWdodCBvZiBsYXllci4gVXNlIFwic3RhZ2UuaGVpZ2h0KHZhbHVlKVwiIGZ1bmN0aW9uIGluc3RlYWQuJyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHRoZSBhcHBseSB0cmFuc2Zvcm0gbWV0aG9kIGlzIGhhbmRsZWQgYnkgdGhlIExheWVyIGFuZCBGYXN0TGF5ZXIgY2xhc3NcbiAgICAgICAgLy8gYmVjYXVzZSBpdCBpcyB1cCB0byB0aGUgbGF5ZXIgdG8gZGVjaWRlIGlmIGFuIGFic29sdXRlIG9yIHJlbGF0aXZlIHRyYW5zZm9ybVxuICAgICAgICAvLyBzaG91bGQgYmUgdXNlZFxuICAgICAgICBfYXBwbHlUcmFuc2Zvcm06IGZ1bmN0aW9uKHNoYXBlLCBjb250ZXh0LCB0b3ApIHtcbiAgICAgICAgICAgIHZhciBtID0gc2hhcGUuZ2V0QWJzb2x1dGVUcmFuc2Zvcm0odG9wKS5nZXRNYXRyaXgoKTtcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNmb3JtKG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sIG1bNF0sIG1bNV0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuQmFzZUxheWVyLCBLb252YS5Db250YWluZXIpO1xuXG4gICAgLy8gYWRkIGdldHRlcnMgYW5kIHNldHRlcnNcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5CYXNlTGF5ZXIsICdjbGVhckJlZm9yZURyYXcnLCB0cnVlKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGNsZWFyQmVmb3JlRHJhdyBmbGFnIHdoaWNoIGRldGVybWluZXMgaWYgdGhlIGxheWVyIGlzIGNsZWFyZWQgb3Igbm90XG4gICAgICogIGJlZm9yZSBkcmF3aW5nXG4gICAgICogQG5hbWUgY2xlYXJCZWZvcmVEcmF3XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjbGVhckJlZm9yZURyYXdcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjbGVhckJlZm9yZURyYXcgZmxhZ1xuICAgICAqIHZhciBjbGVhckJlZm9yZURyYXcgPSBsYXllci5jbGVhckJlZm9yZURyYXcoKTtcbiAgICAgKlxuICAgICAqIC8vIGRpc2FibGUgY2xlYXIgYmVmb3JlIGRyYXdcbiAgICAgKiBsYXllci5jbGVhckJlZm9yZURyYXcoZmFsc2UpO1xuICAgICAqXG4gICAgICogLy8gZW5hYmxlIGNsZWFyIGJlZm9yZSBkcmF3XG4gICAgICogbGF5ZXIuY2xlYXJCZWZvcmVEcmF3KHRydWUpO1xuICAgICAqL1xuXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLkJhc2VMYXllcik7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIGNvbnN0YW50c1xuICAgIHZhciBIQVNIID0gJyMnLFxuICAgICAgICBCRUZPUkVfRFJBVyA9ICdiZWZvcmVEcmF3JyxcbiAgICAgICAgRFJBVyA9ICdkcmF3JyxcblxuICAgICAgICAvKlxuICAgICAgICAgKiAyIC0gMyAtIDRcbiAgICAgICAgICogfCAgICAgICB8XG4gICAgICAgICAqIDEgLSAwICAgNVxuICAgICAgICAgKiAgICAgICAgIHxcbiAgICAgICAgICogOCAtIDcgLSA2XG4gICAgICAgICAqL1xuICAgICAgICBJTlRFUlNFQ1RJT05fT0ZGU0VUUyA9IFtcbiAgICAgICAgICAgIHt4OiAwLCB5OiAwfSwgIC8vIDBcbiAgICAgICAgICAgIHt4OiAtMSwgeTogMH0sIC8vIDFcbiAgICAgICAgICAgIHt4OiAtMSwgeTogLTF9LCAvLyAyXG4gICAgICAgICAgICB7eDogMCwgeTogLTF9LCAvLyAzXG4gICAgICAgICAgICB7eDogMSwgeTogLTF9LCAvLyA0XG4gICAgICAgICAgICB7eDogMSwgeTogMH0sIC8vIDVcbiAgICAgICAgICAgIHt4OiAxLCB5OiAxfSwgLy8gNlxuICAgICAgICAgICAge3g6IDAsIHk6IDF9LCAvLyA3XG4gICAgICAgICAgICB7eDogLTEsIHk6IDF9ICAvLyA4XG4gICAgICAgIF0sXG4gICAgICAgIElOVEVSU0VDVElPTl9PRkZTRVRTX0xFTiA9IElOVEVSU0VDVElPTl9PRkZTRVRTLmxlbmd0aDtcblxuICAgIC8qKlxuICAgICAqIExheWVyIGNvbnN0cnVjdG9yLiAgTGF5ZXJzIGFyZSB0aWVkIHRvIHRoZWlyIG93biBjYW52YXMgZWxlbWVudCBhbmQgYXJlIHVzZWRcbiAgICAgKiB0byBjb250YWluIGdyb3VwcyBvciBzaGFwZXMuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLkJhc2VMYXllclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuY2xlYXJCZWZvcmVEcmF3XSBzZXQgdGhpcyBwcm9wZXJ0eSB0byBmYWxzZSBpZiB5b3UgZG9uJ3Qgd2FudFxuICAgICAqIHRvIGNsZWFyIHRoZSBjYW52YXMgYmVmb3JlIGVhY2ggbGF5ZXIgZHJhdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmNsaXBdIHNldCBjbGlwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFhdIHNldCBjbGlwIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWV0gc2V0IGNsaXAgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBXaWR0aF0gc2V0IGNsaXAgd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwSGVpZ2h0XSBzZXQgY2xpcCBoZWlnaHRcblxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGxheWVyID0gbmV3IEtvbnZhLkxheWVyKCk7XG4gICAgICovXG4gICAgS29udmEuTGF5ZXIgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5VdGlsLmFkZE1ldGhvZHMoS29udmEuTGF5ZXIsIHtcbiAgICAgICAgX19fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5ub2RlVHlwZSA9ICdMYXllcic7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IG5ldyBLb252YS5TY2VuZUNhbnZhcygpO1xuICAgICAgICAgICAgdGhpcy5oaXRDYW52YXMgPSBuZXcgS29udmEuSGl0Q2FudmFzKHtcbiAgICAgICAgICAgICAgICBwaXhlbFJhdGlvOiAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLkJhc2VMYXllci5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zZXRDYW52YXNTaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5oaXRDYW52YXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfSxcbiAgICAgICAgX3ZhbGlkYXRlQWRkOiBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBjaGlsZC5nZXRUeXBlKCk7XG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gJ0dyb3VwJyAmJiB0eXBlICE9PSAnU2hhcGUnKSB7XG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC50aHJvdygnWW91IG1heSBvbmx5IGFkZCBncm91cHMgYW5kIHNoYXBlcyB0byBhIGxheWVyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IHZpc2libGUgaW50ZXJzZWN0aW9uIHNoYXBlLiBUaGlzIGlzIHRoZSBwcmVmZXJyZWRcbiAgICAgICAgICogbWV0aG9kIGZvciBkZXRlcm1pbmluZyBpZiBhIHBvaW50IGludGVyc2VjdHMgYSBzaGFwZSBvciBub3RcbiAgICAgICAgICogYWxzbyB5b3UgbWF5IHBhc3Mgb3B0aW9uYWwgc2VsZWN0b3IgcGFyYW1ldHIgdG8gcmV0dXJuIGFuY2VzdG9yIG9mIGludGVyc2VjdGVkIHNoYXBlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkxheWVyLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9zXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zLnlcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtzZWxlY3Rvcl1cbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIHZhciBzaGFwZSA9IGxheWVyLmdldEludGVyc2VjdGlvbih7eDogNTAsIHk6IDUwfSk7XG4gICAgICAgICAqIC8vIG9yIGlmIHlvdSBpbnRlcmVzdGVkIGluIHNoYXBlIHBhcmVudDpcbiAgICAgICAgICogdmFyIGdyb3VwID0gbGF5ZXIuZ2V0SW50ZXJzZWN0aW9uKHt4OiA1MCwgeTogNTB9LCAnR3JvdXAnKTtcbiAgICAgICAgICovXG4gICAgICAgIGdldEludGVyc2VjdGlvbjogZnVuY3Rpb24ocG9zLCBzZWxlY3Rvcikge1xuICAgICAgICAgICAgdmFyIG9iaiwgaSwgaW50ZXJzZWN0aW9uT2Zmc2V0LCBzaGFwZTtcblxuICAgICAgICAgICAgaWYoIXRoaXMuaGl0R3JhcGhFbmFibGVkKCkgfHwgIXRoaXMuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGluIHNvbWUgY2FzZXMgYW50aWFsaWFzZWQgYXJlYSBtYXkgYmUgYmlnZ2VyIHRoYW4gMXB4XG4gICAgICAgICAgICAvLyBpdCBpcyBwb3NzaWJsZSBpZiB3ZSB3aWxsIGNhY2hlIG5vZGUsIHRoZW4gc2NhbGUgaXQgYSBsb3RcbiAgICAgICAgICAgIC8vIFRPRE86IGNoZWNrIHsgMDsgMCB9IHBvaW50IGJlZm9yZSBsb29wLCBhbmQgcmVtb3ZlIGl0IGZyb20gSU5URVJTRUNUSU9OX09GRlNFVFMuXG4gICAgICAgICAgICB2YXIgc3BpcmFsU2VhcmNoRGlzdGFuY2UgPSAxO1xuICAgICAgICAgICAgdmFyIGNvbnRpbnVlU2VhcmNoID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBJTlRFUlNFQ1RJT05fT0ZGU0VUU19MRU47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25PZmZzZXQgPSBJTlRFUlNFQ1RJT05fT0ZGU0VUU1tpXTtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gdGhpcy5fZ2V0SW50ZXJzZWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHBvcy54ICsgaW50ZXJzZWN0aW9uT2Zmc2V0LnggKiBzcGlyYWxTZWFyY2hEaXN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHBvcy55ICsgaW50ZXJzZWN0aW9uT2Zmc2V0LnkgKiBzcGlyYWxTZWFyY2hEaXN0YW5jZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGUgPSBvYmouc2hhcGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGFwZSAmJiBzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNoYXBlLmZpbmRBbmNlc3RvcihzZWxlY3RvciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgY29udGludWUgc2VhcmNoIGlmIHdlIGZvdW5kIGFudGlhbGlhc2VkIHBpeGVsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgbWVhbnMgb3VyIG5vZGUgc29tZXdoZXJlIHZlcnkgY2xvc2VcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVTZWFyY2ggPSAhIW9iai5hbnRpYWxpYXNlZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBzZWFyY2ggaWYgZm91bmQgZW1wdHkgcGl4ZWxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvYmouYW50aWFsaWFzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIG5vIHNoYXBlLCBhbmQgbm8gYW50aWFsaWFzZWQgcGl4ZWwsIHdlIHNob3VsZCBlbmQgc2VhcmNoaW5nXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRpbnVlU2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwaXJhbFNlYXJjaERpc3RhbmNlICs9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfZ2V0SW1hZ2VEYXRhOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmhpdENhbnZhcy53aWR0aCB8fCAxLFxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuaGl0Q2FudmFzLmhlaWdodCB8fCAxLFxuICAgICAgICAgICAgICAgIGluZGV4ID0gKE1hdGgucm91bmQoeSkgKiB3aWR0aCApICsgTWF0aC5yb3VuZCh4KTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9oaXRJbWFnZURhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaXRJbWFnZURhdGEgPSB0aGlzLmhpdENhbnZhcy5jb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaXRJbWFnZURhdGEuZGF0YVs0ICogaW5kZXggKyAwXSwgLy8gUmVkXG4gICAgICAgICAgICAgICAgdGhpcy5faGl0SW1hZ2VEYXRhLmRhdGFbNCAqIGluZGV4ICsgMV0sIC8vIEdyZWVuXG4gICAgICAgICAgICAgICAgdGhpcy5faGl0SW1hZ2VEYXRhLmRhdGFbNCAqIGluZGV4ICsgMl0sIC8vIEJsdWVcbiAgICAgICAgICAgICAgICB0aGlzLl9oaXRJbWFnZURhdGEuZGF0YVs0ICogaW5kZXggKyAzXSAvLyBBbHBoYVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldEludGVyc2VjdGlvbjogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgICAgICB2YXIgcmF0aW8gPSB0aGlzLmhpdENhbnZhcy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLmhpdENhbnZhcy5jb250ZXh0LmdldEltYWdlRGF0YShNYXRoLnJvdW5kKHBvcy54ICogcmF0aW8pLCBNYXRoLnJvdW5kKHBvcy55ICogcmF0aW8pLCAxLCAxKS5kYXRhLFxuICAgICAgICAgICAgICAgIHAzID0gcFszXSxcbiAgICAgICAgICAgICAgICBjb2xvcktleSwgc2hhcGU7XG4gICAgICAgICAgICAvLyBmdWxseSBvcGFxdWUgcGl4ZWxcbiAgICAgICAgICAgIGlmKHAzID09PSAyNTUpIHtcbiAgICAgICAgICAgICAgICBjb2xvcktleSA9IEtvbnZhLlV0aWwuX3JnYlRvSGV4KHBbMF0sIHBbMV0sIHBbMl0pO1xuICAgICAgICAgICAgICAgIHNoYXBlID0gS29udmEuc2hhcGVzW0hBU0ggKyBjb2xvcktleV07XG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZTogc2hhcGVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYW50aWFsaWFzZWQ6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYW50aWFsaWFzZWQgcGl4ZWxcbiAgICAgICAgICAgIGVsc2UgaWYocDMgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYW50aWFsaWFzZWQ6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZW1wdHkgcGl4ZWxcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhd1NjZW5lOiBmdW5jdGlvbihjYW4sIHRvcCkge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLFxuICAgICAgICAgICAgICAgIGNhbnZhcyA9IGNhbiB8fCAobGF5ZXIgJiYgbGF5ZXIuZ2V0Q2FudmFzKCkpO1xuXG4gICAgICAgICAgICB0aGlzLl9maXJlKEJFRk9SRV9EUkFXLCB7XG4gICAgICAgICAgICAgICAgbm9kZTogdGhpc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuZ2V0Q2xlYXJCZWZvcmVEcmF3KCkpIHtcbiAgICAgICAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgpLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuZHJhd1NjZW5lLmNhbGwodGhpcywgY2FudmFzLCB0b3ApO1xuXG4gICAgICAgICAgICB0aGlzLl9maXJlKERSQVcsIHtcbiAgICAgICAgICAgICAgICBub2RlOiB0aGlzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYXdIaXQ6IGZ1bmN0aW9uKGNhbiwgdG9wKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksXG4gICAgICAgICAgICAgICAgY2FudmFzID0gY2FuIHx8IChsYXllciAmJiBsYXllci5oaXRDYW52YXMpO1xuXG4gICAgICAgICAgICBpZihsYXllciAmJiBsYXllci5nZXRDbGVhckJlZm9yZURyYXcoKSkge1xuICAgICAgICAgICAgICAgIGxheWVyLmdldEhpdENhbnZhcygpLmdldENvbnRleHQoKS5jbGVhcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBLb252YS5Db250YWluZXIucHJvdG90eXBlLmRyYXdIaXQuY2FsbCh0aGlzLCBjYW52YXMsIHRvcCk7XG4gICAgICAgICAgICB0aGlzLmltYWdlRGF0YSA9IG51bGw7IC8vIENsZWFyIGltYWdlRGF0YSBjYWNoZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbihib3VuZHMpIHtcbiAgICAgICAgICAgIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGUuY2xlYXIuY2FsbCh0aGlzLCBib3VuZHMpO1xuICAgICAgICAgICAgdGhpcy5nZXRIaXRDYW52YXMoKS5nZXRDb250ZXh0KCkuY2xlYXIoYm91bmRzKTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VEYXRhID0gbnVsbDsgLy8gQ2xlYXIgZ2V0SW1hZ2VEYXRhIGNhY2hlXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZXh0ZW5kIE5vZGUucHJvdG90eXBlLnNldFZpc2libGVcbiAgICAgICAgc2V0VmlzaWJsZTogZnVuY3Rpb24odmlzaWJsZSkge1xuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0VmlzaWJsZS5jYWxsKHRoaXMsIHZpc2libGUpO1xuICAgICAgICAgICAgaWYodmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgICAgICB0aGlzLmhpdENhbnZhcy5fY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRDYW52YXMoKS5fY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgdGhpcy5oaXRDYW52YXMuX2NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBlbmFibGUgaGl0IGdyYXBoXG4gICAgICAgICAqIEBuYW1lIGVuYWJsZUhpdEdyYXBoXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkxheWVyLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7TGF5ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBlbmFibGVIaXRHcmFwaDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnNldEhpdEdyYXBoRW5hYmxlZCh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZGlzYWJsZSBoaXQgZ3JhcGhcbiAgICAgICAgICogQG5hbWUgZGlzYWJsZUhpdEdyYXBoXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkxheWVyLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7TGF5ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBkaXNhYmxlSGl0R3JhcGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRIaXRHcmFwaEVuYWJsZWQoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGUuc2V0U2l6ZS5jYWxsKHRoaXMsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5oaXRDYW52YXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuTGF5ZXIsIEtvbnZhLkJhc2VMYXllcik7XG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5MYXllciwgJ2hpdEdyYXBoRW5hYmxlZCcsIHRydWUpO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgaGl0R3JhcGhFbmFibGVkIGZsYWcuICBEaXNhYmxpbmcgdGhlIGhpdCBncmFwaCB3aWxsIGdyZWF0bHkgaW5jcmVhc2VcbiAgICAgKiAgZHJhdyBwZXJmb3JtYW5jZSBiZWNhdXNlIHRoZSBoaXQgZ3JhcGggd2lsbCBub3QgYmUgcmVkcmF3biBlYWNoIHRpbWUgdGhlIGxheWVyIGlzXG4gICAgICogIGRyYXduLiAgVGhpcywgaG93ZXZlciwgYWxzbyBkaXNhYmxlcyBtb3VzZS90b3VjaCBldmVudCBkZXRlY3Rpb25cbiAgICAgKiBAbmFtZSBoaXRHcmFwaEVuYWJsZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkxheWVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGhpdEdyYXBoRW5hYmxlZCBmbGFnXG4gICAgICogdmFyIGhpdEdyYXBoRW5hYmxlZCA9IGxheWVyLmhpdEdyYXBoRW5hYmxlZCgpO1xuICAgICAqXG4gICAgICogLy8gZGlzYWJsZSBoaXQgZ3JhcGhcbiAgICAgKiBsYXllci5oaXRHcmFwaEVuYWJsZWQoZmFsc2UpO1xuICAgICAqXG4gICAgICogLy8gZW5hYmxlIGhpdCBncmFwaFxuICAgICAqIGxheWVyLmhpdEdyYXBoRW5hYmxlZCh0cnVlKTtcbiAgICAgKi9cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuTGF5ZXIpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBGYXN0TGF5ZXIgY29uc3RydWN0b3IuIExheWVycyBhcmUgdGllZCB0byB0aGVpciBvd24gY2FudmFzIGVsZW1lbnQgYW5kIGFyZSB1c2VkXG4gICAgICogdG8gY29udGFpbiBzaGFwZXMgb25seS4gIElmIHlvdSBkb24ndCBuZWVkIG5vZGUgbmVzdGluZywgbW91c2UgYW5kIHRvdWNoIGludGVyYWN0aW9ucyxcbiAgICAgKiBvciBldmVudCBwdWIvc3ViLCB5b3Ugc2hvdWxkIHVzZSBGYXN0TGF5ZXIgaW5zdGVhZCBvZiBMYXllciB0byBjcmVhdGUgeW91ciBsYXllcnMuXG4gICAgICogSXQgcmVuZGVycyBhYm91dCAyeCBmYXN0ZXIgdGhhbiBub3JtYWwgbGF5ZXJzLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5CYXNlTGF5ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmNsZWFyQmVmb3JlRHJhd10gc2V0IHRoaXMgcHJvcGVydHkgdG8gZmFsc2UgaWYgeW91IGRvbid0IHdhbnRcbiAgICAgKiB0byBjbGVhciB0aGUgY2FudmFzIGJlZm9yZSBlYWNoIGxheWVyIGRyYXcuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuY2xpcF0gc2V0IGNsaXBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWF0gc2V0IGNsaXAgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBZXSBzZXQgY2xpcCB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFdpZHRoXSBzZXQgY2xpcCB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBIZWlnaHRdIHNldCBjbGlwIGhlaWdodFxuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgbGF5ZXIgPSBuZXcgS29udmEuRmFzdExheWVyKCk7XG4gICAgICovXG4gICAgS29udmEuRmFzdExheWVyID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19fX2luaXQoY29uZmlnKTtcbiAgICB9O1xuXG4gICAgS29udmEuVXRpbC5hZGRNZXRob2RzKEtvbnZhLkZhc3RMYXllciwge1xuICAgICAgICBfX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVUeXBlID0gJ0xheWVyJztcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKCk7XG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICBLb252YS5CYXNlTGF5ZXIuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgICB9LFxuICAgICAgICBfdmFsaWRhdGVBZGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGNoaWxkLmdldFR5cGUoKTtcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSAnU2hhcGUnKSB7XG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC50aHJvdygnWW91IG1heSBvbmx5IGFkZCBzaGFwZXMgdG8gYSBmYXN0IGxheWVyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfc2V0Q2FudmFzU2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfSxcbiAgICAgICAgaGl0R3JhcGhFbmFibGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SW50ZXJzZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBkcmF3U2NlbmU6IGZ1bmN0aW9uKGNhbikge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLFxuICAgICAgICAgICAgICAgIGNhbnZhcyA9IGNhbiB8fCAobGF5ZXIgJiYgbGF5ZXIuZ2V0Q2FudmFzKCkpO1xuXG4gICAgICAgICAgICBpZih0aGlzLmdldENsZWFyQmVmb3JlRHJhdygpKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzLmdldENvbnRleHQoKS5jbGVhcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBLb252YS5Db250YWluZXIucHJvdG90eXBlLmRyYXdTY2VuZS5jYWxsKHRoaXMsIGNhbnZhcyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1NjZW5lKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZXh0ZW5kIE5vZGUucHJvdG90eXBlLnNldFZpc2libGVcbiAgICAgICAgc2V0VmlzaWJsZTogZnVuY3Rpb24odmlzaWJsZSkge1xuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0VmlzaWJsZS5jYWxsKHRoaXMsIHZpc2libGUpO1xuICAgICAgICAgICAgaWYodmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5GYXN0TGF5ZXIsIEtvbnZhLkJhc2VMYXllcik7XG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuRmFzdExheWVyKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogR3JvdXAgY29uc3RydWN0b3IuICBHcm91cHMgYXJlIHVzZWQgdG8gY29udGFpbiBzaGFwZXMgb3Igb3RoZXIgZ3JvdXBzLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5Db250YWluZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmNsaXBdIHNldCBjbGlwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFhdIHNldCBjbGlwIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWV0gc2V0IGNsaXAgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBXaWR0aF0gc2V0IGNsaXAgd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwSGVpZ2h0XSBzZXQgY2xpcCBoZWlnaHRcblxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGdyb3VwID0gbmV3IEtvbnZhLkdyb3VwKCk7XG4gICAgICovXG4gICAgS29udmEuR3JvdXAgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLlV0aWwuYWRkTWV0aG9kcyhLb252YS5Hcm91cCwge1xuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZVR5cGUgPSAnR3JvdXAnO1xuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgS29udmEuQ29udGFpbmVyLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3ZhbGlkYXRlQWRkOiBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBjaGlsZC5nZXRUeXBlKCk7XG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gJ0dyb3VwJyAmJiB0eXBlICE9PSAnU2hhcGUnKSB7XG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC50aHJvdygnWW91IG1heSBvbmx5IGFkZCBncm91cHMgYW5kIHNoYXBlcyB0byBncm91cHMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5Hcm91cCwgS29udmEuQ29udGFpbmVyKTtcblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5Hcm91cCk7XG59KSgpO1xuXG4oZnVuY3Rpb24oS29udmEpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIEJBVENIX0RSQVdfU1RPUF9USU1FX0RJRkYgPSA1MDA7XG5cbiAgICB2YXIgbm93ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoS29udmEuZ2xvYmFsLnBlcmZvcm1hbmNlICYmIEtvbnZhLmdsb2JhbC5wZXJmb3JtYW5jZS5ub3cpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gS29udmEuZ2xvYmFsLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgfTtcbiAgICB9KSgpO1xuXG4gICAgZnVuY3Rpb24gRlJBRihjYWxsYmFjaykge1xuICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICAgIH1cblxuICAgIHZhciBSQUYgPSAoZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIEtvbnZhLmdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgIHx8IEtvbnZhLmdsb2JhbC53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgIHx8IEtvbnZhLmdsb2JhbC5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgIHx8IEtvbnZhLmdsb2JhbC5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICB8fCBLb252YS5nbG9iYWwubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgIHx8IEZSQUY7XG4gICAgfSkoKTtcblxuXG5cbiAgICBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKCkge1xuICAgICAgICByZXR1cm4gUkFGLmFwcGx5KEtvbnZhLmdsb2JhbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRpb24gY29uc3RydWN0b3IuICBBIHN0YWdlIGlzIHVzZWQgdG8gY29udGFpbiBtdWx0aXBsZSBsYXllcnMgYW5kIGhhbmRsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgZnVuY3Rpb24gZXhlY3V0ZWQgb24gZWFjaCBhbmltYXRpb24gZnJhbWUuICBUaGUgZnVuY3Rpb24gaXMgcGFzc2VkIGEgZnJhbWUgb2JqZWN0LCB3aGljaCBjb250YWluc1xuICAgICAqICB0aW1lRGlmZiwgbGFzdFRpbWUsIHRpbWUsIGFuZCBmcmFtZVJhdGUgcHJvcGVydGllcy4gIFRoZSB0aW1lRGlmZiBwcm9wZXJ0eSBpcyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgcGFzc2VkXG4gICAgICogIHNpbmNlIHRoZSBsYXN0IGFuaW1hdGlvbiBmcmFtZS4gIFRoZSBsYXN0VGltZSBwcm9wZXJ0eSBpcyB0aW1lIGluIG1pbGxpc2Vjb25kcyB0aGF0IGVsYXBzZWQgZnJvbSB0aGUgbW9tZW50IHRoZSBhbmltYXRpb24gc3RhcnRlZFxuICAgICAqICB0byB0aGUgbGFzdCBhbmltYXRpb24gZnJhbWUuICBUaGUgdGltZSBwcm9wZXJ0eSBpcyB0aGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdGhhdCBlbGxhcHNlZCBmcm9tIHRoZSBtb21lbnQgdGhlIGFuaW1hdGlvbiBzdGFydGVkXG4gICAgICogIHRvIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBmcmFtZS4gIFRoZSBmcmFtZVJhdGUgcHJvcGVydHkgaXMgdGhlIGN1cnJlbnQgZnJhbWUgcmF0ZSBpbiBmcmFtZXMgLyBzZWNvbmQuIFJldHVybiBmYWxzZSBmcm9tIGZ1bmN0aW9uLFxuICAgICAqICBpZiB5b3UgZG9uJ3QgbmVlZCB0byByZWRyYXcgbGF5ZXIvbGF5ZXJzIG9uIHNvbWUgZnJhbWVzLlxuICAgICAqIEBwYXJhbSB7S29udmEuTGF5ZXJ8QXJyYXl9IFtsYXllcnNdIGxheWVyKHMpIHRvIGJlIHJlZHJhd24gb24gZWFjaCBhbmltYXRpb24gZnJhbWUuIENhbiBiZSBhIGxheWVyLCBhbiBhcnJheSBvZiBsYXllcnMsIG9yIG51bGwuXG4gICAgICogIE5vdCBzcGVjaWZ5aW5nIGEgbm9kZSB3aWxsIHJlc3VsdCBpbiBubyByZWRyYXcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBtb3ZlIGEgbm9kZSB0byB0aGUgcmlnaHQgYXQgNTAgcGl4ZWxzIC8gc2Vjb25kXG4gICAgICogdmFyIHZlbG9jaXR5ID0gNTA7XG4gICAgICpcbiAgICAgKiB2YXIgYW5pbSA9IG5ldyBLb252YS5BbmltYXRpb24oZnVuY3Rpb24oZnJhbWUpIHtcbiAgICAgKiAgIHZhciBkaXN0ID0gdmVsb2NpdHkgKiAoZnJhbWUudGltZURpZmYgLyAxMDAwKTtcbiAgICAgKiAgIG5vZGUubW92ZShkaXN0LCAwKTtcbiAgICAgKiB9LCBsYXllcik7XG4gICAgICpcbiAgICAgKiBhbmltLnN0YXJ0KCk7XG4gICAgICovXG4gICAgS29udmEuQW5pbWF0aW9uID0gZnVuY3Rpb24oZnVuYywgbGF5ZXJzKSB7XG4gICAgICAgIHZhciBBbmltID0gS29udmEuQW5pbWF0aW9uO1xuICAgICAgICB0aGlzLmZ1bmMgPSBmdW5jO1xuICAgICAgICB0aGlzLnNldExheWVycyhsYXllcnMpO1xuICAgICAgICB0aGlzLmlkID0gQW5pbS5hbmltSWRDb3VudGVyKys7XG4gICAgICAgIHRoaXMuZnJhbWUgPSB7XG4gICAgICAgICAgICB0aW1lOiAwLFxuICAgICAgICAgICAgdGltZURpZmY6IDAsXG4gICAgICAgICAgICBsYXN0VGltZTogbm93KClcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qXG4gICAgICogQW5pbWF0aW9uIG1ldGhvZHNcbiAgICAgKi9cbiAgICBLb252YS5BbmltYXRpb24ucHJvdG90eXBlID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IGxheWVycyB0byBiZSByZWRyYXduIG9uIGVhY2ggYW5pbWF0aW9uIGZyYW1lXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkFuaW1hdGlvbi5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtLb252YS5MYXllcnxBcnJheX0gW2xheWVyc10gbGF5ZXIocykgdG8gYmUgcmVkcmF3bi4mbmJzcDsgQ2FuIGJlIGEgbGF5ZXIsIGFuIGFycmF5IG9mIGxheWVycywgb3IgbnVsbC4gIE5vdCBzcGVjaWZ5aW5nIGEgbm9kZSB3aWxsIHJlc3VsdCBpbiBubyByZWRyYXcuXG4gICAgICAgICAqIEByZXR1cm4ge0tvbnZhLkFuaW1hdGlvbn0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgc2V0TGF5ZXJzOiBmdW5jdGlvbihsYXllcnMpIHtcbiAgICAgICAgICAgIHZhciBsYXlzID0gW107XG4gICAgICAgICAgICAvLyBpZiBwYXNzaW5nIGluIG5vIGxheWVyc1xuICAgICAgICAgICAgaWYgKCFsYXllcnMpIHtcbiAgICAgICAgICAgICAgICBsYXlzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBwYXNzaW5nIGluIGFuIGFycmF5IG9mIExheWVyc1xuICAgICAgICAgICAgLy8gTk9URTogbGF5ZXJzIGNvdWxkIGJlIGFuIGFycmF5IG9yIEtvbnZhLkNvbGxlY3Rpb24uICBmb3Igc2ltcGxpY2l0eSwgSSdtIGp1c3QgaW5zcGVjdGluZ1xuICAgICAgICAgICAgLy8gdGhlIGxlbmd0aCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgYm90aCBjYXNlc1xuICAgICAgICAgICAgZWxzZSBpZiAobGF5ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsYXlzID0gbGF5ZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgcGFzc2luZyBpbiBhIExheWVyXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXlzID0gW2xheWVyc107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubGF5ZXJzID0gbGF5cztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGxheWVyc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5BbmltYXRpb24ucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBLb252YS5MYXllclxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGF5ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheWVycztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFkZCBsYXllci4gIFJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5ZXIgd2FzIGFkZGVkLCBhbmQgZmFsc2UgaWYgaXQgd2FzIG5vdFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5BbmltYXRpb24ucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7S29udmEuTGF5ZXJ9IGxheWVyIHRvIGFkZFxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sfSB0cnVlIGlmIGxheWVyIGlzIGFkZGVkIHRvIGFuaW1hdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBhZGRMYXllcjogZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciBsYXllcnMgPSB0aGlzLmxheWVycyxcbiAgICAgICAgICAgICAgICBsZW4gPSBsYXllcnMubGVuZ3RoLCBuO1xuXG4gICAgICAgICAgICAvLyBkb24ndCBhZGQgdGhlIGxheWVyIGlmIGl0IGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXJzW25dLl9pZCA9PT0gbGF5ZXIuX2lkKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5sYXllcnMucHVzaChsYXllcik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRldGVybWluZSBpZiBhbmltYXRpb24gaXMgcnVubmluZyBvciBub3QuICByZXR1cm5zIHRydWUgb3IgZmFsc2VcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sfSBpcyBhbmltYXRpb24gcnVubmluZz9cbiAgICAgICAgICovXG4gICAgICAgIGlzUnVubmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYSA9IEtvbnZhLkFuaW1hdGlvbixcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zID0gYS5hbmltYXRpb25zLFxuICAgICAgICAgICAgICAgIGxlbiA9IGFuaW1hdGlvbnMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG47XG5cbiAgICAgICAgICAgIGZvcihuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgaWYoYW5pbWF0aW9uc1tuXS5pZCA9PT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzdGFydCBhbmltYXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJuIHtLb252YS5BbmltYXRpb259IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBBbmltID0gS29udmEuQW5pbWF0aW9uO1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLmZyYW1lLnRpbWVEaWZmID0gMDtcbiAgICAgICAgICAgIHRoaXMuZnJhbWUubGFzdFRpbWUgPSBub3coKTtcbiAgICAgICAgICAgIEFuaW0uX2FkZEFuaW1hdGlvbih0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogc3RvcCBhbmltYXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJuIHtLb252YS5BbmltYXRpb259IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgS29udmEuQW5pbWF0aW9uLl9yZW1vdmVBbmltYXRpb24odGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgX3VwZGF0ZUZyYW1lT2JqZWN0OiBmdW5jdGlvbih0aW1lKSB7XG4gICAgICAgICAgICB0aGlzLmZyYW1lLnRpbWVEaWZmID0gdGltZSAtIHRoaXMuZnJhbWUubGFzdFRpbWU7XG4gICAgICAgICAgICB0aGlzLmZyYW1lLmxhc3RUaW1lID0gdGltZTtcbiAgICAgICAgICAgIHRoaXMuZnJhbWUudGltZSArPSB0aGlzLmZyYW1lLnRpbWVEaWZmO1xuICAgICAgICAgICAgdGhpcy5mcmFtZS5mcmFtZVJhdGUgPSAxMDAwIC8gdGhpcy5mcmFtZS50aW1lRGlmZjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgS29udmEuQW5pbWF0aW9uLmFuaW1hdGlvbnMgPSBbXTtcbiAgICBLb252YS5BbmltYXRpb24uYW5pbUlkQ291bnRlciA9IDA7XG4gICAgS29udmEuQW5pbWF0aW9uLmFuaW1SdW5uaW5nID0gZmFsc2U7XG5cbiAgICBLb252YS5BbmltYXRpb24uX2FkZEFuaW1hdGlvbiA9IGZ1bmN0aW9uKGFuaW0pIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zLnB1c2goYW5pbSk7XG4gICAgICAgIHRoaXMuX2hhbmRsZUFuaW1hdGlvbigpO1xuICAgIH07XG4gICAgS29udmEuQW5pbWF0aW9uLl9yZW1vdmVBbmltYXRpb24gPSBmdW5jdGlvbihhbmltKSB7XG4gICAgICAgIHZhciBpZCA9IGFuaW0uaWQsXG4gICAgICAgICAgICBhbmltYXRpb25zID0gdGhpcy5hbmltYXRpb25zLFxuICAgICAgICAgICAgbGVuID0gYW5pbWF0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICBuO1xuXG4gICAgICAgIGZvcihuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICBpZihhbmltYXRpb25zW25dLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucy5zcGxpY2UobiwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS29udmEuQW5pbWF0aW9uLl9ydW5GcmFtZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxheWVySGFzaCA9IHt9LFxuICAgICAgICAgICAgYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucyxcbiAgICAgICAgICAgIGFuaW0sIGxheWVycywgZnVuYywgbiwgaSwgbGF5ZXJzTGVuLCBsYXllciwga2V5LCBuZWVkUmVkcmF3O1xuICAgICAgICAvKlxuICAgICAgICAgKiBsb29wIHRocm91Z2ggYWxsIGFuaW1hdGlvbnMgYW5kIGV4ZWN1dGUgYW5pbWF0aW9uXG4gICAgICAgICAqICBmdW5jdGlvbi4gIGlmIHRoZSBhbmltYXRpb24gb2JqZWN0IGhhcyBzcGVjaWZpZWQgbm9kZSxcbiAgICAgICAgICogIHdlIGNhbiBhZGQgdGhlIG5vZGUgdG8gdGhlIG5vZGVzIGhhc2ggdG8gZWxpbWluYXRlXG4gICAgICAgICAqICBkcmF3aW5nIHRoZSBzYW1lIG5vZGUgbXVsdGlwbGUgdGltZXMuICBUaGUgbm9kZSBwcm9wZXJ0eVxuICAgICAgICAgKiAgY2FuIGJlIHRoZSBzdGFnZSBpdHNlbGYgb3IgYSBsYXllclxuICAgICAgICAgKi9cbiAgICAgICAgLypcbiAgICAgICAgICogV0FSTklORzogZG9uJ3QgY2FjaGUgYW5pbWF0aW9ucy5sZW5ndGggYmVjYXVzZSBpdCBjb3VsZCBjaGFuZ2Ugd2hpbGVcbiAgICAgICAgICogdGhlIGZvciBsb29wIGlzIHJ1bm5pbmcsIGNhdXNpbmcgYSBKUyBlcnJvclxuICAgICAgICAgKi9cblxuICAgICAgICBmb3IobiA9IDA7IG4gPCBhbmltYXRpb25zLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICBhbmltID0gYW5pbWF0aW9uc1tuXTtcbiAgICAgICAgICAgIGxheWVycyA9IGFuaW0ubGF5ZXJzO1xuICAgICAgICAgICAgZnVuYyA9IGFuaW0uZnVuYztcblxuXG4gICAgICAgICAgICBhbmltLl91cGRhdGVGcmFtZU9iamVjdChub3coKSk7XG4gICAgICAgICAgICBsYXllcnNMZW4gPSBsYXllcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBpZiBhbmltYXRpb24gb2JqZWN0IGhhcyBhIGZ1bmN0aW9uLCBleGVjdXRlIGl0XG4gICAgICAgICAgICBpZiAoZnVuYykge1xuICAgICAgICAgICAgICAgIC8vIGFsbG93IGFuaW0gYnlwYXNzaW5nIGRyYXdpbmdcbiAgICAgICAgICAgICAgICBuZWVkUmVkcmF3ID0gKGZ1bmMuY2FsbChhbmltLCBhbmltLmZyYW1lKSAhPT0gZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZWVkUmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmVlZFJlZHJhdykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxheWVyc0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIgPSBsYXllcnNbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIuX2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJIYXNoW2xheWVyLl9pZF0gPSBsYXllcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGtleSBpbiBsYXllckhhc2gpIHtcbiAgICAgICAgICAgIGlmICghbGF5ZXJIYXNoLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxheWVySGFzaFtrZXldLmRyYXcoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgS29udmEuQW5pbWF0aW9uLl9hbmltYXRpb25Mb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBBbmltID0gS29udmEuQW5pbWF0aW9uO1xuICAgICAgICBpZihBbmltLmFuaW1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbUZyYW1lKEFuaW0uX2FuaW1hdGlvbkxvb3ApO1xuICAgICAgICAgICAgQW5pbS5fcnVuRnJhbWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBBbmltLmFuaW1SdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEtvbnZhLkFuaW1hdGlvbi5faGFuZGxlQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKCF0aGlzLmFuaW1SdW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1SdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkxvb3AoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBiYXRjaCBkcmF3XG4gICAgICogQG1ldGhvZFxuICAgICAqIEByZXR1cm4ge0tvbnZhLkxheWVyfSB0aGlzXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkJhc2UucHJvdG90eXBlXG4gICAgICovXG4gICAgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZS5iYXRjaERyYXcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgQW5pbSA9IEtvbnZhLkFuaW1hdGlvbjtcblxuICAgICAgICBpZiAoIXRoaXMuYmF0Y2hBbmltKSB7XG4gICAgICAgICAgICB0aGlzLmJhdGNoQW5pbSA9IG5ldyBBbmltKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGF0Lmxhc3RCYXRjaERyYXdUaW1lICYmIG5vdygpIC0gdGhhdC5sYXN0QmF0Y2hEcmF3VGltZSA+IEJBVENIX0RSQVdfU1RPUF9USU1FX0RJRkYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5iYXRjaEFuaW0uc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0QmF0Y2hEcmF3VGltZSA9IG5vdygpO1xuXG4gICAgICAgIGlmICghdGhpcy5iYXRjaEFuaW0uaXNSdW5uaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgICAgICAgdGhpcy5iYXRjaEFuaW0uc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYmF0Y2ggZHJhd1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcmV0dXJuIHtLb252YS5TdGFnZX0gdGhpc1xuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBLb252YS5TdGFnZS5wcm90b3R5cGUuYmF0Y2hEcmF3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgICAgICBsYXllci5iYXRjaERyYXcoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG59KShLb252YSk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGJsYWNrbGlzdCA9IHtcbiAgICAgICAgbm9kZTogMSxcbiAgICAgICAgZHVyYXRpb246IDEsXG4gICAgICAgIGVhc2luZzogMSxcbiAgICAgICAgb25GaW5pc2g6IDEsXG4gICAgICAgIHlveW86IDFcbiAgICB9LFxuXG4gICAgUEFVU0VEID0gMSxcbiAgICBQTEFZSU5HID0gMixcbiAgICBSRVZFUlNJTkcgPSAzLFxuXG4gICAgaWRDb3VudGVyID0gMCxcbiAgICBjb2xvckF0dHJzID0gWydmaWxsJywgJ3N0cm9rZScsICdzaGFkb3dDb2xvciddO1xuXG4gICAgdmFyIFR3ZWVuID0gZnVuY3Rpb24ocHJvcCwgcHJvcEZ1bmMsIGZ1bmMsIGJlZ2luLCBmaW5pc2gsIGR1cmF0aW9uLCB5b3lvKSB7XG4gICAgICAgIHRoaXMucHJvcCA9IHByb3A7XG4gICAgICAgIHRoaXMucHJvcEZ1bmMgPSBwcm9wRnVuYztcbiAgICAgICAgdGhpcy5iZWdpbiA9IGJlZ2luO1xuICAgICAgICB0aGlzLl9wb3MgPSBiZWdpbjtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICB0aGlzLl9jaGFuZ2UgPSAwO1xuICAgICAgICB0aGlzLnByZXZQb3MgPSAwO1xuICAgICAgICB0aGlzLnlveW8gPSB5b3lvO1xuICAgICAgICB0aGlzLl90aW1lID0gMDtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSAwO1xuICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSAwO1xuICAgICAgICB0aGlzLl9maW5pc2ggPSAwO1xuICAgICAgICB0aGlzLmZ1bmMgPSBmdW5jO1xuICAgICAgICB0aGlzLl9jaGFuZ2UgPSBmaW5pc2ggLSB0aGlzLmJlZ2luO1xuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgfTtcbiAgICAvKlxuICAgICAqIFR3ZWVuIG1ldGhvZHNcbiAgICAgKi9cbiAgICBUd2Vlbi5wcm90b3R5cGUgPSB7XG4gICAgICAgIGZpcmU6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzW3N0cl07XG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0VGltZTogZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgaWYodCA+IHRoaXMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnlveW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZSA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy55b3lvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lID0gdDtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRUaW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2UG9zID0gdGhpcy5fcG9zO1xuICAgICAgICAgICAgdGhpcy5wcm9wRnVuYyhwKTtcbiAgICAgICAgICAgIHRoaXMuX3BvcyA9IHA7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFBvc2l0aW9uOiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICBpZih0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0ID0gdGhpcy5fdGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bmModCwgdGhpcy5iZWdpbiwgdGhpcy5fY2hhbmdlLCB0aGlzLmR1cmF0aW9uKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gUExBWUlORztcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHRoaXMuZ2V0VGltZXIoKSAtIHRoaXMuX3RpbWU7XG4gICAgICAgICAgICB0aGlzLm9uRW50ZXJGcmFtZSgpO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdvblBsYXknKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmV2ZXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gUkVWRVJTSU5HO1xuICAgICAgICAgICAgdGhpcy5fdGltZSA9IHRoaXMuZHVyYXRpb24gLSB0aGlzLl90aW1lO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gdGhpcy5nZXRUaW1lcigpIC0gdGhpcy5fdGltZTtcbiAgICAgICAgICAgIHRoaXMub25FbnRlckZyYW1lKCk7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ29uUmV2ZXJzZScpO1xuICAgICAgICB9LFxuICAgICAgICBzZWVrOiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICB0aGlzLl90aW1lID0gdDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ29uU2VlaycpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICB0aGlzLl90aW1lID0gMDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ29uUmVzZXQnKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmluaXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWUgPSB0aGlzLmR1cmF0aW9uO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnb25GaW5pc2gnKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24odGhpcy5nZXRQb3NpdGlvbih0aGlzLl90aW1lKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRW50ZXJGcmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdCA9IHRoaXMuZ2V0VGltZXIoKSAtIHRoaXMuX3N0YXJ0VGltZTtcbiAgICAgICAgICAgIGlmKHRoaXMuc3RhdGUgPT09IFBMQVlJTkcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRpbWUodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBSRVZFUlNJTkcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRpbWUodGhpcy5kdXJhdGlvbiAtIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwYXVzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gUEFVU0VEO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdvblBhdXNlJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFRpbWVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUd2VlbiBjb25zdHJ1Y3Rvci4gIFR3ZWVucyBlbmFibGUgeW91IHRvIGFuaW1hdGUgYSBub2RlIGJldHdlZW4gdGhlIGN1cnJlbnQgc3RhdGUgYW5kIGEgbmV3IHN0YXRlLlxuICAgICAqICBZb3UgY2FuIHBsYXksIHBhdXNlLCByZXZlcnNlLCBzZWVrLCByZXNldCwgYW5kIGZpbmlzaCB0d2VlbnMuICBCeSBkZWZhdWx0LCB0d2VlbnMgYXJlIGFuaW1hdGVkIHVzaW5nXG4gICAgICogIGEgbGluZWFyIGVhc2luZy4gIEZvciBtb3JlIHR3ZWVuaW5nIG9wdGlvbnMsIGNoZWNrIG91dCB7QGxpbmsgS29udmEuRWFzaW5nc31cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGluc3RhbnRpYXRlIG5ldyB0d2VlbiB3aGljaCBmdWxseSByb3RhdGVzIGEgbm9kZSBpbiAxIHNlY29uZFxuICAgICAqIHZhciB0d2VlbiA9IG5ldyBLb252YS5Ud2Vlbih7XG4gICAgICogICBub2RlOiBub2RlLFxuICAgICAqICAgcm90YXRpb25EZWc6IDM2MCxcbiAgICAgKiAgIGR1cmF0aW9uOiAxLFxuICAgICAqICAgZWFzaW5nOiBLb252YS5FYXNpbmdzLkVhc2VJbk91dFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gcGxheSB0d2VlblxuICAgICAqIHR3ZWVuLnBsYXkoKTtcbiAgICAgKlxuICAgICAqIC8vIHBhdXNlIHR3ZWVuXG4gICAgICogdHdlZW4ucGF1c2UoKTtcbiAgICAgKi9cbiAgICBLb252YS5Ud2VlbiA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICBub2RlID0gY29uZmlnLm5vZGUsXG4gICAgICAgICAgICBub2RlSWQgPSBub2RlLl9pZCxcbiAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgICAgZWFzaW5nID0gY29uZmlnLmVhc2luZyB8fCBLb252YS5FYXNpbmdzLkxpbmVhcixcbiAgICAgICAgICAgIHlveW8gPSAhIWNvbmZpZy55b3lvLFxuICAgICAgICAgICAga2V5O1xuXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnLmR1cmF0aW9uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZHVyYXRpb24gPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5kdXJhdGlvbiA9PT0gMCkgeyAgLy8gemVybyBpcyBiYWQgdmFsdWUgZm9yIGR1cmF0aW9uXG4gICAgICAgICAgICBkdXJhdGlvbiA9IDAuMDAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBjb25maWcuZHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5faWQgPSBpZENvdW50ZXIrKztcblxuICAgICAgICB0aGlzLmFuaW0gPSBuZXcgS29udmEuQW5pbWF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhhdC50d2Vlbi5vbkVudGVyRnJhbWUoKTtcbiAgICAgICAgfSwgbm9kZS5nZXRMYXllcigpIHx8ICgobm9kZSBpbnN0YW5jZW9mIEtvbnZhLlN0YWdlKSA/IG5vZGUuZ2V0TGF5ZXJzKCkgOiBudWxsKSk7XG5cbiAgICAgICAgdGhpcy50d2VlbiA9IG5ldyBUd2VlbihrZXksIGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgIHRoYXQuX3R3ZWVuRnVuYyhpKTtcbiAgICAgICAgfSwgZWFzaW5nLCAwLCAxLCBkdXJhdGlvbiAqIDEwMDAsIHlveW8pO1xuXG4gICAgICAgIHRoaXMuX2FkZExpc3RlbmVycygpO1xuXG4gICAgICAgIC8vIGluaXQgYXR0cnMgbWFwXG4gICAgICAgIGlmICghS29udmEuVHdlZW4uYXR0cnNbbm9kZUlkXSkge1xuICAgICAgICAgICAgS29udmEuVHdlZW4uYXR0cnNbbm9kZUlkXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghS29udmEuVHdlZW4uYXR0cnNbbm9kZUlkXVt0aGlzLl9pZF0pIHtcbiAgICAgICAgICAgIEtvbnZhLlR3ZWVuLmF0dHJzW25vZGVJZF1bdGhpcy5faWRdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5pdCB0d2VlbnMgbWFwXG4gICAgICAgIGlmICghS29udmEuVHdlZW4udHdlZW5zW25vZGVJZF0pIHtcbiAgICAgICAgICAgIEtvbnZhLlR3ZWVuLnR3ZWVuc1tub2RlSWRdID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGtleSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIGlmIChibGFja2xpc3Rba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkQXR0cihrZXksIGNvbmZpZ1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgICAvLyBjYWxsYmFja3NcbiAgICAgICAgdGhpcy5vbkZpbmlzaCA9IGNvbmZpZy5vbkZpbmlzaDtcbiAgICAgICAgdGhpcy5vblJlc2V0ID0gY29uZmlnLm9uUmVzZXQ7XG4gICAgfTtcblxuICAgIC8vIHN0YXJ0L2RpZmYgb2JqZWN0ID0gYXR0cnMubm9kZUlkLnR3ZWVuSWQuYXR0clxuICAgIEtvbnZhLlR3ZWVuLmF0dHJzID0ge307XG4gICAgLy8gdHdlZW5JZCA9IHR3ZWVucy5ub2RlSWQuYXR0clxuICAgIEtvbnZhLlR3ZWVuLnR3ZWVucyA9IHt9O1xuXG4gICAgS29udmEuVHdlZW4ucHJvdG90eXBlID0ge1xuICAgICAgICBfYWRkQXR0cjogZnVuY3Rpb24oa2V5LCBlbmQpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlLFxuICAgICAgICAgICAgICAgIG5vZGVJZCA9IG5vZGUuX2lkLFxuICAgICAgICAgICAgICAgIHN0YXJ0LCBkaWZmLCB0d2VlbklkLCBuLCBsZW4sIHRydWVFbmQsIHRydWVTdGFydDtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGNvbmZsaWN0IGZyb20gdHdlZW4gbWFwIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgdHdlZW5JZCA9IEtvbnZhLlR3ZWVuLnR3ZWVuc1tub2RlSWRdW2tleV07XG5cbiAgICAgICAgICAgIGlmICh0d2VlbklkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIEtvbnZhLlR3ZWVuLmF0dHJzW25vZGVJZF1bdHdlZW5JZF1ba2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWRkIHRvIHR3ZWVuIG1hcFxuICAgICAgICAgICAgc3RhcnQgPSBub2RlLmdldEF0dHIoa2V5KTtcblxuICAgICAgICAgICAgaWYgKEtvbnZhLlV0aWwuX2lzQXJyYXkoZW5kKSkge1xuICAgICAgICAgICAgICAgIGRpZmYgPSBbXTtcbiAgICAgICAgICAgICAgICBsZW4gPSBNYXRoLm1heChlbmQubGVuZ3RoLCBzdGFydC5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3BvaW50cycgJiYgZW5kLmxlbmd0aCAhPT0gc3RhcnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJlZm9yZSB0d2VlbmluZyBwb2ludHMgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCBzdGFydC5sZW5ndGggPT09IGVuZC5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgLy8gS29udmEuVXRpbC5fcHJlcGFyZUFycmF5Rm9yVHdlZW4gdGhpbmtpbmcgdGhhdCBlbmQubGVuZ3RoID4gc3RhcnQubGVuZ3RoXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZC5sZW5ndGggPiBzdGFydC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIGluIHRoaXMgY2FzZSB3ZSB3aWxsIGluY3JlYXNlIG51bWJlciBvZiBzdGFydGluZyBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWVTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBLb252YS5VdGlsLl9wcmVwYXJlQXJyYXlGb3JUd2VlbihzdGFydCwgZW5kLCBub2RlLmNsb3NlZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3aWxsIGluY3JlYXNlIG51bWJlciBvZiBlZGluZyBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWVFbmQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBLb252YS5VdGlsLl9wcmVwYXJlQXJyYXlGb3JUd2VlbihlbmQsIHN0YXJ0LCBub2RlLmNsb3NlZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgICAgICBkaWZmLnB1c2goKGVuZFtuXSkgLSAoc3RhcnRbbl0pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sb3JBdHRycy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBLb252YS5VdGlsLmNvbG9yVG9SR0JBKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kUkdCQSA9IEtvbnZhLlV0aWwuY29sb3JUb1JHQkEoZW5kKTtcbiAgICAgICAgICAgICAgICBkaWZmID0ge1xuICAgICAgICAgICAgICAgICAgICByOiBlbmRSR0JBLnIgLSBzdGFydC5yLFxuICAgICAgICAgICAgICAgICAgICBnOiBlbmRSR0JBLmcgLSBzdGFydC5nLFxuICAgICAgICAgICAgICAgICAgICBiOiBlbmRSR0JBLmIgLSBzdGFydC5iLFxuICAgICAgICAgICAgICAgICAgICBhOiBlbmRSR0JBLmEgLSBzdGFydC5hXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlmZiA9IGVuZCAtIHN0YXJ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBLb252YS5Ud2Vlbi5hdHRyc1tub2RlSWRdW3RoaXMuX2lkXVtrZXldID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBkaWZmOiBkaWZmLFxuICAgICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICAgIHRydWVFbmQ6IHRydWVFbmQsXG4gICAgICAgICAgICAgICAgdHJ1ZVN0YXJ0OiB0cnVlU3RhcnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBLb252YS5Ud2Vlbi50d2VlbnNbbm9kZUlkXVtrZXldID0gdGhpcy5faWQ7XG4gICAgICAgIH0sXG4gICAgICAgIF90d2VlbkZ1bmM6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlLFxuICAgICAgICAgICAgICAgIGF0dHJzID0gS29udmEuVHdlZW4uYXR0cnNbbm9kZS5faWRdW3RoaXMuX2lkXSxcbiAgICAgICAgICAgICAgICBrZXksIGF0dHIsIHN0YXJ0LCBkaWZmLCBuZXdWYWwsIG4sIGxlbiwgZW5kO1xuXG4gICAgICAgICAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgICAgICAgICAgIGF0dHIgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gYXR0ci5zdGFydDtcbiAgICAgICAgICAgICAgICBkaWZmID0gYXR0ci5kaWZmO1xuICAgICAgICAgICAgICAgIGVuZCA9IGF0dHIuZW5kO1xuXG4gICAgICAgICAgICAgICAgaWYgKEtvbnZhLlV0aWwuX2lzQXJyYXkoc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBsZW4gPSBNYXRoLm1heChzdGFydC5sZW5ndGgsIGVuZC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbC5wdXNoKChzdGFydFtuXSB8fCAwKSArIChkaWZmW25dICogaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2xvckF0dHJzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsID0gJ3JnYmEoJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZChzdGFydC5yICsgZGlmZi5yICogaSkgKyAnLCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucm91bmQoc3RhcnQuZyArIGRpZmYuZyAqIGkpICsgJywnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKHN0YXJ0LmIgKyBkaWZmLmIgKiBpKSArICcsJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXJ0LmEgKyBkaWZmLmEgKiBpKSArICcpJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWwgPSBzdGFydCArIChkaWZmICogaSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyKGtleSwgbmV3VmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2FkZExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IGxpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy50d2Vlbi5vblBsYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmFuaW0uc3RhcnQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnR3ZWVuLm9uUmV2ZXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuYW5pbS5zdGFydCgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gc3RvcCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHRoaXMudHdlZW4ub25QYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuYW5pbS5zdG9wKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy50d2Vlbi5vbkZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhhdC5ub2RlO1xuXG4gICAgICAgICAgICAgICAgLy8gYWZ0ZXIgdHdlZW5pbmcgIHBvaW50cyBvZiBsaW5lIHdlIG5lZWQgdG8gc2V0IG9yaWdpbmFsIGVuZFxuICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IEtvbnZhLlR3ZWVuLmF0dHJzW25vZGUuX2lkXVt0aGF0Ll9pZF07XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJzLnBvaW50cyAmJiBhdHRycy5wb2ludHMudHJ1ZUVuZCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnBvaW50cyhhdHRycy5wb2ludHMudHJ1ZUVuZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoYXQub25GaW5pc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5vbkZpbmlzaC5jYWxsKHRoYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnR3ZWVuLm9uUmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoYXQubm9kZTtcbiAgICAgICAgICAgICAgICAvLyBhZnRlciB0d2VlbmluZyAgcG9pbnRzIG9mIGxpbmUgd2UgbmVlZCB0byBzZXQgb3JpZ2luYWwgc3RhcnRcbiAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBLb252YS5Ud2Vlbi5hdHRyc1tub2RlLl9pZF1bdGhhdC5faWRdO1xuICAgICAgICAgICAgICAgIGlmIChhdHRycy5wb2ludHMgJiYgYXR0cnMucG9pbnRzLnRydWVTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnBvaW50cyhhdHRycy5wb2ludHMudHJ1ZVN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhhdC5vblJlc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQub25SZXNldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwbGF5XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlR3ZWVuLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7VHdlZW59XG4gICAgICAgICAqL1xuICAgICAgICBwbGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMudHdlZW4ucGxheSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXZlcnNlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlR3ZWVuLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7VHdlZW59XG4gICAgICAgICAqL1xuICAgICAgICByZXZlcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMudHdlZW4ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXNldFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ud2Vlbi5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge1R3ZWVufVxuICAgICAgICAgKi9cbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy50d2Vlbi5yZXNldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZWVrXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlR3ZWVuLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHQgdGltZSBpbiBzZWNvbmRzIGJldHdlZW4gMCBhbmQgdGhlIGR1cmF0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHtUd2Vlbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlZWs6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHRoaXMudHdlZW4uc2Vlayh0ICogMTAwMCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHBhdXNlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlR3ZWVuLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7VHdlZW59XG4gICAgICAgICAqL1xuICAgICAgICBwYXVzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnR3ZWVuLnBhdXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZpbmlzaFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ud2Vlbi5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge1R3ZWVufVxuICAgICAgICAgKi9cbiAgICAgICAgZmluaXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMudHdlZW4uZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRlc3Ryb3lcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHdlZW4ucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBub2RlSWQgPSB0aGlzLm5vZGUuX2lkLFxuICAgICAgICAgICAgICAgIHRoaXNJZCA9IHRoaXMuX2lkLFxuICAgICAgICAgICAgICAgIGF0dHJzID0gS29udmEuVHdlZW4udHdlZW5zW25vZGVJZF0sXG4gICAgICAgICAgICAgICAga2V5O1xuXG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG5cbiAgICAgICAgICAgIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIEtvbnZhLlR3ZWVuLnR3ZWVuc1tub2RlSWRdW2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBLb252YS5Ud2Vlbi5hdHRyc1tub2RlSWRdW3RoaXNJZF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHdlZW4gbm9kZSBwcm9wZXJ0aWVzLiBTaG9ydGVyIHVzYWdlIG9mIHtAbGluayBLb252YS5Ud2Vlbn0gb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBLb252YS5Ob2RlI3RvXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gdHdlZW4gcGFyYW1zXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGNpcmNsZS50byh7XG4gICAgICogIHggOiA1MCxcbiAgICAgKiAgZHVyYXRpb24gOiAwLjVcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBLb252YS5Ob2RlLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgb25GaW5pc2ggPSBwYXJhbXMub25GaW5pc2g7XG4gICAgICAgIHBhcmFtcy5ub2RlID0gdGhpcztcbiAgICAgICAgcGFyYW1zLm9uRmluaXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgICAgICAgICAgIG9uRmluaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0d2VlbiA9IG5ldyBLb252YS5Ud2VlbihwYXJhbXMpO1xuICAgICAgICB0d2Vlbi5wbGF5KCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgKiBUaGVzZSBlYXNlcyB3ZXJlIHBvcnRlZCBmcm9tIGFuIEFkb2JlIEZsYXNoIHR3ZWVuaW5nIGxpYnJhcnkgdG8gSmF2YVNjcmlwdFxuICAgICogYnkgWGFyaWNcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZSBFYXNpbmdzXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICovXG4gICAgS29udmEuRWFzaW5ncyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICogYmFjayBlYXNlIGluXG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICAgICAgJ0JhY2tFYXNlSW4nOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqICgocyArIDEpICogdCAtIHMpICsgYjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogYmFjayBlYXNlIG91dFxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgICAgICdCYWNrRWFzZU91dCc6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgICAgIHJldHVybiBjICogKCggdCA9IHQgLyBkIC0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxKSArIGI7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIGJhY2sgZWFzZSBpbiBvdXRcbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgICAgICAnQmFja0Vhc2VJbk91dCc6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgICAgIGlmKCh0IC89IGQgLyAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYyAvIDIgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpICsgYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjIC8gMiAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0ICsgcykgKyAyKSArIGI7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIGVsYXN0aWMgZWFzZSBpblxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgICAgICdFbGFzdGljRWFzZUluJzogZnVuY3Rpb24odCwgYiwgYywgZCwgYSwgcCkge1xuICAgICAgICAgICAgLy8gYWRkZWQgcyA9IDBcbiAgICAgICAgICAgIHZhciBzID0gMDtcbiAgICAgICAgICAgIGlmKHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCh0IC89IGQpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGIgKyBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIXApIHtcbiAgICAgICAgICAgICAgICBwID0gZCAqIDAuMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCFhIHx8IGEgPCBNYXRoLmFicyhjKSkge1xuICAgICAgICAgICAgICAgIGEgPSBjO1xuICAgICAgICAgICAgICAgIHMgPSBwIC8gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbihjIC8gYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLShhICogTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAqIGQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSkgKyBiO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBlbGFzdGljIGVhc2Ugb3V0XG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICAgICAgJ0VsYXN0aWNFYXNlT3V0JzogZnVuY3Rpb24odCwgYiwgYywgZCwgYSwgcCkge1xuICAgICAgICAgICAgLy8gYWRkZWQgcyA9IDBcbiAgICAgICAgICAgIHZhciBzID0gMDtcbiAgICAgICAgICAgIGlmKHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCh0IC89IGQpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGIgKyBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIXApIHtcbiAgICAgICAgICAgICAgICBwID0gZCAqIDAuMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCFhIHx8IGEgPCBNYXRoLmFicyhjKSkge1xuICAgICAgICAgICAgICAgIGEgPSBjO1xuICAgICAgICAgICAgICAgIHMgPSBwIC8gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbihjIC8gYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGEgKiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0ICogZCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICsgYyArIGIpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBlbGFzdGljIGVhc2UgaW4gb3V0XG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICAgICAgJ0VsYXN0aWNFYXNlSW5PdXQnOiBmdW5jdGlvbih0LCBiLCBjLCBkLCBhLCBwKSB7XG4gICAgICAgICAgICAvLyBhZGRlZCBzID0gMFxuICAgICAgICAgICAgdmFyIHMgPSAwO1xuICAgICAgICAgICAgaWYodCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoKHQgLz0gZCAvIDIpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGIgKyBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIXApIHtcbiAgICAgICAgICAgICAgICBwID0gZCAqICgwLjMgKiAxLjUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIWEgfHwgYSA8IE1hdGguYWJzKGMpKSB7XG4gICAgICAgICAgICAgICAgYSA9IGM7XG4gICAgICAgICAgICAgICAgcyA9IHAgLyA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKGMgLyBhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHQgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoYSAqIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgKiBkIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpICsgYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgKiBkIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKiAwLjUgKyBjICsgYjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogYm91bmNlIGVhc2Ugb3V0XG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICAgICAgJ0JvdW5jZUVhc2VPdXQnOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgICBpZigodCAvPSBkKSA8ICgxIC8gMi43NSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiB0ICogdCkgKyBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZih0IDwgKDIgLyAyLjc1KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjICogKDcuNTYyNSAqICh0IC09ICgxLjUgLyAyLjc1KSkgKiB0ICsgMC43NSkgKyBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZih0IDwgKDIuNSAvIDIuNzUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gKDIuMjUgLyAyLjc1KSkgKiB0ICsgMC45Mzc1KSArIGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAoMi42MjUgLyAyLjc1KSkgKiB0ICsgMC45ODQzNzUpICsgYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogYm91bmNlIGVhc2UgaW5cbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgICAgICAnQm91bmNlRWFzZUluJzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgcmV0dXJuIGMgLSBLb252YS5FYXNpbmdzLkJvdW5jZUVhc2VPdXQoZCAtIHQsIDAsIGMsIGQpICsgYjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogYm91bmNlIGVhc2UgaW4gb3V0XG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICAgICAgJ0JvdW5jZUVhc2VJbk91dCc6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgICAgIGlmKHQgPCBkIC8gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBLb252YS5FYXNpbmdzLkJvdW5jZUVhc2VJbih0ICogMiwgMCwgYywgZCkgKiAwLjUgKyBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEtvbnZhLkVhc2luZ3MuQm91bmNlRWFzZU91dCh0ICogMiAtIGQsIDAsIGMsIGQpICogMC41ICsgYyAqIDAuNSArIGI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIGVhc2UgaW5cbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgICAgICAnRWFzZUluJzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKyBiO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBlYXNlIG91dFxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgICAgICdFYXNlT3V0JzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgcmV0dXJuIC1jICogKHQgLz0gZCkgKiAodCAtIDIpICsgYjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogZWFzZSBpbiBvdXRcbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgICAgICAnRWFzZUluT3V0JzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgaWYoKHQgLz0gZCAvIDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjIC8gMiAqIHQgKiB0ICsgYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtYyAvIDIgKiAoKC0tdCkgKiAodCAtIDIpIC0gMSkgKyBiO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBzdHJvbmcgZWFzZSBpblxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgICAgICdTdHJvbmdFYXNlSW4nOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqIHQgKiB0ICogdCArIGI7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIHN0cm9uZyBlYXNlIG91dFxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgICAgICdTdHJvbmdFYXNlT3V0JzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgcmV0dXJuIGMgKiAoKCB0ID0gdCAvIGQgLSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxKSArIGI7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIHN0cm9uZyBlYXNlIGluIG91dFxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgICAgICdTdHJvbmdFYXNlSW5PdXQnOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgICBpZigodCAvPSBkIC8gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpICsgYjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogbGluZWFyXG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICAgICAgJ0xpbmVhcic6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjICogdCAvIGQgKyBiO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgS29udmEuREQgPSB7XG4gICAgICAgIC8vIHByb3BlcnRpZXNcbiAgICAgICAgYW5pbTogbmV3IEtvbnZhLkFuaW1hdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5kaXJ0eTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9KSxcbiAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIGp1c3REcmFnZ2VkOiBmYWxzZSxcbiAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9LFxuICAgICAgICBub2RlOiBudWxsLFxuXG4gICAgICAgIC8vIG1ldGhvZHNcbiAgICAgICAgX2RyYWc6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgdmFyIGRkID0gS29udmEuREQsXG4gICAgICAgICAgICAgICAgbm9kZSA9IGRkLm5vZGU7XG5cbiAgICAgICAgICAgIGlmKG5vZGUpIHtcbiAgICAgICAgICAgICAgIGlmKCFkZC5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBub2RlLmdldFN0YWdlKCkuZ2V0UG9pbnRlclBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkcmFnRGlzdGFuY2UgPSBub2RlLmRyYWdEaXN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKHBvcy54IC0gZGQuc3RhcnRQb2ludGVyUG9zLngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMocG9zLnkgLSBkZC5zdGFydFBvaW50ZXJQb3MueSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgZHJhZ0Rpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIG5vZGUuZ2V0U3RhZ2UoKS5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICAgICAgICAgICAgbm9kZS5fc2V0RHJhZ1Bvc2l0aW9uKGV2dCk7XG4gICAgICAgICAgICAgICAgaWYoIWRkLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGQuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZmlyZSgnZHJhZ3N0YXJ0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RyYWdzdGFydCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBleGVjdXRlIG9uZHJhZ21vdmUgaWYgZGVmaW5lZFxuICAgICAgICAgICAgICAgIG5vZGUuZmlyZSgnZHJhZ21vdmUnLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkcmFnbW92ZScsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2VuZERyYWdCZWZvcmU6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgdmFyIGRkID0gS29udmEuREQsXG4gICAgICAgICAgICAgICAgbm9kZSA9IGRkLm5vZGUsXG4gICAgICAgICAgICAgICAgbGF5ZXI7XG5cbiAgICAgICAgICAgIGlmKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBsYXllciA9IG5vZGUuZ2V0TGF5ZXIoKTtcbiAgICAgICAgICAgICAgICBkZC5hbmltLnN0b3AoKTtcblxuICAgICAgICAgICAgICAgIC8vIG9ubHkgZmlyZSBkcmFnZW5kIGV2ZW50IGlmIHRoZSBkcmFnIGFuZCBkcm9wXG4gICAgICAgICAgICAgICAgLy8gb3BlcmF0aW9uIGFjdHVhbGx5IHN0YXJ0ZWQuXG4gICAgICAgICAgICAgICAgaWYoZGQuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgICAgICBkZC5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRkLmp1c3REcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgS29udmEubGlzdGVuQ2xpY2tUYXAgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldnQuZHJhZ0VuZE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVsZXRlIGRkLm5vZGU7XG5cbiAgICAgICAgICAgICAgICAobGF5ZXIgfHwgbm9kZSkuZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfZW5kRHJhZ0FmdGVyOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIGV2dCA9IGV2dCB8fCB7fTtcbiAgICAgICAgICAgIHZhciBkcmFnRW5kTm9kZSA9IGV2dC5kcmFnRW5kTm9kZTtcblxuICAgICAgICAgICAgaWYgKGV2dCAmJiBkcmFnRW5kTm9kZSkge1xuICAgICAgICAgICAgICAgIGRyYWdFbmROb2RlLmZpcmUoJ2RyYWdlbmQnLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkcmFnZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBkcmFnRW5kTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBOb2RlIGV4dGVuZGVyc1xuXG4gICAgLyoqXG4gICAgICogaW5pdGlhdGUgZHJhZyBhbmQgZHJvcFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zdGFydERyYWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRkID0gS29udmEuREQsXG4gICAgICAgICAgICBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKSxcbiAgICAgICAgICAgIGxheWVyID0gdGhpcy5nZXRMYXllcigpLFxuICAgICAgICAgICAgcG9zID0gc3RhZ2UuZ2V0UG9pbnRlclBvc2l0aW9uKCksXG4gICAgICAgICAgICBhcCA9IHRoaXMuZ2V0QWJzb2x1dGVQb3NpdGlvbigpO1xuXG4gICAgICAgIGlmKHBvcykge1xuICAgICAgICAgICAgaWYgKGRkLm5vZGUpIHtcbiAgICAgICAgICAgICAgICBkZC5ub2RlLnN0b3BEcmFnKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRkLm5vZGUgPSB0aGlzO1xuICAgICAgICAgICAgZGQuc3RhcnRQb2ludGVyUG9zID0gcG9zO1xuICAgICAgICAgICAgZGQub2Zmc2V0LnggPSBwb3MueCAtIGFwLng7XG4gICAgICAgICAgICBkZC5vZmZzZXQueSA9IHBvcy55IC0gYXAueTtcbiAgICAgICAgICAgIGRkLmFuaW0uc2V0TGF5ZXJzKGxheWVyIHx8IHRoaXMuZ2V0TGF5ZXJzKCkpO1xuICAgICAgICAgICAgZGQuYW5pbS5zdGFydCgpO1xuXG4gICAgICAgICAgICB0aGlzLl9zZXREcmFnUG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5fc2V0RHJhZ1Bvc2l0aW9uID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHZhciBkZCA9IEtvbnZhLkRELFxuICAgICAgICAgICAgcG9zID0gdGhpcy5nZXRTdGFnZSgpLmdldFBvaW50ZXJQb3NpdGlvbigpLFxuICAgICAgICAgICAgZGJmID0gdGhpcy5nZXREcmFnQm91bmRGdW5jKCk7XG4gICAgICAgIGlmICghcG9zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld05vZGVQb3MgPSB7XG4gICAgICAgICAgICB4OiBwb3MueCAtIGRkLm9mZnNldC54LFxuICAgICAgICAgICAgeTogcG9zLnkgLSBkZC5vZmZzZXQueVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmKGRiZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdOb2RlUG9zID0gZGJmLmNhbGwodGhpcywgbmV3Tm9kZVBvcywgZXZ0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEFic29sdXRlUG9zaXRpb24obmV3Tm9kZVBvcyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9sYXN0UG9zIHx8IHRoaXMuX2xhc3RQb3MueCAhPT0gbmV3Tm9kZVBvcy54IHx8XG4gICAgICAgICAgICB0aGlzLl9sYXN0UG9zLnkgIT09IG5ld05vZGVQb3MueSkge1xuICAgICAgICAgICAgZGQuYW5pbS5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sYXN0UG9zID0gbmV3Tm9kZVBvcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc3RvcCBkcmFnIGFuZCBkcm9wXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnN0b3BEcmFnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkZCA9IEtvbnZhLkRELFxuICAgICAgICAgICAgZXZ0ID0ge307XG4gICAgICAgIGRkLl9lbmREcmFnQmVmb3JlKGV2dCk7XG4gICAgICAgIGRkLl9lbmREcmFnQWZ0ZXIoZXZ0KTtcbiAgICB9O1xuXG4gICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0RHJhZ2dhYmxlID0gZnVuY3Rpb24oZHJhZ2dhYmxlKSB7XG4gICAgICAgIHRoaXMuX3NldEF0dHIoJ2RyYWdnYWJsZScsIGRyYWdnYWJsZSk7XG4gICAgICAgIHRoaXMuX2RyYWdDaGFuZ2UoKTtcbiAgICB9O1xuXG4gICAgdmFyIG9yaWdEZXN0cm95ID0gS29udmEuTm9kZS5wcm90b3R5cGUuZGVzdHJveTtcblxuICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRkID0gS29udmEuREQ7XG5cbiAgICAgICAgLy8gc3RvcCBERFxuICAgICAgICBpZihkZC5ub2RlICYmIGRkLm5vZGUuX2lkID09PSB0aGlzLl9pZCkge1xuXG4gICAgICAgICAgICB0aGlzLnN0b3BEcmFnKCk7XG4gICAgICAgIH1cblxuICAgICAgICBvcmlnRGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBkZXRlcm1pbmUgaWYgbm9kZSBpcyBjdXJyZW50bHkgaW4gZHJhZyBhbmQgZHJvcCBtb2RlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLmlzRHJhZ2dpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRkID0gS29udmEuREQ7XG4gICAgICAgIHJldHVybiAhIShkZC5ub2RlICYmIGRkLm5vZGUuX2lkID09PSB0aGlzLl9pZCAmJiBkZC5pc0RyYWdnaW5nKTtcbiAgICB9O1xuXG4gICAgS29udmEuTm9kZS5wcm90b3R5cGUuX2xpc3RlbkRyYWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX2RyYWdDbGVhbnVwKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZ2V0Q2xhc3NOYW1lKCkgPT09ICdTdGFnZScpIHtcbiAgICAgICAgICAgIHRoaXMub24oJ2NvbnRlbnRNb3VzZWRvd24ua29udmEgY29udGVudFRvdWNoc3RhcnQua29udmEnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICBpZighS29udmEuREQubm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnN0YXJ0RHJhZyhldnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbignbW91c2Vkb3duLmtvbnZhIHRvdWNoc3RhcnQua29udmEnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgcmlnaHQgYW5kIG1pZGRsZSBidXR0b25zXG4gICAgICAgICAgICAgICAgaWYgKGV2dC5ldnQuYnV0dG9uID09PSAxIHx8IGV2dC5ldnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoIUtvbnZhLkRELm5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zdGFydERyYWcoZXZ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxpc3RlbmluZyBpcyByZXF1aXJlZCBmb3IgZHJhZyBhbmQgZHJvcFxuICAgICAgICAvKlxuICAgICAgICB0aGlzLl9saXN0ZW5pbmdFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kQW5jZXN0b3JDYWNoZSgnbGlzdGVuaW5nRW5hYmxlZCcpO1xuICAgICAgICAqL1xuICAgIH07XG5cbiAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5fZHJhZ0NoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZih0aGlzLmF0dHJzLmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fbGlzdGVuRHJhZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy5fZHJhZ0NsZWFudXAoKTtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGZvcmNlIGRyYWcgYW5kIGRyb3AgdG8gZW5kXG4gICAgICAgICAgICAgKiBpZiB0aGlzIG5vZGUgaXMgY3VycmVudGx5IGluXG4gICAgICAgICAgICAgKiBkcmFnIGFuZCBkcm9wIG1vZGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpO1xuICAgICAgICAgICAgdmFyIGRkID0gS29udmEuREQ7XG4gICAgICAgICAgICBpZihzdGFnZSAmJiBkZC5ub2RlICYmIGRkLm5vZGUuX2lkID09PSB0aGlzLl9pZCkge1xuICAgICAgICAgICAgICAgIGRkLm5vZGUuc3RvcERyYWcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5fZHJhZ0NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0Q2xhc3NOYW1lKCkgPT09ICdTdGFnZScpIHtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdjb250ZW50TW91c2Vkb3duLmtvbnZhJyk7XG4gICAgICAgICAgICB0aGlzLm9mZignY29udGVudFRvdWNoc3RhcnQua29udmEnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdtb3VzZWRvd24ua29udmEnKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCd0b3VjaHN0YXJ0LmtvbnZhJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2RyYWdCb3VuZEZ1bmMnKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZHJhZyBib3VuZCBmdW5jdGlvbi4gIFRoaXMgaXMgdXNlZCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdFxuICAgICAqICBkcmFnIGFuZCBkcm9wIHBvc2l0aW9uXG4gICAgICogQG5hbWUgZHJhZ0JvdW5kRnVuY1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmFnQm91bmRGdW5jXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGRyYWcgYm91bmQgZnVuY3Rpb25cbiAgICAgKiB2YXIgZHJhZ0JvdW5kRnVuYyA9IG5vZGUuZHJhZ0JvdW5kRnVuYygpO1xuICAgICAqXG4gICAgICogLy8gY3JlYXRlIHZlcnRpY2FsIGRyYWcgYW5kIGRyb3BcbiAgICAgKiBub2RlLmRyYWdCb3VuZEZ1bmMoZnVuY3Rpb24ocG9zKXtcbiAgICAgKiAgIHJldHVybiB7XG4gICAgICogICAgIHg6IHRoaXMuZ2V0QWJzb2x1dGVQb3NpdGlvbigpLngsXG4gICAgICogICAgIHk6IHBvcy55XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXIoS29udmEuTm9kZSwgJ2RyYWdnYWJsZScsIGZhbHNlKTtcbiAgICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2RyYWdnYWJsZScpO1xuXG4gICAgIC8qKlxuICAgICAqIGdldC9zZXQgZHJhZ2dhYmxlIGZsYWdcbiAgICAgKiBAbmFtZSBkcmFnZ2FibGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkcmFnZ2FibGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBkcmFnZ2FibGUgZmxhZ1xuICAgICAqIHZhciBkcmFnZ2FibGUgPSBub2RlLmRyYWdnYWJsZSgpO1xuICAgICAqXG4gICAgICogLy8gZW5hYmxlIGRyYWcgYW5kIGRyb3BcbiAgICAgKiBub2RlLmRyYWdnYWJsZSh0cnVlKTtcbiAgICAgKlxuICAgICAqIC8vIGRpc2FibGUgZHJhZyBhbmQgZHJvcFxuICAgICAqIG5vZGUuZHJhZ2dhYmxlKGZhbHNlKTtcbiAgICAgKi9cblxuICAgIHZhciBodG1sID0gS29udmEuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIEtvbnZhLkRELl9lbmREcmFnQmVmb3JlLCB0cnVlKTtcbiAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgS29udmEuREQuX2VuZERyYWdCZWZvcmUsIHRydWUpO1xuXG4gICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBLb252YS5ERC5fZHJhZyk7XG4gICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBLb252YS5ERC5fZHJhZyk7XG5cbiAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBLb252YS5ERC5fZW5kRHJhZ0FmdGVyLCBmYWxzZSk7XG4gICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIEtvbnZhLkRELl9lbmREcmFnQWZ0ZXIsIGZhbHNlKTtcblxufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBSZWN0IGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNvcm5lclJhZGl1c11cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHJlY3QgPSBuZXcgS29udmEuUmVjdCh7XG4gICAgICogICB3aWR0aDogMTAwLFxuICAgICAqICAgaGVpZ2h0OiA1MCxcbiAgICAgKiAgIGZpbGw6ICdyZWQnLFxuICAgICAqICAgc3Ryb2tlOiAnYmxhY2snLFxuICAgICAqICAgc3Ryb2tlV2lkdGg6IDVcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBLb252YS5SZWN0ID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5SZWN0LnByb3RvdHlwZSA9IHtcbiAgICAgICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICdSZWN0JztcbiAgICAgICAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBjb3JuZXJSYWRpdXMgPSB0aGlzLmdldENvcm5lclJhZGl1cygpLFxuICAgICAgICAgICAgICAgIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgIGlmKCFjb3JuZXJSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAvLyBzaW1wbGUgcmVjdCAtIGRvbid0IGJvdGhlciBkb2luZyBhbGwgdGhhdCBjb21wbGljYXRlZCBtYXRocyBzdHVmZi5cbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGFyY1RvIHdvdWxkIGJlIG5pY2VyLCBidXQgYnJvd3NlciBzdXBwb3J0IGlzIHBhdGNoeSAoT3BlcmEpXG4gICAgICAgICAgICAgICAgY29ybmVyUmFkaXVzID0gTWF0aC5taW4oY29ybmVyUmFkaXVzLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKGNvcm5lclJhZGl1cywgMCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGggLSBjb3JuZXJSYWRpdXMsIDApO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYXJjKHdpZHRoIC0gY29ybmVyUmFkaXVzLCBjb3JuZXJSYWRpdXMsIGNvcm5lclJhZGl1cywgTWF0aC5QSSAqIDMgLyAyLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGgsIGhlaWdodCAtIGNvcm5lclJhZGl1cyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5hcmMod2lkdGggLSBjb3JuZXJSYWRpdXMsIGhlaWdodCAtIGNvcm5lclJhZGl1cywgY29ybmVyUmFkaXVzLCAwLCBNYXRoLlBJIC8gMiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGNvcm5lclJhZGl1cywgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFyYyhjb3JuZXJSYWRpdXMsIGhlaWdodCAtIGNvcm5lclJhZGl1cywgY29ybmVyUmFkaXVzLCBNYXRoLlBJIC8gMiwgTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDAsIGNvcm5lclJhZGl1cyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5hcmMoY29ybmVyUmFkaXVzLCBjb3JuZXJSYWRpdXMsIGNvcm5lclJhZGl1cywgTWF0aC5QSSwgTWF0aC5QSSAqIDMgLyAyLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuUmVjdCwgS29udmEuU2hhcGUpO1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuUmVjdCwgJ2Nvcm5lclJhZGl1cycsIDApO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgY29ybmVyIHJhZGl1c1xuICAgICAqIEBuYW1lIGNvcm5lclJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuUmVjdC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29ybmVyUmFkaXVzXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjb3JuZXIgcmFkaXVzXG4gICAgICogdmFyIGNvcm5lclJhZGl1cyA9IHJlY3QuY29ybmVyUmFkaXVzKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgY29ybmVyIHJhZGl1c1xuICAgICAqIHJlY3QuY29ybmVyUmFkaXVzKDEwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5SZWN0KTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gdGhlIDAuMDAwMSBvZmZzZXQgZml4ZXMgYSBidWcgaW4gQ2hyb21lIDI3XG4gICAgdmFyIFBJeDIgPSAoTWF0aC5QSSAqIDIpIC0gMC4wMDAxLFxuICAgICAgICBDSVJDTEUgPSAnQ2lyY2xlJztcblxuICAgIC8qKlxuICAgICAqIENpcmNsZSBjb25zdHJ1Y3RvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnJhZGl1c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBjcmVhdGUgY2lyY2xlXG4gICAgICogdmFyIGNpcmNsZSA9IG5ldyBLb252YS5DaXJjbGUoe1xuICAgICAqICAgcmFkaXVzOiA0MCxcbiAgICAgKiAgIGZpbGw6ICdyZWQnLFxuICAgICAqICAgc3Ryb2tlOiAnYmxhY2snXG4gICAgICogICBzdHJva2VXaWR0aDogNVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIEtvbnZhLkNpcmNsZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgICB9O1xuXG4gICAgS29udmEuQ2lyY2xlLnByb3RvdHlwZSA9IHtcbiAgICAgICAgX2NlbnRyb2lkOiB0cnVlLFxuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gQ0lSQ0xFO1xuICAgICAgICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHRoaXMuZ2V0UmFkaXVzKCksIDAsIFBJeDIsIGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0V2lkdGgoKVxuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSYWRpdXMoKSAqIDI7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldEhlaWdodCgpXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSYWRpdXMoKSAqIDI7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldFdpZHRoKClcbiAgICAgICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRXaWR0aC5jYWxsKHRoaXMsIHdpZHRoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhZGl1cygpICE9PSB3aWR0aCAvIDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJhZGl1cyh3aWR0aCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRIZWlnaHQoKVxuICAgICAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0LmNhbGwodGhpcywgaGVpZ2h0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhZGl1cygpICE9PSBoZWlnaHQgLyAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYWRpdXMoaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkNpcmNsZSwgS29udmEuU2hhcGUpO1xuXG4gICAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkNpcmNsZSwgJ3JhZGl1cycsIDApO1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5DaXJjbGUsICdyYWRpdXMnKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgcmFkaXVzXG4gICAgICogQG5hbWUgcmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5DaXJjbGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgcmFkaXVzXG4gICAgICogdmFyIHJhZGl1cyA9IGNpcmNsZS5yYWRpdXMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCByYWRpdXNcbiAgICAgKiBjaXJjbGUucmFkaXVzKDEwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5DaXJjbGUpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyB0aGUgMC4wMDAxIG9mZnNldCBmaXhlcyBhIGJ1ZyBpbiBDaHJvbWUgMjdcbiAgICB2YXIgUEl4MiA9IChNYXRoLlBJICogMikgLSAwLjAwMDEsXG4gICAgICAgIEVMTElQU0UgPSAnRWxsaXBzZSc7XG5cbiAgICAvKipcbiAgICAgKiBFbGxpcHNlIGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcucmFkaXVzIGRlZmluZXMgeCBhbmQgeSByYWRpdXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGVsbGlwc2UgPSBuZXcgS29udmEuRWxsaXBzZSh7XG4gICAgICogICByYWRpdXMgOiB7XG4gICAgICogICAgIHggOiA1MCxcbiAgICAgKiAgICAgeSA6IDUwXG4gICAgICogICB9LFxuICAgICAqICAgZmlsbDogJ3JlZCdcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBLb252YS5FbGxpcHNlID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5FbGxpcHNlLnByb3RvdHlwZSA9IHtcbiAgICAgICAgX2NlbnRyb2lkOiB0cnVlLFxuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gRUxMSVBTRTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciByeCA9IHRoaXMuZ2V0UmFkaXVzWCgpLFxuICAgICAgICAgICAgICAgIHJ5ID0gdGhpcy5nZXRSYWRpdXNZKCk7XG5cbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIGlmKHJ4ICE9PSByeSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2NhbGUoMSwgcnkgLyByeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByeCwgMCwgUEl4MiwgZmFsc2UpO1xuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldFdpZHRoKClcbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFkaXVzWCgpICogMjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0SGVpZ2h0KClcbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJhZGl1c1koKSAqIDI7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldFdpZHRoKClcbiAgICAgICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRXaWR0aC5jYWxsKHRoaXMsIHdpZHRoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0UmFkaXVzKHtcbiAgICAgICAgICAgICAgICB4OiB3aWR0aCAvIDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRIZWlnaHQoKVxuICAgICAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0LmNhbGwodGhpcywgaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuc2V0UmFkaXVzKHtcbiAgICAgICAgICAgICAgICB5OiBoZWlnaHQgLyAyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuRWxsaXBzZSwgS29udmEuU2hhcGUpO1xuXG4gICAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5FbGxpcHNlLCAncmFkaXVzJywgWyd4JywgJ3knXSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHJhZGl1c1xuICAgICAqIEBuYW1lIHJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRWxsaXBzZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmFkaXVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cy54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cy55XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCByYWRpdXNcbiAgICAgKiB2YXIgcmFkaXVzID0gZWxsaXBzZS5yYWRpdXMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCByYWRpdXNcbiAgICAgKiBlbGxpcHNlLnJhZGl1cyh7XG4gICAgICogICB4OiAyMDAsXG4gICAgICogICB5OiAxMDBcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkVsbGlwc2UsICdyYWRpdXNYJywgMCk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCByYWRpdXMgeFxuICAgICAqIEBuYW1lIHJhZGl1c1hcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkVsbGlwc2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHJhZGl1cyB4XG4gICAgICogdmFyIHJhZGl1c1ggPSBlbGxpcHNlLnJhZGl1c1goKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCByYWRpdXMgeFxuICAgICAqIGVsbGlwc2UucmFkaXVzWCgyMDApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuRWxsaXBzZSwgJ3JhZGl1c1knLCAwKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHJhZGl1cyB5XG4gICAgICogQG5hbWUgcmFkaXVzWVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRWxsaXBzZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgcmFkaXVzIHlcbiAgICAgKiB2YXIgcmFkaXVzWSA9IGVsbGlwc2UucmFkaXVzWSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHJhZGl1cyB5XG4gICAgICogZWxsaXBzZS5yYWRpdXNZKDIwMCk7XG4gICAgICovXG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuRWxsaXBzZSk7XG5cbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gdGhlIDAuMDAwMSBvZmZzZXQgZml4ZXMgYSBidWcgaW4gQ2hyb21lIDI3XG4gICAgdmFyIFBJeDIgPSAoTWF0aC5QSSAqIDIpIC0gMC4wMDAxO1xuICAgIC8qKlxuICAgICAqIFJpbmcgY29uc3RydWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5pbm5lclJhZGl1c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcub3V0ZXJSYWRpdXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuY2xvY2t3aXNlXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcmluZyA9IG5ldyBLb252YS5SaW5nKHtcbiAgICAgKiAgIGlubmVyUmFkaXVzOiA0MCxcbiAgICAgKiAgIG91dGVyUmFkaXVzOiA4MCxcbiAgICAgKiAgIGZpbGw6ICdyZWQnLFxuICAgICAqICAgc3Ryb2tlOiAnYmxhY2snLFxuICAgICAqICAgc3Ryb2tlV2lkdGg6IDVcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBLb252YS5SaW5nID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5SaW5nLnByb3RvdHlwZSA9IHtcbiAgICAgICAgX2NlbnRyb2lkOiB0cnVlLFxuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1JpbmcnO1xuICAgICAgICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHRoaXMuZ2V0SW5uZXJSYWRpdXMoKSwgMCwgUEl4MiwgZmFsc2UpO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odGhpcy5nZXRPdXRlclJhZGl1cygpLCAwKTtcbiAgICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSwgUEl4MiwgMCwgdHJ1ZSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldFdpZHRoKClcbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldEhlaWdodCgpXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPdXRlclJhZGl1cygpICogMjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0V2lkdGgoKVxuICAgICAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0ZXJSYWRpdXMoKSAhPT0gd2lkdGggLyAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRlclJhZGl1cyh3aWR0aCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRIZWlnaHQoKVxuICAgICAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0LmNhbGwodGhpcywgaGVpZ2h0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dGVyUmFkaXVzKCkgIT09IGhlaWdodCAvIDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE91dGVyUmFkaXVzKGhlaWdodCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRPdXRlclJhZGl1czogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRBdHRyKCdvdXRlclJhZGl1cycsIHZhbCk7XG4gICAgICAgICAgICB0aGlzLnNldFdpZHRoKHZhbCAqIDIpO1xuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQodmFsICogMik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlJpbmcsIEtvbnZhLlNoYXBlKTtcblxuICAgIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5SaW5nLCAnaW5uZXJSYWRpdXMnLCAwKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgaW5uZXJSYWRpdXNcbiAgICAgKiBAbmFtZSBpbm5lclJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuUmluZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5uZXJSYWRpdXNcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGlubmVyIHJhZGl1c1xuICAgICAqIHZhciBpbm5lclJhZGl1cyA9IHJpbmcuaW5uZXJSYWRpdXMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBpbm5lciByYWRpdXNcbiAgICAgKiByaW5nLmlubmVyUmFkaXVzKDIwKTtcbiAgICAgKi9cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlcihLb252YS5SaW5nLCAnb3V0ZXJSYWRpdXMnLCAwKTtcbiAgICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuUmluZywgJ291dGVyUmFkaXVzJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IG91dGVyUmFkaXVzXG4gICAgICogQG5hbWUgb3V0ZXJSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlJpbmcucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG91dGVyUmFkaXVzXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBvdXRlciByYWRpdXNcbiAgICAgKiB2YXIgb3V0ZXJSYWRpdXMgPSByaW5nLm91dGVyUmFkaXVzKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgb3V0ZXIgcmFkaXVzXG4gICAgICogcmluZy5vdXRlclJhZGl1cygyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuUmluZyk7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qKlxuICAgICAqIFdlZGdlIGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuYW5nbGUgaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcucmFkaXVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmNsb2Nrd2lzZV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZHJhdyBhIHdlZGdlIHRoYXQncyBwb2ludGluZyBkb3dud2FyZHNcbiAgICAgKiB2YXIgd2VkZ2UgPSBuZXcgS29udmEuV2VkZ2Uoe1xuICAgICAqICAgcmFkaXVzOiA0MCxcbiAgICAgKiAgIGZpbGw6ICdyZWQnLFxuICAgICAqICAgc3Ryb2tlOiAnYmxhY2snXG4gICAgICogICBzdHJva2VXaWR0aDogNSxcbiAgICAgKiAgIGFuZ2xlRGVnOiA2MCxcbiAgICAgKiAgIHJvdGF0aW9uRGVnOiAtMTIwXG4gICAgICogfSk7XG4gICAgICovXG4gICAgS29udmEuV2VkZ2UgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLldlZGdlLnByb3RvdHlwZSA9IHtcbiAgICAgICAgX2NlbnRyb2lkOiB0cnVlLFxuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1dlZGdlJztcbiAgICAgICAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCB0aGlzLmdldFJhZGl1cygpLCAwLCBLb252YS5nZXRBbmdsZSh0aGlzLmdldEFuZ2xlKCkpLCB0aGlzLmdldENsb2Nrd2lzZSgpKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDAsIDApO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRXaWR0aCgpXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJhZGl1cygpICogMjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0SGVpZ2h0KClcbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJhZGl1cygpICogMjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0V2lkdGgoKVxuICAgICAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmFkaXVzKCkgIT09IHdpZHRoIC8gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmFkaXVzKHdpZHRoIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldEhlaWdodCgpXG4gICAgICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRIZWlnaHQuY2FsbCh0aGlzLCBoZWlnaHQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmFkaXVzKCkgIT09IGhlaWdodCAvIDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJhZGl1cyhoZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuV2VkZ2UsIEtvbnZhLlNoYXBlKTtcblxuICAgIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5XZWRnZSwgJ3JhZGl1cycsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCByYWRpdXNcbiAgICAgKiBAbmFtZSByYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLldlZGdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHJhZGl1c1xuICAgICAqIHZhciByYWRpdXMgPSB3ZWRnZS5yYWRpdXMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCByYWRpdXNcbiAgICAgKiB3ZWRnZS5yYWRpdXMoMTApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuV2VkZ2UsICdhbmdsZScsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBhbmdsZSBpbiBkZWdyZWVzXG4gICAgICogQG5hbWUgYW5nbGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLldlZGdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgYW5nbGVcbiAgICAgKiB2YXIgYW5nbGUgPSB3ZWRnZS5hbmdsZSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGFuZ2xlXG4gICAgICogd2VkZ2UuYW5nbGUoMjApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuV2VkZ2UsICdjbG9ja3dpc2UnLCBmYWxzZSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGNsb2Nrd2lzZSBmbGFnXG4gICAgICogQG5hbWUgY2xvY2t3aXNlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5XZWRnZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2xvY2t3aXNlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjbG9ja3dpc2UgZmxhZ1xuICAgICAqIHZhciBjbG9ja3dpc2UgPSB3ZWRnZS5jbG9ja3dpc2UoKTtcbiAgICAgKlxuICAgICAqIC8vIGRyYXcgd2VkZ2UgY291bnRlci1jbG9ja3dpc2VcbiAgICAgKiB3ZWRnZS5jbG9ja3dpc2UoZmFsc2UpO1xuICAgICAqXG4gICAgICogLy8gZHJhdyB3ZWRnZSBjbG9ja3dpc2VcbiAgICAgKiB3ZWRnZS5jbG9ja3dpc2UodHJ1ZSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmJhY2tDb21wYXQoS29udmEuV2VkZ2UsIHtcbiAgICAgICAgYW5nbGVEZWc6ICdhbmdsZScsXG4gICAgICAgIGdldEFuZ2xlRGVnOiAnZ2V0QW5nbGUnLFxuICAgICAgICBzZXRBbmdsZURlZzogJ3NldEFuZ2xlJ1xuICAgIH0pO1xuXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLldlZGdlKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogQXJjIGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuYW5nbGUgaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuaW5uZXJSYWRpdXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLm91dGVyUmFkaXVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmNsb2Nrd2lzZV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZHJhdyBhIEFyYyB0aGF0J3MgcG9pbnRpbmcgZG93bndhcmRzXG4gICAgICogdmFyIGFyYyA9IG5ldyBLb252YS5BcmMoe1xuICAgICAqICAgaW5uZXJSYWRpdXM6IDQwLFxuICAgICAqICAgb3V0ZXJSYWRpdXM6IDgwLFxuICAgICAqICAgZmlsbDogJ3JlZCcsXG4gICAgICogICBzdHJva2U6ICdibGFjaydcbiAgICAgKiAgIHN0cm9rZVdpZHRoOiA1LFxuICAgICAqICAgYW5nbGU6IDYwLFxuICAgICAqICAgcm90YXRpb25EZWc6IC0xMjBcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBLb252YS5BcmMgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLkFyYy5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9jZW50cm9pZDogdHJ1ZSxcbiAgICAgICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICdBcmMnO1xuICAgICAgICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gS29udmEuZ2V0QW5nbGUodGhpcy5hbmdsZSgpKSxcbiAgICAgICAgICAgICAgICBjbG9ja3dpc2UgPSB0aGlzLmNsb2Nrd2lzZSgpO1xuXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgdGhpcy5nZXRPdXRlclJhZGl1cygpLCAwLCBhbmdsZSwgY2xvY2t3aXNlKTtcbiAgICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHRoaXMuZ2V0SW5uZXJSYWRpdXMoKSwgYW5nbGUsIDAsICFjbG9ja3dpc2UpO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRXaWR0aCgpXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE91dGVyUmFkaXVzKCkgKiAyO1xuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRIZWlnaHQoKVxuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldFdpZHRoKClcbiAgICAgICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRXaWR0aC5jYWxsKHRoaXMsIHdpZHRoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldE91dGVyUmFkaXVzKCkgIT09IHdpZHRoIC8gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0T3V0ZXJSYWRpdXMod2lkdGggLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0SGVpZ2h0KClcbiAgICAgICAgc2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldEhlaWdodC5jYWxsKHRoaXMsIGhlaWdodCk7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRPdXRlclJhZGl1cygpICE9PSBoZWlnaHQgLyAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRlclJhZGl1cyhoZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuQXJjLCBLb252YS5TaGFwZSk7XG5cbiAgICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQXJjLCAnaW5uZXJSYWRpdXMnLCAwKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgaW5uZXJSYWRpdXNcbiAgICAgKiBAbmFtZSBpbm5lclJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQXJjLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbm5lclJhZGl1c1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgaW5uZXIgcmFkaXVzXG4gICAgICogdmFyIGlubmVyUmFkaXVzID0gYXJjLmlubmVyUmFkaXVzKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgaW5uZXIgcmFkaXVzXG4gICAgICogYXJjLmlubmVyUmFkaXVzKDIwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkFyYywgJ291dGVyUmFkaXVzJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IG91dGVyUmFkaXVzXG4gICAgICogQG5hbWUgb3V0ZXJSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkFyYy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3V0ZXJSYWRpdXNcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IG91dGVyIHJhZGl1c1xuICAgICAqIHZhciBvdXRlclJhZGl1cyA9IGFyYy5vdXRlclJhZGl1cygpO1xuICAgICAqXG4gICAgICogLy8gc2V0IG91dGVyIHJhZGl1c1xuICAgICAqIGFyYy5vdXRlclJhZGl1cygyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5BcmMsICdhbmdsZScsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBhbmdsZSBpbiBkZWdyZWVzXG4gICAgICogQG5hbWUgYW5nbGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkFyYy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGFuZ2xlXG4gICAgICogdmFyIGFuZ2xlID0gYXJjLmFuZ2xlKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgYW5nbGVcbiAgICAgKiBhcmMuYW5nbGUoMjApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQXJjLCAnY2xvY2t3aXNlJywgZmFsc2UpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBjbG9ja3dpc2UgZmxhZ1xuICAgICAqIEBuYW1lIGNsb2Nrd2lzZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQXJjLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xvY2t3aXNlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY2xvY2t3aXNlIGZsYWdcbiAgICAgKiB2YXIgY2xvY2t3aXNlID0gYXJjLmNsb2Nrd2lzZSgpO1xuICAgICAqXG4gICAgICogLy8gZHJhdyBhcmMgY291bnRlci1jbG9ja3dpc2VcbiAgICAgKiBhcmMuY2xvY2t3aXNlKGZhbHNlKTtcbiAgICAgKlxuICAgICAqIC8vIGRyYXcgYXJjIGNsb2Nrd2lzZVxuICAgICAqIGFyYy5jbG9ja3dpc2UodHJ1ZSk7XG4gICAgICovXG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuQXJjKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gQ09OU1RBTlRTXG4gICAgdmFyIElNQUdFID0gJ0ltYWdlJztcblxuICAgIC8qKlxuICAgICAqIEltYWdlIGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7SW1hZ2V9IGNvbmZpZy5pbWFnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmNyb3BdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBpbWFnZU9iaiA9IG5ldyBJbWFnZSgpO1xuICAgICAqIGltYWdlT2JqLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAqICAgdmFyIGltYWdlID0gbmV3IEtvbnZhLkltYWdlKHtcbiAgICAgKiAgICAgeDogMjAwLFxuICAgICAqICAgICB5OiA1MCxcbiAgICAgKiAgICAgaW1hZ2U6IGltYWdlT2JqLFxuICAgICAqICAgICB3aWR0aDogMTAwLFxuICAgICAqICAgICBoZWlnaHQ6IDEwMFxuICAgICAqICAgfSk7XG4gICAgICogfTtcbiAgICAgKiBpbWFnZU9iai5zcmMgPSAnL3BhdGgvdG8vaW1hZ2UuanBnJ1xuICAgICAqL1xuICAgIEtvbnZhLkltYWdlID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5JbWFnZS5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBJTUFHRTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgICAgICAgICB0aGlzLmhpdEZ1bmModGhpcy5faGl0RnVuYyk7XG4gICAgICAgIH0sXG4gICAgICAgIF91c2VCdWZmZXJDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmhhc1NoYWRvdygpIHx8IHRoaXMuZ2V0QWJzb2x1dGVPcGFjaXR5KCkgIT09IDEpICYmIHRoaXMuaGFzU3Ryb2tlKCkgJiYgdGhpcy5nZXRTdGFnZSgpO1xuICAgICAgICB9LFxuICAgICAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKSxcbiAgICAgICAgICAgICAgICBpbWFnZSA9IHRoaXMuZ2V0SW1hZ2UoKSxcbiAgICAgICAgICAgICAgICBjcm9wV2lkdGgsIGNyb3BIZWlnaHQsIHBhcmFtcztcblxuICAgICAgICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgICAgICAgICAgY3JvcFdpZHRoID0gdGhpcy5nZXRDcm9wV2lkdGgoKTtcbiAgICAgICAgICAgICAgICBjcm9wSGVpZ2h0ID0gdGhpcy5nZXRDcm9wSGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGNyb3BXaWR0aCAmJiBjcm9wSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IFtpbWFnZSwgdGhpcy5nZXRDcm9wWCgpLCB0aGlzLmdldENyb3BZKCksIGNyb3BXaWR0aCwgY3JvcEhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gW2ltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0ZpbGwoKSB8fCB0aGlzLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UuYXBwbHkoY29udGV4dCwgcGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2hpdEZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5yZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmdldEltYWdlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRycy53aWR0aCB8fCAoaW1hZ2UgPyBpbWFnZS53aWR0aCA6IDApO1xuICAgICAgICB9LFxuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGltYWdlID0gdGhpcy5nZXRJbWFnZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cnMuaGVpZ2h0IHx8IChpbWFnZSA/IGltYWdlLmhlaWdodCA6IDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5JbWFnZSwgS29udmEuU2hhcGUpO1xuXG4gICAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkltYWdlLCAnaW1hZ2UnKTtcblxuICAgIC8qKlxuICAgICAqIHNldCBpbWFnZVxuICAgICAqIEBuYW1lIHNldEltYWdlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5JbWFnZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogZ2V0IGltYWdlXG4gICAgICogQG5hbWUgZ2V0SW1hZ2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtJbWFnZX1cbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5JbWFnZSwgJ2Nyb3AnLCBbJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnXSk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBjcm9wXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBuYW1lIGNyb3BcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuSW1hZ2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNyb3BcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY3JvcC54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNyb3AueVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjcm9wLndpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNyb3AuaGVpZ2h0XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjcm9wXG4gICAgICogdmFyIGNyb3AgPSBpbWFnZS5jcm9wKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgY3JvcFxuICAgICAqIGltYWdlLmNyb3Aoe1xuICAgICAqICAgeDogMjAsXG4gICAgICogICB5OiAyMCxcbiAgICAgKiAgIHdpZHRoOiAyMCxcbiAgICAgKiAgIGhlaWdodDogMjBcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkltYWdlLCAnY3JvcFgnLCAwKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGNyb3AgeFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbmFtZSBjcm9wWFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5JbWFnZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY3JvcCB4XG4gICAgICogdmFyIGNyb3BYID0gaW1hZ2UuY3JvcFgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBjcm9wIHhcbiAgICAgKiBpbWFnZS5jcm9wWCgyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5JbWFnZSwgJ2Nyb3BZJywgMCk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBjcm9wIHlcbiAgICAgKiBAbmFtZSBjcm9wWVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuSW1hZ2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNyb3AgeVxuICAgICAqIHZhciBjcm9wWSA9IGltYWdlLmNyb3BZKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgY3JvcCB5XG4gICAgICogaW1hZ2UuY3JvcFkoMjApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuSW1hZ2UsICdjcm9wV2lkdGgnLCAwKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGNyb3Agd2lkdGhcbiAgICAgKiBAbmFtZSBjcm9wV2lkdGhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY3JvcCB3aWR0aFxuICAgICAqIHZhciBjcm9wV2lkdGggPSBpbWFnZS5jcm9wV2lkdGgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBjcm9wIHdpZHRoXG4gICAgICogaW1hZ2UuY3JvcFdpZHRoKDIwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkltYWdlLCAnY3JvcEhlaWdodCcsIDApO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgY3JvcCBoZWlnaHRcbiAgICAgKiBAbmFtZSBjcm9wSGVpZ2h0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5JbWFnZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjcm9wIGhlaWdodFxuICAgICAqIHZhciBjcm9wSGVpZ2h0ID0gaW1hZ2UuY3JvcEhlaWdodCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGNyb3AgaGVpZ2h0XG4gICAgICogaW1hZ2UuY3JvcEhlaWdodCgyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuSW1hZ2UpO1xuXG4gICAgLyoqXG4gICAgICogbG9hZCBpbWFnZSBmcm9tIGdpdmVuIHVybCBhbmQgY3JlYXRlIGBLb252YS5JbWFnZWAgaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBpbWFnZSBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB3aXRoIEtvbnZhLkltYWdlIGluc3RhbmNlIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgS29udmEuSW1hZ2UuZnJvbVVSTChpbWFnZVVSTCwgZnVuY3Rpb24oaW1hZ2Upe1xuICAgICAqICAgIC8vIGltYWdlIGlzIEtvbnZhLkltYWdlIGluc3RhbmNlXG4gICAgICogICAgbGF5ZXIuYWRkKGltYWdlKTtcbiAgICAgKiAgICBsYXllci5kcmF3KCk7XG4gICAgICogIH0pO1xuICAgICAqL1xuICAgIEtvbnZhLkltYWdlLmZyb21VUkwgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBLb252YS5JbWFnZSh7XG4gICAgICAgICAgICBpbWFnZTogaW1nXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2FsbGJhY2soaW1hZ2UpO1xuICAgICAgICB9O1xuICAgICAgICBpbWcuc3JjID0gdXJsO1xuICAgIH07XG59KSgpO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1kZXB0aCAqL1xuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBjb25zdGFudHNcbiAgICB2YXIgQVVUTyA9ICdhdXRvJyxcbiAgICAgICAgLy9DQU5WQVMgPSAnY2FudmFzJyxcbiAgICAgICAgQ0VOVEVSID0gJ2NlbnRlcicsXG4gICAgICAgIENIQU5HRV9LT05WQSA9ICdDaGFuZ2Uua29udmEnLFxuICAgICAgICBDT05URVhUXzJEID0gJzJkJyxcbiAgICAgICAgREFTSCA9ICctJyxcbiAgICAgICAgRU1QVFlfU1RSSU5HID0gJycsXG4gICAgICAgIExFRlQgPSAnbGVmdCcsXG4gICAgICAgIFRFWFQgPSAndGV4dCcsXG4gICAgICAgIFRFWFRfVVBQRVIgPSAnVGV4dCcsXG4gICAgICAgIE1JRERMRSA9ICdtaWRkbGUnLFxuICAgICAgICBOT1JNQUwgPSAnbm9ybWFsJyxcbiAgICAgICAgUFhfU1BBQ0UgPSAncHggJyxcbiAgICAgICAgU1BBQ0UgPSAnICcsXG4gICAgICAgIFJJR0hUID0gJ3JpZ2h0JyxcbiAgICAgICAgV09SRCA9ICd3b3JkJyxcbiAgICAgICAgQ0hBUiA9ICdjaGFyJyxcbiAgICAgICAgTk9ORSA9ICdub25lJyxcbiAgICAgICAgQVRUUl9DSEFOR0VfTElTVCA9IFsnZm9udEZhbWlseScsICdmb250U2l6ZScsICdmb250U3R5bGUnLCAnZm9udFZhcmlhbnQnLCAncGFkZGluZycsICdhbGlnbicsICdsaW5lSGVpZ2h0JywgJ3RleHQnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ3dyYXAnXSxcblxuICAgICAgICAvLyBjYWNoZWQgdmFyaWFibGVzXG4gICAgICAgIGF0dHJDaGFuZ2VMaXN0TGVuID0gQVRUUl9DSEFOR0VfTElTVC5sZW5ndGgsXG4gICAgICAgIGR1bW15Q29udGV4dCA9IEtvbnZhLlV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLmdldENvbnRleHQoQ09OVEVYVF8yRCk7XG5cbiAgICAvKipcbiAgICAgKiBUZXh0IGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZvbnRGYW1pbHldIGRlZmF1bHQgaXMgQXJpYWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5mb250U2l6ZV0gaW4gcGl4ZWxzLiAgRGVmYXVsdCBpcyAxMlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZvbnRTdHlsZV0gY2FuIGJlIG5vcm1hbCwgYm9sZCwgb3IgaXRhbGljLiAgRGVmYXVsdCBpcyBub3JtYWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5mb250VmFyaWFudF0gY2FuIGJlIG5vcm1hbCBvciBzbWFsbC1jYXBzLiAgRGVmYXVsdCBpcyBub3JtYWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLnRleHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5hbGlnbl0gY2FuIGJlIGxlZnQsIGNlbnRlciwgb3IgcmlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5wYWRkaW5nXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXSBkZWZhdWx0IGlzIGF1dG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdIGRlZmF1bHQgaXMgYXV0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmxpbmVIZWlnaHRdIGRlZmF1bHQgaXMgMVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLndyYXBdIGNhbiBiZSB3b3JkLCBjaGFyLCBvciBub25lLiBEZWZhdWx0IGlzIHdvcmRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHRleHQgPSBuZXcgS29udmEuVGV4dCh7XG4gICAgICogICB4OiAxMCxcbiAgICAgKiAgIHk6IDE1LFxuICAgICAqICAgdGV4dDogJ1NpbXBsZSBUZXh0JyxcbiAgICAgKiAgIGZvbnRTaXplOiAzMCxcbiAgICAgKiAgIGZvbnRGYW1pbHk6ICdDYWxpYnJpJyxcbiAgICAgKiAgIGZpbGw6ICdncmVlbidcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBLb252YS5UZXh0ID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gX2ZpbGxGdW5jKGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dCh0aGlzLnBhcnRpYWxUZXh0LCAwLCAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3N0cm9rZUZ1bmMoY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQodGhpcy5wYXJ0aWFsVGV4dCwgMCwgMCk7XG4gICAgfVxuXG4gICAgS29udmEuVGV4dC5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gICAgICAgICAgICAvLyBzZXQgZGVmYXVsdCBjb2xvciB0byBibGFja1xuICAgICAgICAgICAgaWYgKCFjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wcyAmJiAhY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuZmlsbCA9IGNvbmZpZy5maWxsIHx8ICdibGFjayc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb25maWcud2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy53aWR0aCA9IEFVVE87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLmhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmhlaWdodCA9IEFVVE87XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcblxuICAgICAgICAgICAgdGhpcy5fZmlsbEZ1bmMgPSBfZmlsbEZ1bmM7XG4gICAgICAgICAgICB0aGlzLl9zdHJva2VGdW5jID0gX3N0cm9rZUZ1bmM7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFRFWFRfVVBQRVI7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0ZXh0IGRhdGEgZm9yIGNlcnRhaW4gYXR0ciBjaGFuZ2VzXG4gICAgICAgICAgICBmb3IodmFyIG4gPSAwOyBuIDwgYXR0ckNoYW5nZUxpc3RMZW47IG4rKykge1xuICAgICAgICAgICAgICAgIHRoaXMub24oQVRUUl9DSEFOR0VfTElTVFtuXSArIENIQU5HRV9LT05WQSwgdGhpcy5fc2V0VGV4dERhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9zZXRUZXh0RGF0YSgpO1xuICAgICAgICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICAgICAgICAgIHRoaXMuaGl0RnVuYyh0aGlzLl9oaXRGdW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLmdldFBhZGRpbmcoKSxcbiAgICAgICAgICAgICAgICB0ZXh0SGVpZ2h0ID0gdGhpcy5nZXRUZXh0SGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgbGluZUhlaWdodFB4ID0gdGhpcy5nZXRMaW5lSGVpZ2h0KCkgKiB0ZXh0SGVpZ2h0LFxuICAgICAgICAgICAgICAgIHRleHRBcnIgPSB0aGlzLnRleHRBcnIsXG4gICAgICAgICAgICAgICAgdGV4dEFyckxlbiA9IHRleHRBcnIubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHRvdGFsV2lkdGggPSB0aGlzLmdldFdpZHRoKCksXG4gICAgICAgICAgICAgICAgbjtcblxuICAgICAgICAgICAgY29udGV4dC5zZXRBdHRyKCdmb250JywgdGhpcy5fZ2V0Q29udGV4dEZvbnQoKSk7XG5cbiAgICAgICAgICAgIGNvbnRleHQuc2V0QXR0cigndGV4dEJhc2VsaW5lJywgTUlERExFKTtcbiAgICAgICAgICAgIGNvbnRleHQuc2V0QXR0cigndGV4dEFsaWduJywgTEVGVCk7XG4gICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUocCwgMCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoMCwgcCArIHRleHRIZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoMCwgdGV4dEhlaWdodCAvIDIpO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIGRyYXcgdGV4dCBsaW5lc1xuICAgICAgICAgICAgZm9yKG4gPSAwOyBuIDwgdGV4dEFyckxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IHRleHRBcnJbbl0sXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSBvYmoudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBvYmoud2lkdGg7XG5cbiAgICAgICAgICAgICAgICAvLyBob3Jpem9udGFsIGFsaWdubWVudFxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuZ2V0QWxpZ24oKSA9PT0gUklHSFQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUodG90YWxXaWR0aCAtIHdpZHRoIC0gcCAqIDIsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKHRoaXMuZ2V0QWxpZ24oKSA9PT0gQ0VOVEVSKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKCh0b3RhbFdpZHRoIC0gd2lkdGggLSBwICogMikgLyAyLCAwKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpYWxUZXh0ID0gdGV4dDtcblxuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKDAsIGxpbmVIZWlnaHRQeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2hpdEZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5yZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRUZXh0OiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gS29udmEuVXRpbC5faXNTdHJpbmcodGV4dCkgPyB0ZXh0IDogdGV4dC50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5fc2V0QXR0cihURVhULCBzdHIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgd2lkdGggb2YgdGV4dCBhcmVhLCB3aGljaCBpbmNsdWRlcyBwYWRkaW5nXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRycy53aWR0aCA9PT0gQVVUTyA/IHRoaXMuZ2V0VGV4dFdpZHRoKCkgKyB0aGlzLmdldFBhZGRpbmcoKSAqIDIgOiB0aGlzLmF0dHJzLndpZHRoO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IHRoZSBoZWlnaHQgb2YgdGhlIHRleHQgYXJlYSwgd2hpY2ggdGFrZXMgaW50byBhY2NvdW50IG11bHRpLWxpbmUgdGV4dCwgbGluZSBoZWlnaHRzLCBhbmQgcGFkZGluZ1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJzLmhlaWdodCA9PT0gQVVUTyA/ICh0aGlzLmdldFRleHRIZWlnaHQoKSAqIHRoaXMudGV4dEFyci5sZW5ndGggKiB0aGlzLmdldExpbmVIZWlnaHQoKSkgKyB0aGlzLmdldFBhZGRpbmcoKSAqIDIgOiB0aGlzLmF0dHJzLmhlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCB0ZXh0IHdpZHRoXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUZXh0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dFdpZHRoO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IHRleHQgaGVpZ2h0XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUZXh0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHRIZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRUZXh0U2l6ZTogZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgdmFyIF9jb250ZXh0ID0gZHVtbXlDb250ZXh0LFxuICAgICAgICAgICAgICAgIGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpLFxuICAgICAgICAgICAgICAgIG1ldHJpY3M7XG5cbiAgICAgICAgICAgIF9jb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIF9jb250ZXh0LmZvbnQgPSB0aGlzLl9nZXRDb250ZXh0Rm9udCgpO1xuXG4gICAgICAgICAgICBtZXRyaWNzID0gX2NvbnRleHQubWVhc3VyZVRleHQodGV4dCk7XG4gICAgICAgICAgICBfY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBtZXRyaWNzLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcGFyc2VJbnQoZm9udFNpemUsIDEwKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldENvbnRleHRGb250OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZvbnRTdHlsZSgpICsgU1BBQ0UgKyB0aGlzLmdldEZvbnRWYXJpYW50KCkgKyBTUEFDRSArIHRoaXMuZ2V0Rm9udFNpemUoKSArIFBYX1NQQUNFICsgdGhpcy5nZXRGb250RmFtaWx5KCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9hZGRUZXh0TGluZTogZnVuY3Rpb24gKGxpbmUsIHdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0QXJyLnB1c2goe3RleHQ6IGxpbmUsIHdpZHRoOiB3aWR0aH0pO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0VGV4dFdpZHRoOiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGR1bW15Q29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgX3NldFRleHREYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSB0aGlzLmdldFRleHQoKS5zcGxpdCgnXFxuJyksXG4gICAgICAgICAgICAgICAgZm9udFNpemUgPSArdGhpcy5nZXRGb250U2l6ZSgpLFxuICAgICAgICAgICAgICAgIHRleHRXaWR0aCA9IDAsXG4gICAgICAgICAgICAgICAgbGluZUhlaWdodFB4ID0gdGhpcy5nZXRMaW5lSGVpZ2h0KCkgKiBmb250U2l6ZSxcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHRoaXMuYXR0cnMud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5hdHRycy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgZml4ZWRXaWR0aCA9IHdpZHRoICE9PSBBVVRPLFxuICAgICAgICAgICAgICAgIGZpeGVkSGVpZ2h0ID0gaGVpZ2h0ICE9PSBBVVRPLFxuICAgICAgICAgICAgICAgIHBhZGRpbmcgPSB0aGlzLmdldFBhZGRpbmcoKSxcbiAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IHdpZHRoIC0gcGFkZGluZyAqIDIsXG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0UHggPSBoZWlnaHQgLSBwYWRkaW5nICogMixcbiAgICAgICAgICAgICAgICBjdXJyZW50SGVpZ2h0UHggPSAwLFxuICAgICAgICAgICAgICAgIHdyYXAgPSB0aGlzLmdldFdyYXAoKSxcbiAgICAgICAgICAgICAgICBzaG91bGRXcmFwID0gd3JhcCAhPT0gTk9ORSxcbiAgICAgICAgICAgICAgICB3cmFwQXRXb3JkID0gd3JhcCAhPT0gQ0hBUiAmJiBzaG91bGRXcmFwO1xuXG4gICAgICAgICAgICB0aGlzLnRleHRBcnIgPSBbXTtcbiAgICAgICAgICAgIGR1bW15Q29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICBkdW1teUNvbnRleHQuZm9udCA9IHRoaXMuX2dldENvbnRleHRGb250KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbWF4ID0gbGluZXMubGVuZ3RoOyBpIDwgbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldLFxuICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSB0aGlzLl9nZXRUZXh0V2lkdGgobGluZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpeGVkV2lkdGggJiYgbGluZVdpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICogaWYgd2lkdGggaXMgZml4ZWQgYW5kIGxpbmUgZG9lcyBub3QgZml0IGVudGlyZWx5XG4gICAgICAgICAgICAgICAgICAgICAqIGJyZWFrIHRoZSBsaW5lIGludG8gbXVsdGlwbGUgZml0dGluZyBsaW5lc1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxpbmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHVzZSBiaW5hcnkgc2VhcmNoIHRvIGZpbmQgdGhlIGxvbmdlc3Qgc3Vic3RyaW5nIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoYXQgd291bGQgZml0IGluIHRoZSBzcGVjaWZpZWQgd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBsaW5lLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9ICcnLCBtYXRjaFdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RyID0gbGluZS5zbGljZSgwLCBtaWQgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RyV2lkdGggPSB0aGlzLl9nZXRUZXh0V2lkdGgoc3Vic3RyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic3RyV2lkdGggPD0gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBzdWJzdHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoV2lkdGggPSBzdWJzdHJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAnbG93JyBpcyBub3cgdGhlIGluZGV4IG9mIHRoZSBzdWJzdHJpbmcgZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAnbWF0Y2gnIGlzIHRoZSBzdWJzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICdtYXRjaFdpZHRoJyBpcyB0aGUgc3Vic3RyaW5nIHdpZHRoIGluIHB4XG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgZml0dGluZyBzdWJzdHJpbmcgd2FzIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdyYXBBdFdvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGZpbmQgYSBzcGFjZSBvciBkYXNoIHdoZXJlIHdyYXBwaW5nIGNvdWxkIGJlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBJbmRleCA9IE1hdGgubWF4KG1hdGNoLmxhc3RJbmRleE9mKFNQQUNFKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC5sYXN0SW5kZXhPZihEQVNIKSkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod3JhcEluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmUtY3V0IHRoZSBzdWJzdHJpbmcgZm91bmQgYXQgdGhlIHNwYWNlL2Rhc2ggcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvdyA9IHdyYXBJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2guc2xpY2UoMCwgbG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoV2lkdGggPSB0aGlzLl9nZXRUZXh0V2lkdGgobWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRleHRMaW5lKG1hdGNoLCBtYXRjaFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0V2lkdGggPSBNYXRoLm1heCh0ZXh0V2lkdGgsIG1hdGNoV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRIZWlnaHRQeCArPSBsaW5lSGVpZ2h0UHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG91bGRXcmFwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmaXhlZEhlaWdodCAmJiBjdXJyZW50SGVpZ2h0UHggKyBsaW5lSGVpZ2h0UHggPiBtYXhIZWlnaHRQeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogc3RvcCB3cmFwcGluZyBpZiB3cmFwcGluZyBpcyBkaXNhYmxlZCBvciBpZiBhZGRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogb25lIG1vcmUgbGluZSB3b3VsZCBvdmVyZmxvdyB0aGUgZml4ZWQgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UobG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSByZW1haW5pbmcgdGV4dCB3b3VsZCBmaXQgb24gb25lIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoID0gdGhpcy5fZ2V0VGV4dFdpZHRoKGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZVdpZHRoIDw9IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCBkb2VzLCBhZGQgdGhlIGxpbmUgYW5kIGJyZWFrIG91dCBvZiB0aGUgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVGV4dExpbmUobGluZSwgbGluZVdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRIZWlnaHRQeCArPSBsaW5lSGVpZ2h0UHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0V2lkdGggPSBNYXRoLm1heCh0ZXh0V2lkdGgsIGxpbmVXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IGV2ZW4gb25lIGNoYXJhY3RlciBjb3VsZCBmaXQgaW4gdGhlIGVsZW1lbnQsIGFib3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IHdpZHRoIGlzIGF1dG9tYXRpY2FsbHkgYWRqdXN0ZWQgdG8gbWF4IGxpbmUgd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVGV4dExpbmUobGluZSwgbGluZVdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEhlaWdodFB4ICs9IGxpbmVIZWlnaHRQeDtcbiAgICAgICAgICAgICAgICAgICAgdGV4dFdpZHRoID0gTWF0aC5tYXgodGV4dFdpZHRoLCBsaW5lV2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiBlbGVtZW50IGhlaWdodCBpcyBmaXhlZCwgYWJvcnQgaWYgYWRkaW5nIG9uZSBtb3JlIGxpbmUgd291bGQgb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICBpZiAoZml4ZWRIZWlnaHQgJiYgY3VycmVudEhlaWdodFB4ICsgbGluZUhlaWdodFB4ID4gbWF4SGVpZ2h0UHgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHVtbXlDb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIHRoaXMudGV4dEhlaWdodCA9IGZvbnRTaXplO1xuICAgICAgICAgICAgdGhpcy50ZXh0V2lkdGggPSB0ZXh0V2lkdGg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlRleHQsIEtvbnZhLlNoYXBlKTtcblxuICAgIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0LCAnZm9udEZhbWlseScsICdBcmlhbCcpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmb250IGZhbWlseVxuICAgICAqIEBuYW1lIGZvbnRGYW1pbHlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvbnRGYW1pbHlcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZvbnQgZmFtaWx5XG4gICAgICogdmFyIGZvbnRGYW1pbHkgPSB0ZXh0LmZvbnRGYW1pbHkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmb250IGZhbWlseVxuICAgICAqIHRleHQuZm9udEZhbWlseSgnQXJpYWwnKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICdmb250U2l6ZScsIDEyKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZm9udCBzaXplIGluIHBpeGVsc1xuICAgICAqIEBuYW1lIGZvbnRTaXplXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmb250U2l6ZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZm9udCBzaXplXG4gICAgICogdmFyIGZvbnRTaXplID0gdGV4dC5mb250U2l6ZSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZvbnQgc2l6ZSB0byAyMnB4XG4gICAgICogdGV4dC5mb250U2l6ZSgyMik7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0LCAnZm9udFN0eWxlJywgTk9STUFMKTtcblxuICAgIC8qKlxuICAgICAqIHNldCBmb250IHN0eWxlLiAgQ2FuIGJlICdub3JtYWwnLCAnaXRhbGljJywgb3IgJ2JvbGQnLiAgJ25vcm1hbCcgaXMgdGhlIGRlZmF1bHQuXG4gICAgICogQG5hbWUgZm9udFN0eWxlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb250U3R5bGVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZvbnQgc3R5bGVcbiAgICAgKiB2YXIgZm9udFN0eWxlID0gdGV4dC5mb250U3R5bGUoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmb250IHN0eWxlXG4gICAgICogdGV4dC5mb250U3R5bGUoJ2JvbGQnKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICdmb250VmFyaWFudCcsIE5PUk1BTCk7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgZm9udCB2YXJpYW50LiAgQ2FuIGJlICdub3JtYWwnIG9yICdzbWFsbC1jYXBzJy4gICdub3JtYWwnIGlzIHRoZSBkZWZhdWx0LlxuICAgICAqIEBuYW1lIGZvbnRWYXJpYW50XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb250VmFyaWFudFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZm9udCB2YXJpYW50XG4gICAgICogdmFyIGZvbnRWYXJpYW50ID0gdGV4dC5mb250VmFyaWFudCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZvbnQgdmFyaWFudFxuICAgICAqIHRleHQuZm9udFZhcmlhbnQoJ3NtYWxsLWNhcHMnKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICdwYWRkaW5nJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgcGFkZGluZ1xuICAgICAqIEBuYW1lIHBhZGRpbmdcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBhZGRpbmdcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHBhZGRpbmdcbiAgICAgKiB2YXIgcGFkZGluZyA9IHRleHQucGFkZGluZygpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHBhZGRpbmcgdG8gMTAgcGl4ZWxzXG4gICAgICogdGV4dC5wYWRkaW5nKDEwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICdhbGlnbicsIExFRlQpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBob3Jpem9udGFsIGFsaWduIG9mIHRleHQuICBDYW4gYmUgJ2xlZnQnLCAnY2VudGVyJywgb3IgJ3JpZ2h0J1xuICAgICAqIEBuYW1lIGFsaWduXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhbGlnblxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgdGV4dCBhbGlnblxuICAgICAqIHZhciBhbGlnbiA9IHRleHQuYWxpZ24oKTtcbiAgICAgKlxuICAgICAqIC8vIGNlbnRlciB0ZXh0XG4gICAgICogdGV4dC5hbGlnbignY2VudGVyJyk7XG4gICAgICpcbiAgICAgKiAvLyBhbGlnbiB0ZXh0IHRvIHJpZ2h0XG4gICAgICogdGV4dC5hbGlnbigncmlnaHQnKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICdsaW5lSGVpZ2h0JywgMSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGxpbmUgaGVpZ2h0LiAgVGhlIGRlZmF1bHQgaXMgMS5cbiAgICAgKiBAbmFtZSBsaW5lSGVpZ2h0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSGVpZ2h0XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBsaW5lIGhlaWdodFxuICAgICAqIHZhciBsaW5lSGVpZ2h0ID0gdGV4dC5saW5lSGVpZ2h0KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgdGhlIGxpbmUgaGVpZ2h0XG4gICAgICogdGV4dC5saW5lSGVpZ2h0KDIpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ3dyYXAnLCBXT1JEKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgd3JhcC4gIENhbiBiZSB3b3JkLCBjaGFyLCBvciBub25lLiBEZWZhdWx0IGlzIHdvcmQuXG4gICAgICogQG5hbWUgd3JhcFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gd3JhcFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgd3JhcFxuICAgICAqIHZhciB3cmFwID0gdGV4dC53cmFwKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgd3JhcFxuICAgICAqIHRleHQud3JhcCgnd29yZCcpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXIoS29udmEuVGV4dCwgJ3RleHQnLCBFTVBUWV9TVFJJTkcpO1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5UZXh0LCAndGV4dCcpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCB0ZXh0XG4gICAgICogQG5hbWUgZ2V0VGV4dFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgdGV4dFxuICAgICAqIHZhciB0ZXh0ID0gdGV4dC50ZXh0KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgdGV4dFxuICAgICAqIHRleHQudGV4dCgnSGVsbG8gd29ybGQhJyk7XG4gICAgICovXG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuVGV4dCk7XG59KSgpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBMaW5lIGNvbnN0cnVjdG9yLiZuYnNwOyBMaW5lcyBhcmUgZGVmaW5lZCBieSBhbiBhcnJheSBvZiBwb2ludHMgYW5kXG4gICAgICogIGEgdGVuc2lvblxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWcucG9pbnRzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcudGVuc2lvbl0gSGlnaGVyIHZhbHVlcyB3aWxsIHJlc3VsdCBpbiBhIG1vcmUgY3VydnkgbGluZS4gIEEgdmFsdWUgb2YgMCB3aWxsIHJlc3VsdCBpbiBubyBpbnRlcnBvbGF0aW9uLlxuICAgICAqICAgVGhlIGRlZmF1bHQgaXMgMFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5jbG9zZWRdIGRlZmluZXMgd2hldGhlciBvciBub3QgdGhlIGxpbmUgc2hhcGUgaXMgY2xvc2VkLCBjcmVhdGluZyBhIHBvbHlnb24gb3IgYmxvYlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgbGluZSA9IG5ldyBLb252YS5MaW5lKHtcbiAgICAgKiAgIHg6IDEwMCxcbiAgICAgKiAgIHk6IDUwLFxuICAgICAqICAgcG9pbnRzOiBbNzMsIDcwLCAzNDAsIDIzLCA0NTAsIDYwLCA1MDAsIDIwXSxcbiAgICAgKiAgIHN0cm9rZTogJ3JlZCcsXG4gICAgICogICB0ZW5zaW9uOiAxXG4gICAgICogfSk7XG4gICAgICovXG4gICAgS29udmEuTGluZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLkxpbmUucHJvdG90eXBlID0ge1xuICAgICAgICBfX19pbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICdMaW5lJztcblxuICAgICAgICAgICAgdGhpcy5vbigncG9pbnRzQ2hhbmdlLmtvbnZhIHRlbnNpb25DaGFuZ2Uua29udmEgY2xvc2VkQ2hhbmdlLmtvbnZhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoJ3RlbnNpb25Qb2ludHMnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgICAgICB9LFxuICAgICAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzKCksXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB0ZW5zaW9uID0gdGhpcy5nZXRUZW5zaW9uKCksXG4gICAgICAgICAgICAgICAgY2xvc2VkID0gdGhpcy5nZXRDbG9zZWQoKSxcbiAgICAgICAgICAgICAgICB0cCwgbGVuLCBuO1xuXG4gICAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcblxuICAgICAgICAgICAgLy8gdGVuc2lvblxuICAgICAgICAgICAgaWYgKHRlbnNpb24gIT09IDAgJiYgbGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgICAgIHRwID0gdGhpcy5nZXRUZW5zaW9uUG9pbnRzKCk7XG4gICAgICAgICAgICAgICAgbGVuID0gdHAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIG4gPSBjbG9zZWQgPyAwIDogNDtcblxuICAgICAgICAgICAgICAgIGlmICghY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh0cFswXSwgdHBbMV0sIHRwWzJdLCB0cFszXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPCBsZW4gLSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh0cFtuKytdLCB0cFtuKytdLCB0cFtuKytdLCB0cFtuKytdLCB0cFtuKytdLCB0cFtuKytdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8odHBbbGVuIC0gMl0sIHRwW2xlbiAtIDFdLCBwb2ludHNbbGVuZ3RoIC0gMl0sIHBvaW50c1tsZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm8gdGVuc2lvblxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChuID0gMjsgbiA8IGxlbmd0aDsgbiArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHBvaW50c1tuXSwgcG9pbnRzW24gKyAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjbG9zZWQgZS5nLiBwb2x5Z29ucyBhbmQgYmxvYnNcbiAgICAgICAgICAgIGlmIChjbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3BlbiBlLmcuIGxpbmVzIGFuZCBzcGxpbmVzXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRUZW5zaW9uUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoJ3RlbnNpb25Qb2ludHMnLCB0aGlzLl9nZXRUZW5zaW9uUG9pbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldFRlbnNpb25Qb2ludHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldENsb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRlbnNpb25Qb2ludHNDbG9zZWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEtvbnZhLlV0aWwuX2V4cGFuZFBvaW50cyh0aGlzLmdldFBvaW50cygpLCB0aGlzLmdldFRlbnNpb24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRUZW5zaW9uUG9pbnRzQ2xvc2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMuZ2V0UG9pbnRzKCksXG4gICAgICAgICAgICAgICAgbGVuID0gcC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdGVuc2lvbiA9IHRoaXMuZ2V0VGVuc2lvbigpLFxuICAgICAgICAgICAgICAgIHV0aWwgPSBLb252YS5VdGlsLFxuICAgICAgICAgICAgICAgIGZpcnN0Q29udHJvbFBvaW50cyA9IHV0aWwuX2dldENvbnRyb2xQb2ludHMoXG4gICAgICAgICAgICAgICAgICAgIHBbbGVuIC0gMl0sXG4gICAgICAgICAgICAgICAgICAgIHBbbGVuIC0gMV0sXG4gICAgICAgICAgICAgICAgICAgIHBbMF0sXG4gICAgICAgICAgICAgICAgICAgIHBbMV0sXG4gICAgICAgICAgICAgICAgICAgIHBbMl0sXG4gICAgICAgICAgICAgICAgICAgIHBbM10sXG4gICAgICAgICAgICAgICAgICAgIHRlbnNpb25cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGxhc3RDb250cm9sUG9pbnRzID0gdXRpbC5fZ2V0Q29udHJvbFBvaW50cyhcbiAgICAgICAgICAgICAgICAgICAgcFtsZW4gLSA0XSxcbiAgICAgICAgICAgICAgICAgICAgcFtsZW4gLSAzXSxcbiAgICAgICAgICAgICAgICAgICAgcFtsZW4gLSAyXSxcbiAgICAgICAgICAgICAgICAgICAgcFtsZW4gLSAxXSxcbiAgICAgICAgICAgICAgICAgICAgcFswXSxcbiAgICAgICAgICAgICAgICAgICAgcFsxXSxcbiAgICAgICAgICAgICAgICAgICAgdGVuc2lvblxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbWlkZGxlID0gS29udmEuVXRpbC5fZXhwYW5kUG9pbnRzKHAsIHRlbnNpb24pLFxuICAgICAgICAgICAgICAgIHRwID0gW1xuICAgICAgICAgICAgICAgICAgICBmaXJzdENvbnRyb2xQb2ludHNbMl0sXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Q29udHJvbFBvaW50c1szXVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAuY29uY2F0KG1pZGRsZSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbnRyb2xQb2ludHNbMF0sXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250cm9sUG9pbnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICBwW2xlbiAtIDJdLFxuICAgICAgICAgICAgICAgICAgICBwW2xlbiAtIDFdLFxuICAgICAgICAgICAgICAgICAgICBsYXN0Q29udHJvbFBvaW50c1syXSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbnRyb2xQb2ludHNbM10sXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Q29udHJvbFBvaW50c1swXSxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RDb250cm9sUG9pbnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICBwWzBdLFxuICAgICAgICAgICAgICAgICAgICBwWzFdXG4gICAgICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNlbGZSZWN0KCkud2lkdGg7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VsZlJlY3QoKS5oZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIG92ZXJsb2FkIHNpemUgZGV0ZWN0aW9uXG4gICAgICAgIGdldFNlbGZSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0VGVuc2lvbigpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gdGhpcy5fZ2V0VGVuc2lvblBvaW50cygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb2ludHMgPSB0aGlzLmdldFBvaW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1pblggPSBwb2ludHNbMF07XG4gICAgICAgICAgICB2YXIgbWF4WCA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIHZhciBtaW5ZID0gcG9pbnRzWzFdO1xuICAgICAgICAgICAgdmFyIG1heFkgPSBwb2ludHNbMV07XG4gICAgICAgICAgICB2YXIgeCwgeTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICAgICAgICAgIHggPSBwb2ludHNbaSAqIDJdO1xuICAgICAgICAgICAgICAgIHkgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCk7XG4gICAgICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xuICAgICAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcbiAgICAgICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IE1hdGgucm91bmQobWluWCksXG4gICAgICAgICAgICAgICAgeTogTWF0aC5yb3VuZChtaW5ZKSxcbiAgICAgICAgICAgICAgICB3aWR0aDogTWF0aC5yb3VuZChtYXhYIC0gbWluWCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKG1heFkgLSBtaW5ZKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuTGluZSwgS29udmEuU2hhcGUpO1xuXG4gICAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkxpbmUsICdjbG9zZWQnLCBmYWxzZSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGNsb3NlZCBmbGFnLiAgVGhlIGRlZmF1bHQgaXMgZmFsc2VcbiAgICAgKiBAbmFtZSBjbG9zZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkxpbmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjbG9zZWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjbG9zZWQgZmxhZ1xuICAgICAqIHZhciBjbG9zZWQgPSBsaW5lLmNsb3NlZCgpO1xuICAgICAqXG4gICAgICogLy8gY2xvc2UgdGhlIHNoYXBlXG4gICAgICogbGluZS5jbG9zZWQodHJ1ZSk7XG4gICAgICpcbiAgICAgKiAvLyBvcGVuIHRoZSBzaGFwZVxuICAgICAqIGxpbmUuY2xvc2VkKGZhbHNlKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkxpbmUsICd0ZW5zaW9uJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHRlbnNpb25cbiAgICAgKiBAbmFtZSB0ZW5zaW9uXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5MaW5lLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBIaWdoZXIgdmFsdWVzIHdpbGwgcmVzdWx0IGluIGEgbW9yZSBjdXJ2eSBsaW5lLiAgQSB2YWx1ZSBvZiAwIHdpbGwgcmVzdWx0IGluIG5vIGludGVycG9sYXRpb24uXG4gICAgICogICBUaGUgZGVmYXVsdCBpcyAwXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCB0ZW5zaW9uXG4gICAgICogdmFyIHRlbnNpb24gPSBsaW5lLnRlbnNpb24oKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCB0ZW5zaW9uXG4gICAgICogbGluZS50ZW5zaW9uKDMpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTGluZSwgJ3BvaW50cycsIFtdKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHBvaW50cyBhcnJheVxuICAgICAqIEBuYW1lIHBvaW50c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTGluZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgcG9pbnRzXG4gICAgICogdmFyIHBvaW50cyA9IGxpbmUucG9pbnRzKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgcG9pbnRzXG4gICAgICogbGluZS5wb2ludHMoWzEwLCAyMCwgMzAsIDQwLCA1MCwgNjBdKTtcbiAgICAgKlxuICAgICAqIC8vIHB1c2ggYSBuZXcgcG9pbnRcbiAgICAgKiBsaW5lLnBvaW50cyhsaW5lLnBvaW50cygpLmNvbmNhdChbNzAsIDgwXSkpO1xuICAgICAqL1xuXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLkxpbmUpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBTcHJpdGUgY29uc3RydWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5hbmltYXRpb24gYW5pbWF0aW9uIGtleVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcuYW5pbWF0aW9ucyBhbmltYXRpb24gbWFwXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBbY29uZmlnLmZyYW1lSW5kZXhdIGFuaW1hdGlvbiBmcmFtZSBpbmRleFxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IGNvbmZpZy5pbWFnZSBpbWFnZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGltYWdlT2JqID0gbmV3IEltYWdlKCk7XG4gICAgICogaW1hZ2VPYmoub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICogICB2YXIgc3ByaXRlID0gbmV3IEtvbnZhLlNwcml0ZSh7XG4gICAgICogICAgIHg6IDIwMCxcbiAgICAgKiAgICAgeTogMTAwLFxuICAgICAqICAgICBpbWFnZTogaW1hZ2VPYmosXG4gICAgICogICAgIGFuaW1hdGlvbjogJ3N0YW5kaW5nJyxcbiAgICAgKiAgICAgYW5pbWF0aW9uczoge1xuICAgICAqICAgICAgIHN0YW5kaW5nOiBbXG4gICAgICogICAgICAgICAvLyB4LCB5LCB3aWR0aCwgaGVpZ2h0ICg2IGZyYW1lcylcbiAgICAgKiAgICAgICAgIDAsIDAsIDQ5LCAxMDksXG4gICAgICogICAgICAgICA1MiwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgICAgIDEwNSwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgICAgIDE1OCwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgICAgIDIxMCwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgICAgIDI2MiwgMCwgNDksIDEwOVxuICAgICAqICAgICAgIF0sXG4gICAgICogICAgICAga2lja2luZzogW1xuICAgICAqICAgICAgICAgLy8geCwgeSwgd2lkdGgsIGhlaWdodCAoNiBmcmFtZXMpXG4gICAgICogICAgICAgICAwLCAxMDksIDQ1LCA5OCxcbiAgICAgKiAgICAgICAgIDQ1LCAxMDksIDQ1LCA5OCxcbiAgICAgKiAgICAgICAgIDk1LCAxMDksIDYzLCA5OCxcbiAgICAgKiAgICAgICAgIDE1NiwgMTA5LCA3MCwgOTgsXG4gICAgICogICAgICAgICAyMjksIDEwOSwgNjAsIDk4LFxuICAgICAqICAgICAgICAgMjg3LCAxMDksIDQxLCA5OFxuICAgICAqICAgICAgIF1cbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgZnJhbWVSYXRlOiA3LFxuICAgICAqICAgICBmcmFtZUluZGV4OiAwXG4gICAgICogICB9KTtcbiAgICAgKiB9O1xuICAgICAqIGltYWdlT2JqLnNyYyA9ICcvcGF0aC90by9pbWFnZS5qcGcnXG4gICAgICovXG4gICAgS29udmEuU3ByaXRlID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5TcHJpdGUucHJvdG90eXBlID0ge1xuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1Nwcml0ZSc7XG5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5hbmltID0gbmV3IEtvbnZhLkFuaW1hdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBkb24ndCBuZWVkIHRvIHJlZHJhdyBsYXllciB3ZSBzaG91bGQgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZWQgPSB0aGF0Ll91cGRhdGVkO1xuICAgICAgICAgICAgICAgIHRoYXQuX3VwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5vbignYW5pbWF0aW9uQ2hhbmdlLmtvbnZhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgaW5kZXggd2hlbiBhbmltYXRpb24gY2hhbmdlc1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVJbmRleCgwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5vbignZnJhbWVJbmRleENoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBzbW9vdGggY2hhbmdlIGZvciBmcmFtZVJhdGVcbiAgICAgICAgICAgIHRoaXMub24oJ2ZyYW1lUmF0ZUNoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hbmltLmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRJbnRlcnZhbCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgICAgICAgICB0aGlzLmhpdEZ1bmModGhpcy5faGl0RnVuYyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBhbmltID0gdGhpcy5nZXRBbmltYXRpb24oKSxcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuZnJhbWVJbmRleCgpLFxuICAgICAgICAgICAgICAgIGl4NCA9IGluZGV4ICogNCxcbiAgICAgICAgICAgICAgICBzZXQgPSB0aGlzLmdldEFuaW1hdGlvbnMoKVthbmltXSxcbiAgICAgICAgICAgICAgICBvZmZzZXRzID0gdGhpcy5mcmFtZU9mZnNldHMoKSxcbiAgICAgICAgICAgICAgICB4ID0gc2V0W2l4NCArIDBdLFxuICAgICAgICAgICAgICAgIHkgPSBzZXRbaXg0ICsgMV0sXG4gICAgICAgICAgICAgICAgd2lkdGggPSBzZXRbaXg0ICsgMl0sXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gc2V0W2l4NCArIDNdLFxuICAgICAgICAgICAgICAgIGltYWdlID0gdGhpcy5nZXRJbWFnZSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGaWxsKCkgfHwgdGhpcy5oYXNTdHJva2UoKSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGltYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldHNbYW5pbV0sXG4gICAgICAgICAgICAgICAgICAgIGl4MiA9IGluZGV4ICogMjtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQsIG9mZnNldFtpeDIgKyAwXSwgb2Zmc2V0W2l4MiArIDFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfaGl0RnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGFuaW0gPSB0aGlzLmdldEFuaW1hdGlvbigpLFxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5mcmFtZUluZGV4KCksXG4gICAgICAgICAgICAgICAgaXg0ID0gaW5kZXggKiA0LFxuICAgICAgICAgICAgICAgIHNldCA9IHRoaXMuZ2V0QW5pbWF0aW9ucygpW2FuaW1dLFxuICAgICAgICAgICAgICAgIG9mZnNldHMgPSB0aGlzLmZyYW1lT2Zmc2V0cygpLFxuICAgICAgICAgICAgICAgIHdpZHRoID0gc2V0W2l4NCArIDJdLFxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHNldFtpeDQgKyAzXTtcblxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGlmIChvZmZzZXRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldHNbYW5pbV07XG4gICAgICAgICAgICAgICAgdmFyIGl4MiA9IGluZGV4ICogMjtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlY3Qob2Zmc2V0W2l4MiArIDBdLCBvZmZzZXRbaXgyICsgMV0sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5maWxsU2hhcGUodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIF91c2VCdWZmZXJDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmhhc1NoYWRvdygpIHx8IHRoaXMuZ2V0QWJzb2x1dGVPcGFjaXR5KCkgIT09IDEpICYmIHRoaXMuaGFzU3Ryb2tlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zZXRJbnRlcnZhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5fdXBkYXRlSW5kZXgoKTtcbiAgICAgICAgICAgIH0sIDEwMDAgLyB0aGlzLmdldEZyYW1lUmF0ZSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHN0YXJ0IHNwcml0ZSBhbmltYXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3ByaXRlLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogYW5pbWF0aW9uIG9iamVjdCBoYXMgbm8gZXhlY3V0YWJsZSBmdW5jdGlvbiBiZWNhdXNlXG4gICAgICAgICAgICAgKiAgdGhlIHVwZGF0ZXMgYXJlIGRvbmUgd2l0aCBhIGZpeGVkIEZQUyB3aXRoIHRoZSBzZXRJbnRlcnZhbFxuICAgICAgICAgICAgICogIGJlbG93LiAgVGhlIGFuaW0gb2JqZWN0IG9ubHkgbmVlZHMgdGhlIGxheWVyIHJlZmVyZW5jZSBmb3JcbiAgICAgICAgICAgICAqICByZWRyYXdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5hbmltLnNldExheWVycyhsYXllcik7XG4gICAgICAgICAgICB0aGlzLl9zZXRJbnRlcnZhbCgpO1xuICAgICAgICAgICAgdGhpcy5hbmltLnN0YXJ0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzdG9wIHNwcml0ZSBhbmltYXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3ByaXRlLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW0uc3RvcCgpO1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRldGVybWluZSBpZiBhbmltYXRpb24gb2Ygc3ByaXRlIGlzIHJ1bm5pbmcgb3Igbm90LiAgcmV0dXJucyB0cnVlIG9yIGZhbHNlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkFuaW1hdGlvbi5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpc1J1bm5pbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbS5pc1J1bm5pbmcoKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3VwZGF0ZUluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuZnJhbWVJbmRleCgpLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbiA9IHRoaXMuZ2V0QW5pbWF0aW9uKCksXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9ucyA9IHRoaXMuZ2V0QW5pbWF0aW9ucygpLFxuICAgICAgICAgICAgICAgIGFuaW0gPSBhbmltYXRpb25zW2FuaW1hdGlvbl0sXG4gICAgICAgICAgICAgICAgbGVuID0gYW5pbS5sZW5ndGggLyA0O1xuXG4gICAgICAgICAgICBpZihpbmRleCA8IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lSW5kZXgoaW5kZXggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVJbmRleCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuU3ByaXRlLCBLb252YS5TaGFwZSk7XG5cbiAgICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3ByaXRlLCAnYW5pbWF0aW9uJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGFuaW1hdGlvbiBrZXlcbiAgICAgKiBAbmFtZSBhbmltYXRpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNwcml0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYW5pbSBhbmltYXRpb24ga2V5XG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBhbmltYXRpb24ga2V5XG4gICAgICogdmFyIGFuaW1hdGlvbiA9IHNwcml0ZS5hbmltYXRpb24oKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBhbmltYXRpb24ga2V5XG4gICAgICogc3ByaXRlLmFuaW1hdGlvbigna2lja2luZycpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3ByaXRlLCAnYW5pbWF0aW9ucycpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBhbmltYXRpb25zIG1hcFxuICAgICAqIEBuYW1lIGFuaW1hdGlvbnNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNwcml0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYW5pbWF0aW9uc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgYW5pbWF0aW9ucyBtYXBcbiAgICAgKiB2YXIgYW5pbWF0aW9ucyA9IHNwcml0ZS5hbmltYXRpb25zKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgYW5pbWF0aW9ucyBtYXBcbiAgICAgKiBzcHJpdGUuYW5pbWF0aW9ucyh7XG4gICAgICogICBzdGFuZGluZzogW1xuICAgICAqICAgICAvLyB4LCB5LCB3aWR0aCwgaGVpZ2h0ICg2IGZyYW1lcylcbiAgICAgKiAgICAgMCwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgNTIsIDAsIDQ5LCAxMDksXG4gICAgICogICAgIDEwNSwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgMTU4LCAwLCA0OSwgMTA5LFxuICAgICAqICAgICAyMTAsIDAsIDQ5LCAxMDksXG4gICAgICogICAgIDI2MiwgMCwgNDksIDEwOVxuICAgICAqICAgXSxcbiAgICAgKiAgIGtpY2tpbmc6IFtcbiAgICAgKiAgICAgLy8geCwgeSwgd2lkdGgsIGhlaWdodCAoNiBmcmFtZXMpXG4gICAgICogICAgIDAsIDEwOSwgNDUsIDk4LFxuICAgICAqICAgICA0NSwgMTA5LCA0NSwgOTgsXG4gICAgICogICAgIDk1LCAxMDksIDYzLCA5OCxcbiAgICAgKiAgICAgMTU2LCAxMDksIDcwLCA5OCxcbiAgICAgKiAgICAgMjI5LCAxMDksIDYwLCA5OCxcbiAgICAgKiAgICAgMjg3LCAxMDksIDQxLCA5OFxuICAgICAqICAgXVxuICAgICAqIH0pO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3ByaXRlLCAnZnJhbWVPZmZzZXRzJyk7XG5cbiAgICAvKipcbiAgICAqIGdldC9zZXQgb2Zmc2V0cyBtYXBcbiAgICAqIEBuYW1lIG9mZnNldHNcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5TcHJpdGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb2Zmc2V0c1xuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqIEBleGFtcGxlXG4gICAgKiAvLyBnZXQgb2Zmc2V0cyBtYXBcbiAgICAqIHZhciBvZmZzZXRzID0gc3ByaXRlLm9mZnNldHMoKTtcbiAgICAqXG4gICAgKiAvLyBzZXQgb2Zmc2V0cyBtYXBcbiAgICAqIHNwcml0ZS5vZmZzZXRzKHtcbiAgICAqICAgc3RhbmRpbmc6IFtcbiAgICAqICAgICAvLyB4LCB5ICg2IGZyYW1lcylcbiAgICAqICAgICAwLCAwLFxuICAgICogICAgIDAsIDAsXG4gICAgKiAgICAgNSwgMCxcbiAgICAqICAgICAwLCAwLFxuICAgICogICAgIDAsIDMsXG4gICAgKiAgICAgMiwgMFxuICAgICogICBdLFxuICAgICogICBraWNraW5nOiBbXG4gICAgKiAgICAgLy8geCwgeSAoNiBmcmFtZXMpXG4gICAgKiAgICAgMCwgNSxcbiAgICAqICAgICA1LCAwLFxuICAgICogICAgIDEwLCAwLFxuICAgICogICAgIDAsIDAsXG4gICAgKiAgICAgMiwgMSxcbiAgICAqICAgICAwLCAwXG4gICAgKiAgIF1cbiAgICAqIH0pO1xuICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TcHJpdGUsICdpbWFnZScpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBpbWFnZVxuICAgICAqIEBuYW1lIGltYWdlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TcHJpdGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2V9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgaW1hZ2VcbiAgICAgKiB2YXIgaW1hZ2UgPSBzcHJpdGUuaW1hZ2UoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBpbWFnZVxuICAgICAqIHNwcml0ZS5pbWFnZShpbWFnZU9iaik7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TcHJpdGUsICdmcmFtZUluZGV4JywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBzZXQvc2V0IGFuaW1hdGlvbiBmcmFtZSBpbmRleFxuICAgICAqIEBuYW1lIGZyYW1lSW5kZXhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNwcml0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGZyYW1lSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBhbmltYXRpb24gZnJhbWUgaW5kZXhcbiAgICAgKiB2YXIgZnJhbWVJbmRleCA9IHNwcml0ZS5mcmFtZUluZGV4KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgYW5pbWF0aW9uIGZyYW1lIGluZGV4XG4gICAgICogc3ByaXRlLmZyYW1lSW5kZXgoMyk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TcHJpdGUsICdmcmFtZVJhdGUnLCAxNyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZyYW1lIHJhdGUgaW4gZnJhbWVzIHBlciBzZWNvbmQuICBJbmNyZWFzZSB0aGlzIG51bWJlciB0byBtYWtlIHRoZSBzcHJpdGVcbiAgICAgKiAgYW5pbWF0aW9uIHJ1biBmYXN0ZXIsIGFuZCBkZWNyZWFzZSB0aGUgbnVtYmVyIHRvIG1ha2UgdGhlIHNwcml0ZSBhbmltYXRpb24gcnVuIHNsb3dlclxuICAgICAqICBUaGUgZGVmYXVsdCBpcyAxNyBmcmFtZXMgcGVyIHNlY29uZFxuICAgICAqIEBuYW1lIGZyYW1lUmF0ZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3ByaXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gZnJhbWVSYXRlXG4gICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZnJhbWUgcmF0ZVxuICAgICAqIHZhciBmcmFtZVJhdGUgPSBzcHJpdGUuZnJhbWVSYXRlKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZnJhbWUgcmF0ZSB0byAyIGZyYW1lcyBwZXIgc2Vjb25kXG4gICAgICogc3ByaXRlLmZyYW1lUmF0ZSgyKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYmFja0NvbXBhdChLb252YS5TcHJpdGUsIHtcbiAgICAgICAgaW5kZXg6ICdmcmFtZUluZGV4JyxcbiAgICAgICAgZ2V0SW5kZXg6ICdnZXRGcmFtZUluZGV4JyxcbiAgICAgICAgc2V0SW5kZXg6ICdzZXRGcmFtZUluZGV4J1xuICAgIH0pO1xuXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlNwcml0ZSk7XG59KSgpO1xuXG4vKmVzbGludC1kaXNhYmxlICBuby1zaGFkb3csIG1heC1sZW4sIG1heC1kZXB0aCAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogUGF0aCBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAYXV0aG9yIEphc29uIEZvbGxhc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmRhdGEgU1ZHIGRhdGEgc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBwYXRoID0gbmV3IEtvbnZhLlBhdGgoe1xuICAgICAqICAgeDogMjQwLFxuICAgICAqICAgeTogNDAsXG4gICAgICogICBkYXRhOiAnTTEyLjU4Miw5LjU1MUMzLjI1MSwxNi4yMzcsMC45MjEsMjkuMDIxLDcuMDgsMzguNTY0bC0yLjM2LDEuNjg5bDQuODkzLDIuMjYybDQuODkzLDIuMjYybC0wLjU2OC01LjM2bC0wLjU2Ny01LjM1OWwtMi4zNjUsMS42OTRjLTQuNjU3LTcuMzc1LTIuODMtMTcuMTg1LDQuMzUyLTIyLjMzYzcuNDUxLTUuMzM4LDE3LjgxNy0zLjYyNSwyMy4xNTYsMy44MjRjNS4zMzcsNy40NDksMy42MjUsMTcuODEzLTMuODIxLDIzLjE1MmwyLjg1NywzLjk4OGM5LjYxNy02Ljg5MywxMS44MjctMjAuMjc3LDQuOTM1LTI5Ljg5NkMzNS41OTEsNC44NywyMi4yMDQsMi42NTgsMTIuNTgyLDkuNTUxeicsXG4gICAgICogICBmaWxsOiAnZ3JlZW4nLFxuICAgICAqICAgc2NhbGU6IDJcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBLb252YS5QYXRoID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgICB9O1xuXG4gICAgS29udmEuUGF0aC5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YUFycmF5ID0gW107XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1BhdGgnO1xuXG4gICAgICAgICAgICB0aGlzLmRhdGFBcnJheSA9IEtvbnZhLlBhdGgucGFyc2VQYXRoRGF0YSh0aGlzLmdldERhdGEoKSk7XG4gICAgICAgICAgICB0aGlzLm9uKCdkYXRhQ2hhbmdlLmtvbnZhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuZGF0YUFycmF5ID0gS29udmEuUGF0aC5wYXJzZVBhdGhEYXRhKHRoaXMuZ2V0RGF0YSgpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgICAgICB9LFxuICAgICAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgY2EgPSB0aGlzLmRhdGFBcnJheSxcbiAgICAgICAgICAgICAgICBjbG9zZWRQYXRoID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIGNvbnRleHQgcG9zaXRpb25cbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGNhLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBjYVtuXS5jb21tYW5kO1xuICAgICAgICAgICAgICAgIHZhciBwID0gY2Fbbl0ucG9pbnRzO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHBbMF0sIHBbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ocFswXSwgcFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8ocFswXSwgcFsxXSwgcFsyXSwgcFszXSwgcFs0XSwgcFs1XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocFswXSwgcFsxXSwgcFsyXSwgcFszXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3ggPSBwWzBdLCBjeSA9IHBbMV0sIHJ4ID0gcFsyXSwgcnkgPSBwWzNdLCB0aGV0YSA9IHBbNF0sIGRUaGV0YSA9IHBbNV0sIHBzaSA9IHBbNl0sIGZzID0gcFs3XTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSAocnggPiByeSkgPyByeCA6IHJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlWCA9IChyeCA+IHJ5KSA/IDEgOiByeCAvIHJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlWSA9IChyeCA+IHJ5KSA/IHJ5IC8gcnggOiAxO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShjeCwgY3kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yb3RhdGUocHNpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgciwgdGhldGEsIHRoZXRhICsgZFRoZXRhLCAxIC0gZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zY2FsZSgxIC8gc2NhbGVYLCAxIC8gc2NhbGVZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucm90YXRlKC1wc2kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoLWN4LCAtY3kpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VkUGF0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjbG9zZWRQYXRoKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRTZWxmUmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICAgICAgICB0aGlzLmRhdGFBcnJheS5mb3JFYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBwb2ludHMuY29uY2F0KGRhdGEucG9pbnRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG1pblggPSBwb2ludHNbMF07XG4gICAgICAgICAgICB2YXIgbWF4WCA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIHZhciBtaW5ZID0gcG9pbnRzWzBdO1xuICAgICAgICAgICAgdmFyIG1heFkgPSBwb2ludHNbMF07XG4gICAgICAgICAgICB2YXIgeCwgeTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICAgICAgICAgIHggPSBwb2ludHNbaSAqIDJdOyB5ID0gcG9pbnRzW2kgKiAyICsgMV07XG4gICAgICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgpO1xuICAgICAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4KTtcbiAgICAgICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSk7XG4gICAgICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBNYXRoLnJvdW5kKG1pblgpLFxuICAgICAgICAgICAgICAgIHk6IE1hdGgucm91bmQobWluWSksXG4gICAgICAgICAgICAgICAgd2lkdGg6IE1hdGgucm91bmQobWF4WCAtIG1pblgpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogTWF0aC5yb3VuZChtYXhZIC0gbWluWSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlBhdGgsIEtvbnZhLlNoYXBlKTtcblxuICAgIEtvbnZhLlBhdGguZ2V0TGluZUxlbmd0aCA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpKTtcbiAgICB9O1xuICAgIEtvbnZhLlBhdGguZ2V0UG9pbnRPbkxpbmUgPSBmdW5jdGlvbihkaXN0LCBQMXgsIFAxeSwgUDJ4LCBQMnksIGZyb21YLCBmcm9tWSkge1xuICAgICAgICBpZihmcm9tWCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmcm9tWCA9IFAxeDtcbiAgICAgICAgfVxuICAgICAgICBpZihmcm9tWSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmcm9tWSA9IFAxeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtID0gKFAyeSAtIFAxeSkgLyAoKFAyeCAtIFAxeCkgKyAwLjAwMDAwMDAxKTtcbiAgICAgICAgdmFyIHJ1biA9IE1hdGguc3FydChkaXN0ICogZGlzdCAvICgxICsgbSAqIG0pKTtcbiAgICAgICAgaWYoUDJ4IDwgUDF4KSB7XG4gICAgICAgICAgICBydW4gKj0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJpc2UgPSBtICogcnVuO1xuICAgICAgICB2YXIgcHQ7XG5cbiAgICAgICAgaWYgKFAyeCA9PT0gUDF4KSB7IC8vIHZlcnRpY2FsIGxpbmVcbiAgICAgICAgICAgIHB0ID0ge1xuICAgICAgICAgICAgICAgIHg6IGZyb21YLFxuICAgICAgICAgICAgICAgIHk6IGZyb21ZICsgcmlzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmKChmcm9tWSAtIFAxeSkgLyAoKGZyb21YIC0gUDF4KSArIDAuMDAwMDAwMDEpID09PSBtKSB7XG4gICAgICAgICAgICBwdCA9IHtcbiAgICAgICAgICAgICAgICB4OiBmcm9tWCArIHJ1bixcbiAgICAgICAgICAgICAgICB5OiBmcm9tWSArIHJpc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaXgsIGl5O1xuXG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5nZXRMaW5lTGVuZ3RoKFAxeCwgUDF5LCBQMngsIFAyeSk7XG4gICAgICAgICAgICBpZihsZW4gPCAwLjAwMDAwMDAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB1ID0gKCgoZnJvbVggLSBQMXgpICogKFAyeCAtIFAxeCkpICsgKChmcm9tWSAtIFAxeSkgKiAoUDJ5IC0gUDF5KSkpO1xuICAgICAgICAgICAgdSA9IHUgLyAobGVuICogbGVuKTtcbiAgICAgICAgICAgIGl4ID0gUDF4ICsgdSAqIChQMnggLSBQMXgpO1xuICAgICAgICAgICAgaXkgPSBQMXkgKyB1ICogKFAyeSAtIFAxeSk7XG5cbiAgICAgICAgICAgIHZhciBwUmlzZSA9IHRoaXMuZ2V0TGluZUxlbmd0aChmcm9tWCwgZnJvbVksIGl4LCBpeSk7XG4gICAgICAgICAgICB2YXIgcFJ1biA9IE1hdGguc3FydChkaXN0ICogZGlzdCAtIHBSaXNlICogcFJpc2UpO1xuICAgICAgICAgICAgcnVuID0gTWF0aC5zcXJ0KHBSdW4gKiBwUnVuIC8gKDEgKyBtICogbSkpO1xuICAgICAgICAgICAgaWYoUDJ4IDwgUDF4KSB7XG4gICAgICAgICAgICAgICAgcnVuICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmlzZSA9IG0gKiBydW47XG4gICAgICAgICAgICBwdCA9IHtcbiAgICAgICAgICAgICAgICB4OiBpeCArIHJ1bixcbiAgICAgICAgICAgICAgICB5OiBpeSArIHJpc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHQ7XG4gICAgfTtcblxuICAgIEtvbnZhLlBhdGguZ2V0UG9pbnRPbkN1YmljQmV6aWVyID0gZnVuY3Rpb24ocGN0LCBQMXgsIFAxeSwgUDJ4LCBQMnksIFAzeCwgUDN5LCBQNHgsIFA0eSkge1xuICAgICAgICBmdW5jdGlvbiBDQjEodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBDQjIodCkge1xuICAgICAgICAgICAgcmV0dXJuIDMgKiB0ICogdCAqICgxIC0gdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gQ0IzKHQpIHtcbiAgICAgICAgICAgIHJldHVybiAzICogdCAqICgxIC0gdCkgKiAoMSAtIHQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIENCNCh0KSB7XG4gICAgICAgICAgICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCkgKiAoMSAtIHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB4ID0gUDR4ICogQ0IxKHBjdCkgKyBQM3ggKiBDQjIocGN0KSArIFAyeCAqIENCMyhwY3QpICsgUDF4ICogQ0I0KHBjdCk7XG4gICAgICAgIHZhciB5ID0gUDR5ICogQ0IxKHBjdCkgKyBQM3kgKiBDQjIocGN0KSArIFAyeSAqIENCMyhwY3QpICsgUDF5ICogQ0I0KHBjdCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBLb252YS5QYXRoLmdldFBvaW50T25RdWFkcmF0aWNCZXppZXIgPSBmdW5jdGlvbihwY3QsIFAxeCwgUDF5LCBQMngsIFAyeSwgUDN4LCBQM3kpIHtcbiAgICAgICAgZnVuY3Rpb24gUUIxKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0ICogdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBRQjIodCkge1xuICAgICAgICAgICAgcmV0dXJuIDIgKiB0ICogKDEgLSB0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBRQjModCkge1xuICAgICAgICAgICAgcmV0dXJuICgxIC0gdCkgKiAoMSAtIHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB4ID0gUDN4ICogUUIxKHBjdCkgKyBQMnggKiBRQjIocGN0KSArIFAxeCAqIFFCMyhwY3QpO1xuICAgICAgICB2YXIgeSA9IFAzeSAqIFFCMShwY3QpICsgUDJ5ICogUUIyKHBjdCkgKyBQMXkgKiBRQjMocGN0KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEtvbnZhLlBhdGguZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMgPSBmdW5jdGlvbihjeCwgY3ksIHJ4LCByeSwgdGhldGEsIHBzaSkge1xuICAgICAgICB2YXIgY29zUHNpID0gTWF0aC5jb3MocHNpKSwgc2luUHNpID0gTWF0aC5zaW4ocHNpKTtcbiAgICAgICAgdmFyIHB0ID0ge1xuICAgICAgICAgICAgeDogcnggKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICAgICAgICB5OiByeSAqIE1hdGguc2luKHRoZXRhKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogY3ggKyAocHQueCAqIGNvc1BzaSAtIHB0LnkgKiBzaW5Qc2kpLFxuICAgICAgICAgICAgeTogY3kgKyAocHQueCAqIHNpblBzaSArIHB0LnkgKiBjb3NQc2kpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKlxuICAgICAqIGdldCBwYXJzZWQgZGF0YSBhcnJheSBmcm9tIHRoZSBkYXRhXG4gICAgICogIHN0cmluZy4gIFYsIHYsIEgsIGgsIGFuZCBsIGRhdGEgYXJlIGNvbnZlcnRlZCB0b1xuICAgICAqICBMIGRhdGEgZm9yIHRoZSBwdXJwb3NlIG9mIGhpZ2ggcGVyZm9ybWFuY2UgUGF0aFxuICAgICAqICByZW5kZXJpbmdcbiAgICAgKi9cbiAgICBLb252YS5QYXRoLnBhcnNlUGF0aERhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIC8vIFBhdGggRGF0YSBTZWdtZW50IG11c3QgYmVnaW4gd2l0aCBhIG1vdmVUb1xuICAgICAgICAvL20gKHggeSkrICBSZWxhdGl2ZSBtb3ZlVG8gKHN1YnNlcXVlbnQgcG9pbnRzIGFyZSB0cmVhdGVkIGFzIGxpbmVUbylcbiAgICAgICAgLy9NICh4IHkpKyAgQWJzb2x1dGUgbW92ZVRvIChzdWJzZXF1ZW50IHBvaW50cyBhcmUgdHJlYXRlZCBhcyBsaW5lVG8pXG4gICAgICAgIC8vbCAoeCB5KSsgIFJlbGF0aXZlIGxpbmVUb1xuICAgICAgICAvL0wgKHggeSkrICBBYnNvbHV0ZSBMaW5lVG9cbiAgICAgICAgLy9oICh4KSsgICAgUmVsYXRpdmUgaG9yaXpvbnRhbCBsaW5lVG9cbiAgICAgICAgLy9IICh4KSsgICAgQWJzb2x1dGUgaG9yaXpvbnRhbCBsaW5lVG9cbiAgICAgICAgLy92ICh5KSsgICAgUmVsYXRpdmUgdmVydGljYWwgbGluZVRvXG4gICAgICAgIC8vViAoeSkrICAgIEFic29sdXRlIHZlcnRpY2FsIGxpbmVUb1xuICAgICAgICAvL3ogKGNsb3NlcGF0aClcbiAgICAgICAgLy9aIChjbG9zZXBhdGgpXG4gICAgICAgIC8vYyAoeDEgeTEgeDIgeTIgeCB5KSsgUmVsYXRpdmUgQmV6aWVyIGN1cnZlXG4gICAgICAgIC8vQyAoeDEgeTEgeDIgeTIgeCB5KSsgQWJzb2x1dGUgQmV6aWVyIGN1cnZlXG4gICAgICAgIC8vcSAoeDEgeTEgeCB5KSsgICAgICAgUmVsYXRpdmUgUXVhZHJhdGljIEJlemllclxuICAgICAgICAvL1EgKHgxIHkxIHggeSkrICAgICAgIEFic29sdXRlIFF1YWRyYXRpYyBCZXppZXJcbiAgICAgICAgLy90ICh4IHkpKyAgICBTaG9ydGhhbmQvU21vb3RoIFJlbGF0aXZlIFF1YWRyYXRpYyBCZXppZXJcbiAgICAgICAgLy9UICh4IHkpKyAgICBTaG9ydGhhbmQvU21vb3RoIEFic29sdXRlIFF1YWRyYXRpYyBCZXppZXJcbiAgICAgICAgLy9zICh4MiB5MiB4IHkpKyAgICAgICBTaG9ydGhhbmQvU21vb3RoIFJlbGF0aXZlIEJlemllciBjdXJ2ZVxuICAgICAgICAvL1MgKHgyIHkyIHggeSkrICAgICAgIFNob3J0aGFuZC9TbW9vdGggQWJzb2x1dGUgQmV6aWVyIGN1cnZlXG4gICAgICAgIC8vYSAocnggcnkgeC1heGlzLXJvdGF0aW9uIGxhcmdlLWFyYy1mbGFnIHN3ZWVwLWZsYWcgeCB5KSsgICAgIFJlbGF0aXZlIEVsbGlwdGljYWwgQXJjXG4gICAgICAgIC8vQSAocnggcnkgeC1heGlzLXJvdGF0aW9uIGxhcmdlLWFyYy1mbGFnIHN3ZWVwLWZsYWcgeCB5KSsgIEFic29sdXRlIEVsbGlwdGljYWwgQXJjXG5cbiAgICAgICAgLy8gcmV0dXJuIGVhcmx5IGlmIGRhdGEgaXMgbm90IGRlZmluZWRcbiAgICAgICAgaWYoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbW1hbmQgc3RyaW5nXG4gICAgICAgIHZhciBjcyA9IGRhdGE7XG5cbiAgICAgICAgLy8gY29tbWFuZCBjaGFyc1xuICAgICAgICB2YXIgY2MgPSBbJ20nLCAnTScsICdsJywgJ0wnLCAndicsICdWJywgJ2gnLCAnSCcsICd6JywgJ1onLCAnYycsICdDJywgJ3EnLCAnUScsICd0JywgJ1QnLCAncycsICdTJywgJ2EnLCAnQSddO1xuICAgICAgICAvLyBjb252ZXJ0IHdoaXRlIHNwYWNlcyB0byBjb21tYXNcbiAgICAgICAgY3MgPSBjcy5yZXBsYWNlKG5ldyBSZWdFeHAoJyAnLCAnZycpLCAnLCcpO1xuICAgICAgICAvLyBjcmVhdGUgcGlwZXMgc28gdGhhdCB3ZSBjYW4gc3BsaXQgdGhlIGRhdGFcbiAgICAgICAgZm9yKHZhciBuID0gMDsgbiA8IGNjLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICBjcyA9IGNzLnJlcGxhY2UobmV3IFJlZ0V4cChjY1tuXSwgJ2cnKSwgJ3wnICsgY2Nbbl0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBhcnJheVxuICAgICAgICB2YXIgYXJyID0gY3Muc3BsaXQoJ3wnKTtcbiAgICAgICAgdmFyIGNhID0gW107XG4gICAgICAgIC8vIGluaXQgY29udGV4dCBwb2ludFxuICAgICAgICB2YXIgY3B4ID0gMDtcbiAgICAgICAgdmFyIGNweSA9IDA7XG4gICAgICAgIGZvciggbiA9IDE7IG4gPCBhcnIubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSBhcnJbbl07XG4gICAgICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoMCk7XG4gICAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG4gICAgICAgICAgICAvLyByZW1vdmUgLC0gZm9yIGNvbnNpc3RlbmN5XG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShuZXcgUmVnRXhwKCcsLScsICdnJyksICctJyk7XG4gICAgICAgICAgICAvLyBhZGQgY29tbWFzIHNvIHRoYXQgaXQncyBlYXN5IHRvIHNwbGl0XG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShuZXcgUmVnRXhwKCctJywgJ2cnKSwgJywtJyk7XG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShuZXcgUmVnRXhwKCdlLC0nLCAnZycpLCAnZS0nKTtcbiAgICAgICAgICAgIHZhciBwID0gc3RyLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBpZihwLmxlbmd0aCA+IDAgJiYgcFswXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb252ZXJ0IHN0cmluZ3MgdG8gZmxvYXRzXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHBbaV0gPSBwYXJzZUZsb2F0KHBbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUocC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYoaXNOYU4ocFswXSkpIHsvLyBjYXNlIGZvciBhIHRyYWlsaW5nIGNvbW1hIGJlZm9yZSBuZXh0IGNvbW1hbmRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNtZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydFggPSBjcHgsIHN0YXJ0WSA9IGNweTtcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHZhciBmcm9tIHdpdGhpbiB0aGUgc3dpdGNoIHRvIHVwIGhlcmUgKGpzaGludClcbiAgICAgICAgICAgICAgICB2YXIgcHJldkNtZCwgY3RsUHR4LCBjdGxQdHk7ICAgICAvLyBTcywgVHRcbiAgICAgICAgICAgICAgICB2YXIgcngsIHJ5LCBwc2ksIGZhLCBmcywgeDEsIHkxOyAvLyBBYVxuXG5cbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IGwsIEgsIGgsIFYsIGFuZCB2IHRvIExcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGMpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBLZWVwIHRoZSBsaW5lVG8ncyBhYm92ZSB0aGUgbW92ZVRvJ3MgaW4gdGhpcyBzd2l0Y2hcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdMJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IGxpbmVUbyBoYW5kbGVycyBuZWVkIHRvIGJlIGFib3ZlIHRoaXMgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gZHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnTSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZnRlciBjbG9zaW5nIHRoZSBwYXRoIG1vdmUgdGhlIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHRoZSB0aGUgZmlyc3QgcG9pbnQgb2YgdGhlIHBhdGggKGlmIGFueSkuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjYS5sZW5ndGggPiAyICYmIGNhW2NhLmxlbmd0aCAtIDFdLmNvbW1hbmQgPT09ICd6Jyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpZHggPSBjYS5sZW5ndGggLSAyOyBpZHggPj0gMDsgaWR4LS0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjYVtpZHhdLmNvbW1hbmQgPT09ICdNJyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBjYVtpZHhdLnBvaW50c1swXSArIGR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gY2FbaWR4XS5wb2ludHNbMV0gKyBkeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICdsJztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1YnNlcXVlbnQgcG9pbnRzIGFyZSB0cmVhdGVkIGFzIHJlbGF0aXZlIGxpbmVUb1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ00nO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICdMJztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1YnNlcXVlbnQgcG9pbnRzIGFyZSB0cmVhdGVkIGFzIGFic29sdXRlIGxpbmVUb1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ0wnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ0wnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdMJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdMJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHAuc2hpZnQoKSwgcC5zaGlmdCgpLCBwLnNoaWZ0KCksIHAuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHggKyBwLnNoaWZ0KCksIGNweSArIHAuc2hpZnQoKSwgY3B4ICsgcC5zaGlmdCgpLCBjcHkgKyBwLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnQyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Q21kID0gY2FbY2EubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwcmV2Q21kLmNvbW1hbmQgPT09ICdDJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweCArIChjcHggLSBwcmV2Q21kLnBvaW50c1syXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5ICsgKGNweSAtIHByZXZDbWQucG9pbnRzWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGN0bFB0eCwgY3RsUHR5LCBwLnNoaWZ0KCksIHAuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnQyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Q21kID0gY2FbY2EubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwcmV2Q21kLmNvbW1hbmQgPT09ICdDJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweCArIChjcHggLSBwcmV2Q21kLnBvaW50c1syXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5ICsgKGNweSAtIHByZXZDbWQucG9pbnRzWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGN0bFB0eCwgY3RsUHR5LCBjcHggKyBwLnNoaWZ0KCksIGNweSArIHAuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdDJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHAuc2hpZnQoKSwgcC5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdxJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCArIHAuc2hpZnQoKSwgY3B5ICsgcC5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ1EnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkNtZCA9IGNhW2NhLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYocHJldkNtZC5jb21tYW5kID09PSAnUScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHggKyAoY3B4IC0gcHJldkNtZC5wb2ludHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweSArIChjcHkgLSBwcmV2Q21kLnBvaW50c1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnUSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkNtZCA9IGNhW2NhLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYocHJldkNtZC5jb21tYW5kID09PSAnUScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHggKyAoY3B4IC0gcHJldkNtZC5wb2ludHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweSArIChjcHkgLSBwcmV2Q21kLnBvaW50c1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdRJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGN0bFB0eCwgY3RsUHR5LCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByeCA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ5ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHNpID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmEgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcyA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnQSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSB0aGlzLmNvbnZlcnRFbmRwb2ludFRvQ2VudGVyUGFyYW1ldGVyaXphdGlvbih4MSwgeTEsIGNweCwgY3B5LCBmYSwgZnMsIHJ4LCByeSwgcHNpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwc2kgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MSA9IGNweTsgY3B4ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnQSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSB0aGlzLmNvbnZlcnRFbmRwb2ludFRvQ2VudGVyUGFyYW1ldGVyaXphdGlvbih4MSwgeTEsIGNweCwgY3B5LCBmYSwgZnMsIHJ4LCByeSwgcHNpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBjbWQgfHwgYyxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBzdGFydFgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBzdGFydFlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aExlbmd0aDogdGhpcy5jYWxjTGVuZ3RoKHN0YXJ0WCwgc3RhcnRZLCBjbWQgfHwgYywgcG9pbnRzKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihjID09PSAneicgfHwgYyA9PT0gJ1onKSB7XG4gICAgICAgICAgICAgICAgY2EucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICd6JyxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aExlbmd0aDogMFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhO1xuICAgIH07XG4gICAgS29udmEuUGF0aC5jYWxjTGVuZ3RoID0gZnVuY3Rpb24oeCwgeSwgY21kLCBwb2ludHMpIHtcbiAgICAgICAgdmFyIGxlbiwgcDEsIHAyLCB0O1xuICAgICAgICB2YXIgcGF0aCA9IEtvbnZhLlBhdGg7XG5cbiAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoLmdldExpbmVMZW5ndGgoeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgLy8gQXBwcm94aW1hdGVzIGJ5IGJyZWFraW5nIGN1cnZlIGludG8gMTAwIGxpbmUgc2VnbWVudHNcbiAgICAgICAgICAgICAgICBsZW4gPSAwLjA7XG4gICAgICAgICAgICAgICAgcDEgPSBwYXRoLmdldFBvaW50T25DdWJpY0JlemllcigwLCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHBvaW50c1s0XSwgcG9pbnRzWzVdKTtcbiAgICAgICAgICAgICAgICBmb3IoIHQgPSAwLjAxOyB0IDw9IDE7IHQgKz0gMC4wMSkge1xuICAgICAgICAgICAgICAgICAgICBwMiA9IHBhdGguZ2V0UG9pbnRPbkN1YmljQmV6aWVyKHQsIHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgcG9pbnRzWzRdLCBwb2ludHNbNV0pO1xuICAgICAgICAgICAgICAgICAgICBsZW4gKz0gcGF0aC5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuO1xuICAgICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICAgICAgLy8gQXBwcm94aW1hdGVzIGJ5IGJyZWFraW5nIGN1cnZlIGludG8gMTAwIGxpbmUgc2VnbWVudHNcbiAgICAgICAgICAgICAgICBsZW4gPSAwLjA7XG4gICAgICAgICAgICAgICAgcDEgPSBwYXRoLmdldFBvaW50T25RdWFkcmF0aWNCZXppZXIoMCwgeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdKTtcbiAgICAgICAgICAgICAgICBmb3IoIHQgPSAwLjAxOyB0IDw9IDE7IHQgKz0gMC4wMSkge1xuICAgICAgICAgICAgICAgICAgICBwMiA9IHBhdGguZ2V0UG9pbnRPblF1YWRyYXRpY0Jlemllcih0LCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuICAgICAgICAgICAgICAgICAgICBsZW4gKz0gcGF0aC5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuO1xuICAgICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAgICAgLy8gQXBwcm94aW1hdGVzIGJ5IGJyZWFraW5nIGN1cnZlIGludG8gbGluZSBzZWdtZW50c1xuICAgICAgICAgICAgICAgIGxlbiA9IDAuMDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBwb2ludHNbNF07XG4gICAgICAgICAgICAgICAgLy8gNCA9IHRoZXRhXG4gICAgICAgICAgICAgICAgdmFyIGRUaGV0YSA9IHBvaW50c1s1XTtcbiAgICAgICAgICAgICAgICAvLyA1ID0gZFRoZXRhXG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IHBvaW50c1s0XSArIGRUaGV0YTtcbiAgICAgICAgICAgICAgICB2YXIgaW5jID0gTWF0aC5QSSAvIDE4MC4wO1xuICAgICAgICAgICAgICAgIC8vIDEgZGVncmVlIHJlc29sdXRpb25cbiAgICAgICAgICAgICAgICBpZihNYXRoLmFicyhzdGFydCAtIGVuZCkgPCBpbmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jID0gTWF0aC5hYnMoc3RhcnQgLSBlbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBmb3IgcHVycG9zZSBvZiBjYWxjdWxhdGluZyBhcmMgbGVuZ3RoLCBub3QgZ29pbmcgdG8gd29ycnkgYWJvdXQgcm90YXRpbmcgWC1heGlzIGJ5IGFuZ2xlIHBzaVxuICAgICAgICAgICAgICAgIHAxID0gcGF0aC5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHN0YXJ0LCAwKTtcbiAgICAgICAgICAgICAgICBpZihkVGhldGEgPCAwKSB7Ly8gY2xvY2t3aXNlXG4gICAgICAgICAgICAgICAgICAgIGZvciggdCA9IHN0YXJ0IC0gaW5jOyB0ID4gZW5kOyB0IC09IGluYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcDIgPSBwYXRoLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgdCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4gKz0gcGF0aC5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsvLyBjb3VudGVyLWNsb2Nrd2lzZVxuICAgICAgICAgICAgICAgICAgICBmb3IoIHQgPSBzdGFydCArIGluYzsgdCA8IGVuZDsgdCArPSBpbmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAyID0gcGF0aC5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHQsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuICs9IHBhdGguZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAxID0gcDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcDIgPSBwYXRoLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgZW5kLCAwKTtcbiAgICAgICAgICAgICAgICBsZW4gKz0gcGF0aC5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgS29udmEuUGF0aC5jb252ZXJ0RW5kcG9pbnRUb0NlbnRlclBhcmFtZXRlcml6YXRpb24gPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgZmEsIGZzLCByeCwgcnksIHBzaURlZykge1xuICAgICAgICAvLyBEZXJpdmVkIGZyb206IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9pbXBsbm90ZS5odG1sI0FyY0ltcGxlbWVudGF0aW9uTm90ZXNcbiAgICAgICAgdmFyIHBzaSA9IHBzaURlZyAqIChNYXRoLlBJIC8gMTgwLjApO1xuICAgICAgICB2YXIgeHAgPSBNYXRoLmNvcyhwc2kpICogKHgxIC0geDIpIC8gMi4wICsgTWF0aC5zaW4ocHNpKSAqICh5MSAtIHkyKSAvIDIuMDtcbiAgICAgICAgdmFyIHlwID0gLTEgKiBNYXRoLnNpbihwc2kpICogKHgxIC0geDIpIC8gMi4wICsgTWF0aC5jb3MocHNpKSAqICh5MSAtIHkyKSAvIDIuMDtcblxuICAgICAgICB2YXIgbGFtYmRhID0gKHhwICogeHApIC8gKHJ4ICogcngpICsgKHlwICogeXApIC8gKHJ5ICogcnkpO1xuXG4gICAgICAgIGlmKGxhbWJkYSA+IDEpIHtcbiAgICAgICAgICAgIHJ4ICo9IE1hdGguc3FydChsYW1iZGEpO1xuICAgICAgICAgICAgcnkgKj0gTWF0aC5zcXJ0KGxhbWJkYSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZiA9IE1hdGguc3FydCgoKChyeCAqIHJ4KSAqIChyeSAqIHJ5KSkgLSAoKHJ4ICogcngpICogKHlwICogeXApKSAtICgocnkgKiByeSkgKiAoeHAgKiB4cCkpKSAvICgocnggKiByeCkgKiAoeXAgKiB5cCkgKyAocnkgKiByeSkgKiAoeHAgKiB4cCkpKTtcblxuICAgICAgICBpZihmYSA9PT0gZnMpIHtcbiAgICAgICAgICAgIGYgKj0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaXNOYU4oZikpIHtcbiAgICAgICAgICAgIGYgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN4cCA9IGYgKiByeCAqIHlwIC8gcnk7XG4gICAgICAgIHZhciBjeXAgPSBmICogLXJ5ICogeHAgLyByeDtcblxuICAgICAgICB2YXIgY3ggPSAoeDEgKyB4MikgLyAyLjAgKyBNYXRoLmNvcyhwc2kpICogY3hwIC0gTWF0aC5zaW4ocHNpKSAqIGN5cDtcbiAgICAgICAgdmFyIGN5ID0gKHkxICsgeTIpIC8gMi4wICsgTWF0aC5zaW4ocHNpKSAqIGN4cCArIE1hdGguY29zKHBzaSkgKiBjeXA7XG5cbiAgICAgICAgdmFyIHZNYWcgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdlJhdGlvID0gZnVuY3Rpb24odSwgdikge1xuICAgICAgICAgICAgcmV0dXJuICh1WzBdICogdlswXSArIHVbMV0gKiB2WzFdKSAvICh2TWFnKHUpICogdk1hZyh2KSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB2QW5nbGUgPSBmdW5jdGlvbih1LCB2KSB7XG4gICAgICAgICAgICByZXR1cm4gKHVbMF0gKiB2WzFdIDwgdVsxXSAqIHZbMF0gPyAtMSA6IDEpICogTWF0aC5hY29zKHZSYXRpbyh1LCB2KSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aGV0YSA9IHZBbmdsZShbMSwgMF0sIFsoeHAgLSBjeHApIC8gcngsICh5cCAtIGN5cCkgLyByeV0pO1xuICAgICAgICB2YXIgdSA9IFsoeHAgLSBjeHApIC8gcngsICh5cCAtIGN5cCkgLyByeV07XG4gICAgICAgIHZhciB2ID0gWygtMSAqIHhwIC0gY3hwKSAvIHJ4LCAoLTEgKiB5cCAtIGN5cCkgLyByeV07XG4gICAgICAgIHZhciBkVGhldGEgPSB2QW5nbGUodSwgdik7XG5cbiAgICAgICAgaWYodlJhdGlvKHUsIHYpIDw9IC0xKSB7XG4gICAgICAgICAgICBkVGhldGEgPSBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICAgIGlmKHZSYXRpbyh1LCB2KSA+PSAxKSB7XG4gICAgICAgICAgICBkVGhldGEgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmKGZzID09PSAwICYmIGRUaGV0YSA+IDApIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IGRUaGV0YSAtIDIgKiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICAgIGlmKGZzID09PSAxICYmIGRUaGV0YSA8IDApIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IGRUaGV0YSArIDIgKiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbY3gsIGN5LCByeCwgcnksIHRoZXRhLCBkVGhldGEsIHBzaSwgZnNdO1xuICAgIH07XG4gICAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlBhdGgsICdkYXRhJyk7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgU1ZHIHBhdGggZGF0YSBzdHJpbmcuICBUaGlzIG1ldGhvZFxuICAgICAqICBhbHNvIGF1dG9tYXRpY2FsbHkgcGFyc2VzIHRoZSBkYXRhIHN0cmluZ1xuICAgICAqICBpbnRvIGEgZGF0YSBhcnJheS4gIEN1cnJlbnRseSBzdXBwb3J0ZWQgU1ZHIGRhdGE6XG4gICAgICogIE0sIG0sIEwsIGwsIEgsIGgsIFYsIHYsIFEsIHEsIFQsIHQsIEMsIGMsIFMsIHMsIEEsIGEsIFosIHpcbiAgICAgKiBAbmFtZSBzZXREYXRhXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5QYXRoLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBTVkcgcGF0aCBjb21tYW5kIHN0cmluZ1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogZ2V0IFNWRyBwYXRoIGRhdGEgc3RyaW5nXG4gICAgICogQG5hbWUgZ2V0RGF0YVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuUGF0aC5wcm90b3R5cGVcbiAgICAgKi9cblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5QYXRoKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIEVNUFRZX1NUUklORyA9ICcnLFxuICAgICAgICAvL0NBTElCUkkgPSAnQ2FsaWJyaScsXG4gICAgICAgIE5PUk1BTCA9ICdub3JtYWwnO1xuXG4gICAgLyoqXG4gICAgICogUGF0aCBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAYXV0aG9yIEphc29uIEZvbGxhc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5mb250RmFtaWx5XSBkZWZhdWx0IGlzIENhbGlicmlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5mb250U2l6ZV0gZGVmYXVsdCBpcyAxMlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZvbnRTdHlsZV0gY2FuIGJlIG5vcm1hbCwgYm9sZCwgb3IgaXRhbGljLiAgRGVmYXVsdCBpcyBub3JtYWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5mb250VmFyaWFudF0gY2FuIGJlIG5vcm1hbCBvciBzbWFsbC1jYXBzLiAgRGVmYXVsdCBpcyBub3JtYWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLnRleHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmRhdGEgU1ZHIGRhdGEgc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciB0ZXh0cGF0aCA9IG5ldyBLb252YS5UZXh0UGF0aCh7XG4gICAgICogICB4OiAxMDAsXG4gICAgICogICB5OiA1MCxcbiAgICAgKiAgIGZpbGw6ICcjMzMzJyxcbiAgICAgKiAgIGZvbnRTaXplOiAnMjQnLFxuICAgICAqICAgZm9udEZhbWlseTogJ0FyaWFsJyxcbiAgICAgKiAgIHRleHQ6ICdBbGwgdGhlIHdvcmxkXFwncyBhIHN0YWdlLCBhbmQgYWxsIHRoZSBtZW4gYW5kIHdvbWVuIG1lcmVseSBwbGF5ZXJzLicsXG4gICAgICogICBkYXRhOiAnTTEwLDEwIEMwLDAgMTAsMTUwIDEwMCwxMDAgUzMwMCwxNTAgNDAwLDUwJ1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIEtvbnZhLlRleHRQYXRoID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfZmlsbEZ1bmMoY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHRoaXMucGFydGlhbFRleHQsIDAsIDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfc3Ryb2tlRnVuYyhjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dCh0aGlzLnBhcnRpYWxUZXh0LCAwLCAwKTtcbiAgICB9XG5cbiAgICBLb252YS5UZXh0UGF0aC5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5kdW1teUNhbnZhcyA9IEtvbnZhLlV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgICAgICAgdGhpcy5kYXRhQXJyYXkgPSBbXTtcblxuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuXG4gICAgICAgICAgICAvLyBvdmVycmlkZXNcbiAgICAgICAgICAgIC8vIFRPRE86IHNob3VsZG4ndCB0aGlzIGJlIG9uIHRoZSBwcm90b3R5cGU/XG4gICAgICAgICAgICB0aGlzLl9maWxsRnVuYyA9IF9maWxsRnVuYztcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZUZ1bmMgPSBfc3Ryb2tlRnVuYztcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxGdW5jSGl0ID0gX2ZpbGxGdW5jO1xuICAgICAgICAgICAgdGhpcy5fc3Ryb2tlRnVuY0hpdCA9IF9zdHJva2VGdW5jO1xuXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICdUZXh0UGF0aCc7XG5cbiAgICAgICAgICAgIHRoaXMuZGF0YUFycmF5ID0gS29udmEuUGF0aC5wYXJzZVBhdGhEYXRhKHRoaXMuYXR0cnMuZGF0YSk7XG4gICAgICAgICAgICB0aGlzLm9uKCdkYXRhQ2hhbmdlLmtvbnZhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5kYXRhQXJyYXkgPSBLb252YS5QYXRoLnBhcnNlUGF0aERhdGEodGhpcy5hdHRycy5kYXRhKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGV4dCBkYXRhIGZvciBjZXJ0YWluIGF0dHIgY2hhbmdlc1xuICAgICAgICAgICAgdGhpcy5vbigndGV4dENoYW5nZS5rb252YSB0ZXh0U3Ryb2tlLmtvbnZhIHRleHRTdHJva2VXaWR0aC5rb252YScsIHRoYXQuX3NldFRleHREYXRhKTtcbiAgICAgICAgICAgIHRoYXQuX3NldFRleHREYXRhKCk7XG4gICAgICAgICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgICAgICB9LFxuICAgICAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0LnNldEF0dHIoJ2ZvbnQnLCB0aGlzLl9nZXRDb250ZXh0Rm9udCgpKTtcbiAgICAgICAgICAgIGNvbnRleHQuc2V0QXR0cigndGV4dEJhc2VsaW5lJywgJ21pZGRsZScpO1xuICAgICAgICAgICAgY29udGV4dC5zZXRBdHRyKCd0ZXh0QWxpZ24nLCAnbGVmdCcpO1xuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICAgICAgICAgIHZhciBnbHlwaEluZm8gPSB0aGlzLmdseXBoSW5mbztcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBnbHlwaEluZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgICAgICAgICAgICAgIHZhciBwMCA9IGdseXBoSW5mb1tpXS5wMDtcblxuICAgICAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKHAwLngsIHAwLnkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucm90YXRlKGdseXBoSW5mb1tpXS5yb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWFsVGV4dCA9IGdseXBoSW5mb1tpXS50ZXh0O1xuXG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgICAgICAvLy8vIFRvIGFzc2lzdCB3aXRoIGRlYnVnZ2luZyB2aXN1YWxseSwgdW5jb21tZW50IGZvbGxvd2luZ1xuICAgICAgICAgICAgICAgIC8vIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgLy8gaWYgKGkgJSAyKVxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnY3lhbic7XG4gICAgICAgICAgICAgICAgLy8gZWxzZVxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnZ3JlZW4nO1xuICAgICAgICAgICAgICAgIC8vIHZhciBwMSA9IGdseXBoSW5mb1tpXS5wMTtcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0Lm1vdmVUbyhwMC54LCBwMC55KTtcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0LmxpbmVUbyhwMS54LCBwMS55KTtcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgdGV4dCB3aWR0aCBpbiBwaXhlbHNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRUZXh0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dFdpZHRoO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IHRleHQgaGVpZ2h0IGluIHBpeGVsc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGdldFRleHRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dEhlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCB0ZXh0XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0VGV4dDogZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgS29udmEuVGV4dC5wcm90b3R5cGUuc2V0VGV4dC5jYWxsKHRoaXMsIHRleHQpO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0VGV4dFNpemU6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgIHZhciBkdW1teUNhbnZhcyA9IHRoaXMuZHVtbXlDYW52YXM7XG4gICAgICAgICAgICB2YXIgX2NvbnRleHQgPSBkdW1teUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICBfY29udGV4dC5zYXZlKCk7XG5cbiAgICAgICAgICAgIF9jb250ZXh0LmZvbnQgPSB0aGlzLl9nZXRDb250ZXh0Rm9udCgpO1xuICAgICAgICAgICAgdmFyIG1ldHJpY3MgPSBfY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KTtcblxuICAgICAgICAgICAgX2NvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBtZXRyaWNzLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcGFyc2VJbnQodGhpcy5hdHRycy5mb250U2l6ZSwgMTApXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBfc2V0VGV4dERhdGE6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuX2dldFRleHRTaXplKHRoaXMuYXR0cnMudGV4dCk7XG4gICAgICAgICAgICB0aGlzLnRleHRXaWR0aCA9IHNpemUud2lkdGg7XG4gICAgICAgICAgICB0aGlzLnRleHRIZWlnaHQgPSBzaXplLmhlaWdodDtcblxuICAgICAgICAgICAgdGhpcy5nbHlwaEluZm8gPSBbXTtcblxuICAgICAgICAgICAgdmFyIGNoYXJBcnIgPSB0aGlzLmF0dHJzLnRleHQuc3BsaXQoJycpO1xuXG4gICAgICAgICAgICB2YXIgcDAsIHAxLCBwYXRoQ21kO1xuXG4gICAgICAgICAgICB2YXIgcEluZGV4ID0gLTE7XG4gICAgICAgICAgICB2YXIgY3VycmVudFQgPSAwO1xuXG4gICAgICAgICAgICB2YXIgZ2V0TmV4dFBhdGhTZWdtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFQgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHRoYXQuZGF0YUFycmF5O1xuXG4gICAgICAgICAgICAgICAgZm9yKHZhciBqID0gcEluZGV4ICsgMTsgaiA8IHBhdGhEYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHBhdGhEYXRhW2pdLnBhdGhMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwSW5kZXggPSBqO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aERhdGFbal07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihwYXRoRGF0YVtqXS5jb21tYW5kID09PSAnTScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAwID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHBhdGhEYXRhW2pdLnBvaW50c1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBwYXRoRGF0YVtqXS5wb2ludHNbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGZpbmRTZWdtZW50VG9GaXRDaGFyYWN0ZXIgPSBmdW5jdGlvbihjKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZ2x5cGhXaWR0aCA9IHRoYXQuX2dldFRleHRTaXplKGMpLndpZHRoO1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJMZW4gPSAwO1xuICAgICAgICAgICAgICAgIHZhciBhdHRlbXB0cyA9IDA7XG5cbiAgICAgICAgICAgICAgICBwMSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB3aGlsZShNYXRoLmFicyhnbHlwaFdpZHRoIC0gY3VyckxlbikgLyBnbHlwaFdpZHRoID4gMC4wMSAmJiBhdHRlbXB0cyA8IDI1KSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRzKys7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdW11bGF0aXZlUGF0aExlbmd0aCA9IGN1cnJMZW47XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHBhdGhDbWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aENtZCA9IGdldE5leHRQYXRoU2VnbWVudCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwYXRoQ21kICYmIGN1bXVsYXRpdmVQYXRoTGVuZ3RoICsgcGF0aENtZC5wYXRoTGVuZ3RoIDwgZ2x5cGhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1bXVsYXRpdmVQYXRoTGVuZ3RoICs9IHBhdGhDbWQucGF0aExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoQ21kID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYocGF0aENtZCA9PT0ge30gfHwgcDAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZWVkTmV3U2VnbWVudCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocGF0aENtZC5jb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihLb252YS5QYXRoLmdldExpbmVMZW5ndGgocDAueCwgcDAueSwgcGF0aENtZC5wb2ludHNbMF0sIHBhdGhDbWQucG9pbnRzWzFdKSA+IGdseXBoV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcDEgPSBLb252YS5QYXRoLmdldFBvaW50T25MaW5lKGdseXBoV2lkdGgsIHAwLngsIHAwLnksIHBhdGhDbWQucG9pbnRzWzBdLCBwYXRoQ21kLnBvaW50c1sxXSwgcDAueCwgcDAueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoQ21kID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0EnOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcGF0aENtZC5wb2ludHNbNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNCA9IHRoZXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRUaGV0YSA9IHBhdGhDbWQucG9pbnRzWzVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDUgPSBkVGhldGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gcGF0aENtZC5wb2ludHNbNF0gKyBkVGhldGE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50VCA9PT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gc3RhcnQgKyAwLjAwMDAwMDAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBKdXN0IGluIGNhc2Ugc3RhcnQgaXMgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZ2x5cGhXaWR0aCA+IGN1cnJMZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgKz0gKE1hdGguUEkgLyAxODAuMCkgKiBkVGhldGEgLyBNYXRoLmFicyhkVGhldGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgLT0gTWF0aC5QSSAvIDM2MC4wICogZFRoZXRhIC8gTWF0aC5hYnMoZFRoZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVkaXQgZm9yIGJ1ZyBmaXg6IEB0aGVydGggaHR0cHM6Ly9naXRodWIuY29tL2VyaWNkcm93ZWxsL0tvbnZhSlMvaXNzdWVzLzI0OVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9sZCBjb2RlIGZhaWxlZCB0byByZW5kZXIgdGV4dCBhbG9uZyBhcmMgb2YgdGhpcyBwYXRoOiBcIk0gNTAgNTAgYSAxNTAgNTAgMCAwIDEgMjUwIDUwIGwgNTAgMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZFRoZXRhIDwgMCAmJiBjdXJyZW50VCA8IGVuZCB8fCBkVGhldGEgPj0gMCAmJiBjdXJyZW50VCA+IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZE5ld1NlZ21lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMSA9IEtvbnZhLlBhdGguZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMocGF0aENtZC5wb2ludHNbMF0sIHBhdGhDbWQucG9pbnRzWzFdLCBwYXRoQ21kLnBvaW50c1syXSwgcGF0aENtZC5wb2ludHNbM10sIGN1cnJlbnRULCBwYXRoQ21kLnBvaW50c1s2XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50VCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihnbHlwaFdpZHRoID4gcGF0aENtZC5wYXRoTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IDAuMDAwMDAwMDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IGdseXBoV2lkdGggLyBwYXRoQ21kLnBhdGhMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihnbHlwaFdpZHRoID4gY3Vyckxlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCArPSAoZ2x5cGhXaWR0aCAtIGN1cnJMZW4pIC8gcGF0aENtZC5wYXRoTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgLT0gKGN1cnJMZW4gLSBnbHlwaFdpZHRoKSAvIHBhdGhDbWQucGF0aExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50VCA+IDEuMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IDEuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZE5ld1NlZ21lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMSA9IEtvbnZhLlBhdGguZ2V0UG9pbnRPbkN1YmljQmV6aWVyKGN1cnJlbnRULCBwYXRoQ21kLnN0YXJ0LngsIHBhdGhDbWQuc3RhcnQueSwgcGF0aENtZC5wb2ludHNbMF0sIHBhdGhDbWQucG9pbnRzWzFdLCBwYXRoQ21kLnBvaW50c1syXSwgcGF0aENtZC5wb2ludHNbM10sIHBhdGhDbWQucG9pbnRzWzRdLCBwYXRoQ21kLnBvaW50c1s1XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50VCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IGdseXBoV2lkdGggLyBwYXRoQ21kLnBhdGhMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZ2x5cGhXaWR0aCA+IGN1cnJMZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgKz0gKGdseXBoV2lkdGggLSBjdXJyTGVuKSAvIHBhdGhDbWQucGF0aExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUIC09IChjdXJyTGVuIC0gZ2x5cGhXaWR0aCkgLyBwYXRoQ21kLnBhdGhMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY3VycmVudFQgPiAxLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZWROZXdTZWdtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcDEgPSBLb252YS5QYXRoLmdldFBvaW50T25RdWFkcmF0aWNCZXppZXIoY3VycmVudFQsIHBhdGhDbWQuc3RhcnQueCwgcGF0aENtZC5zdGFydC55LCBwYXRoQ21kLnBvaW50c1swXSwgcGF0aENtZC5wb2ludHNbMV0sIHBhdGhDbWQucG9pbnRzWzJdLCBwYXRoQ21kLnBvaW50c1szXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKHAxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJMZW4gPSBLb252YS5QYXRoLmdldExpbmVMZW5ndGgocDAueCwgcDAueSwgcDEueCwgcDEueSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihuZWVkTmV3U2VnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZE5ld1NlZ21lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhDbWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNoYXJBcnIubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIC8vIEZpbmQgcDEgc3VjaCB0aGF0IGxpbmUgc2VnbWVudCBiZXR3ZWVuIHAwIGFuZCBwMSBpcyBhcHByb3guIHdpZHRoIG9mIGdseXBoXG4gICAgICAgICAgICAgICAgZmluZFNlZ21lbnRUb0ZpdENoYXJhY3RlcihjaGFyQXJyW2ldKTtcblxuICAgICAgICAgICAgICAgIGlmKHAwID09PSB1bmRlZmluZWQgfHwgcDEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBLb252YS5QYXRoLmdldExpbmVMZW5ndGgocDAueCwgcDAueSwgcDEueCwgcDEueSk7XG5cbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBTaW5jZSBnbHlwaHMgYXJlIHJlbmRlcmVkIG9uZSBhdCBhIHRpbWUsIGFueSBrZXJuaW5nIHBhaXIgZGF0YSBidWlsdCBpbnRvIHRoZSBmb250IHdpbGwgbm90IGJlIHVzZWQuXG4gICAgICAgICAgICAgICAgLy8gQ2FuIGZvcmVzZWUgaGF2aW5nIGEgcm91Z2ggcGFpciB0YWJsZSBidWlsdCBpbiB0aGF0IHRoZSBkZXZlbG9wZXIgY2FuIG92ZXJyaWRlIGFzIG5lZWRlZC5cblxuICAgICAgICAgICAgICAgIHZhciBrZXJuID0gMDtcbiAgICAgICAgICAgICAgICAvLyBwbGFjZWhvbGRlciBmb3IgZnV0dXJlIGltcGxlbWVudGF0aW9uXG5cbiAgICAgICAgICAgICAgICB2YXIgbWlkcG9pbnQgPSBLb252YS5QYXRoLmdldFBvaW50T25MaW5lKGtlcm4gKyB3aWR0aCAvIDIuMCwgcDAueCwgcDAueSwgcDEueCwgcDEueSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcm90YXRpb24gPSBNYXRoLmF0YW4yKChwMS55IC0gcDAueSksIChwMS54IC0gcDAueCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2x5cGhJbmZvLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3Bvc2VYOiBtaWRwb2ludC54LFxuICAgICAgICAgICAgICAgICAgICB0cmFuc3Bvc2VZOiBtaWRwb2ludC55LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaGFyQXJyW2ldLFxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHAwOiBwMCxcbiAgICAgICAgICAgICAgICAgICAgcDE6IHAxXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcDAgPSBwMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U2VsZlJlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGZvbnRTaXplID0gdGhpcy5mb250U2l6ZSgpO1xuXG4gICAgICAgICAgICB0aGlzLmdseXBoSW5mby5mb3JFYWNoKGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChpbmZvLnAwLngpO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGluZm8ucDAueSk7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goaW5mby5wMS54KTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChpbmZvLnAxLnkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbWluWCA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIHZhciBtYXhYID0gcG9pbnRzWzBdO1xuICAgICAgICAgICAgdmFyIG1pblkgPSBwb2ludHNbMF07XG4gICAgICAgICAgICB2YXIgbWF4WSA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIHZhciB4LCB5O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeCA9IHBvaW50c1tpICogMl07IHkgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCk7XG4gICAgICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xuICAgICAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcbiAgICAgICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IE1hdGgucm91bmQobWluWCkgLSBmb250U2l6ZSxcbiAgICAgICAgICAgICAgICB5OiBNYXRoLnJvdW5kKG1pblkpIC0gZm9udFNpemUsXG4gICAgICAgICAgICAgICAgd2lkdGg6IE1hdGgucm91bmQobWF4WCAtIG1pblgpICsgZm9udFNpemUgKiAyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogTWF0aC5yb3VuZChtYXhZIC0gbWluWSkgKyBmb250U2l6ZSAqIDJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gbWFwIFRleHRQYXRoIG1ldGhvZHMgdG8gVGV4dFxuICAgIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZS5fZ2V0Q29udGV4dEZvbnQgPSBLb252YS5UZXh0LnByb3RvdHlwZS5fZ2V0Q29udGV4dEZvbnQ7XG5cbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5UZXh0UGF0aCwgS29udmEuU2hhcGUpO1xuXG4gICAgLy8gYWRkIHNldHRlcnMgYW5kIGdldHRlcnNcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0UGF0aCwgJ2ZvbnRGYW1pbHknLCAnQXJpYWwnKTtcblxuICAgIC8qKlxuICAgICAqIHNldCBmb250IGZhbWlseVxuICAgICAqIEBuYW1lIHNldEZvbnRGYW1pbHlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb250RmFtaWx5XG4gICAgICovXG5cbiAgICAgLyoqXG4gICAgICogZ2V0IGZvbnQgZmFtaWx5XG4gICAgICogQG5hbWUgZ2V0Rm9udEZhbWlseVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0UGF0aCwgJ2ZvbnRTaXplJywgMTIpO1xuXG4gICAgLyoqXG4gICAgICogc2V0IGZvbnQgc2l6ZVxuICAgICAqIEBuYW1lIHNldEZvbnRTaXplXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge2ludH0gZm9udFNpemVcbiAgICAgKi9cblxuICAgICAvKipcbiAgICAgKiBnZXQgZm9udCBzaXplXG4gICAgICogQG5hbWUgZ2V0Rm9udFNpemVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dFBhdGgsICdmb250U3R5bGUnLCBOT1JNQUwpO1xuXG4gICAgLyoqXG4gICAgICogc2V0IGZvbnQgc3R5bGUuICBDYW4gYmUgJ25vcm1hbCcsICdpdGFsaWMnLCBvciAnYm9sZCcuICAnbm9ybWFsJyBpcyB0aGUgZGVmYXVsdC5cbiAgICAgKiBAbmFtZSBzZXRGb250U3R5bGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb250U3R5bGVcbiAgICAgKi9cblxuICAgICAvKipcbiAgICAgKiBnZXQgZm9udCBzdHlsZVxuICAgICAqIEBuYW1lIGdldEZvbnRTdHlsZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0UGF0aCwgJ2ZvbnRWYXJpYW50JywgTk9STUFMKTtcblxuICAgIC8qKlxuICAgICAqIHNldCBmb250IHZhcmlhbnQuICBDYW4gYmUgJ25vcm1hbCcgb3IgJ3NtYWxsLWNhcHMnLiAgJ25vcm1hbCcgaXMgdGhlIGRlZmF1bHQuXG4gICAgICogQG5hbWUgc2V0Rm9udFZhcmlhbnRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb250VmFyaWFudFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQGdldCBmb250IHZhcmlhbnRcbiAgICAgKiBAbmFtZSBnZXRGb250VmFyaWFudFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlcihLb252YS5UZXh0UGF0aCwgJ3RleHQnLCBFTVBUWV9TVFJJTkcpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0IHRleHRcbiAgICAgKiBAbmFtZSBnZXRUZXh0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICAgKi9cblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5UZXh0UGF0aCk7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qKlxuICAgICAqIFJlZ3VsYXJQb2x5Z29uIGNvbnN0cnVjdG9yLiZuYnNwOyBFeGFtcGxlcyBpbmNsdWRlIHRyaWFuZ2xlcywgc3F1YXJlcywgcGVudGFnb25zLCBoZXhhZ29ucywgZXRjLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnNpZGVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5yYWRpdXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGhleGFnb24gPSBuZXcgS29udmEuUmVndWxhclBvbHlnb24oe1xuICAgICAqICAgeDogMTAwLFxuICAgICAqICAgeTogMjAwLFxuICAgICAqICAgc2lkZXM6IDYsXG4gICAgICogICByYWRpdXM6IDcwLFxuICAgICAqICAgZmlsbDogJ3JlZCcsXG4gICAgICogICBzdHJva2U6ICdibGFjaycsXG4gICAgICogICBzdHJva2VXaWR0aDogNFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIEtvbnZhLlJlZ3VsYXJQb2x5Z29uID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5SZWd1bGFyUG9seWdvbi5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9jZW50cm9pZDogdHJ1ZSxcbiAgICAgICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICdSZWd1bGFyUG9seWdvbic7XG4gICAgICAgICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgICAgICB9LFxuICAgICAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgc2lkZXMgPSB0aGlzLmF0dHJzLnNpZGVzLFxuICAgICAgICAgICAgICAgIHJhZGl1cyA9IHRoaXMuYXR0cnMucmFkaXVzLFxuICAgICAgICAgICAgICAgIG4sIHgsIHk7XG5cbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbygwLCAwIC0gcmFkaXVzKTtcblxuICAgICAgICAgICAgZm9yKG4gPSAxOyBuIDwgc2lkZXM7IG4rKykge1xuICAgICAgICAgICAgICAgIHggPSByYWRpdXMgKiBNYXRoLnNpbihuICogMiAqIE1hdGguUEkgLyBzaWRlcyk7XG4gICAgICAgICAgICAgICAgeSA9IC0xICogcmFkaXVzICogTWF0aC5jb3MobiAqIDIgKiBNYXRoLlBJIC8gc2lkZXMpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSYWRpdXMoKSAqIDI7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldEhlaWdodCgpXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSYWRpdXMoKSAqIDI7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldFdpZHRoKClcbiAgICAgICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRXaWR0aC5jYWxsKHRoaXMsIHdpZHRoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhZGl1cygpICE9PSB3aWR0aCAvIDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJhZGl1cyh3aWR0aCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRIZWlnaHQoKVxuICAgICAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0LmNhbGwodGhpcywgaGVpZ2h0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhZGl1cygpICE9PSBoZWlnaHQgLyAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYWRpdXMoaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlJlZ3VsYXJQb2x5Z29uLCBLb252YS5TaGFwZSk7XG5cbiAgICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuUmVndWxhclBvbHlnb24sICdyYWRpdXMnLCAwKTtcblxuICAgIC8qKlxuICAgICAqIHNldCByYWRpdXNcbiAgICAgKiBAbmFtZSBzZXRSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlJlZ3VsYXJQb2x5Z29uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcbiAgICAgKi9cblxuICAgICAvKipcbiAgICAgKiBnZXQgcmFkaXVzXG4gICAgICogQG5hbWUgZ2V0UmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5SZWd1bGFyUG9seWdvbi5wcm90b3R5cGVcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlJlZ3VsYXJQb2x5Z29uLCAnc2lkZXMnLCAwKTtcblxuICAgIC8qKlxuICAgICAqIHNldCBudW1iZXIgb2Ygc2lkZXNcbiAgICAgKiBAbmFtZSBzZXRTaWRlc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuUmVndWxhclBvbHlnb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtpbnR9IHNpZGVzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBnZXQgbnVtYmVyIG9mIHNpZGVzXG4gICAgICogQG5hbWUgZ2V0U2lkZXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlJlZ3VsYXJQb2x5Z29uLnByb3RvdHlwZVxuICAgICAqL1xuXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlJlZ3VsYXJQb2x5Z29uKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogU3RhciBjb25zdHJ1Y3RvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGNvbmZpZy5udW1Qb2ludHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLmlubmVyUmFkaXVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5vdXRlclJhZGl1c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgc3RhciA9IG5ldyBLb252YS5TdGFyKHtcbiAgICAgKiAgIHg6IDEwMCxcbiAgICAgKiAgIHk6IDIwMCxcbiAgICAgKiAgIG51bVBvaW50czogNSxcbiAgICAgKiAgIGlubmVyUmFkaXVzOiA3MCxcbiAgICAgKiAgIG91dGVyUmFkaXVzOiA3MCxcbiAgICAgKiAgIGZpbGw6ICdyZWQnLFxuICAgICAqICAgc3Ryb2tlOiAnYmxhY2snLFxuICAgICAqICAgc3Ryb2tlV2lkdGg6IDRcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBLb252YS5TdGFyID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5TdGFyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgX2NlbnRyb2lkOiB0cnVlLFxuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1N0YXInO1xuICAgICAgICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGlubmVyUmFkaXVzID0gdGhpcy5pbm5lclJhZGl1cygpLFxuICAgICAgICAgICAgICAgIG91dGVyUmFkaXVzID0gdGhpcy5vdXRlclJhZGl1cygpLFxuICAgICAgICAgICAgICAgIG51bVBvaW50cyA9IHRoaXMubnVtUG9pbnRzKCk7XG5cbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbygwLCAwIC0gb3V0ZXJSYWRpdXMpO1xuXG4gICAgICAgICAgICBmb3IodmFyIG4gPSAxOyBuIDwgbnVtUG9pbnRzICogMjsgbisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhZGl1cyA9IG4gJSAyID09PSAwID8gb3V0ZXJSYWRpdXMgOiBpbm5lclJhZGl1cztcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHJhZGl1cyAqIE1hdGguc2luKG4gKiBNYXRoLlBJIC8gbnVtUG9pbnRzKTtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IC0xICogcmFkaXVzICogTWF0aC5jb3MobiAqIE1hdGguUEkgLyBudW1Qb2ludHMpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldFdpZHRoKClcbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldEhlaWdodCgpXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPdXRlclJhZGl1cygpICogMjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0V2lkdGgoKVxuICAgICAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0ZXJSYWRpdXMoKSAhPT0gd2lkdGggLyAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRlclJhZGl1cyh3aWR0aCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRIZWlnaHQoKVxuICAgICAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0LmNhbGwodGhpcywgaGVpZ2h0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dGVyUmFkaXVzKCkgIT09IGhlaWdodCAvIDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE91dGVyUmFkaXVzKGhlaWdodCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5TdGFyLCBLb252YS5TaGFwZSk7XG5cbiAgICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3RhciwgJ251bVBvaW50cycsIDUpO1xuXG4gICAgLyoqXG4gICAgICogc2V0IG51bWJlciBvZiBwb2ludHNcbiAgICAgKiBAbmFtZSBzZXROdW1Qb2ludHNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBwb2ludHNcbiAgICAgKi9cblxuICAgICAvKipcbiAgICAgKiBnZXQgbnVtYmVyIG9mIHBvaW50c1xuICAgICAqIEBuYW1lIGdldE51bVBvaW50c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3Rhci5wcm90b3R5cGVcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlN0YXIsICdpbm5lclJhZGl1cycsIDApO1xuXG4gICAgLyoqXG4gICAgICogc2V0IGlubmVyIHJhZGl1c1xuICAgICAqIEBuYW1lIHNldElubmVyUmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcbiAgICAgKi9cblxuICAgICAvKipcbiAgICAgKiBnZXQgaW5uZXIgcmFkaXVzXG4gICAgICogQG5hbWUgZ2V0SW5uZXJSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YXIucHJvdG90eXBlXG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TdGFyLCAnb3V0ZXJSYWRpdXMnLCAwKTtcblxuICAgIC8qKlxuICAgICAqIHNldCBvdXRlciByYWRpdXNcbiAgICAgKiBAbmFtZSBzZXRPdXRlclJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3Rhci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG4gICAgICovXG5cbiAgICAgLyoqXG4gICAgICogZ2V0IG91dGVyIHJhZGl1c1xuICAgICAqIEBuYW1lIGdldE91dGVyUmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFyLnByb3RvdHlwZVxuICAgICAqL1xuXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlN0YXIpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBjb25zdGFudHNcbiAgICB2YXIgQVRUUl9DSEFOR0VfTElTVCA9IFsnZm9udEZhbWlseScsICdmb250U2l6ZScsICdmb250U3R5bGUnLCAncGFkZGluZycsICdsaW5lSGVpZ2h0JywgJ3RleHQnXSxcbiAgICAgICAgQ0hBTkdFX0tPTlZBID0gJ0NoYW5nZS5rb252YScsXG4gICAgICAgIE5PTkUgPSAnbm9uZScsXG4gICAgICAgIFVQID0gJ3VwJyxcbiAgICAgICAgUklHSFQgPSAncmlnaHQnLFxuICAgICAgICBET1dOID0gJ2Rvd24nLFxuICAgICAgICBMRUZUID0gJ2xlZnQnLFxuICAgICAgICBMQUJFTCA9ICdMYWJlbCcsXG5cbiAgICAgLy8gY2FjaGVkIHZhcmlhYmxlc1xuICAgICBhdHRyQ2hhbmdlTGlzdExlbiA9IEFUVFJfQ0hBTkdFX0xJU1QubGVuZ3RoO1xuXG4gICAgLyoqXG4gICAgICogTGFiZWwgY29uc3RydWN0b3IuJm5ic3A7IExhYmVscyBhcmUgZ3JvdXBzIHRoYXQgY29udGFpbiBhIFRleHQgYW5kIFRhZyBzaGFwZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gY3JlYXRlIGxhYmVsXG4gICAgICogdmFyIGxhYmVsID0gbmV3IEtvbnZhLkxhYmVsKHtcbiAgICAgKiAgIHg6IDEwMCxcbiAgICAgKiAgIHk6IDEwMCxcbiAgICAgKiAgIGRyYWdnYWJsZTogdHJ1ZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gYWRkIGEgdGFnIHRvIHRoZSBsYWJlbFxuICAgICAqIGxhYmVsLmFkZChuZXcgS29udmEuVGFnKHtcbiAgICAgKiAgIGZpbGw6ICcjYmJiJyxcbiAgICAgKiAgIHN0cm9rZTogJyMzMzMnLFxuICAgICAqICAgc2hhZG93Q29sb3I6ICdibGFjaycsXG4gICAgICogICBzaGFkb3dCbHVyOiAxMCxcbiAgICAgKiAgIHNoYWRvd09mZnNldDogWzEwLCAxMF0sXG4gICAgICogICBzaGFkb3dPcGFjaXR5OiAwLjIsXG4gICAgICogICBsaW5lSm9pbjogJ3JvdW5kJyxcbiAgICAgKiAgIHBvaW50ZXJEaXJlY3Rpb246ICd1cCcsXG4gICAgICogICBwb2ludGVyV2lkdGg6IDIwLFxuICAgICAqICAgcG9pbnRlckhlaWdodDogMjAsXG4gICAgICogICBjb3JuZXJSYWRpdXM6IDVcbiAgICAgKiB9KSk7XG4gICAgICpcbiAgICAgKiAvLyBhZGQgdGV4dCB0byB0aGUgbGFiZWxcbiAgICAgKiBsYWJlbC5hZGQobmV3IEtvbnZhLlRleHQoe1xuICAgICAqICAgdGV4dDogJ0hlbGxvIFdvcmxkIScsXG4gICAgICogICBmb250U2l6ZTogNTAsXG4gICAgICogICBsaW5lSGVpZ2h0OiAxLjIsXG4gICAgICogICBwYWRkaW5nOiAxMCxcbiAgICAgKiAgIGZpbGw6ICdncmVlbidcbiAgICAgKiAgfSkpO1xuICAgICAqL1xuICAgIEtvbnZhLkxhYmVsID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19fX2luaXQoY29uZmlnKTtcbiAgICB9O1xuXG4gICAgS29udmEuTGFiZWwucHJvdG90eXBlID0ge1xuICAgICAgICBfX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIEtvbnZhLkdyb3VwLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gTEFCRUw7XG5cbiAgICAgICAgICAgIHRoaXMub24oJ2FkZC5rb252YScsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgIHRoYXQuX2FkZExpc3RlbmVycyhldnQuY2hpbGQpO1xuICAgICAgICAgICAgICAgIHRoYXQuX3N5bmMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IFRleHQgc2hhcGUgZm9yIHRoZSBsYWJlbC4gIFlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgVGV4dCBzaGFwZSBpbiBvcmRlciB0byB1cGRhdGVcbiAgICAgICAgICogdGhlIHRleHQgcHJvcGVydGllc1xuICAgICAgICAgKiBAbmFtZSBnZXRUZXh0XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkxhYmVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kKCdUZXh0JylbMF07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgVGFnIHNoYXBlIGZvciB0aGUgbGFiZWwuICBZb3UgbmVlZCB0byBhY2Nlc3MgdGhlIFRhZyBzaGFwZSBpbiBvcmRlciB0byB1cGRhdGVcbiAgICAgICAgICogdGhlIHBvaW50ZXIgcHJvcGVydGllcyBhbmQgdGhlIGNvcm5lciByYWRpdXNcbiAgICAgICAgICogQG5hbWUgZ2V0VGFnXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkxhYmVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGFnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmQoJ1RhZycpWzBdO1xuICAgICAgICB9LFxuICAgICAgICBfYWRkTGlzdGVuZXJzOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgbjtcbiAgICAgICAgICAgIHZhciBmdW5jID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fc3luYygpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0ZXh0IGRhdGEgZm9yIGNlcnRhaW4gYXR0ciBjaGFuZ2VzXG4gICAgICAgICAgICBmb3IobiA9IDA7IG4gPCBhdHRyQ2hhbmdlTGlzdExlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgdGV4dC5vbihBVFRSX0NIQU5HRV9MSVNUW25dICsgQ0hBTkdFX0tPTlZBLCBmdW5jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGV4dCgpLmdldFdpZHRoKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUZXh0KCkuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zeW5jOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5nZXRUZXh0KCksXG4gICAgICAgICAgICAgICAgdGFnID0gdGhpcy5nZXRUYWcoKSxcbiAgICAgICAgICAgICAgICB3aWR0aCwgaGVpZ2h0LCBwb2ludGVyRGlyZWN0aW9uLCBwb2ludGVyV2lkdGgsIHgsIHksIHBvaW50ZXJIZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmICh0ZXh0ICYmIHRhZykge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gdGV4dC5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRleHQuZ2V0SGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgcG9pbnRlckRpcmVjdGlvbiA9IHRhZy5nZXRQb2ludGVyRGlyZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgcG9pbnRlcldpZHRoID0gdGFnLmdldFBvaW50ZXJXaWR0aCgpO1xuICAgICAgICAgICAgICAgIHBvaW50ZXJIZWlnaHQgPSB0YWcuZ2V0UG9pbnRlckhlaWdodCgpO1xuICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgIHkgPSAwO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoKHBvaW50ZXJEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBVUDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gLTEgKiBwb2ludGVySGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUklHSFQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gd2lkdGggKyBwb2ludGVyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIERPV046XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGhlaWdodCArIHBvaW50ZXJIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBMRUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IC0xICogcG9pbnRlcldpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0YWcuc2V0QXR0cnMoe1xuICAgICAgICAgICAgICAgICAgICB4OiAtMSAqIHgsXG4gICAgICAgICAgICAgICAgICAgIHk6IC0xICogeSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGV4dC5zZXRBdHRycyh7XG4gICAgICAgICAgICAgICAgICAgIHg6IC0xICogeCxcbiAgICAgICAgICAgICAgICAgICAgeTogLTEgKiB5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuTGFiZWwsIEtvbnZhLkdyb3VwKTtcblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5MYWJlbCk7XG5cbiAgICAvKipcbiAgICAgKiBUYWcgY29uc3RydWN0b3IuJm5ic3A7IEEgVGFnIGNhbiBiZSBjb25maWd1cmVkXG4gICAgICogIHRvIGhhdmUgYSBwb2ludGVyIGVsZW1lbnQgdGhhdCBwb2ludHMgdXAsIHJpZ2h0LCBkb3duLCBvciBsZWZ0XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnBvaW50ZXJEaXJlY3Rpb25dIGNhbiBiZSB1cCwgcmlnaHQsIGRvd24sIGxlZnQsIG9yIG5vbmU7IHRoZSBkZWZhdWx0XG4gICAgICogIGlzIG5vbmUuICBXaGVuIGEgcG9pbnRlciBpcyBwcmVzZW50LCB0aGUgcG9zaXRpb25pbmcgb2YgdGhlIGxhYmVsIGlzIHJlbGF0aXZlIHRvIHRoZSB0aXAgb2YgdGhlIHBvaW50ZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucG9pbnRlcldpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnBvaW50ZXJIZWlnaHRdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY29ybmVyUmFkaXVzXVxuICAgICAqL1xuICAgIEtvbnZhLlRhZyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgICB9O1xuXG4gICAgS29udmEuVGFnLnByb3RvdHlwZSA9IHtcbiAgICAgICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICdUYWcnO1xuICAgICAgICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgcG9pbnRlckRpcmVjdGlvbiA9IHRoaXMuZ2V0UG9pbnRlckRpcmVjdGlvbigpLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJXaWR0aCA9IHRoaXMuZ2V0UG9pbnRlcldpZHRoKCksXG4gICAgICAgICAgICAgICAgcG9pbnRlckhlaWdodCA9IHRoaXMuZ2V0UG9pbnRlckhlaWdodCgpLFxuICAgICAgICAgICAgICAgIGNvcm5lclJhZGl1cyA9IE1hdGgubWluKHRoaXMuZ2V0Q29ybmVyUmFkaXVzKCksIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBpZiAoIWNvcm5lclJhZGl1cykge1xuICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKDAsIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhjb3JuZXJSYWRpdXMsIDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9pbnRlckRpcmVjdGlvbiA9PT0gVVApIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbygod2lkdGggLSBwb2ludGVyV2lkdGgpIC8gMiwgMCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGggLyAyLCAtMSAqIHBvaW50ZXJIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKCh3aWR0aCArIHBvaW50ZXJXaWR0aCkgLyAyLCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIWNvcm5lclJhZGl1cykge1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGggLSBjb3JuZXJSYWRpdXMsIDApO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYXJjKHdpZHRoIC0gY29ybmVyUmFkaXVzLCBjb3JuZXJSYWRpdXMsIGNvcm5lclJhZGl1cywgTWF0aC5QSSAqIDMgLyAyLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb2ludGVyRGlyZWN0aW9uID09PSBSSUdIVCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoLCAoaGVpZ2h0IC0gcG9pbnRlckhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCArIHBvaW50ZXJXaWR0aCwgaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGgsIChoZWlnaHQgKyBwb2ludGVySGVpZ2h0KSAvIDIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZighY29ybmVyUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoLCBoZWlnaHQgLSBjb3JuZXJSYWRpdXMpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYXJjKHdpZHRoIC0gY29ybmVyUmFkaXVzLCBoZWlnaHQgLSBjb3JuZXJSYWRpdXMsIGNvcm5lclJhZGl1cywgMCwgTWF0aC5QSSAvIDIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvaW50ZXJEaXJlY3Rpb24gPT09IERPV04pIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbygod2lkdGggKyBwb2ludGVyV2lkdGgpIC8gMiwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCAvIDIsIGhlaWdodCArIHBvaW50ZXJIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKCh3aWR0aCAtIHBvaW50ZXJXaWR0aCkgLyAyLCBoZWlnaHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZighY29ybmVyUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oMCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oY29ybmVyUmFkaXVzLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYXJjKGNvcm5lclJhZGl1cywgaGVpZ2h0IC0gY29ybmVyUmFkaXVzLCBjb3JuZXJSYWRpdXMsIE1hdGguUEkgLyAyLCBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb2ludGVyRGlyZWN0aW9uID09PSBMRUZUKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oMCwgKGhlaWdodCArIHBvaW50ZXJIZWlnaHQpIC8gMik7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oLTEgKiBwb2ludGVyV2lkdGgsIGhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDAsIChoZWlnaHQgLSBwb2ludGVySGVpZ2h0KSAvIDIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihjb3JuZXJSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbygwLCBjb3JuZXJSYWRpdXMpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYXJjKGNvcm5lclJhZGl1cywgY29ybmVyUmFkaXVzLCBjb3JuZXJSYWRpdXMsIE1hdGguUEksIE1hdGguUEkgKiAzIC8gMiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFNlbGZSZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB4ID0gMCxcbiAgICAgICAgICAgICAgICB5ID0gMCxcbiAgICAgICAgICAgICAgICBwb2ludGVyV2lkdGggPSB0aGlzLmdldFBvaW50ZXJXaWR0aCgpLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJIZWlnaHQgPSB0aGlzLmdldFBvaW50ZXJIZWlnaHQoKSxcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSB0aGlzLnBvaW50ZXJEaXJlY3Rpb24oKSxcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBVUCkge1xuICAgICAgICAgICAgICAgIHkgLT0gcG9pbnRlckhlaWdodDtcbiAgICAgICAgICAgICAgICBoZWlnaHQgKz0gcG9pbnRlckhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBET1dOKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ICs9IHBvaW50ZXJIZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gTEVGVCkge1xuICAgICAgICAgICAgICAgIC8vIEFSR0ghISEgSSBoYXZlIG5vIGlkZWEgd2h5IHNob3VsZCBJIHVzZWQgbWFnaWMgMS41ISEhISEhISEhXG4gICAgICAgICAgICAgICAgeCAtPSBwb2ludGVyV2lkdGggKiAxLjU7XG4gICAgICAgICAgICAgICAgd2lkdGggKz0gcG9pbnRlcldpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFJJR0hUKSB7XG4gICAgICAgICAgICAgICAgd2lkdGggKz0gcG9pbnRlcldpZHRoICogMS41O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlRhZywgS29udmEuU2hhcGUpO1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRhZywgJ3BvaW50ZXJEaXJlY3Rpb24nLCBOT05FKTtcblxuICAgIC8qKlxuICAgICAqIHNldCBwb2ludGVyIERpcmVjdGlvblxuICAgICAqIEBuYW1lIHNldFBvaW50ZXJEaXJlY3Rpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRhZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcG9pbnRlckRpcmVjdGlvbiBjYW4gYmUgdXAsIHJpZ2h0LCBkb3duLCBsZWZ0LCBvciBub25lLiAgVGhlXG4gICAgICogIGRlZmF1bHQgaXMgbm9uZVxuICAgICAqL1xuXG4gICAgIC8qKlxuICAgICAqIGdldCBwb2ludGVyIERpcmVjdGlvblxuICAgICAqIEBuYW1lIGdldFBvaW50ZXJEaXJlY3Rpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRhZy5wcm90b3R5cGVcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRhZywgJ3BvaW50ZXJXaWR0aCcsIDApO1xuXG4gICAgLyoqXG4gICAgICogc2V0IHBvaW50ZXIgd2lkdGhcbiAgICAgKiBAbmFtZSBzZXRQb2ludGVyV2lkdGhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRhZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9pbnRlcldpZHRoXG4gICAgICovXG5cbiAgICAgLyoqXG4gICAgICogZ2V0IHBvaW50ZXIgd2lkdGhcbiAgICAgKiBAbmFtZSBnZXRQb2ludGVyV2lkdGhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRhZy5wcm90b3R5cGVcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRhZywgJ3BvaW50ZXJIZWlnaHQnLCAwKTtcblxuICAgIC8qKlxuICAgICAqIHNldCBwb2ludGVyIGhlaWdodFxuICAgICAqIEBuYW1lIHNldFBvaW50ZXJIZWlnaHRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRhZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9pbnRlckhlaWdodFxuICAgICAqL1xuXG4gICAgIC8qKlxuICAgICAqIGdldCBwb2ludGVyIGhlaWdodFxuICAgICAqIEBuYW1lIGdldFBvaW50ZXJIZWlnaHRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRhZy5wcm90b3R5cGVcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRhZywgJ2Nvcm5lclJhZGl1cycsIDApO1xuXG4gICAgLyoqXG4gICAgICogc2V0IGNvcm5lciByYWRpdXNcbiAgICAgKiBAbmFtZSBzZXRDb3JuZXJSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRhZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29ybmVyIHJhZGl1c1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogZ2V0IGNvcm5lciByYWRpdXNcbiAgICAgKiBAbmFtZSBnZXRDb3JuZXJSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRhZy5wcm90b3R5cGVcbiAgICAgKi9cblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5UYWcpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBBcnJvdyBjb25zdHJ1Y3RvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWcucG9pbnRzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcudGVuc2lvbl0gSGlnaGVyIHZhbHVlcyB3aWxsIHJlc3VsdCBpbiBhIG1vcmUgY3VydnkgbGluZS4gIEEgdmFsdWUgb2YgMCB3aWxsIHJlc3VsdCBpbiBubyBpbnRlcnBvbGF0aW9uLlxuICAgICAqICAgVGhlIGRlZmF1bHQgaXMgMFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcucG9pbnRlckxlbmd0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcucG9pbnRlcldpZHRoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBsaW5lID0gbmV3IEtvbnZhLkxpbmUoe1xuICAgICAqICAgcG9pbnRzOiBbNzMsIDcwLCAzNDAsIDIzLCA0NTAsIDYwLCA1MDAsIDIwXSxcbiAgICAgKiAgIHN0cm9rZTogJ3JlZCcsXG4gICAgICogICB0ZW5zaW9uOiAxLFxuICAgICAqICAgcG9pbnRlckxlbmd0aCA6IDEwLFxuICAgICAqICAgcG9pbnRlcldpZHRoIDogMTJcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBLb252YS5BcnJvdyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLkFycm93LnByb3RvdHlwZSA9IHtcbiAgICAgICAgX19fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgS29udmEuTGluZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICdBcnJvdyc7XG4gICAgICAgIH0sXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgS29udmEuTGluZS5wcm90b3R5cGUuX3NjZW5lRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzKCk7XG4gICAgICAgICAgICB2YXIgbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgZHggPSBwb2ludHNbbiAtIDJdIC0gcG9pbnRzW24gLSA0XTtcbiAgICAgICAgICAgIHZhciBkeSA9IHBvaW50c1tuIC0gMV0gLSBwb2ludHNbbiAtIDNdO1xuICAgICAgICAgICAgdmFyIHJhZGlhbnMgPSAoTWF0aC5hdGFuMihkeSwgZHgpICsgUEkyKSAlIFBJMjtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLnBvaW50ZXJMZW5ndGgoKTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMucG9pbnRlcldpZHRoKCk7XG5cbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHBvaW50c1tuIC0gMl0sIHBvaW50c1tuIC0gMV0pO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShyYWRpYW5zKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKC1sZW5ndGgsIHdpZHRoIC8gMik7XG4gICAgICAgICAgICBjdHgubGluZVRvKC1sZW5ndGgsIC13aWR0aCAvIDIpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMucG9pbnRlckF0QmVnaW5uaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgICAgICAgICAgICAgIGR4ID0gcG9pbnRzWzJdIC0gcG9pbnRzWzBdO1xuICAgICAgICAgICAgICAgIGR5ID0gcG9pbnRzWzNdIC0gcG9pbnRzWzFdO1xuICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoKE1hdGguYXRhbjIoLWR5LCAtZHgpICsgUEkyKSAlIFBJMik7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKC1sZW5ndGgsIHdpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbygtbGVuZ3RoLCAtd2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuQXJyb3csIEtvbnZhLkxpbmUpO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgcG9pbnRlckxlbmd0aFxuICAgICAqIEBuYW1lIHBvaW50ZXJMZW5ndGhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkFycm93LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBMZW5ndGggb2YgcG9pbnRlciBvZiBhcnJvdy5cbiAgICAgKiAgIFRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgdGVuc2lvblxuICAgICAqIHZhciBwb2ludGVyTGVuZ3RoID0gbGluZS5wb2ludGVyTGVuZ3RoKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgdGVuc2lvblxuICAgICAqIGxpbmUucG9pbnRlckxlbmd0aCgxNSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5BcnJvdywgJ3BvaW50ZXJMZW5ndGgnLCAxMCk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBwb2ludGVyV2lkdGhcbiAgICAgKiBAbmFtZSBwb2ludGVyV2lkdGhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkFycm93LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBXaWR0aCBvZiBwb2ludGVyIG9mIGFycm93LlxuICAgICAqICAgVGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCB0ZW5zaW9uXG4gICAgICogdmFyIHBvaW50ZXJXaWR0aCA9IGxpbmUucG9pbnRlcldpZHRoKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgdGVuc2lvblxuICAgICAqIGxpbmUucG9pbnRlcldpZHRoKDE1KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkFycm93LCAncG9pbnRlcldpZHRoJywgMTApO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgcG9pbnRlckF0QmVnaW5uaW5nXG4gICAgICogQG5hbWUgcG9pbnRlckF0QmVnaW5uaW5nXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5BcnJvdy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gU2hvdWxkIHBvaW50ZXIgZGlzcGxheWVkIGF0IGJlZ2lubmluZyBvZiBhcnJvdy5cbiAgICAgKiAgIFRoZSBkZWZhdWx0IGlzIGZhbHNlLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHRlbnNpb25cbiAgICAgKiB2YXIgcG9pbnRlckF0QmVnaW5uaW5nID0gbGluZS5wb2ludGVyQXRCZWdpbm5pbmcoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCB0ZW5zaW9uXG4gICAgICogbGluZS5wb2ludGVyQXRCZWdpbm5pbmcodHJ1ZSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5BcnJvdywgJ3BvaW50ZXJBdEJlZ2lubmluZycsIGZhbHNlKTtcbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuQXJyb3cpO1xuXG59KSgpO1xuXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgdmFyIG07XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSAwO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVtaXR0ZXIuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gMTtcbiAgZWxzZVxuICAgIHJldCA9IGVtaXR0ZXIuX2V2ZW50c1t0eXBlXS5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiJdfQ==
